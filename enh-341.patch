diff -Pru nethack-3.4.1/.cvsignore nethack/.cvsignore
--- nethack-3.4.1/.cvsignore	Wed Dec 31 16:00:00 1969
+++ nethack/.cvsignore	Thu Jan 10 20:03:16 2002
@@ -0,0 +1 @@
+Makefile
diff -Pru nethack-3.4.1/dat/.cvsignore nethack/dat/.cvsignore
--- nethack-3.4.1/dat/.cvsignore	Wed Dec 31 16:00:00 1969
+++ nethack/dat/.cvsignore	Thu Jan 10 20:03:17 2002
@@ -0,0 +1,11 @@
+*.lev
+Makefile
+data
+dungeon
+dungeon.pdf
+options
+oracles
+quest.dat
+quest_levs
+rumors
+spec_levs
diff -Pru nethack-3.4.1/doc/.cvsignore nethack/doc/.cvsignore
--- nethack-3.4.1/doc/.cvsignore	Wed Dec 31 16:00:00 1969
+++ nethack/doc/.cvsignore	Thu Jan 10 20:03:17 2002
@@ -0,0 +1 @@
+Makefile
diff -Pru nethack-3.4.1/doc/Guidebook.mn nethack/doc/Guidebook.mn
--- nethack-3.4.1/doc/Guidebook.mn	Sun Feb 23 06:43:18 2003
+++ nethack/doc/Guidebook.mn	Sun Mar  9 13:39:27 2003
@@ -1,4 +1,4 @@
-.\" $Revision: 1.61 $ $Date: 2003/02/13 04:55:27 $
+.\" $Revision: 1.1.1.3 $ $Date: 2003/03/09 21:39:27 $
 .ds h0 "NetHack Guidebook
 .ds h1
 .ds h2 %
diff -Pru nethack-3.4.1/doc/Guidebook.tex nethack/doc/Guidebook.tex
--- nethack-3.4.1/doc/Guidebook.tex	Sun Feb 23 06:43:18 2003
+++ nethack/doc/Guidebook.tex	Sun Mar  9 13:39:28 2003
@@ -27,7 +27,7 @@
 \begin{document}
 %
 % input file: guidebook.mn
-% $Revision: 1.61 $ $Date: 2003/02/13 04:55:28 $
+% $Revision: 1.1.1.3 $ $Date: 2003/03/09 21:39:28 $
 %
 %.ds h0 "
 %.ds h1 %.ds h2 \%
diff -Pru nethack-3.4.1/doc/fixes34.1 nethack/doc/fixes34.1
--- nethack-3.4.1/doc/fixes34.1	Sun Feb 23 06:43:18 2003
+++ nethack/doc/fixes34.1	Sun Mar  9 13:39:27 2003
@@ -1,4 +1,4 @@
-$RCSfile: fixes34.1,v $ $Revision: 1.331 $ $Date: 2003/02/20 00:19:46 $
+$RCSfile: fixes34.1,v $ $Revision: 1.1.1.1 $ $Date: 2003/03/09 21:39:27 $
 
 General Fixes and Modified Features
 -----------------------------------
diff -Pru nethack-3.4.1/doc/tmac.n nethack/doc/tmac.n
--- nethack-3.4.1/doc/tmac.n	Sun Feb 23 06:43:19 2003
+++ nethack/doc/tmac.n	Thu Jan 10 16:43:13 2002
@@ -1,4 +1,4 @@
-\" @(#)$Id: tmac.n,v 1.3 2000/02/02 18:49:05 dean Exp $
+\" @(#)$Id: tmac.n,v 1.1.1.1 2002/01/11 00:43:13 sabetts Exp $
 .\" The News macro package
 .\"
 .\" This  is  the macro package that is used to format news documents.  It
diff -Pru nethack-3.4.1/include/.cvsignore nethack/include/.cvsignore
--- nethack-3.4.1/include/.cvsignore	Wed Dec 31 16:00:00 1969
+++ nethack/include/.cvsignore	Thu Jan 10 20:03:17 2002
@@ -0,0 +1,6 @@
+date.h
+dgn_comp.h
+lev_comp.h
+onames.h
+pm.h
+vis_tab.h
diff -Pru nethack-3.4.1/include/config.h nethack/include/config.h
--- nethack-3.4.1/include/config.h	Sun Feb 23 06:43:19 2003
+++ nethack/include/config.h	Sun Mar  9 13:49:04 2003
@@ -42,17 +42,18 @@
  * Define all of those you want supported in your binary.
  * Some combinations make no sense.  See the installation document.
  */
-#define TTY_GRAPHICS	/* good old tty based graphics */
+/* #define TTY_GRAPHICS */	/* good old tty based graphics */
 /* #define X11_GRAPHICS */	/* X11 interface */
 /* #define QT_GRAPHICS */	/* Qt interface */
 /* #define GNOME_GRAPHICS */	/* Gnome interface */
 /* #define MSWIN_GRAPHICS */	/* Windows NT, CE, Graphics */
+#define LISP_GRAPHICS	/* lisp interface */
 
 /*
  * Define the default window system.  This should be one that is compiled
  * into your system (see defines above).  Known window systems are:
  *
- *	tty, X11, mac, amii, BeOS, Qt, Gem, Gnome
+ *	tty, X11, mac, amii, BeOS, Qt, Gem, Gnome, lisp
  */
 
 /* MAC also means MAC windows */
@@ -109,6 +110,12 @@
 #  define DEFAULT_WINDOW_SYS "mswin"
 # endif
 # define HACKDIR "\\nethack"
+#endif
+
+#ifdef LISP_GRAPHICS
+# ifndef DEFAULT_WINDOW_SYS
+#  define DEFAULT_WINDOW_SYS "lisp"
+# endif
 #endif
 
 #ifndef DEFAULT_WINDOW_SYS
diff -Pru nethack-3.4.1/include/qttableview.h nethack/include/qttableview.h
--- nethack-3.4.1/include/qttableview.h	Sun Feb 23 06:43:22 2003
+++ nethack/include/qttableview.h	Tue Apr 23 12:00:16 2002
@@ -1,5 +1,5 @@
 /**********************************************************************
-** $Id: qttableview.h,v 1.2 2002/03/09 03:13:13 jwalz Exp $
+** $Id: qttableview.h,v 1.1.1.1 2002/04/23 19:00:16 sabetts Exp $
 **
 ** Definition of QtTableView class
 **
diff -Pru nethack-3.4.1/include/winlisp.h nethack/include/winlisp.h
--- nethack-3.4.1/include/winlisp.h	Wed Dec 31 16:00:00 1969
+++ nethack/include/winlisp.h	Thu Jan 10 19:54:20 2002
@@ -0,0 +1,70 @@
+#ifndef WINLISP_H
+#define WINLISP_H
+
+#ifndef E
+#define E extern
+#endif
+
+#if defined(BOS) || defined(NHSTDC)
+#define DIMENSION_P int
+#else
+# ifdef WIDENED_PROTOTYPES
+#define DIMENSION_P unsigned int
+# else
+#define DIMENSION_P Dimension
+# endif
+#endif
+
+extern struct window_procs tty_procs;
+
+/* ### winlisp.c ### */
+E void NDECL(win_lisp_init);
+E void FDECL(lisp_init_nhwindows, (int *, char **));
+E void NDECL(lisp_player_selection);
+E void NDECL(lisp_askname);
+E void NDECL(lisp_get_nh_event) ;
+E void FDECL(lisp_exit_nhwindows, (const char *));
+E void FDECL(lisp_suspend_nhwindows, (const char *));
+E void NDECL(lisp_resume_nhwindows);
+E winid FDECL(lisp_create_nhwindow, (int));
+E void FDECL(lisp_clear_nhwindow, (winid));
+E void FDECL(lisp_display_nhwindow, (winid, BOOLEAN_P));
+E void FDECL(lisp_destroy_nhwindow, (winid));
+E void FDECL(lisp_curs, (winid,int,int));
+E void FDECL(lisp_putstr, (winid, int, const char *));
+E void FDECL(lisp_display_file, (const char *, BOOLEAN_P));
+E void FDECL(lisp_start_menu, (winid));
+E void FDECL(lisp_add_menu, (winid,int,const ANY_P *,
+			CHAR_P, CHAR_P, int, const char *, BOOLEAN_P));
+E void FDECL(lisp_end_menu, (winid, const char *));
+E int FDECL(lisp_select_menu, (winid, int, MENU_ITEM_P **));
+E char FDECL(lisp_message_menu, (char, int, const char *mesg));
+E void NDECL(lisp_update_inventory);
+E void NDECL(lisp_mark_synch);
+E void NDECL(lisp_wait_synch);
+#ifdef CLIPPING
+E void FDECL(lisp_cliparound, (int, int));
+#endif
+#ifdef POSITIONBAR
+E void FDECL(lisp_update_positionbar, (char *));
+#endif
+E void FDECL(lisp_print_glyph, (winid,XCHAR_P,XCHAR_P,int));
+E void FDECL(lisp_raw_print, (const char *));
+E void FDECL(lisp_raw_print_bold, (const char *));
+E int NDECL(lisp_nhgetch);
+E int FDECL(lisp_nh_poskey, (int *, int *, int *));
+E void NDECL(lisp_nhbell);
+E int NDECL(lisp_doprev_message);
+E char FDECL(lisp_yn_function, (const char *, const char *, CHAR_P));
+E void FDECL(lisp_getlin, (const char *,char *));
+E int NDECL(lisp_get_ext_cmd);
+E void FDECL(lisp_number_pad, (int));
+E void NDECL(lisp_delay_output);
+
+/* other defs that really should go away (they're tty specific) */
+E void NDECL(lisp_start_screen);
+E void NDECL(lisp_end_screen);
+
+E void FDECL(lisp_outrip, (winid,int));
+
+#endif /* WINLISP_H */
diff -Pru nethack-3.4.1/src/.cvsignore nethack/src/.cvsignore
--- nethack-3.4.1/src/.cvsignore	Wed Dec 31 16:00:00 1969
+++ nethack/src/.cvsignore	Thu Jan 10 20:03:17 2002
@@ -0,0 +1,8 @@
+Makefile
+Sysunix
+config.h-t
+hack.h-t
+monstr.c
+nethack
+tile.c
+vis_tab.c
diff -Pru nethack-3.4.1/src/windows.c nethack/src/windows.c
--- nethack-3.4.1/src/windows.c	Sun Feb 23 06:43:31 2003
+++ nethack/src/windows.c	Tue Apr 23 17:44:58 2002
@@ -40,6 +40,10 @@
 #ifdef MSWIN_GRAPHICS
 extern struct window_procs mswin_procs;
 #endif
+#ifdef LISP_GRAPHICS
+#include "winlisp.h"
+extern struct window_procs lisp_procs;
+#endif
 
 STATIC_DCL void FDECL(def_raw_print, (const char *s));
 
@@ -80,6 +84,9 @@
 #endif
 #ifdef MSWIN_GRAPHICS
     { &mswin_procs, 0 },
+#endif
+#ifdef LISP_GRAPHICS
+    { &lisp_procs, win_lisp_init },
 #endif
     { 0, 0 }		/* must be last */
 };
diff -Pru nethack-3.4.1/sys/amiga/HackWB.uu nethack/sys/amiga/HackWB.uu
--- nethack-3.4.1/sys/amiga/HackWB.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/HackWB.uu	Thu Jan 10 16:43:23 2002
@@ -0,0 +1,22 @@
+begin 777 HackWB.info
+MXQ```0``````$0`/`%``$P`&``,``0`F":@`)F<(````````````````````
+M```!`P````````````````T````$`````````````$X@``````!0`!(``@`!
+M3B`#```````````````````!`````````````P````````````,```"```!`
+M```C```!@```P```8P!]\8"Y[L`;VF,```&```#```!C``>!@___P?__XP``
+M`8````````,`^]V```!````C!___@```P```8P````'6Y<!\FF,```````#`
+M``!C`````___P?__XP````````````,````````````#`````````````W__
+M_______________________^P````````````,````````````#/__\'__^#
+M___`S```!@```P```,Q]\`:Y[@,;V@#,```&```#````S`>`!````@```,P`
+M``````````#,^]P'__^#___`R```!@```P```,````?6Y0-\F@#````&```#
+M````P```!````@```,````````````#`````````````P````````````(``
+M`````````````````%``$@`"``%/B`,``````/____________[`````````
+M````P````````````,___P```$```"#/__X```#```!@SX(.`+GNP!O:8,__
+M_@```,```&#/^'X#___!___@S__^`````````,\$(@```$```"#(``````#`
+M``!@P````=;EP'R:8,```````,```&#````#___!___@P````````````,``
+M``````````#`````````````@`````````````````````````$`````````
+M```#`````````````P```(?__X/__\,#__^&```#```#`X(/AKGN`QO:`P/_
+M_X8```,```,#^'^$```"```#`___@````````P,$(X?__X/__\,'__^&```#
+M```#````!];E`WR:`P````8```,```,````$```"```#`````````````P``
+<``````````,````````````#?____________P`"
+`
+end
diff -Pru nethack-3.4.1/sys/amiga/NHinfo.uu nethack/sys/amiga/NHinfo.uu
--- nethack-3.4.1/sys/amiga/NHinfo.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/NHinfo.uu	Thu Jan 10 16:43:23 2002
@@ -0,0 +1,38 @@
+begin 777 NetHack.info
+MXQ```0``````=@`^`%``(@`&`0L``0`DT>``)4KX``````````````````0`
+M```!!!@`)-O@`"69&(````"``````````````````)Q```````!0`"$``@`"
+M_0@#```````````````````!`````````````P````````````,`````````
+M```#`````````````P````````````,``!__@``````#``!U57```````P`!
+MJJJH``````,``5557``````#``:JJJH``````P`%??WU``````,`!OJ[^P``
+M```#``5O_=4``````P`&JJJK`````/L`!575U0'_[/_[``:OOJO_____XP`%
+M5554>^```!L#_JZJJT%4F*=3'\5UWO7224```S`&N^^K!EPE]TL"M55556K6
+MHL`#)6?___\#4Z^``SJG____X@`*E-,<D?____H#5*W3("L?___XR`<`<RO]
+M[___Z.ZGW#,H(8#___.`>H(#%"$#?__`+`!-BP!!&/@/0`,D0!,V"`P,<WQX
+M``9+*`%F`X!CG#F`ZW_________________________^P````````````,0!
+M\$`(`````$#`#X`$``0`@!``P#\``$`@`@"``,!^`$``((``@(#$?A__L```
+M`0``Q'_U57`!P````,(_JJJH8`@``0#`'5557`!`1```P`:JJJH!```"`,`5
+M`0`%`````0#$1H**"R$#!@``Q@4!`%4``"```,`6JJJK`>@.LP#$%455%1``
+M$P``P`:JHHH``````,$E5554``````#(!*JJJP``````P`4U`!4``````,`&
+MJ`BK``````#`!5555```````P`?___\``````,````````````#`````````
+M````P````````````,````````````#`````````````P````````````,``
+M``````````#`````````````P````````````(```````````````````%``
+M(0`"``1:T`,``````/_____________`````````````P````````````,``
+M``````````#`````````````P````````````,````````````#`````````
+M````P````````````,````````````#```/G@```````P`!^_>```````,``
+M]SOX``````#``:_]W```````P`>JJJX`````^,`%5=74`?_L__C`!J^^JW__
+M___@P`55551[X```&,-^KJJK0528IU#>!77>]=))0```\8:[[ZL&3"6W2,+5
+M5555:M8BP`#D1____P-`#H``^V?____"``J4T-U!____Z@,4K=#@*Q___\B(
+M!@!PZ]WH_\P([B?<,.@A@,$$<X!R``#4(`-$*T`D`$V(P$$8^`%``R1`$/8(
+M#`QS;'@`!DCH`68#@&.<.8#H@```````````````````````````````````
+M```#!`?X0`@`````0P`?_@0`!`"`$`,`/_\`0"`"`(`#`'__@``@@`"`@P1_
+M_X`````!``,$?_^```'````#`C__``!@"``!`P`?_@```$!$``,`!_/G@`$`
+M``(#`!!^_&`````!`P1`]PHX(0,&``,&`8$`7```(``#`!>JJJX!Z`ZS`P05
+M1544$``3``,`!JJBB@`````#`255550``````P@$JJJK````"`,`!34`%0``
+M```#``:H"*L```!``P`%5554`````(,`!____P`(`$`#````````$````P`0
+M``````!```,````````!```#`"```````````P```````````@,``P````!"
+M"``#`````````````P````````````,````````````#?____________P``
+M`!!(86-K17AE.DYE=$AA8VL`````%````!%(04-+1$E2/4YE=$AA8VLZ````
+M`!9,159%3%,]3F5T:&%C:SIL979E;',`````$E-!5D4]3F5T:&%C:SIS879E
+3``````Y0051(/4YE=$AA8VLZ`'9E
+`
+end
diff -Pru nethack-3.4.1/sys/amiga/NewGame.uu nethack/sys/amiga/NewGame.uu
--- nethack-3.4.1/sys/amiga/NewGame.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/NewGame.uu	Thu Jan 10 16:43:23 2002
@@ -0,0 +1,38 @@
+begin 777 NewGame.info
+MXQ```0``````=@`^`%``(@`&`0L``0`DT>``)4KX``````````````````0`
+M```!!!@`)-O@`"69&(````"``````````````````)Q```````!0`"$``@`"
+M_0@#```````````````````!`````````````P````````````,`````````
+M```#`````````````P````````````,``!__@``````#``!U57```````P`!
+MJJJH``````,``5557``````#``:JJJH``````P`%??WU``````,`!OJ[^P``
+M```#``5O_=4``````P`&JJJK`````/L`!575U0'_[/_[``:OOJO_____XP`%
+M5554>^```!L#_JZJJT%4F*=3'\5UWO7224```S`&N^^K!EPE]TL"M55556K6
+MHL`#)6?___\#4Z^``SJG____X@`*E-,<D?____H#5*W3("L?___XR`<`<RO]
+M[___Z.ZGW#,H(8#___.`>H(#%"$#?__`+`!-BP!!&/@/0`,D0!,V"`P,<WQX
+M``9+*`%F`X!CG#F`ZW_________________________^P````````````,0!
+M\$`(`````$#`#X`$``0`@!``P#\``$`@`@"``,!^`$``((``@(#$?A__L```
+M`0``Q'_U57`!P````,(_JJJH8`@``0#`'5557`!`1```P`:JJJH!```"`,`5
+M`0`%`````0#$1H**"R$#!@``Q@4!`%4``"```,`6JJJK`>@.LP#$%455%1``
+M$P``P`:JHHH``````,$E5554``````#(!*JJJP``````P`4U`!4``````,`&
+MJ`BK``````#`!5555```````P`?___\``````,````````````#`````````
+M````P````````````,````````````#`````````````P````````````,``
+M``````````#`````````````P````````````(```````````````````%``
+M(0`"``1:T`,``````/_____________`````````````P````````````,``
+M``````````#`````````````P````````````,````````````#`````````
+M````P````````````,````````````#```/G@```````P`!^_>```````,``
+M]SOX``````#``:_]W```````P`>JJJX`````^,`%5=74`?_L__C`!J^^JW__
+M___@P`55551[X```&,-^KJJK0528IU#>!77>]=))0```\8:[[ZL&3"6W2,+5
+M5555:M8BP`#D1____P-`#H``^V?____"``J4T-U!____Z@,4K=#@*Q___\B(
+M!@!PZ]WH_\P([B?<,.@A@,$$<X!R``#4(`-$*T`D`$V(P$$8^`%``R1`$/8(
+M#`QS;'@`!DCH`68#@&.<.8#H@```````````````````````````````````
+M```#!`?X0`@`````0P`?_@0`!`"`$`,`/_\`0"`"`(`#`'__@``@@`"`@P1_
+M_X`````!``,$?_^```'````#`C__``!@"``!`P`?_@```$!$``,`!_/G@`$`
+M``(#`!!^_&`````!`P1`]PHX(0,&``,&`8$`7```(``#`!>JJJX!Z`ZS`P05
+M1544$``3``,`!JJBB@`````#`255550``````P@$JJJK````"`,`!34`%0``
+M```#``:H"*L```!``P`%5554`````(,`!____P`(`$`#````````$````P`0
+M``````!```,````````!```#`"```````````P```````````@,``P````!"
+M"``#`````````````P````````````,````````````#?____________P``
+M`!!(86-K17AE.DYE=$AA8VL`````%````!%(04-+1$E2/4YE=$AA8VLZ````
+M`!9,159%3%,]3F5T:&%C:SIL979E;',`````$E-!5D4]3F5T:&%C:SIS879E
+3``````Y0051(/4YE=$AA8VLZ`'9E
+`
+end
diff -Pru nethack-3.4.1/sys/amiga/amilib.c nethack/sys/amiga/amilib.c
--- nethack-3.4.1/sys/amiga/amilib.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/amilib.c	Thu Jan 10 16:43:23 2002
@@ -0,0 +1,369 @@
+/*	SCCS Id: @(#)amilib.c	3.2	96/02/04	*/
+/* Copyright (c) Gregg Wonderly, Naperville, Illinois,  1991,1992,1993,1996. */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#include "hack.h"
+#include "wintype.h"
+#include "winami.h"
+#include "func_tab.h"
+
+#ifdef AMIGA_INTUITION
+
+#include <exec/types.h>
+#include <graphics/gfxbase.h>
+#include <intuition/intuition.h>
+#include <intuition/intuitionbase.h>
+#include <libraries/dosextens.h>
+#include <ctype.h>
+#undef  strcmpi
+#include <string.h>
+#include <errno.h>
+
+#ifdef  IDCMP_CLOSEWINDOW
+# define	INTUI_NEW_LOOK
+#endif
+
+#ifdef AZTEC_C
+# include <functions.h>
+#else
+# ifndef _DCC
+#  include <dos.h>
+# endif
+# ifdef _DCC
+#  include <clib/exec_protos.h>
+# else
+#  include <proto/exec.h>
+# endif
+#endif
+
+#include "NH:sys/amiga/lib/amilib.h"
+#include "winproto.h"
+
+WinamiBASE *WinamiBase = 0;
+
+extern char *roles[];
+extern char orgdir[];
+
+struct Library *ConsoleDevice = 0;
+int bigscreen = 0;
+char Initialized = 0;
+struct amii_DisplayDesc *amiIDisplay = 0;
+struct Screen *HackScreen = 0;
+winid WIN_BASE = WIN_ERR;
+#ifdef	VIEWWINDOW
+winid WIN_OVER = WIN_ERR;
+#endif
+winid amii_rawprwin = WIN_ERR;
+extern const char *configfile;
+
+void amii_outrip( winid, int );
+void setup_librefs( WinamiBASE * );
+
+/* The current color map */
+unsigned short amii_initmap[ MAXCOLORS ] = {
+#define C_BLACK		0
+#define C_WHITE		1
+#define C_BROWN		2
+#define C_CYAN		3
+#define C_GREEN		4
+#define C_MAGENTA	5
+#define C_BLUE		6
+#define C_RED		7
+
+    0x0000, /* color #0 */
+    0x0FFF, /* color #1 */
+    0x0830, /* color #2 */
+    0x07ac, /* color #3 */
+    0x0181, /* color #4 */
+    0x0C06, /* color #5 */
+    0x023E, /* color #6 */
+    0x0c00  /* color #7 */
+#ifdef	VIEWWINDOW
+    0x0AAA,	/* Various shades of grey */
+    0x0fff,
+    0x0444,
+    0x0666,
+    0x0888,
+    0x0bbb,
+    0x0ddd,
+    0x0222,
+#endif
+};
+
+/* Interface definition, for use by windows.c and winprocs.h to provide
+ * the simple intuition interface for the amiga...
+ */
+struct window_procs amii_procs =
+{
+    "amii",
+    amii_init_nhwindows,
+    amii_player_selection,
+    amii_askname,
+    amii_get_nh_event,
+    amii_exit_nhwindows,
+    amii_suspend_nhwindows,
+    amii_resume_nhwindows,
+    amii_create_nhwindow,
+    amii_clear_nhwindow,
+    amii_display_nhwindow,
+    amii_destroy_nhwindow,
+    amii_curs,
+    amii_putstr,
+    amii_display_file,
+    amii_start_menu,
+    amii_add_menu,
+    amii_end_menu,
+    amii_select_menu,
+    genl_message_menu,
+    amii_update_inventory,
+    amii_mark_synch,
+    amii_wait_synch,
+#ifdef CLIPPING
+    amii_cliparound,
+#endif
+#ifdef POSITIONBAR
+    donull,
+#endif
+    amii_print_glyph,
+    amii_raw_print,
+    amii_raw_print_bold,
+    amii_nhgetch,
+    amii_nh_poskey,
+    amii_bell,
+    amii_doprev_message,
+    amii_yn_function,
+    amii_getlin,
+    amii_get_ext_cmd,
+    amii_number_pad,
+    amii_delay_output,
+    /* other defs that really should go away (they're tty specific) */
+#ifdef CHANGE_COLOR
+    amii_change_color,
+    amii_get_color_string,
+#endif
+    (void *)amii_delay_output,
+    (void *)amii_delay_output,
+
+    amii_outrip,
+};
+
+
+/* Interface definition, for use by windows.c and winprocs.h to provide
+ * the view window interface to nethack...
+ */
+struct window_procs amiv_procs =
+{
+    "amiv",
+    amii_init_nhwindows,
+    amii_player_selection,
+    amii_askname,
+    amii_get_nh_event,
+    amii_exit_nhwindows,
+    amii_suspend_nhwindows,
+    amii_resume_nhwindows,
+    amii_create_nhwindow,
+    amii_clear_nhwindow,
+    amii_display_nhwindow,
+    amii_destroy_nhwindow,
+    amii_curs,
+    amii_putstr,
+    amii_display_file,
+    amii_start_menu,
+    amii_add_menu,
+    amii_end_menu,
+    amii_select_menu,
+    genl_message_menu,
+    amii_update_inventory,
+    amii_mark_synch,
+    amii_wait_synch,
+#ifdef CLIPPING
+    amii_cliparound,
+#endif
+#ifdef POSITIONBAR
+    donull,
+#endif
+    amii_print_glyph,
+    amii_raw_print,
+    amii_raw_print_bold,
+    amii_nhgetch,
+    amii_nh_poskey,
+    amii_bell,
+    amii_doprev_message,
+    amii_yn_function,
+    amii_getlin,
+    amii_get_ext_cmd,
+    amii_number_pad,
+    (void *)amii_delay_output,
+    /* other defs that really should go away (they're tty specific) */
+#ifdef CHANGE_COLOR
+    amii_change_color,
+    amii_get_color_string,
+#endif
+    (void *)amii_delay_output,
+    (void *)amii_delay_output,
+
+    amii_outrip,
+};
+
+void
+amii_loadlib( void )
+{
+    /* Close the library if opened it already (switching display types) */
+    if( WinamiBase )
+	CloseLibrary( (struct Library *)WinamiBase );
+
+    if( ( WinamiBase = ( WinamiBASE *)OpenLibrary( "winami.library", 0 ) ) == NULL )
+    {
+	panic( "can't find winami.library" );
+    }
+    setup_librefs( WinamiBase );
+}
+
+void
+amiv_loadlib( void )
+{
+    /* Close the library if opened it already (switching display types) */
+    if( WinamiBase )
+	CloseLibrary( (struct Library *)WinamiBase );
+
+    if( ( WinamiBase = ( WinamiBASE *)OpenLibrary( "winamiv.library", 0 ) ) == NULL )
+    {
+	panic( "can't find winami.library" );
+    }
+    setup_librefs( WinamiBase );
+}
+
+void
+CleanUp()
+{
+    if( WinamiBase )
+    {
+	CloseLibrary( (struct Library *)WinamiBase );
+	WinamiBase = NULL;
+    }
+}
+
+/* The library has references to the following code and data items in the main
+ * game, so fill in the access pointers for it to user...uggghhh...
+ */
+void
+setup_librefs( base )
+	WinamiBASE *base;
+{
+    base->G_pline = pline;
+    base->G_display_inventory = display_inventory;
+    base->G_terminate = terminate;
+    base->G_rnd = rnd;
+    base->G_rn2 = rn2;
+    base->G_panic = panic;
+    base->G_clearlocks = clearlocks;
+    base->G_on_level = on_level;
+    base->G_exit = exit;
+    base->G_lowc = lowc;
+    base->G_alloc = alloc;
+    base->G_Abort = Abort;
+    base->G_error = error;
+    base->G_fopenp = fopenp;
+    base->G_doredraw = doredraw;
+    base->G_fopen = fopen;
+    base->G_fclose = fclose;
+    base->G_fputs = fputs;
+    base->G_fprintf = fprintf;
+    base->G_fgets = fgets;
+    base->G_fflush = fflush;
+
+    base->G_yn_number = &yn_number;
+    base->G_zapcolors = zapcolors;
+    base->G_plname = plname;
+    base->G_objects = objects;
+    base->G_monsyms = monsyms;
+    base->G_extcmdlist = extcmdlist;
+    base->G_flags = &flags;
+    base->G_oc_syms = oc_syms;
+    base->G_showsyms = showsyms;
+    base->G_quitchars = quitchars;
+    base->G_pl_character = pl_character;
+    base->G_WIN_MESSAGE = &WIN_MESSAGE;
+    base->G_WIN_MAP = &WIN_MAP;
+    base->G_tc_gbl_data = &tc_gbl_data;
+    base->G_defsyms = defsyms;
+    base->G_WIN_STATUS = &WIN_STATUS;
+    base->G_u = &u;
+    base->G_roles = roles;
+    base->G_dungeon_topology = &dungeon_topology;
+    base->G_toplines = toplines;
+    base->G_WIN_INVEN = &WIN_INVEN;
+    base->G_windowprocs = &windowprocs;
+    base->G_orgdir = orgdir;
+    base->G_mons = mons;
+    base->G_amiIDisplay = &amiIDisplay;
+    base->G_HackScreen = &HackScreen;
+    base->G_pl_classes = pl_classes;
+    base->G_bigscreen = &bigscreen;
+    base->G_WINBASE = &WIN_BASE;
+    base->G_amii_rawprwin = &amii_rawprwin;
+    base->G_amii_initmap = amii_initmap;
+    base->G_Initialized = &Initialized;
+    base->G_ConsoleDevice = &ConsoleDevice;
+    base->G_configfile = configfile;
+    base->G_amii_procs = &amii_procs;
+    base->G_amii_set_text_font = amii_set_text_font;
+}
+
+/*
+ * We don't compile the NetHack sources with amilib.h, so we define the function
+ * here to call the shared library version
+ */
+void
+amii_set_text_font( name, size )
+    char *name;
+    int size;
+{
+	/*(*WinamiBase->G_amii_set_text_font)( name, size );*/
+}
+#endif
+
+void Abort(rc)
+long rc;
+{
+#ifdef CHDIR
+    chdir(orgdir);
+#endif
+    if (Initialized && ConsoleDevice) {
+	printf("\n\nAbort with alert code %08lx...\n", rc);
+	amii_getret();
+    } else
+	Alert(rc);
+#ifdef __SASC
+    {
+/*  __emit(0x4afc);     /* illegal instruction */
+    __emit(0x40fc);     /* divide by */
+    __emit(0x0000);     /*  #0  */
+	/* NOTE: don't move CleanUp() above here - */
+	/* it is too likely to kill the system     */
+	/* before it can get the SnapShot out, if  */
+	/* there is something really wrong.    */
+    }
+#endif
+    CleanUp();
+#undef exit
+#ifdef AZTEC_C
+    _abort();
+#endif
+    exit((int) rc);
+}
+
+/* fatal error */
+/*VARARGS1*/
+void error VA_DECL(const char *, s)
+    VA_START(s);
+    VA_INIT(s, char *);
+
+    putchar('\n');
+    vprintf(s, VA_ARGS);
+    putchar('\n');
+
+    VA_END();
+    Abort(0L);
+}
+
diff -Pru nethack-3.4.1/sys/amiga/amiwbench.c nethack/sys/amiga/amiwbench.c
--- nethack-3.4.1/sys/amiga/amiwbench.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/amiwbench.c	Thu Jan 10 16:43:23 2002
@@ -0,0 +1,639 @@
+/*    SCCS Id: @(#)amiwbench.c      3.1   93/01/08
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1990, 1992, 1993 */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*  Amiga Workbench interface  */
+
+#include "hack.h"
+
+#ifdef _DCC
+# define isascii(ch) ((ch) >= 0 && (ch) < 0x80 ? 1 : 0)
+#endif
+
+/* Have to #undef CLOSE, because it's used in display.h and intuition.h */
+#undef CLOSE
+
+#ifdef __SASC
+# undef COUNT
+# include <proto/exec.h>
+# include <proto/dos.h>
+# include <proto/icon.h>
+#else
+# ifdef _DCC
+#  include <clib/exec_protos.h>
+#  include <clib/dos_protos.h>
+#  include <clib/icon_protos.h>
+# endif
+#endif
+
+#include <workbench/startup.h>
+#include <workbench/workbench.h>
+#include <exec/memory.h>
+#include <ctype.h>
+
+#ifdef __SASC
+# include <ios1.h>
+# include <string.h>
+# undef strlen          /* grrr */
+#endif
+
+#define ALLOC_SIZE      ((long)sizeof(struct FileInfoBlock))
+
+#if defined(AZTEC_C) || defined(_DCC)
+extern struct Library *IconBase;
+# ifdef AZTEC_C
+#  include <functions.h>
+# endif
+#endif
+
+extern void NDECL( preserve_icon );
+extern void NDECL( clear_icon );
+#ifndef	SHAREDLIB
+extern void FDECL( amii_set_text_font, ( char *, int ) );
+#endif
+extern int FDECL(parse_config_line, (FILE *, char *, char *, char *));
+extern char *FDECL( ami_default_icon, ( char * ) );
+
+/*XXXint ami_argc;           /* global argc */
+/*XXXchar **ami_argv;        /* global argv */
+struct WBStartup *wbs;	/* startup message */
+
+boolean FromWBench=0;       /* how did we get started? */
+boolean FromCLI=0;      /* via frontend and INTERNALCLI */
+static BOOL FromTool=0;     /* or from Project (ergo nothing to restore) */
+static char argline[80];    /* fake command line from ToolTypes */
+static BOOL TTparse=0;      /* parsing tooltypes? */
+static BOOL KillIcon=FALSE; /* delayed expunge of user's icon */
+static char iconname[PATHLEN+5];
+static char origicon[PATHLEN+5];
+static char savefname[PL_NSIZ];     /* name from name of save file */
+int amibbs=0;			/* BBS mode */
+char bbs_id[80]="";		/* BBS uid equivalent */
+long afh_in, afh_out;		/* BBS mode Amiga filehandles */
+
+static unsigned long FDECL(ahtoi, (const char *));
+long bbs_save_stdin=0;
+long bbs_save_stdout=0;
+long bbs_save_stderr=0;
+
+#ifdef AMII_GRAPHICS
+extern int bigscreen;
+#endif
+extern const char *classes; /* liberated from pcmain */
+extern char PATH[];
+
+static void score(char *);
+
+#ifdef _DCC
+/* When run from Workbench, DICE calls wbmain() instead of main(), so we
+ * need to call main() ourselves.
+ */
+wbmain(struct WBStartup *WBMsg) 
+{
+	main(0, (char **)WBMsg);
+}
+#endif
+
+/* Called after NetHack.cnf (and maybe NETHACKOPTIONS) are read.
+ * If this is a request to show the score file, do it here and quit.
+ */
+void ami_wbench_init()
+{
+    struct WBArg *wa;
+    int ia;         /* arg of active icon */
+    int x,doscore=0;
+    char    *p,*lp;
+    BPTR    olddir;         /* starting directory */
+    struct DiskObject *dobj;
+    char    *scorearg, *t;
+    char    tmp_levels[PATHLEN];
+
+    if(!FromWBench)return;          /* nothing if from CLI */
+
+    /*
+     * "NULL" out arrays
+     */
+    tmp_levels[0]  = '\0';
+
+    IconBase=OpenLibrary("icon.library",33L);
+    if(!IconBase)error("icon.library missing!");
+
+    wa=wbs->sm_ArgList;
+    if(wbs->sm_NumArgs>2)error("You can only play one game at a time!");
+    ia=wbs->sm_NumArgs-1;
+
+    if(strcmp("NewGame",wa[ia].wa_Name)){
+	strcpy(savefname,wa[ia].wa_Name);
+	strcpy(plname,wa[ia].wa_Name);
+    }
+
+    if( ( t = strrchr( plname, '.' ) ) && strcmp( t, ".sav" ) == 0 )
+	*t = 0;
+
+    olddir=CurrentDir(wa[ia].wa_Lock);   /* where the icon is */
+
+    dobj=GetDiskObject(wa[ia].wa_Name);
+    (void)CurrentDir(olddir);       /* and back */
+    if(!dobj){
+	error("Sorry, I can't find your icon!");
+    }
+
+    FromTool=(dobj->do_Type==WBTOOL)?1:
+	(dobj->do_Type==WBPROJECT)?0:
+	(error("Sorry, I don't recognize this icon type!"),1);
+
+    if(index(savefname,'.') && !strncmp(index(savefname,'.'),".sav",4)){
+	*index(savefname,'.')='\0';
+    } else {
+	savefname[0]='\0';  /* don't override if not save file */
+	FromTool = 1;
+    }
+
+    argline[0]='\0';
+#ifdef AMII_GRAPHICS
+    if( p = FindToolType( dobj->do_ToolTypes, "SCREEN" ) )
+    {
+	if( MatchToolValue( p, "NOLACE" ) )
+	    bigscreen = -1;
+	else if( MatchToolValue( p, "LACE" ) )
+	    bigscreen = 1;
+    }
+#endif
+    if(dobj->do_ToolTypes)for(x=0;p=dobj->do_ToolTypes[x];x++){
+	lp=index(p,'=');
+	if( !lp || strncmp(p, "SCORE", 5 ) == 0 ){
+	    if((strncmp(p,"SCORES",6)==0) || (strncmp(p,"SCORE",5)==0)){
+		if( !lp )
+		    lp = "";
+		else
+		    ++lp;
+		doscore=1;
+		scorearg=(char *)alloc(strlen(lp)+1);
+		strcpy(scorearg,lp);
+	    } else {
+		TTparse=TRUE;
+		parseoptions(p,(boolean)TRUE,(boolean)FALSE);
+		TTparse=FALSE;
+	    }
+	} else {
+	    lp++;
+	    TTparse=TRUE;
+		/* new things */
+	    if((strncmp(p,"CMDLINE",7)==0)||
+	      (strncmp(p,"COMMANDLINE",11)==0)||
+	      (strncmp(p,"INTERNALCLI",11)==0)){
+	    	strncpy(argline,lp,79);
+		if(*p=='I'){
+		    FromTool=0; /* ugly hack bugfix */
+		    FromCLI=1;  /* frontend ICLI only */
+		    if(*argline==':'){		/* BBS mode */
+				/* bbs info: :%08x %08x ;%s
+				 * where the info is : Input() Output()
+				 * ; bbs_id
+				 */
+			char *ptri, *ptro;
+			amibbs=1;
+			afh_in=ahtoi(lp+1);
+			afh_out=ahtoi(lp+10);
+			ptri = lp+19, ptro = bbs_id;
+			if(*ptri == ';'){
+			    ptri++;
+			    while(*ptri && !isspace(*ptri)){
+				if(ptro < &bbs_id[sizeof(bbs_id)-1])
+				    *ptro++ = *ptri++;
+				}
+			    *ptro++ = '_';
+			}
+			*ptro = '\0';
+#ifdef __SASC
+# if (__VERSION__== 6) && (__REVISION__ >= 51)
+
+	chkufb(fileno(stdout))->ufbfh=afh_out;
+	
+# else
+   VERSION SPECIFIC SUPPORT REQUIRED
+# endif
+#else
+# if _DCC
+	_IoStaticFD[fileno(stdin)].fd_Fh = afh_in;
+	_IoStaticFD[fileno(stdout)].fd_Fh = afh_out;
+	_IoStaticFD[fileno(stderr)].fd_Fh = afh_out;
+# else
+  COMPILER SPECIFIC SUPPORT REQUIRED
+	Move stdin, stdout, stderr to the Input and Output values
+	passed from the front end.
+# endif
+#endif
+			strncpy(argline,ptri,79);
+		    }
+		}
+	    }
+	    else if( strncmp( p, "FONT", 4 ) == 0 )
+	    {
+		if( p = strdup( lp ) )
+		{
+		    lp = strchr( p, ':' );
+		    *lp++ = 0;
+		    amii_set_text_font( p, atoi( lp ) );
+		    free( p );
+		}
+	    }
+	    else if( strncmp( p, "SCREEN",6 ) )
+	    {
+		if (!parse_config_line((FILE *)0, p, 0, tmp_levels)){
+		    raw_printf("Bad ToolTypes line: '%s'\n",p);
+		    getreturn("to continue");
+		}
+	    } 
+	    TTparse=FALSE;
+	}
+    }
+
+    /* cleanup - from files.c, except we only change things
+     * that are explicitly changed, since we already
+     * did this once to get the defaults (in amidos.c)
+     */
+
+    if(plname[0]){
+	plnamesuffix(); /* from files.c */
+	set_savefile_name();
+    }
+    if(tmp_levels[0])strcpy(permbones,tmp_levels);
+    if(tmp_levels[0]){
+	strcpy(levels,tmp_levels);
+	strcpy(bones,levels);
+    }
+    FreeDiskObject(dobj);   /* we'll get it again later if we need it */
+
+    if(doscore)score(scorearg);
+
+	    /* if the user started us from the tool icon,
+	     * we can't save the game in the same place
+	     * we started from, so pick up the plname
+	     * and hope for the best.
+	     */
+    if(FromTool){
+	set_savefile_name();
+    }
+}
+
+#if 0
+/* Simulate the command line. Note that we do not handle the
+ * entire range of standard NetHack flags.
+ */
+void ami_wbench_args(){
+    char *p=argline;
+
+    if(!FromWBench) return;
+
+    while(*p){
+	switch(*p++){
+	case ' ':
+	case '-':   break;
+#ifdef NEWS
+	case 'n':   iflags.news = FALSE;
+#endif
+	case 'D':
+# ifdef WIZARD
+#  ifdef KR1ED
+	    if(!strcmp(plname,WIZARD_NAME))
+#  else
+	    if(!strcmp(plname,WIZARD))
+#  endif
+	    {
+		wizard=TRUE;break;
+	    }
+	    /* else fall through */
+# endif
+	case 'X':   discover=TRUE;
+	    break;
+#ifdef AMII_GRAPHICS
+	case 'L':   /* interlaced screen */
+	    bigscreen = 1;
+	    break;
+	case 'l':   /* No interlaced screen */
+	    bigscreen = -1;
+	    break;
+#endif
+	case 'u':
+	    {
+	    char *c,*dest;
+	    while(*p && isascii(*p) && isspace(*p))p++;
+	    c=p;
+	    dest=plname;
+	    for(;*p && isascii(*p) && !isspace(*p);){
+		if(dest-plname>=(sizeof(plname)-1))break;
+		*dest++=*p++;
+	    }
+	    *dest='\0';
+	    if(c==dest)
+		raw_print("Player name expected after -u");
+	    }
+	    strcpy(savefname,plname);
+	    set_savefile_name();
+	    break;
+	case 's':
+	    score(p);
+	    /* NOTREACHED */
+	default:
+	    {
+	    	char *q = p-1;
+	    	int i;
+
+
+	    	while (*p && !isspace(*p)) p++;
+	    	if (*p) *p++ = '\0';
+	    	if ((i = str2role(q) >= 0) {
+	    		flags.initrole = i;
+	    		break;
+	    	} else if ((i = str2race(q) >= 0) {
+	    		flags.initrace = i;
+	    		break;
+	    	} else if ((i = str2gend(q) >= 0) {
+	    		flags.initgend = i;
+	    		break;
+	    	} else if ((i = str2align(q) >= 0) {
+	    		flags.initalign = i;
+	    		break;
+	    	}
+	    }
+	    raw_printf("Unknown switch: %s\n",p);
+	    /* FALL THROUGH */
+	case '?':
+	    {
+		char buf[77];
+
+		raw_printf("Usage: %s -s [-[%s]] [maxrank] [name]...",
+		  hname, classes);
+		raw_print("       or");
+		sprintf(buf,"       %s [-u name] [-[%s]]", hname, classes);
+		strcat(buf," [-[DX]]");
+#ifdef NEWS
+		strcat(buf," [-n]");
+#endif
+#ifdef MFLOPPY
+# ifndef AMIGA
+		strcat(" [-r]");
+# endif
+#endif
+		raw_print(buf);
+		exit(0);
+	    }
+	}
+    }
+}
+#endif
+
+/* IF (from workbench) && (currently parsing ToolTypes)
+ * THEN print error message and return 0
+ * ELSE return 1
+ */
+ami_wbench_badopt(oopsline)
+const char *oopsline;
+{
+    if(!FromWBench)return 1;
+    if(!TTparse)return 1;
+
+    raw_printf("Bad Syntax in OPTIONS in ToolTypes: %s.",oopsline);
+    return 0;
+}
+
+/* Construct (if necessary) and fill in icon for given save file */
+void ami_wbench_iconwrite(base)
+char *base;
+{
+    BPTR lock;
+    char tmp[PATHLEN+5];
+    char *n;
+
+    if(!FromWBench)return;
+    if(FromCLI)return;
+
+    strcpy(tmp,base);
+    strcat(tmp,".info");
+
+    /* Get the name of the icon */
+    n = ami_default_icon( DEFAULT_ICON );
+    if(FromTool){               /* user clicked on main icon */
+	(void)CopyFile( n, tmp );
+    } else {                /* from project */
+	lock=Lock(tmp,ACCESS_READ);
+	if(lock==0){    /* maybe our name changed - try to get
+			 * original icon */
+	    if(!Rename(origicon,tmp)){
+		/* nope, build a new icon */
+	    lock=Lock( n, ACCESS_READ);
+	    if(lock==0)return;      /* no icon today */
+	    UnLock(lock);
+	    (void)CopyFile( n,tmp);
+	    }
+	} else UnLock(lock);
+    }
+    KillIcon=FALSE;
+}
+
+/* How much disk space will we need for the icon? */
+int ami_wbench_iconsize(base)
+char *base;
+{
+    struct FileInfoBlock *fib;
+    BPTR lock;
+    int rv;
+    char tmp[PATHLEN+5];
+
+    if(!FromWBench)return(0);
+    if(FromCLI)return(0);
+
+    strcpy(tmp,base);
+    strcat(tmp,".info");
+    lock=Lock(tmp,ACCESS_READ);
+    if(lock==0){    /* check the default */
+	lock=Lock( ami_default_icon( DEFAULT_ICON ),ACCESS_READ);
+	if(lock==0)return(0);
+    }
+    fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE, MEMF_CLEAR);
+    if(!Examine(lock,fib)){
+	UnLock(lock);
+	FreeMem(fib, ALLOC_SIZE);
+	return(0);          /* if no icon, there never will be one */
+    }
+    rv=fib->fib_Size+strlen(plname);    /* guessing */
+    UnLock(lock);
+    FreeMem(fib, ALLOC_SIZE);
+    return(rv);
+}
+
+char *
+ami_default_icon( defname )
+    char *defname;
+{
+    static char name[ 300 ];
+
+    strcpy( name, "NetHack:x.icon" );
+    name[ 8 ] = pl_character[ 0 ];
+
+    if( access( name, 0 ) == 0 )
+    	return( name );
+
+    return( defname );
+}
+
+/* Delete the icon associated with the given file (NOT the file itself! */
+/* (Don't worry if the icon doesn't exist */
+void ami_wbench_unlink(base)
+char *base;
+{
+    if(!FromWBench)return;
+    if(FromCLI)return;
+
+    strcpy(iconname,base);
+    strcat(iconname,".info");
+    KillIcon=TRUE;          /* don't do it now - this way the user
+			     * gets back whatever picture we had
+			     * when we started if the game is
+			     * saved again           */
+}
+
+static int preserved=0;		/* wizard mode && saved save file */
+
+void
+preserve_icon(){
+    preserved=1;
+}
+
+void
+clear_icon(){
+    if(!FromWBench)return;
+    if(FromCLI)return;
+    if(preserved)return;
+    if(!KillIcon)return;
+
+    DeleteFile(iconname);
+}
+
+/* Check for a saved game.
+IF not a saved game -> -1
+IF can't open SAVEF -> -1
+ELSE -> fd for reading SAVEF */
+int ami_wbench_getsave(mode)
+int mode;
+{
+    BPTR lock;
+    struct FileInfoBlock *fib;
+
+    if(!FromWBench)return(open(SAVEF,mode));
+	    /* if the file will be created anyway, skip the
+	     * checks and just do it       */
+    if(mode & O_CREAT)return(open(SAVEF,mode));
+    if(FromTool)return(-1);	/* otherwise, by definition, there
+				 * isn't a save file (even if a
+				 * file of the right name exists) */
+    if(savefname[0])
+	strncpy(plname,savefname,PL_NSIZ-1); /* restore poly'd name */
+    lock=Lock(SAVEF,ACCESS_READ);
+    fib = (struct FileInfoBlock *)AllocMem(ALLOC_SIZE, MEMF_CLEAR);
+    if(lock && Examine(lock,fib)){
+	if(fib->fib_Size>100){  /* random number << save file size */
+	    UnLock(lock);
+	    FreeMem(fib,ALLOC_SIZE);
+	    return(open(SAVEF,mode));
+	} else {
+		/* this is a dummy file we need because
+		 * workbench won't duplicate an icon with no
+		 * "real" data attached - try to get rid of it.
+		 */
+	    UnLock(lock);
+	    unlink(SAVEF);
+	    FreeMem(fib,ALLOC_SIZE);
+	    return(-1);
+	}
+    }
+    FreeMem(fib,ALLOC_SIZE);
+    return(-1);     /* give up */
+}
+
+/* Check the original args to the program, set up internal state the rest
+ * of NetHack doesn't care about, and if we don't have a real command line,
+ * build one.  This is split this way to get around the fruit setting problem.
+ */
+void
+ami_argset(argcp, argv)
+    int *argcp;
+    char *argv[];
+{
+    wbs = (struct WBStartup *)argv;
+    FromWBench=(*argcp==0);
+
+}
+void
+ami_mkargline(argcp, argvp)
+    int *argcp;
+    char **argvp[];
+{
+    int ac = 0;
+    char **argv;
+    char *p;
+
+    if(!FromWBench)return;	/* already have an argv */
+
+    for(p=argline;*p;p++) ac += isspace(*p);
+
+    *argvp = argv = (char**)alloc(sizeof(char *) * (ac+1));   /* upper bound */
+    argv[0] = "NetHack";
+
+    for(*argcp = 0,p=argline;*p;){
+	(*argcp)++;
+	argv[*argcp] = p;	/* remember start */
+	while(*p && !isspace(*p))p++;
+	if(!*p)break;		/* done */
+	*p = '\0';
+	p++;
+	while(*p && isspace(*p))p++;
+    }
+    argv[++(*argcp)] = 0;
+}
+
+static void
+score(scorearg)
+	char *scorearg;
+        {
+	long ac;
+	char *p;
+	char **av=calloc(1,50*sizeof(char *));
+
+#ifdef CHDIR
+	chdirx(hackdir,0);
+#endif
+	av[0]="NetHack";            /* why not? */
+	av[1]="-s";             /* why not? */
+	av[2]=0;
+	for(ac=2,p=scorearg;*p;ac++){
+	    av[ac]=p;av[ac+1]=0;
+	    while(*p && !isspace(*p))p++;
+	    if(!*p)break;
+	    *p++='\0';
+	    while(*p && isspace(*p))p++;
+	    /* *p='\0';	/* extra? */
+	}
+	prscore(ac+1,av);
+	free( av );
+	nethack_exit(0);
+}
+
+static
+unsigned long
+ahtoi(p)
+    const char *p;
+{
+    static char hex[]="0123456789abcdef";
+    unsigned long r;
+    char *cp;
+
+/*fprintf(stderr,"conv: '%s'\n",p);*/
+    for(r=0;*p && (cp=index(hex,*p)); p++){
+	r *= 16;
+	r += cp-hex;
+    }
+
+    return r;
+}
diff -Pru nethack-3.4.1/sys/amiga/ask.uu nethack/sys/amiga/ask.uu
--- nethack-3.4.1/sys/amiga/ask.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/ask.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,13 @@
+begin 777 ask.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "K     E   #_    
+M 0     !      9A<VLN8P           0 "$   ( !   4 !?____\     
+M!\:O,                        0?&:_@       5!<VM?   ! $L 50(,
+M !( !0 %_____P    $        )  0 '  *     P !!],"+      'QHKP
+M             0?3 EC_____ P  !0?3 CP            =    '0 +    
+M"P           P     "  $     !\: (          $*#\I      H    !
+M!\:#\ ?&A*@'QH>0!\:'V ?&C)@'QHRH     0     !      $      0  
+M   !      $  0     L  4     !]+>           :5&AI<R!I<R!T:&4@
+.475E<W1I;VX@87)E80 L
+ 
+end
diff -Pru nethack-3.4.1/sys/amiga/char.c nethack/sys/amiga/char.c
--- nethack-3.4.1/sys/amiga/char.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/char.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,527 @@
+SHORT Type_BorderVectors1[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border1 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors1,
+	NULL
+};
+
+struct IntuiText Type_IText1 = {
+	3,0,JAM1,
+	38,1,
+	NULL,
+	"Wizard",
+	NULL
+};
+
+struct Gadget Type_Gadget13 = {
+	NULL,
+	137,79,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border1,
+	NULL,
+	&Type_IText1,
+	NULL,
+	NULL,
+	'W',
+	NULL
+};
+
+SHORT Type_BorderVectors2[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border2 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors2,
+	NULL
+};
+
+struct IntuiText Type_IText2 = {
+	3,0,JAM1,
+	29,1,
+	NULL,
+	"Valkyrie",
+	NULL
+};
+
+struct Gadget Type_Gadget12 = {
+	&Type_Gadget13,
+	9,79,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border2,
+	NULL,
+	&Type_IText2,
+	NULL,
+	NULL,
+	'V',
+	NULL
+};
+
+SHORT Type_BorderVectors3[] = {
+	0,0,
+	251,0,
+	251,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border3 = {
+	-1,-1,
+	1,0,JAM1,
+	5,
+	Type_BorderVectors3,
+	NULL
+};
+
+struct IntuiText Type_IText3 = {
+	1,0,JAM1,
+	14,1,
+	NULL,
+	"Pick a Random Character Type",
+	NULL
+};
+
+struct Gadget Type_Gadget11 = {
+	&Type_Gadget12,
+	9,94,
+	250,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border3,
+	NULL,
+	&Type_IText3,
+	NULL,
+	NULL,
+	1,
+	NULL
+};
+
+SHORT Type_BorderVectors4[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border4 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors4,
+	NULL
+};
+
+struct IntuiText Type_IText4 = {
+	3,0,JAM1,
+	33,1,
+	NULL,
+	"Samurai",
+	NULL
+};
+
+struct Gadget Type_Gadget10 = {
+	&Type_Gadget11,
+	9,66,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border4,
+	NULL,
+	&Type_IText4,
+	NULL,
+	NULL,
+	'S',
+	NULL
+};
+
+SHORT Type_BorderVectors5[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border5 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors5,
+	NULL
+};
+
+struct IntuiText Type_IText5 = {
+	3,0,JAM1,
+	34,1,
+	NULL,
+	"Tourist",
+	NULL
+};
+
+struct Gadget Type_Gadget9 = {
+	&Type_Gadget10,
+	137,66,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border5,
+	NULL,
+	&Type_IText5,
+	NULL,
+	NULL,
+	'T',
+	NULL
+};
+
+SHORT Type_BorderVectors6[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border6 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors6,
+	NULL
+};
+
+struct IntuiText Type_IText6 = {
+	3,0,JAM1,
+	40,1,
+	NULL,
+	"Rogue",
+	NULL
+};
+
+struct Gadget Type_Gadget8 = {
+	&Type_Gadget9,
+	137,53,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border6,
+	NULL,
+	&Type_IText6,
+	NULL,
+	NULL,
+	'R',
+	NULL
+};
+
+SHORT Type_BorderVectors7[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border7 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors7,
+	NULL
+};
+
+struct IntuiText Type_IText7 = {
+	3,0,JAM1,
+	36,1,
+	NULL,
+	"Priest",
+	NULL
+};
+
+struct Gadget Type_Gadget7 = {
+	&Type_Gadget8,
+	9,53,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border7,
+	NULL,
+	&Type_IText7,
+	NULL,
+	NULL,
+	'P',
+	NULL
+};
+
+SHORT Type_BorderVectors8[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border8 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors8,
+	NULL
+};
+
+struct IntuiText Type_IText8 = {
+	3,0,JAM1,
+	35,1,
+	NULL,
+	"Healer",
+	NULL
+};
+
+struct Gadget Type_Gadget6 = {
+	&Type_Gadget7,
+	9,40,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border8,
+	NULL,
+	&Type_IText8,
+	NULL,
+	NULL,
+	'H',
+	NULL
+};
+
+SHORT Type_BorderVectors9[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border9 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors9,
+	NULL
+};
+
+struct IntuiText Type_IText9 = {
+	3,0,JAM1,
+	33,1,
+	NULL,
+	"Caveman",
+	NULL
+};
+
+struct Gadget Type_Gadget5 = {
+	&Type_Gadget6,
+	9,27,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border9,
+	NULL,
+	&Type_IText9,
+	NULL,
+	NULL,
+	'C',
+	NULL
+};
+
+SHORT Type_BorderVectors10[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border10 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors10,
+	NULL
+};
+
+struct IntuiText Type_IText10 = {
+	3,0,JAM1,
+	16,1,
+	NULL,
+	"Archeologist",
+	NULL
+};
+
+struct Gadget Type_Gadget4 = {
+	&Type_Gadget5,
+	9,14,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border10,
+	NULL,
+	&Type_IText10,
+	NULL,
+	NULL,
+	'A',
+	NULL
+};
+
+SHORT Type_BorderVectors11[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border11 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors11,
+	NULL
+};
+
+struct IntuiText Type_IText11 = {
+	3,0,JAM1,
+	36,1,
+	NULL,
+	"Knight",
+	NULL
+};
+
+struct Gadget Type_Gadget3 = {
+	&Type_Gadget4,
+	137,40,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border11,
+	NULL,
+	&Type_IText11,
+	NULL,
+	NULL,
+	'K',
+	NULL
+};
+
+SHORT Type_BorderVectors12[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border12 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors12,
+	NULL
+};
+
+struct IntuiText Type_IText12 = {
+	3,0,JAM1,
+	48,1,
+	NULL,
+	"Elf",
+	NULL
+};
+
+struct Gadget Type_Gadget2 = {
+	&Type_Gadget3,
+	137,27,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border12,
+	NULL,
+	&Type_IText12,
+	NULL,
+	NULL,
+	'E',
+	NULL
+};
+
+SHORT Type_BorderVectors13[] = {
+	0,0,
+	123,0,
+	123,11,
+	0,11,
+	0,0
+};
+struct Border Type_Border13 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Type_BorderVectors13,
+	NULL
+};
+
+struct IntuiText Type_IText13 = {
+	3,0,JAM1,
+	27,1,
+	NULL,
+	"Barbarian",
+	NULL
+};
+
+struct Gadget Type_Gadget1 = {
+	&Type_Gadget2,
+	137,14,
+	122,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Type_Border13,
+	NULL,
+	&Type_IText13,
+	NULL,
+	NULL,
+	'B',
+	NULL
+};
+
+#define Type_GadgetList1 Type_Gadget1
+
+struct NewWindow Type_NewWindowStructure1 = {
+	155,24,
+	267,108,
+	0,1,
+	GADGETUP+CLOSEWINDOW+VANILLAKEY,
+	WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Type_Gadget1,
+	NULL,
+	"Pick a Character",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+
+/* end of PowerWindows source generation */
diff -Pru nethack-3.4.1/sys/amiga/charwin.uu nethack/sys/amiga/charwin.uu
--- nethack-3.4.1/sys/amiga/charwin.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/charwin.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,63 @@
+begin 777 char.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "K     E   #\    
+M 0     !      =C:&%R+F, !]/%0      "@ #(  ,  8    \     !\9K
+M^                @    $      0     !     !@   #@X.#0<%#  (  
+ML #P (!04/#P       !  (0"  @ D  !0 %_____P                  
+M               -!\:(X       !E1Y<&5?   ! )L & $+ &P !0 %____
+M_P   !%0:6-K(&$@0VAA<F%C=&5R  ?3#R  B0 . 'H "@    ,  0?3"EP 
+M    !\;-6             $'TP00_____P,   4'TPIL            >P  
+M 'L "P    L           ,     &P !      ?&SQ          "D)A<F)A
+M<FEA;@     *     0?&SF 'QL_ !\;/T ?&T' 'QM" !\B[L     $     
+M 0     !      0G0B<      0     !  ?3PL  B0 ; 'H "@    ,  0?3
+M#TP     !\GV\             ('T\*8_____P,   4'TP]<            
+M>P   'L "P    L           ,     ,  !      ?(VP          !$5L
+M9@     *     0?(W4 'R-\8!\G[2 ?)_C 'RW+0!\T%J     $      0  
+M   !      0G12<      0     !  ?3PT  B0 H 'H "@    ,  0?3PNP 
+M    !](_Z             ,'T\,8_____P,   4'T\+\            >P  
+M 'L "P    L           ,     )  !      ?-$X@         !TMN:6=H
+M=      *     0?23;@'TE&@!])2F ?26I 'TF X!])@2     $      0  
+M   !      0G2R<      0     !  ?3TC  "0 . 'H "@    ,  0?3PVP 
+M    !])DP             0'T\.8_____P,   4'T\-\            >P  
+M 'L "P    L           ,     $  !      ?2:C@         #4%R8VAE
+M;VQO9VES=      *     0?29@@'TFWX!])N" ?2;O@'TF\(!])^0     $ 
+M     0     !      0G02<      0     !  ?3TK  "0 ; 'H "@    , 
+M 0?3TEP     !]*Q.             4'T]*(_____P,   4'T])L        
+M    >P   'L "P    L           ,     (0 !      ?2H;          
+M"$-A=F5M86X     "@    $'TJAH!]*JH ?2M8 'TK60!]*Y  ?2PB@    !
+M      $      0     $)T,G      $      0 'T],P  D * !Z  H    #
+M  $'T]+<      ?2W'@            &!]/3"/____\#   %!]/2[       
+M     'L   ![  L    +           #     ",  0     'TJJ(        
+M  =(96%L97(     "@    $'TNS8!]+LZ ?3 U 'TP-@!],%: ?3#W@    !
+M      $      0     $)T@G      $      0 'T]00  D -0!Z  H    #
+M  $'T]-<      ?3$(@            '!]/3B/____\#   %!]/3;       
+M     'L   ![  L    +           #     "0  0     'TK5P        
+M  =0<FEE<W0     "@    $'T].P!]/3P ?3T] 'T]/@!]/3\ ?3U      !
+M      $      0     $)U G      $      0 'T]4@ (D -0!Z  H    #
+M  $'T]0\      ?3U&@            (!]/4F/____\#   %!]/43       
+M     'L   ![  L    +           #     "@  0     'TKCP        
+M  92;V=U90     *     0?3U, 'T]30!]/4X ?3U/ 'T]4 !]/5$     $ 
+M     0     !      0G4B<      0     !  ?3UC  B0!" 'H "@    , 
+M 0?3U4P     !]/5>             D'T]6H_____P,   4'T]5<        
+M    >P   'L "P    L           ,     (@ !      ?2?^@         
+M"%1O=7)I<W0     "@    $'T]70!]/5X ?3U? 'T]8 !]/6$ ?3UB     !
+M      $      0     $)U0G      $      0 'T]=   D 0@!Z  H    #
+M  $'T]9<      ?3UH@            *!]/6N/____\#   %!]/6;       
+M     'L   ![  L    +           #     "$  0     'TMQ         
+M  A386UU<F%I      H    !!]/6X ?3UO 'T]< !]/7$ ?3UR 'T]<P    
+M 0     !      $     !"=3)P     !      $ !]/8:  ) %X ^@ *    
+M P !!]/7;      'T]>8              ?3U^#_____ 0  !0?3UWP     
+M      #[    ^P +    "P           0     .  $     !]+;>       
+M   =4&EC:R!A(%)A;F1O;2!#:&%R86-T97(@5'EP90     *     0?3V @'
+MT]@8!]/8* ?3V#@'T]A(!]/86     $      0     !      (Q      $ 
+M     0 'T]F   D 3P!Z  H    #  $'T]B4      ?3V,             ,
+M!]/8^/____\#   %!]/8I            'L   ![  L    +           #
+M     !T  0     'TKC8          E686QK>7)I90     *     0?3V2 '
+MT]DP!]/90 ?3V5 'T]E@!]/9<     $      0     !      0G5B<     
+M 0     !        B0!/ 'H "@    ,  0?3V:P     !]/9V           
+M  T'T]H(_____P,   4'T]F\            >P   'L "P    L         
+M  ,     )@ !      ?2JG@         !U=I>F%R9      *     0?3VC '
+MT]I !]/:4 ?3VF 'T]IP!]/:@     $      0     !      0G5R<     
+' 0     !  ?3
+ 
+end
diff -Pru nethack-3.4.1/sys/amiga/clipwin.uu nethack/sys/amiga/clipwin.uu
--- nethack-3.4.1/sys/amiga/clipwin.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/clipwin.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,39 @@
+begin 777 clip.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#X
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   #_     E  8#^    X
+M 0     !      IC;&EP=VEN+F, !Y9E^      "@ #(  ,  8    \     X
+M!X+O(                @    $      0     !     !B@H*    #P\/!0X
+M@+   /#P /  \/#P\/     !  (0#P!D G(!7@!,_____P              X
+M                   &!X9HZ       !4-L:7    $ <@ 0 5H 3  %  7_X
+M____    &45D:70@0VQI<'!I;F<@4&%R86UE=&5R<P 'EG/0 (8 &/\Y  < X
+M(  #  ,'AFF8      >&:O@     !X<[Z   !Y9SJ/____\#   %!Y9SC   X
+M         )0   "4  @    (      !%    &  #                    X
+M  ,   #_A/__      >&;&          $%D@4V-A;&4@1F%C=&]R.@   YJOX
+M__\JJO__    "@ @  ,'AFCX!X<\F >'/*@'ASZH!X<^N >'/V@    &65-)X
+M6D4      0     !      994TE:10     !      $ !Y9TX "&  __.0 'X
+M "   P #!X= "      'AT"X      >'0A@   >6="C_____ P  !0>6= P X
+M          "4    E  (    "       +0   !@  P                  X
+M   #    _X3__P     'AT%H         !!8(%-C86QE($9A8W1O<CH   -FX
+M9/__*JK__P    H (  #!X="R >'0M@'AT-X!X=#B >'1"@'AT0X    !EA3X
+M25I%      $      0     &6%-)6D4      0     !  >6=3@ A@ N_SD X
+M!P @  ,  P>'5Z      !X=84      'AUFP   'EG10_____P,   4'EG4<X
+M            E    )0 "     @      !8    8  ,                 X
+M     P   /^,__\     !X=9           /62!#;&EP($)O<F1E<CH   ,SX
+M,O__*JK__P    H (  #!X=:8 >'6G 'AU_@!X=?\ >'81@'AV$H    !EE#X
+M3$E0      $      0     &64-,25       0     !  >6=;@ A@ E_SD X
+M!P @  ,  P>'8<@     !X=B>      'AW]@   'EG60_____P,   4'EG5TX
+M            E    )0 "     @      "L    8  ,                 X
+M     P   /^,__\     !X=G.          /6"!#;&EP($)O<F1E<CH  0-?X
+MN/__*JK__P    H (  #!X>R* >'LI@'A\*H!XA[F >(T* 'B-10    !EA#X
+M3$E0      $      0     &6$-,25       0     !  >6=C@ $0 \ $T X
+M"@    ,  0>6=>0     !Y57(             D'EG80_____P,   4'EG7TX
+M            3@   $X "P    L           0     &  !      >) ]  X
+M        !4]K87D     "@    $'B4%(!XE!B >)SY 'BA$(!XH;X >*'/  X
+M   %3VMA>0     !      $     "$=!1$]+05D      0     !        X
+M\  [ $L "@    ,  0>6=F0     !Y6+.             H'EG@8_____P, X
+M  4'EG9T            3    $P "P    L           0     #P !    X
+M  >*N7          !T-A;F-E;      *     0>3Q+@'D\;@!Y0)8 >4#*@'X
+ME [ !Y00.     =#86YC96P      0     !      I'041#04Y#14P     X
+' 0     !    X
+ X
+end
diff -Pru nethack-3.4.1/sys/amiga/colors.uu nethack/sys/amiga/colors.uu
--- nethack-3.4.1/sys/amiga/colors.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/colors.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,38 @@
+begin 777 colors.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "[     E   #\    
+M 0     !     !%A;6EG83IC;VQO<G=I;BYC  ?3QL@      H  R  #  & 
+M   /      ?&; @               (    !      $      0     8    
+M\/#P8"  4(# $' 0P !@(##@P        0 "$ X 8 )X  4 !?____\     
+M!],-2                       !@?&AY        5#;VQ?   ! *\ +0$X
+M %T !0 %_____P   !-%9&ET(%-C<F5E;B!#;VQO<G, !]/8.  @ "0!#P +
+M     P #!\;.8                 ?&S\  !0?3U(#_____ P  !0?3V!P 
+M          $0   !$  ,    #            0< !P                  
+M   ! P    #_____    "@    L'QH?8!\:AZ ?&J. 'QJE8!\;/$ ?&T'  
+M   (0FQU95!E;@     !      $     "T=!1$),545014X      0     !
+M  ?3V+@ (  8 0\ "P    ,  P?)]O                 'SF<P  8'T]B0
+M_____P,   4'T]AT           !$    1  #     P           $'  < 
+M                     0,     _____P    H    +!\C;  ?&T( 'R+NP
+M!\C=0 ?(WQ@'R?M(    "4=R965N4&5N      $      0     ,1T%$1U)%
+M14Y014X      0     !  ?3V3@ (  , 0\ "P    ,  P?20(          
+M       'TF X  <'T]D0_____P,   4'T]CT           !$    1  #   
+M  P           $'  <                      0,     _____P    H 
+M   +!\G^, ?+<M 'S06H!\U"@ ?-$X@'S4)     !U)E9%!E;@     !    
+M  $     "D=!1%)%1%!%3@     !      $ !]/X( #T $T .@ +     P !
+M!]/99      'TF3             !@?3V9#_____ P  !0?3V70         
+M   [    .P ,    #           !P     &  $     !])2F          '
+M0V%N8V5L      H    !!]):D ?29@@'TFGP!])J. ?2:@ 'TFMX    !T-A
+M;F-E;      !      $     #4=!1$-/3$-!3D-%3      !      $ !]/X
+M> "  $T .@ +     P !!]/X3      'TFWX            !P?3V\C_____
+M P  !0?3^%P            [    .P ,    #           !P     1  $ 
+M    !])N^          $57-E      H    !!])O" ?2?D 'TH2(!]*H: ?2
+MA)@'TH68    !4]K87D      0     !      M'041#3TQ/2T%9      $ 
+M     0        D 30 Z  L    #  $'T_BD      ?2Y#             *
+M!]/Y"/____\#   %!]/XM            #L    [  P    ,           '
+M      T  0     'TFM@          53879E      H    !!]*JH ?2L4@'
+MTK3X!]+"* ?2N,@'TK^(    !5-A=F4      0     !      M'041#3TQ3
+M059%      $      0 '     !  #@     'QHF@!]/5&     )2  0     
+M$  :      ?2:U 'T]OP     D<  P     1 "8     !]*AL          "
+"0@ :
+ 
+end
diff -Pru nethack-3.4.1/sys/amiga/dflticon.uu nethack/sys/amiga/dflticon.uu
--- nethack-3.4.1/sys/amiga/dflticon.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/dflticon.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,28 @@
+begin 777 default.icon
+MXQ```0``````"@`/`%``&0`&`0H``0`V>1``-GJH``````````````````8`
+M```!!,P`(VS8`",5F(````"``````````````````,-0``````!0`!@``@``
+M;Z0#```````````````````!`````````````P````````````,'_@``````
+M```##_\&,`!'```'`P__!S``PP```P,/_P>QX?-AX>,S#_\&\S##L#,S8P_^
+M!G/PPS#S`\,#_`8S`-,S,S-C`?@&,>!G,=GG,P#_``````````,`?X``````
+M```#``?P`&&>``P``P``/@!ALP`<``,`_`<`,P,`#``#`_^'@#,.``P``P<`
+M`X`>`P`,``,#@`.`'C,,#``#`?Q_``P>##\``P`?_@````````,`````````
+M```#`````````````W_________________________^P````````````,``
+M``````````#`````````````P````````````,/\``````````#.9P``````
+M````SY\``````````,_^``````````###```````````P?@``````````,#_
+M``````````#`?X``````````P`?P`````````,``/@````````#`5`<`````
+M````PU0'@````````,<``X````````##@`.`````````P?Q_`````````,`?
+M_@````````#`````````````P````````````(```````````````````%``
+M&``"``/D3`,``````/____________[`````````````P````````````,``
+M``````````#```8P`$<```<`P/@',`##```#`,<SA['A\V'AXS#'SX;S,,.P
+M,S-@Q_\&<_##,/,#P,&,!C,`TS,S,V#`P`8QX&<QV><PP'```````````,`C
+M@`````````#`!_``89X`#```P%`^`&&S`!P``,-4!P`S`P`,``##``>`,PX`
+M#```QP`#@!X#``P``,.``X`>,PP,``#!_'\`#!X,/P``P!_^`````````,``
+M``````````#`````````````@`````````````````````````$`````````
+M```#`````````````P/_``````````,'_X`````````#!_^``````````P?_
+M@`````````,'_X`````````#!_\``````````P'\``````````,`_P``````
+M```#`'_@`````````P`_@`````````,`%_`````````#`/N^`````````P/_
+MAP````````,#``>````````#!P`#@````````P.``X````````,!_'\`````
+M```#`!_^`````````P````````````,````````````#?____________P``
+D``DO;F5T:&%C:P`````(````$4A!0TM$25(]3F5T2&%C:SH`
+`
+end
diff -Pru nethack-3.4.1/sys/amiga/dispmap.s nethack/sys/amiga/dispmap.s
--- nethack-3.4.1/sys/amiga/dispmap.s	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/dispmap.s	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,652 @@
+;    SCCS Id: @(#)dispmap.s    3.2    94/04/19
+;Copyright (c) Andrew Church, Olney, Maryland,  1994.
+;NetHack may be freely redistributed.  See license for details.
+
+;Display the game map (using tiles).
+;
+;Call from C: display_map(struct Window *win)
+;where win is the window to draw the map in.
+;
+;At the moment, this routine is limited to tile display sizes of 8, 16,
+;24, 32, and 48 pixels square (determined by mxsize/mysize).
+;
+;This code depends on structs amiv_glyph_node and PDAT.  If either of
+;these are changed, the corresponding offsets below will also need to be
+;changed.
+
+;struct BitMap
+bm_BytesPerRow	equ 0
+bm_Rows		equ 2
+bm_Flags	equ 4
+bm_Depth	equ 5
+bm_Planes	equ 8
+bm_sizeof	equ 40
+
+;struct Window (incomplete)
+wd_LeftEdge	equ 4
+wd_TopEdge	equ 6
+wd_RPort	equ 50
+wd_BorderLeft	equ 54
+wd_BorderTop	equ 55
+
+;struct RastPort (incomplete)
+rp_BitMap	equ 4
+
+;struct amiv_glyph_node
+gn_odstx	equ 0
+gn_odsty	equ 2
+gn_srcx		equ 4
+gn_srcy		equ 6
+gn_dstx		equ 8
+gn_dsty		equ 10
+gn_bitmap	equ 12
+gn_sizeof	equ 16
+
+;struct PDAT
+pdat_nplanes	equ 0
+pdat_pbytes	equ 4
+pdat_across	equ 8
+pdat_down	equ 12
+pdat_npics	equ 16
+pdat_xsize	equ 20
+pdat_ysize	equ 24
+pdat_sizeof	equ 28
+
+	section text,code
+
+	xdef	_display_map
+	xdef	loop		;for debugging
+	xdef	put8		; |
+	xdef	put16		; |
+	xdef	put24		; |
+	xdef	put32		; |
+	xdef	put48		; V
+	xref	_glyph_node_index
+	xref	_amiv_g_nodes
+	xref	_pictdata
+	xref	_mxsize
+	xref	_mysize
+	xref	_clipping
+	xref	_clipx
+	xref	_clipy
+	xref	_clipxmax
+	xref	_clipymax
+	xref	_amii_extraplanes
+	xref	_reclip
+
+;display_map(struct Window *vw)
+;
+;Register usage:
+;	D0 - temp
+;	D1 - temp
+;	D2 - glyph_node loop counter
+;	D3 - temp
+;	D4 - Number of planes to use
+;	D5 - index (bytes) into tile bitmap
+;	D6 - temp
+;	D7 - temp
+;	A0 - tile bitmap
+;	A1 - overview window bitmap
+;	A2 - amiv_g_nodes[]
+;	A3 - tile display routine (depends on requested tile size)
+;	A4 - data base (from main program)
+;	A5 - source bitplane \ used by
+;	A6 - dest bitplane   /  putNN
+;
+;Passed to putNN on stack:
+;     [ 0(a7)	- return address ]
+;	4(a7)	- BytesPerRow of tile bitmap
+;       6(a7)	- BytesPerRow of overview bitmap
+;	8(a7)	- Bitmap offset to beginning of top row of window
+;	12(a7)	- X coordinate of left edge of window
+
+_display_map:
+	cmp.l	#2,_reclip
+	bne	dispmap
+	rts
+dispmap	move.l	4(a7),a1
+	movem.l d2-d7/a2-a3/a5-a6,-(a7)
+	move.l	a1,a6
+	move.l	wd_RPort(a6),a1
+	move.l	rp_BitMap(a1),a1
+	move.w	bm_BytesPerRow(a1),d0
+	pea	bm_Planes(a1)
+	lea	_pictdata,a0
+	move.l	pdat_nplanes(a0),d4
+	add.l	_amii_extraplanes,d4
+	move.w	d4,-(a7)
+	move.w	wd_TopEdge(a6),d1
+	mulu	d0,d1
+	move.w	wd_LeftEdge(a6),-(a7)
+	move.l	d1,-(a7)
+	move.w	d0,-(a7)
+	subq.l	#2,a7
+	lea	_amiv_g_nodes,a2
+	move.l	_mxsize,d5
+	move.w	_glyph_node_index,d2
+	subq.w	#1,d2
+	cmp.w	#8,d5
+	beq	set8
+	cmp.w	#16,d5
+	beq	set16
+	cmp.w	#24,d5
+	beq	set24
+	cmp.w	#32,d5
+	beq	set32
+	lea	put48(pc),a3
+	bra	loop
+set8	lea	put8(pc),a3
+	bra	loop
+set16	lea	put16(pc),a3
+	bra	loop
+set24	lea	put24(pc),a3
+	bra	loop
+set32	lea	put32(pc),a3
+loop	move.l	gn_bitmap(a2),a0
+	tst.l	_clipping
+	beq	noclip
+	moveq	#0,d0
+	move.w	gn_odstx(a2),d0
+	cmp.l	_clipx,d0
+	blt	endlp
+	cmp.l	_clipxmax,d0
+	bge	endlp
+	move.w	gn_odsty(a2),d0
+	cmp.l	_clipy,d0
+	blt	endlp
+	cmp.l	_clipymax,d0
+	bge	endlp
+noclip	moveq	#0,d5
+	move.w	gn_srcx(a2),d5
+	lsr.w	#3,d5
+	move.w	gn_srcy(a2),d0
+	move.w	bm_BytesPerRow(a0),d7
+	mulu	d7,d0
+	add.l	d0,d5
+	lea	bm_Planes(a0),a0
+	move.w	d7,(a7)
+	move.w	10(a7),d4
+	move.l	12(a7),a1
+	jsr	(a3)
+endlp	lea	gn_sizeof(a2),a2
+	dbf	d2,loop
+	lea	16(a7),a7
+	movem.l	(a7)+,d2-d7/a2-a3/a5-a6
+	rts
+
+
+put8:
+	subq.w	#1,d4
+	move.w	4(a7),d7
+	add.w	d7,d7
+	moveq	#0,d3
+	move.w	gn_dstx(a2),d3
+	add.w	12(a7),d3
+	lsr.w	#3,d3
+	move.w	gn_dsty(a2),d0
+	mulu	6(a7),d0
+	add.l	d0,d3
+	add.l	8(a7),d3
+p8Plp	moveq	#7,d6
+	move.l	(a0)+,a5
+	add.l	d5,a5
+	move.l	(a1)+,a6
+	add.l	d3,a6
+p8Ylp	move.w	(a5),d0		;No loops here - they'd slow this down
+	lsl.w	#1,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	lsl.w	#2,d0
+	roxl.b	#1,d1
+	move.b	d1,(a6)
+	add.w	d7,a5
+	add.w	6(a7),a6
+	dbf	d6,p8Ylp
+	dbf	d4,p8Plp
+	rts
+
+put16:
+	subq.w	#1,d4
+	move.w	6(a7),d7
+	moveq	#0,d3
+	move.w	gn_dstx(a2),d3
+	add.w	12(a7),d3
+	lsr.w	#3,d3
+	move.w	gn_dsty(a2),d0
+	mulu	d7,d0
+	add.l	d0,d3
+	add.l	8(a7),d3
+p16Plp	moveq	#15,d6
+	move.l	(a0)+,a5
+	add.l	d5,a5
+	move.l	(a1)+,a6
+	add.l	d3,a6
+p16Ylp	move.w	(a5),d0
+	move.b	d0,1(a6)
+	lsr.w	#8,d0
+	move.b	d0,(a6)
+	add.w	4(a7),a5
+	add.w	d7,a6
+	dbf	d6,p16Ylp
+	dbf	d4,p16Plp
+	rts
+
+put24:
+	move.w	d2,-(a7)
+	subq.w	#1,d4
+	move.w	8(a7),d7
+	moveq	#0,d3
+	move.w	gn_dstx(a2),d3
+	add.w	14(a7),d3
+	lsr.w	#3,d3
+	move.w	gn_dsty(a2),d0
+	mulu	d7,d0
+	add.l	d0,d3
+	add.l	10(a7),d3
+p24Plp	moveq	#7,d6
+	move.l	(a0)+,a5
+	add.l	d5,a5
+	move.l	(a1)+,a6
+	add.l	d3,a6
+p24Ylp	move.w	(a5),d0
+	moveq	#0,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	swap	d1
+	move.b	d1,(a6)
+	swap	d1
+	move.b	d1,2(a6)
+	lsr.w	#8,d1
+	move.b	d1,1(a6)
+	add.w	6(a7),a5
+	add.w	d7,a6
+	move.w	(a5),d0
+	moveq	#0,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#3,d2
+	lsl.l	#2,d1
+	or.b	d2,d1
+	add.w	d0,d0
+	roxl.l	#1,d1
+	swap	d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,(a6)
+	swap	d1
+	move.b	d1,2(a6,d7.w)
+	move.b	d1,2(a6)
+	lsr.w	#8,d1
+	move.b	d1,1(a6,d7.w)
+	move.b	d1,1(a6)
+	add.w	6(a7),a5
+	add.w	d7,a6
+	add.w	d7,a6
+	dbf	d6,p24Ylp
+	dbf	d4,p24Plp
+	move.w	(a7)+,d2
+	rts
+
+put32:
+	move.w	d2,-(a7)
+	subq.w	#1,d4
+	move.w	8(a7),d7
+	moveq	#0,d3
+	move.w	gn_dstx(a2),d3
+	add.w	14(a7),d3
+	lsr.w	#3,d3
+	move.w	gn_dsty(a2),d0
+	mulu	d7,d0
+	add.l	d0,d3
+	add.l	10(a7),d3
+p32Plp	moveq	#15,d6
+	move.l	(a0)+,a5
+	add.l	d5,a5
+	move.l	(a1)+,a6
+	add.l	d3,a6
+p32Ylp	move.w	(a5),d0
+	moveq	#0,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$C0,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$30,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$0C,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$03,d2
+	or.b	d2,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,(a6)+
+	moveq	#0,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$C0,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$30,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$0C,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$03,d2
+	or.b	d2,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,(a6)+
+	moveq	#0,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$C0,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$30,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$0C,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$03,d2
+	or.b	d2,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,(a6)+
+	moveq	#0,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$C0,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$30,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$0C,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$03,d2
+	or.b	d2,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,(a6)
+	add.w	6(a7),a5
+	add.w	d7,a6
+	lea	-3(a6,d7.w),a6
+	dbf	d6,p32Ylp
+	dbf	d4,p32Plp
+	move.w	(a7)+,d2
+	rts
+
+put48:
+	move.w	d2,-(a7)
+	subq.w	#1,d4
+	move.w	d4,-(a7)
+	move.l	d5,-(a7)
+	move.w	14(a7),d7
+	moveq	#0,d3
+	move.w	gn_dstx(a2),d3
+	add.w	20(a7),d3
+	lsr.w	#3,d3
+	move.w	gn_dsty(a2),d0
+	add.l	16(a7),d3
+	mulu	d7,d0
+	add.l	d0,d3
+	move.w	d7,d5
+	add.w	d5,d5
+p48Plp	moveq	#15,d6
+	move.l	(a0)+,a5
+	add.l	(a7),a5
+	move.l	(a1)+,a6
+	add.l	d3,a6
+p48Ylp	move.w	(a5),d0
+	moveq	#0,d1
+	moveq	#21,d4
+	moveq	#0,d2
+	add.w	d0,d0
+	scs	d2
+	and.b	#7,d2
+	lsl.l	d4,d2
+	or.l	d2,d1
+	subq.w	#3,d4
+	moveq	#0,d2
+	add.w	d0,d0
+	scs	d2
+	and.b	#7,d2
+	lsl.l	d4,d2
+	or.l	d2,d1
+	subq.w	#3,d4
+	moveq	#0,d2
+	add.w	d0,d0
+	scs	d2
+	and.b	#7,d2
+	lsl.l	d4,d2
+	or.l	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.w	#$7000,d2
+	or.w	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.w	#$E00,d2
+	or.w	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.w	#$1C0,d2
+	or.w	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$38,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.b	#7,d2
+	or.b	d2,d1
+	swap	d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,0(a6,d5.w)
+	move.b	d1,(a6)+
+	rol.l	#8,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,0(a6,d5.w)
+	move.b	d1,(a6)+
+	rol.l	#8,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,0(a6,d5.w)
+	move.b	d1,(a6)+
+	moveq	#0,d1
+	moveq	#21,d4
+	moveq	#0,d2
+	add.w	d0,d0
+	scs	d2
+	and.b	#7,d2
+	lsl.l	d4,d2
+	or.l	d2,d1
+	subq.w	#3,d4
+	moveq	#0,d2
+	add.w	d0,d0
+	scs	d2
+	and.b	#7,d2
+	lsl.l	d4,d2
+	or.l	d2,d1
+	subq.w	#3,d4
+	moveq	#0,d2
+	add.w	d0,d0
+	scs	d2
+	and.b	#7,d2
+	lsl.l	d4,d2
+	or.l	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.w	#$7000,d2
+	or.w	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.w	#$E00,d2
+	or.w	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.w	#$1C0,d2
+	or.w	d2,d1
+	add.w	d0,d0
+	scs	d2
+	and.b	#$38,d2
+	or.b	d2,d1
+	add.w	d0,d0
+	scs	d2
+	ext.w	d2
+	and.b	#7,d2
+	or.b	d2,d1
+	swap	d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,0(a6,d5.w)
+	move.b	d1,(a6)+
+	rol.l	#8,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,0(a6,d5.w)
+	move.b	d1,(a6)+
+	rol.l	#8,d1
+	move.b	d1,0(a6,d7.w)
+	move.b	d1,0(a6,d5.w)
+	move.b	d1,(a6)
+	add.w	12(a7),a5
+	add.w	d7,a6
+	lea	-5(a6,d5.w),a6
+	dbf	d6,p48Ylp
+	subq.w	#1,4(a7)
+	bpl	p48Plp
+	move.l	(a7)+,d5
+	addq.l	#2,a7
+	move.w	(a7)+,d2
+	rts
+
+	end
diff -Pru nethack-3.4.1/sys/amiga/hackwb.hlp nethack/sys/amiga/hackwb.hlp
--- nethack-3.4.1/sys/amiga/hackwb.hlp	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/hackwb.hlp	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,42 @@
+HackWB provides a WorkBench-like setting for NetHack - if
+you know how to use WorkBench you know how to use HackWb.
+If you prefer a command line interface, use HackCli.
+Happy Hacking!
+
+Main Window
+    Single click to select a game.
+    Double click to start a game.
+    Use the NewGame icon to start a new game.
+
+Options Window
+    Click on the options to toggle them on/off or enter
+    strings as appropriate.
+
+Edit Game Definition Window
+    Enter name of player and select load to load previously
+    saved game definition.
+
+Project Menu
+ Help        - This file...
+ About       - Credit where credit is due...
+ Top Scores  - View the score file.
+ Recover     - Recover a game which was interrupted by a
+               GURU, Software Failure, or other disaster.
+ Edit Configuration - The string data in nethack.cnf can be
+               edited saved and loaded using the requester
+               opened by this selection.
+
+Game Menu
+ Info        - This selection lets you edit the tooltypes
+               entries for the selected icons.  The Edit
+               Game Configuration  gadget lets you change
+               the options that "Edit Default Game" let you
+               enter.  
+ Copy Info   - Creates a new icon with the same tooltypes as
+               the selected icon.  The new icon has no saved
+               game associated with it.
+ Discard     - Deletes the icon and any saved game
+               associated with it.
+ Rename      - Lets you rename the Icon file and saved game.
+               The information in the save file is not
+               changed.
diff -Pru nethack-3.4.1/sys/amiga/randwin.c nethack/sys/amiga/randwin.c
--- nethack-3.4.1/sys/amiga/randwin.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/randwin.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,101 @@
+SHORT Rnd_BorderVectors1[] = {
+	0,0,
+	49,0,
+	49,18,
+	0,18,
+	0,0
+};
+struct Border Rnd_Border1 = {
+	-1,-1,	/* XY origin relative to container TopLeft */
+	3,0,JAM1,	/* front pen, back pen and drawmode */
+	5,	/* number of XY vectors */
+	Rnd_BorderVectors1,	/* pointer to XY vectors */
+	NULL	/* next border in list */
+};
+
+struct IntuiText Rnd_IText1 = {
+	7,0,JAM1,	/* front and back text pens, drawmode and fill byte */
+	8,5,	/* XY origin relative to container TopLeft */
+	NULL,	/* font pointer or NULL for default */
+	"OKAY",	/* pointer to text */
+	NULL	/* next IntuiText structure */
+};
+
+struct Gadget Rnd_Gadget1 = {
+	NULL,	/* next gadget */
+	99,65,	/* origin XY of hit box relative to window TopLeft */
+	48,17,	/* hit box width and height */
+	NULL,	/* gadget flags */
+	RELVERIFY,	/* activation flags */
+	BOOLGADGET,	/* gadget type flags */
+	(APTR)&Rnd_Border1,	/* gadget border or image to be rendered */
+	NULL,	/* alternate imagery for selection */
+	&Rnd_IText1,	/* first IntuiText structure */
+	NULL,	/* gadget mutual-exclude long word */
+	NULL,	/* SpecialInfo structure */
+	1,	/* user-definable data */
+	NULL	/* pointer to user-definable data */
+};
+
+#define Rnd_GadgetList1 Rnd_Gadget1
+
+struct IntuiText Rnd_IText6 = {
+	6,0,JAM1,	/* front and back text pens, drawmode and fill byte */
+	198,29,	/* XY origin relative to container TopLeft */
+	NULL,	/* font pointer or NULL for default */
+	"a",	/* pointer to text */
+	NULL	/* next IntuiText structure */
+};
+
+struct IntuiText Rnd_IText5 = {
+	6,0,JAM1,	/* front and back text pens, drawmode and fill byte */ /* Was 1,0 -jhsa*/
+	67,47,	/* XY origin relative to container TopLeft */
+	NULL,	/* font pointer or NULL for default */
+	"Character Choice",	/* pointer to text */
+	&Rnd_IText6	/* next IntuiText structure */
+};
+
+struct IntuiText Rnd_IText4 = {
+	6,0,JAM1,	/* front and back text pens, drawmode and fill byte */
+	25,29,	/* XY origin relative to container TopLeft */
+	NULL,	/* font pointer or NULL for default */
+	"exciting game playing as",	/* pointer to text */
+	&Rnd_IText5	/* next IntuiText structure */
+};
+
+struct IntuiText Rnd_IText3 = {
+	6,0,JAM1,	/* front and back text pens, drawmode and fill byte */
+	15,18,	/* XY origin relative to container TopLeft */
+	NULL,	/* font pointer or NULL for default */
+	"I think that you will have an",	/* pointer to text */
+	&Rnd_IText4	/* next IntuiText structure */
+};
+
+struct IntuiText Rnd_IText2 = {
+	6,0,JAM1,	/* front and back text pens, drawmode and fill byte */
+	7,6,	/* XY origin relative to container TopLeft */
+	NULL,	/* font pointer or NULL for default */
+	"You asked for a random Character.",	/* pointer to text */
+	&Rnd_IText3	/* next IntuiText structure */
+};
+
+#define Rnd_IntuiTextList1 Rnd_IText2
+
+struct NewWindow Rnd_NewWindowStructure1 = {
+	174,58,	/* window XY origin relative to TopLeft of screen */
+	249,90,	/* window width and height */
+	0,1,	/* detail and block pens */
+	GADGETUP+CLOSEWINDOW+INACTIVEWINDOW+INTUITICKS,	/* IDCMP flags */
+	ACTIVATE+NOCAREREFRESH,	/* other window flags */
+	&Rnd_Gadget1,	/* first gadget in gadget list */
+	NULL,	/* custom CHECKMARK imagery */
+	NULL,	/* window title */
+	NULL,	/* custom screen pointer */
+	NULL,	/* custom bitmap */
+	5,5,	/* minimum width and height */
+	-1,-1,	/* maximum width and height */
+	CUSTOMSCREEN	/* destination screen type */
+};
+
+
+/* end of PowerWindows source generation */
diff -Pru nethack-3.4.1/sys/amiga/randwin.uu nethack/sys/amiga/randwin.uu
--- nethack-3.4.1/sys/amiga/randwin.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/randwin.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,19 @@
+begin 777 randwin.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "[     E   #\    
+M 0     !     !!A;6EG83IR86YD=VEN+F, !]/.<      "@ #(  (  8  
+M  \     !\9K6                @    $      0     !      R@H*  
+M  #P\/"00'     !  (0  !( D  !0 %_____P     'R?;P            
+M           !!\:(X       !5)N9%\   $ K@ Z /D 6@ %  7_____    
+M 0       &, 00 P !$    #  $'T]/T      ?&SQ              !]/)
+MP/____\#   %!]/4!            #$    Q !(    2           '    
+M  @ !0     'QL_           5/2T%9      H    !!\;/T ?&T' 'QM" 
+M!\B[L ?(VP 'R-U      0     !      $      C$      0     !  8 
+M    !P &      ?3RA@'TC_H    (EEO=2!A<VME9"!F;W(@82!R86YD;VT@
+M0VAA<F%C=&5R+@ &      \ $@     'T]0@!])@.    !Y)('1H:6YK('1H
+M870@>6]U('=I;&P@:&%V92!A;@ &     !D '0     'T]1(!])DP    !EE
+M>&-I=&EN9R!G86UE('!L87EI;F<@87,  0    !# "\     !\:O, ?2;O@ 
+M   10VAA<F%C=&5R($-H;VEC90 &     ,8 '0     'R-\8          )A
+!   1
+ 
+end
diff -Pru nethack-3.4.1/sys/amiga/scroll.uu nethack/sys/amiga/scroll.uu
--- nethack-3.4.1/sys/amiga/scroll.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/scroll.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,12 @@
+begin 777 scroll.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "K     E  8#_    
+M 0     !      =B87)F+F,           $  A +   "6@ %  7_____    
+M                              $ (86        !   ! ,\ $0$  'T 
+M!0 %_____P    $      /_Q  H #__M %   P # "&'T               
+M   AB"   P AB.C_____ P  !0 NKQ0            0    $ !K    :P  
+M          < 9@                     !!?__________    "@!0  D 
+M(8E  "*KR  BL:@ (^]0 "/P0  C\L     !      $      0     !    
+(  $      0 B
+ 
+end
diff -Pru nethack-3.4.1/sys/amiga/splitter/amiout.h nethack/sys/amiga/splitter/amiout.h
--- nethack-3.4.1/sys/amiga/splitter/amiout.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/amiout.h	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,92 @@
+/*    SCCS Id: @(#)amiout.h		3.2   95/07/25
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1990, 1995	  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * This is essentially a.out.h for the Amiga object and load file format,
+ * as extended by Lattice (now SAS, then adopted by CBM, and extended again).
+ */
+
+/*
+ * OBJECT FILE STRUCTURE
+ */
+	
+	/* these blocks are of the form: ID,N,N data longs */
+#define HUNK_UNIT	999
+#define HUNK_NAME	1000
+#define HUNK_DEBUG	1009
+
+	/* these blocks are of the form: ID,N*,N data longs. */
+	/* If (N* && 0xc0000000 == 0xc0000000) then an additional long appears*/
+#define HUNK_CODE	1001
+#define HUNK_DATA	1002
+#define HUNK_BSS	1003
+# define MEM_OBJ_ANY	 0
+# define MEM_OBJ_FAST	0x80000000
+# define MEM_OBJ_CHIP	0x40000000
+# define MEM_OBJ_EXTEND 0xc0000000
+
+	/* these blocks are of the form: ID, (N!=0,long,N data longs)*, 0 */
+#define HUNK_RELOC32	1004
+#define HUNK_RELOC16	1005
+#define HUNK_RELOC8	1006
+#define HUNK_RELOC32s	1020		/* ADOS 2.0 */
+#define HUNK_DRELOC32	1015		/* Lattice & ADOS 2.0 */
+#define HUNK_DRELOC16	1016		/* Lattice & ADOS 2.0 */
+#define HUNK_DRELOC8	1017		/* Lattice & ADOS 2.0 */
+
+	/* these blocks are of the form: ID,(symbol data unit)*,0 */
+#define HUNK_EXT	1007
+#define		EXT_SYMB	0	/* SDU format 0 */
+#define		EXT_DEF		1	/* SDU format 1 */
+#define		EXT_ABS		2	/* SDU format 1 */
+#define		EXT_RES		3	/* SDU format 1 */
+#define		EXT_REF32	129	/* SDU format 2 */
+#define		EXT_COMMON	130	/* SDU format 3 */
+#define		EXT_REF16	131	/* SDU format 2 */
+#define		EXT_REF8	132	/* SDU format 2 */
+#define		EXT_DREF32	133	/* ADOS 2.0 */
+#define		EXT_DREF16	134	/* SDU format 2 Lattice - data ref */
+#define		EXT_DREF8	135	/* ADOS 2.0 */
+#define	HUNK_SYMBOL	1008
+
+	/* this block is of the form: ID */
+#define HUNK_END	1010
+
+/*
+ * LOAD FILE STRUCTURE
+ */
+	/* this block is of the form:
+	 * ID,(N!=0,X,X longs)*,0,SZ,first,last,last-first+1 sizes
+	 */
+#define HUNK_HEADER	1011
+
+	/* this block is of the form:
+	 * ID,SZ,M+2,M+1 longs of 0,overlay data table [(O+1)*8+M+1 longs]
+	 * where M=tree depth (root=0), O=# overlays-1 [zero base]
+	 */
+#define HUNK_OVERLAY	1013
+
+	/* this block is of the form: ID */
+#define HUNK_BREAK	1014
+
+/*
+ * LINK LIBRARY STRUCTURE
+ */
+		/* NB - this is a Lattice extension.  It is perfectly
+		 * legal to concatenate .o files and call it a library.
+		 * Now adopted by ADOS 2.0
+		 */
+	/* this block is of the form:
+	 * ID, size in longs of the code/data/etc following
+	 */
+#define LIB_HUNK	1018
+	/* this block is of the form:
+	 * ID, size, 16-bit size of string table, string table, reloc info
+	 */
+#define LIB_INDEX	1019
+	/* the ADOS 2.0 book defines them this way -
+	 *	HUNK_LIB 1019
+	 *	HUNK_INDEX 1020
+	 * it's wrong, right?
+	 */
diff -Pru nethack-3.4.1/sys/amiga/splitter/arg.c nethack/sys/amiga/splitter/arg.c
--- nethack-3.4.1/sys/amiga/splitter/arg.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/arg.c	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,242 @@
+/*    SCCS Id: @(#)arg.c		3.1   95/07/25
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993, 1995 */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * arg.c - semi-generic argument parser
+ */
+#include <exec/types.h>
+#include <exec/lists.h>
+#ifdef _DCC
+# include <clib/exec_protos.h>
+#else
+# include <proto/exec.h>
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include "arg.h"
+
+static char *a_desc;
+static int a_argc;
+static char **a_argv;
+static int a_apos;
+static char more=0;
+static char *argp;
+
+static char *arg_fillbuf(void);
+static char *splitline2(char *);
+
+char *argarg;
+
+#ifndef ARGLEN
+#define ARGLEN 134		/* longest line we can deal with */
+#endif
+
+static struct List flist;	/* stack of files to read from */
+struct fentry {			/* structures on that stack */
+	struct Node node;
+	FILE *fp;
+	char *ptr;
+	char buf[ARGLEN];
+};
+
+static char *splitline(struct fentry *); /* L505 bug? can't be above def  */
+
+#define ListHead(x) ((x).lh_Head)
+#define ListEmpty(x) (!(x).lh_Head->ln_Succ)
+
+/*
+ * arg_init(description string, argc, argv)
+ * Called by user to initialize system - must be called before calling
+ * other entry points.  desc is getopt(3) style description string; argc and
+ * argv are the arguments to main().
+ */
+void arg_init(char *desc,int argc,char *argv[]){
+	a_desc=desc;
+	a_argc=argc;
+	a_argv=argv;
+	a_apos=0;
+	NewList(&flist);
+}
+
+/*
+ * arg_next(void)
+ * Called by user to return each argument.  See arg.h for exceptional return
+ * values - normally returns the argument flag found; if a flag takes an
+ * argument, the argument is returned in argarg.
+ * An argument beginning with @ is taken to be a file name from which to read
+ * further arguments - such files are held on a stack and read as found, then
+ * the previous file (or the command line) is continued.
+ * In an argument file, the following are recognized:
+ * #  as the first character of a line only, causes the line to be ignored
+ * @  recursively read arguments from another file
+ * \n embedded newline
+ * \r embedded carriage return
+ * \f embedded formfeed
+ * \b embedded backspace
+ * \  literal next character (except above)
+ * "  start/end double quoted string
+ * '  start/end single quoted string
+ */
+int arg_next(){
+	char *cp;
+	char key;
+
+	if(!more){				/* anything still buffered? */
+		if(!(argp=arg_fillbuf())){	/* nothing more */
+			argarg=0;		/* be neat */
+			return(ARG_DONE);
+		}
+	}
+	if(more ||(*argp=='-' && argp++)){
+		for(cp=a_desc;*cp;cp++){
+			if(*cp== *argp){
+				key=*argp++;
+				if(*++cp==':'){
+					if(*argp){
+						argarg=argp;
+					} else {
+						argarg=arg_fillbuf();
+						if(!argarg)return(ARG_ERROR);
+					}
+					more=0;
+				} else {
+					argarg=0; /* doesn't take an arg */
+					more= *argp;
+				}
+				return((int) key);
+			}
+		}
+		return(ARG_ERROR);	/* no such option */
+	} else {
+		argarg=argp;
+		more=0;
+		return(ARG_FREE);
+	}
+}
+
+static char *arg_fillbuf(){
+    char *p,*nlp;
+
+    if(ListEmpty(flist)){
+	if(++a_apos>a_argc)return(0);
+	p=a_argv[a_apos];
+    } else {
+	struct fentry *f=(struct fentry *)ListHead(flist);
+	if(!f->ptr){
+	    do{
+		if(!fgets(f->buf,ARGLEN,f->fp)){
+		    if(ferror(f->fp)){
+			fprintf(stderr, "I/O error on @file\n");
+			return(0);
+		    }
+		    fclose(f->fp);
+		    RemHead(&flist);
+		    free(f);
+		    return(arg_fillbuf());
+		}
+	    }while(f->buf[0]=='#');	/* comment */
+	    if(nlp=strchr(f->buf,'\n'))*nlp='\0';
+	}
+	p=splitline(f);
+	if(p == (char *)-1)return(0);		/* error */
+	if(!p)return(arg_fillbuf());		/* skip blank line */
+    }
+	if(p && *p=='@'){
+		struct fentry *f=calloc(sizeof(struct fentry),1);
+		f->fp=fopen(++p,"r");
+		if(!(f->fp)){
+			fprintf(stderr,"Can't open @file '%s'\n",p);
+			free(f);
+			return(0);
+		}
+		AddHead(&flist,(struct Node *)f);
+		return(arg_fillbuf());
+	}
+	return(p);
+}
+
+static char *splitline(struct fentry *f){
+	char *out=(f->ptr?f->ptr:f->buf);
+	char *ret;
+
+	while(*out && isspace(*out))out++;
+	if(!*out)return(0);	/* blank line or spaces at end */
+	ret=out;
+	while(*out && !isspace(*out)){
+		switch(*out){
+		case '\\':
+		case '\"':
+		case '\'':
+			out=splitline2(out);
+			if(!out)return((char *)-1);	/* error */
+			break;
+		default:
+			out++;
+			break;
+		}
+	}
+	if(!*out){
+		f->ptr=0;	/* this was last arg on current line */
+	} else {
+		*out='\0';
+		f->ptr= ++out;
+		if(!(*f->ptr))f->ptr=0;
+	}
+	return ret;
+}
+
+static char *splitline2(char *p){
+	char *out=p;
+	char c;
+	char dq=0, sq=0;
+	while(*p){
+		switch(c= *p++){
+		case '\\':
+			switch(c= *p++){
+			case 'n':	*out++='\n';break;
+			case 'r':	*out++='\r';break;
+			case 'f':	*out++='\f';break;
+			case 'b':	*out++='\b';break;
+			case 0:		p--;break;
+			default:	*out++=c;break;
+			}
+			break;
+		case '\"':	if(sq){
+					*out++=c;
+				} else {
+					dq=1-dq;
+				}
+				break;
+		case '\'':	if(dq){
+					*out++=c;
+				} else {
+					sq=1-sq;
+				}
+				break;
+		case ' ':	if(!sq && !dq){*out=0;return(p-1);}
+				*out++=' ';
+				break;
+		default:	*out++=c;break;
+		}
+	}
+	if(sq ||dq){
+		fprintf(stderr,"Warning - quote error in @file\n");
+		return((char *)-1);
+	}
+	*out=0;
+	return(p);
+}
+
+#ifdef DEBUG_ARG
+main(int argc,char *argv[]){
+	int x=0;
+	arg_init(getenv("test_arg"),argc,argv);
+	do{
+		x=arg_next();
+		printf("r=%d (%d)'%s'\n",x,argarg,argarg);
+	}while(x >= 0);
+}
+#endif /* DEBUG_ARG */
diff -Pru nethack-3.4.1/sys/amiga/splitter/arg.h nethack/sys/amiga/splitter/arg.h
--- nethack-3.4.1/sys/amiga/splitter/arg.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/arg.h	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,17 @@
+/*    SCCS Id: @(#)arg.h		3.1   93/01/08
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993 */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * arg.h
+ * external interface for argument parsing
+ */
+
+int arg_next(void);
+void arg_init(char *,int, char **);
+
+extern char *argarg;
+
+#define ARG_ERROR	(-2)	/* no such arg, bad file, etc. */
+#define ARG_DONE	(-1)	/* ok, but nothing left */
+#define ARG_FREE	0	/* a name not associated with an arg */
diff -Pru nethack-3.4.1/sys/amiga/splitter/loader.c nethack/sys/amiga/splitter/loader.c
--- nethack-3.4.1/sys/amiga/splitter/loader.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/loader.c	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,465 @@
+/* 	SCCS Id: @(#)loader.c 3.1	93/01/08
+/*	Copyright (c) Kenneth Lorber, Bethesda, Maryland 1992, 1993 */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * Amiga split binary runtime system
+ */
+
+/*#define LDEBUG	 	/* turn on debugging I/O */
+#define SDEBUG		/* static primary array allocation */
+/*#define NOCLEAN		/* turn off ___spl_memchain code */
+/*#define NOSPLIT		/* debug: load an unsplit binary(run ONCE!)*/
+#define MULTI			/* real file reading code */
+/*#define PARANOID		/* check for refs off end that might be OK */
+#define CACHE			/* deal with cache flushing */
+
+unsigned long xx;
+long *yy;
+
+#include "split.h"
+
+#ifdef SPLIT
+
+#include <stdio.h>		/* for spanic - should change */
+#include <exec/types.h>
+#include <exec/memory.h>
+#include <libraries/dosextens.h>
+#ifdef _DCC
+#include <clib/dos_protos.h>
+#include <clib/exec_protos.h>
+#else
+#include <proto/dos.h>
+#include <proto/exec.h>
+#include <dos.h>			/* NOT libraries/dos.h! */
+#endif
+#include <setjmp.h>
+#include <stdlib.h>
+
+jmp_buf jbuf;
+
+#include "amiout.h"
+
+#include "multi.h"
+
+#define F_LOAD 0
+#define F_RELOAD 1
+
+#define HT(x)	((x) & ~MEM_OBJ_EXTEND)
+
+void *___spl_AllocMem(unsigned int);
+void spanic(char *);			/* think about this!!!! */
+void exit(int);
+
+#ifdef SDEBUG
+unsigned long *___spl_hunktable[500];	/* 229 as of 2/3/93 */
+#else
+unsigned long *(*___spl_hunktable)[];
+int ___spl_hunktablesize;
+#endif
+
+#ifndef NOCLEAN
+BPTR ___spl_memchain=0;
+#endif
+BPTR ovlfile=0;
+BPTR fh;
+ULONG database;
+
+BPTR s_LoadSeg(char *);
+void s_UnLoadSeg(void);
+BPTR load_code(int,char *);
+void load_data(int,char *);
+unsigned long *load_hunk(BPTR,int,ULONG *);
+
+#ifdef MULTI
+union multiopts mo;
+	/* dump these after testing */
+#define Read MultiRead
+#define Close MultiClose
+#endif
+
+BPTR
+s_LoadSeg(dir)
+	char *dir;
+	{
+	static BPTR base;
+	static char never=1;
+
+	if( setjmp( jbuf ) != 0 )
+		return( NULL );
+	if(never){
+#ifdef LDEBUG
+		fprintf(stderr,"s_LoadSeg waiting\n");
+		Delay(100);
+		fprintf(stderr,"going\n");
+#endif
+		base=load_code(F_LOAD,dir);
+#ifndef NOSPLIT
+		load_data(F_LOAD,dir);
+		never=0;
+#endif
+	}else{
+		load_data(F_RELOAD,dir);
+	}
+#ifdef LDEBUG
+	fprintf(stderr,"loadseg done! (waiting)\n");
+	getchar();
+#endif
+#ifdef CACHE
+	{
+	struct Library *eb=OpenLibrary("exec.library",36);
+	if(eb){
+		CacheClearU();
+		CloseLibrary(eb);
+	} else {
+		/* force a context switch and hope for the best */
+		Delay(1);
+	}
+	}
+#endif
+	return(base);
+}
+
+BPTR
+load_code(dummy,dir)
+	int dummy;	/* always F_LOAD */
+	char *dir;	/* direction file */
+{
+	ULONG x;
+	ULONG *xp;
+	ULONG c,hc;
+	ULONG r;
+#ifdef MULTI
+	mo.r.mor_tag='C';
+	fh=MultiOpen(dir,MODE_OLDFILE,&mo);
+#else
+	fh=Open("s_NetHack.c00",MODE_OLDFILE);
+#endif
+	if(fh==0){
+		fprintf(stderr,"open failed %d\n",IoErr());
+		spanic("missing code file");
+	}
+	Read(fh,&x,4);	/* HUNK_HEADER */
+	Read(fh,&x,4);	/* 0 */
+	Read(fh,&hc,4);	/* table size */
+#ifdef LDEBUG
+	fprintf(stderr,"hunk count=%d\n",hc);
+#endif
+#ifndef SDEBUG
+	___spl_hunktable= (long*(*)[])___spl_AllocMem(hc*4);
+	___spl_hunktablesize=hc*4;
+#endif
+#ifdef LDEBUG
+	fprintf(stderr,"table at %08x\n",___spl_hunktable);
+#endif
+	Read(fh,&x,4);	/* F==0 */
+	Read(fh,&x,4);	/* L==size-1 */
+	for(c=0;c<hc;c++){
+		Read(fh,&x,4);
+#ifdef SDEBUG
+		yy=___spl_hunktable[c]=___spl_AllocMem(x*4);
+#else
+		yy=(*___spl_hunktable)[c]=___spl_AllocMem(x*4);
+#endif
+#ifdef LDEBUG
+		fprintf(stderr,"t[%d]=%08x, len=%08x\n",c,yy,yy[-2]);
+#endif
+	}
+#ifdef LDEBUG
+	fprintf(stderr,"TABLE LOADED\n");Delay(50);
+#endif
+	for(c=0,xp=(unsigned long*)1;xp;c++){
+#ifdef LDEBUG
+# ifdef SDEBUG
+		yy=___spl_hunktable[c];
+# else
+		yy=(*___spl_hunktable)[c];
+# endif
+		fprintf(stderr,"loading hunk %d@%08x len=%08x\n",c,yy,yy[-2]);
+#endif
+#ifdef SDEBUG
+		xp=load_hunk(fh,dummy,___spl_hunktable[c]);
+#else
+		xp=load_hunk(fh,dummy,(*___spl_hunktable)[c]);
+#endif
+	}
+	database=c-1;	/* first hunk for use for data on each load */
+	Close(fh);
+#ifdef LDEBUG
+# ifdef SDEBUG
+	fprintf(stderr,"retval=%08x\n",___spl_hunktable[0]);
+# else
+	fprintf(stderr,"retval=%08x\n",(*___spl_hunktable)[0]);
+# endif
+#endif
+#ifdef SDEBUG
+	r= (unsigned long) ___spl_hunktable[0];		/* BPTR to seglist */
+#else
+	r= (unsigned long) (*___spl_hunktable)[0];	/* BPTR to seglist */
+#endif
+	return (BPTR)(r>>2)-1;
+}
+
+void
+load_data(fl,dir)
+	int fl;
+	char *dir;
+{
+	int c;
+	unsigned long *x;
+#ifdef MULTI
+	mo.r.mor_tag='D';
+	fh=MultiOpen(dir,MODE_OLDFILE,&mo);
+#else
+	fh=Open("s_NetHack.d00",MODE_OLDFILE);
+#endif
+			/* doing it this way we don't need the hunk count */
+	for(c=database,x=(unsigned long*)1;x;c++){
+#ifdef SDEBUG
+		x=load_hunk(fh,fl,___spl_hunktable[c]);
+#else
+		x=load_hunk(fh,fl,(*___spl_hunktable)[c]);
+#endif
+	}
+#ifdef LDEBUG
+	fprintf(stderr,"end of load_data (waiting)\n");
+	getchar();
+#endif
+	Close(fh);
+}
+
+unsigned long *
+load_hunk(ovlfile,fl,lbase)
+	BPTR ovlfile;		/* AmigaDOS file handle */
+	int fl;
+	ULONG *lbase;
+{
+	unsigned long data[2];
+	unsigned long *where;
+	unsigned long reloc_type;
+	static int lbufsize=680;	/* max xref in one hunk 347 2/3/93 */
+	static unsigned long *lbuf=0;	/* load buffer */
+	unsigned long *lbp;
+	unsigned short *lbps;
+
+	if(!lbuf)lbuf=malloc(lbufsize*4);
+	if(!lbuf)spanic("Can't allocate lbuf");
+#ifdef LDEBUG
+# ifndef MULTI
+	{
+	int pos=Seek(ovlfile,0,0);
+	fprintf(stderr,"load_hunk (fpos=%08x) @%08x len=%08x(%08x)\n",pos,
+		lbase,lbase[-2],lbase[-2]/4);
+	}
+# endif
+#endif
+	if(0==Read(ovlfile,data,sizeof(data))){
+#ifdef LDEBUG
+		fprintf(stderr,"getchar EOF\n");
+		getchar();
+#endif
+		return(0);	/* EOF */
+	}
+#ifdef LDEBUG
+	fprintf(stderr,"read type=%08x len=%08x\n",data[0],data[1]<<2);
+#endif
+	if( HT(data[0])!=HUNK_CODE &&
+	    HT(data[0])!=HUNK_DATA &&
+	    HT(data[0])!=HUNK_BSS){
+		fprintf(stderr,"bad data=%08x\n",data[0]);
+		spanic("ovlfile cookie botch");
+	}
+	where=lbase;
+#if 0
+				/* clear memory if:
+				 * 1. not the first time (MEMF_CLEAR'd already)
+				 * 2. data or bss (just in case)
+				 * This is just a sanity check since these are
+				 * the only hunks we should be seeing on reload.
+				 */
+	if(fl==F_RELOAD && (HT(data[0])==HUNK_DATA || HT(data[0])==HUNK_BSS)
+#endif
+	{
+		ULONG *p=where;		/* clear memory block */
+		ULONG c=(where[-2]/4)-1;	/* (len includes ptr) */
+#if 0			/* don't ship enabled - Gigamem returns 0 */
+		if(!TypeOfMem(p))spanic("clearing bogus memory");
+#endif
+		while(c--)*p++=0;	/* not memset - use longs for speed */
+	}
+
+	if(HT(data[0])==HUNK_DATA || HT(data[0])==HUNK_CODE){
+		xx=Read(ovlfile,where,data[1]*4);	/* load the block */
+		if(xx!=data[1]*4){
+			fprintf(stderr,"Read(%08x,%08x)->%08x\n",where,
+			  data[1]*4,xx);
+			spanic("out of data");
+		}
+	} else {
+#ifdef LDEBUG
+		fprintf(stderr,"BSS - no load\n");
+#endif
+	}
+			/* link/relocate as needed */
+	xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
+	if(xx!=sizeof(reloc_type))spanic("lost reloc_type");
+	while(reloc_type!=HUNK_END){
+		unsigned long reloc_count;
+		unsigned long reloc_count2;
+		unsigned long *base;
+		unsigned long reloc_offset;
+		unsigned long reloc_shift;
+		int hnum;
+		if(reloc_type==HUNK_END)continue;	/* and quit */
+		if(reloc_type!=HUNK_RELOC32 && reloc_type!=HUNK_RELOC32s){
+			fprintf(stderr,"bad data %08x\n",reloc_type);
+			spanic("ovlfile reloc cookie botch");
+		}
+		reloc_shift=(reloc_type==HUNK_RELOC32)?2:1;
+		xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
+		if(xx!=sizeof(reloc_count))spanic("lost reloc_count");
+
+		reloc_count2=reloc_count;
+		while(reloc_count){     /* fix indent */
+			if((reloc_count<<reloc_shift) >= (lbufsize*4)){
+				free(lbuf);
+				lbufsize=10+reloc_count;
+				lbuf=malloc(lbufsize*4);
+				if(!lbuf)spanic("Can't realloc lbuf");
+			}
+			xx=Read(ovlfile,lbuf,((1+reloc_count)<<reloc_shift));
+			if(xx!=((1+reloc_count)<<reloc_shift))
+				spanic("can't fill lbuf");
+			lbp= &lbuf[1];		/* 0 is reloc_hunk */
+			lbps= ((unsigned short *)lbuf)+1;
+			hnum=(reloc_shift==2)? lbp[-1]: lbps[-1];
+#ifdef SDEBUG
+			base=___spl_hunktable[hnum];
+#else
+			base=(*___spl_hunktable)[hnum];
+#endif
+#ifdef LDEBUG
+			fprintf(stderr,"reloc #%d: hunk #%d@%08x\n",
+			  reloc_count,hnum,base);
+#endif
+			while(reloc_count--){
+				if(reloc_shift==2){
+					reloc_offset= *lbp++;
+				} else {
+					reloc_offset= *lbps++;
+				}
+				if(reloc_offset<0 || reloc_offset>where[-2]){
+					fprintf(stderr,"where[-2]==%08x\n",
+					  where[-2]);
+					spanic("offset out of hunk");
+				}
+				{
+				ULONG *p=(ULONG*)(((ULONG)where)+reloc_offset);
+#ifdef PARANOID
+/* NB - nasty violation of signed/unsigned here */
+				{
+				if(*p > base[-2])
+				  fprintf(stderr,
+				  "WARNING: offset points outside block\n");
+				}
+#endif
+#ifdef LDEBUG
+				fprintf(stderr,
+				  "reloc_offset=%08x where=%08x p=%08x\n",
+				  reloc_offset,where,p);
+				fprintf(stderr," current *p=%08x\n",*p);
+#endif
+				(*p)+=(unsigned long)base;
+#ifdef LDEBUG
+				fprintf(stderr," new *p=%08x\n",*p);
+#endif
+				}
+			}
+			if( reloc_shift == 1 && (reloc_count2 & 1) == 0){ /* longword align */
+				short x;
+				Read(ovlfile,&x,sizeof(x));
+			}
+			xx=Read(ovlfile,&reloc_count,sizeof(reloc_count));
+			if(xx!=sizeof(reloc_count))spanic("lost reloc_count2");
+			reloc_count2=reloc_count;
+		}
+		xx=Read(ovlfile,&reloc_type,sizeof(reloc_type));
+		if(xx!=sizeof(reloc_count))spanic("lost reloc_type2");
+	}
+/* BUG -
+ * lbuf never freed
+ */
+	return(where);			/* return execute start point */
+}
+
+/*
+	-2	len (bytes)
+	-1	next block
+	 0	data
+ */
+void *
+___spl_AllocMem(len)
+	unsigned int len;
+	{
+	unsigned long *adr;
+	ULONG length=(len&0x0fffffff);
+				/* Always clear the memory.  On reload of
+				 * bss or data we have to do it manually */
+	adr=AllocMem(length+8,(6&(len>>29))|MEMF_CLEAR);
+	{
+		int type=6&(len>>29);
+		if(	type!=MEMF_CHIP &&
+			type!=MEMF_FAST &&
+			type!=MEMF_PUBLIC &&
+			type != 0
+		){
+			printf("%08x %08x* ",len,type);
+			spanic("bad memory type");
+		}
+	}
+	if(!adr)spanic("allocation failure");
+	adr[0]=length;
+#ifndef NOCLEAN
+	adr[1]=(unsigned long)___spl_memchain;	/* list for freeing at end */
+	___spl_memchain=((long)adr>>2)+1;	/* BPTR to next ptr */
+# ifdef LDEBUG
+	fprintf(stderr,"Alloc: adr[0]=%08x adr[1]=%08x\n",adr[0],adr[1]);
+# endif
+#endif
+	return adr+2;
+}
+
+void
+s_UnLoadSeg()
+{
+#ifndef NOCLEAN
+	BPTR p,p1;
+
+# ifdef LDEBUG
+	fprintf(stderr,"starting Free loop: ovlmemchain=%x\n",___spl_memchain);
+# endif
+	for(p=___spl_memchain;p;p=p1){
+		p1=*(BPTR *)BADDR(p);
+# ifdef LDEBUG
+		fprintf(stderr,"Free(%x,%x)\n",BADDR(p-1),
+		  (*(long *)BADDR(p-1))+8);
+# endif
+		FreeMem(BADDR(p-1),(*(long *)BADDR(p-1))+8);
+	}
+#endif
+#ifndef SDEBUG
+	FreeMem(___spl_hunktable,___spl_hunktablesize);
+#endif
+	return;
+}
+
+/* this needs to be improved and integrated with wb.c */
+void
+spanic(s)
+	char *s;
+{
+	fprintf(stderr,"s_LoadSeg failed: %s\n",s);
+	s_UnLoadSeg();
+	longjmp( jbuf, -1 );
+}
+#endif /* SPLIT */
diff -Pru nethack-3.4.1/sys/amiga/splitter/multi.c nethack/sys/amiga/splitter/multi.c
--- nethack-3.4.1/sys/amiga/splitter/multi.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/multi.c	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,115 @@
+/* 	SCCS Id: @(#)multi.c 3.1	95/07/25
+/*	Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993, 1995  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * NB - internal structure under development.  End users should NOT
+ *      get too creative!
+ */
+#include <exec/types.h>
+#include <exec/memory.h>
+#ifdef _DCC
+# include <clib/dos_protos.h>
+# include <clib/exec_protos.h>
+#else
+# include <proto/dos.h>
+# include <proto/exec.h>
+# include <dos.h>
+#endif
+#include <string.h>
+#include <assert.h>
+#include <ctype.h>
+#include "multi.h"
+
+static int start_next_file(multifh *);	/* XXX should return enum */
+BPTR
+MultiOpen(char *dirfile, ULONG mode, union multiopts *mo){
+	multifh *retval;
+
+	assert(mode==MODE_OLDFILE);	/* XXX no chioce this version */
+	retval=(multifh *)AllocMem(sizeof(multifh),MEMF_CLEAR);
+	if(retval){
+		retval->mfh_dirfh=Open(dirfile,MODE_OLDFILE);
+		if(retval->mfh_dirfh){
+			retval->mfh_mo= *mo;
+			if(start_next_file(retval)==1){
+				return((BPTR)retval);		/* success */
+			}
+		}
+	}
+
+	if(retval)FreeMem(retval,sizeof(multifh));
+	return 0;
+}
+
+ULONG
+MultiRead(BPTR xmfp, void *where0, ULONG len){
+	char *where = (char*)where0;
+	multifh *mfp=(multifh *)xmfp;
+	ULONG sofar=0;
+	ULONG this;
+
+	if(len<=0)return len;
+	if(mfp->mfh_fh==0)return 0;	/* pending EOF (possibly premature) */
+
+	while(sofar<len){
+		this=Read(mfp->mfh_fh,where,len-sofar);
+		if(this==-1) return -1;
+		if(this==0){
+			Close(mfp->mfh_fh);
+			mfp->mfh_fh=0;
+			if(start_next_file(mfp)<=0){
+				return sofar;
+			}
+		}
+		sofar += this; where += this;
+	}
+	return sofar;
+}
+
+void
+MultiClose(BPTR xmfp){
+	multifh *mfp=(multifh *)xmfp;
+	if(mfp->mfh_dirfh)Close(mfp->mfh_dirfh);
+	if(mfp->mfh_fh)Close(mfp->mfh_fh);
+	FreeMem(mfp,sizeof(multifh));
+}
+
+/* Return 0==no more data, -1 error.  Else more data available unless file
+ * is empty.
+ */
+static
+start_next_file(multifh *mfp){
+	ULONG t;
+	char line[100];		/* should be based on PATHLEN */
+	char *eol;
+
+	while(1){
+		t=Read(mfp->mfh_dirfh,line,99);
+		if(t==0)return(0);
+		if(t==-1)return(-1);
+
+		line[t]='\0';
+		eol=strchr(line,'\n');
+		if(eol){
+			*eol='\0';
+			Seek(mfp->mfh_dirfh,-(t-(eol-line))+1,OFFSET_CURRENT);
+		}
+		switch(line[0]){
+		case '\0':
+		case '#':
+			break;			/* comment, blank lines */
+		default:
+			if(line[0]==mfp->mfh_mo.r.mor_tag){
+						/* allow blanks after tag */
+				char *file= &line[1];
+				while(*file && isspace(*file))file++;
+				mfp->mfh_fh=Open(file,MODE_OLDFILE);
+				if(!mfp->mfh_fh){
+					return -1;	/* error */
+				}
+				return 1;
+			}
+		}
+	}
+}
diff -Pru nethack-3.4.1/sys/amiga/splitter/multi.h nethack/sys/amiga/splitter/multi.h
--- nethack-3.4.1/sys/amiga/splitter/multi.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/multi.h	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,35 @@
+/* 	SCCS Id: @(#)multi.h 3.1	93/01/08
+/*	Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993 */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * external definitions for multi-file file handling package.
+ * NB - internal structure under development.  End users should NOT
+ *      get too creative!
+ */
+
+union multiopts {
+	struct mo_read {
+		char mor_tag;	/* tag character for this open */
+	}r;
+	struct mo_write {
+		char dummy;	/* (no write in this version) */
+	}w;
+};
+
+struct multifh {
+	unsigned long mfh_fh;	/* AmigaDOS file handle of current segment */
+	unsigned long mfh_dirfh;/* AmigaDOS file handle of direction file */
+	union multiopts mfh_mo;	/* copy from MultiOpen */
+	struct mfh_flags {
+		int version:8;	/* not used yet */
+		int flags:24;	/* not used yet */
+	};
+};
+
+typedef union multiopts multiopts;
+typedef struct multifh multifh;
+
+extern BPTR MultiOpen(char *, ULONG, multiopts *);
+extern ULONG MultiRead(BPTR, void *, ULONG);
+extern void MultiClose(BPTR);
diff -Pru nethack-3.4.1/sys/amiga/splitter/split.doc nethack/sys/amiga/splitter/split.doc
--- nethack-3.4.1/sys/amiga/splitter/split.doc	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/split.doc	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,63 @@
+	Splitter			[split.doc 95/07/02]
+
+Usage:
+	splitter [-Cc_prototype] [-Dd_prototype] [-ddir_prototype] binary
+
+Default prototypes:
+	d: %n.dir
+	C: %n.c%C
+	D: %n.d%D
+
+Prototypes:
+	%n	base file name
+	%C	current code file #
+	%D	current data file #
+
+Creates:
+	binary.dir		directions file
+	binary.d00		data files
+	binary.d01 ...
+	binary.c00		code files
+	binary.c01 ...
+
+Format of the directions file (subject to change):
+	Cbinary.c00
+	Cbinary.c01
+	Cbinary.c02
+	Dbinary.d00
+	Dbinary.d01
+The above entries may be edited to reflect the location of the various files
+if it is necessary for them to be moved by the user.  All C entries must
+precede all D entries.  Whitespace is permitted after the directive key
+and before the filename.
+
+Maximum output file size is 800K (819200 bytes) - this leaves just enough
+space on an empty floppy for a small icon.  Note that splitter will now
+break a hunk as needed to respect the file size limit.
+
+Code file contents:
+The first code file contains:
+	the (modified) HUNK_HEADER from the original binary
+	(followed by)
+All code files contain:
+	HUNK_CODE's from the original binary
+
+Data file contents:
+	HUNK_BSS's from the original binary
+	HUNK_DATA's from the original binary
+
+CHANGES FOR 3.1.1:
+	Faster loading by buffering offsets.
+	Smaller files: splitter will now write out HUNK_RELOC32short
+	relocation blocks whenever possible.
+	Blanks may now be between the C/D and the file name in the .dir file.
+
+CHANGES FOR 3.2:
+	Hunks will now be split if necessary.
+
+BUGS
+	The present system for generating multiple files is a hack -
+	multi.[ch] should be upgraded instead.
+
+	Many optimizations for minimizing the size of the output file
+	could/should/will be added.
diff -Pru nethack-3.4.1/sys/amiga/splitter/split.h nethack/sys/amiga/splitter/split.h
--- nethack-3.4.1/sys/amiga/splitter/split.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/split.h	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,201 @@
+/*    SCCS Id: @(#)split.h		3.1   93/01/08
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993	  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * split.h
+ * Common definitions for binary file splitting and loading of split files.
+ */
+
+/*#define SVER	1	/* Basic file splitting capability */
+#define SVER	2	/* emit HUNK_RELOC32s as appropriate */
+
+/* Nothing below this line should need to be modified. */
+
+#ifndef SVER
+ __SPLIT_H__SVER_MUST_BE_DEFINED
+#endif
+
+#if SVER == 2
+	/* enable options */
+# define EMIT_32s
+#endif
+
+/* internal structures, etc */
+
+#include <exec/types.h>
+#include <exec/lists.h>
+#ifdef _DCC
+#include <clib/exec_protos.h>
+#else
+#include <proto/exec.h>
+#endif
+/*#include "ldextern.h"*/
+
+		/* one for each file we need something from */
+struct file_ {
+	struct MinNode	node;		/* linkage */
+	struct List	punits;		/* program units we need */
+	int		fd;		/* fd (-1 if not open) */
+	char *		name;		/* open(2)'able name */
+};
+typedef struct file_ file;
+
+		/* one for each program unit we need to load */
+struct punit_ {
+	struct MinNode	node;		/* linkage */
+	int		libsize;	/* 0 if normal, libsize if library */
+	struct block_ *	unit_header;
+	struct List	hunks;		/* hunks in this program unit */
+};
+typedef struct punit_ punit;
+
+		/* one for each hunk we need to load */
+struct hunk_ {
+	struct MinNode	node;		/* linkage */
+	struct List	reloc;		/* reloc8,16,32 */
+	struct List	dreloc;		/* drelec8,16,32 */
+	struct block_ *	rb;		/* ONE relocatable block */
+	struct block_ *	name;		/* max ONE name */
+	struct List	extsym;		/* external symbol entries */
+	struct punit_ * punit;		/* back pointer */
+	struct hunk_  * merge;		/* 0 if lone or last section, else next
+					 * part in this (merged by name) hunk */
+	struct hunk_  * jmptab;		/* alv's live here, if any do. If so,
+					 * it's at the end of the chain */
+	int	hunkstart:1;	/* lone hunk or start of a chain */
+	int	hunkchain:1;	/* allocated to a chain */
+	int	hunkgone:1;	/* hunk has been written */
+	long	overlay;	/* 0 if root node */
+	long 	hunknum;	/* in output file */
+	long	hunkoffset;	/* 0 unless not at start of chain */
+};
+typedef struct hunk_ hunk;
+#define UNASSIGNED_HUNK	0x7ffffff0
+
+struct block_ {
+	struct MinNode	node;	/* linkage */
+	struct swap_ *sw;	/* if !0, where to reload from disk */
+	int id;			/* if used */
+	long *b;		/* if !0, block of raw data (else swapped) */
+				/* (this should be replaced with a union) */
+};
+typedef struct block_ block;
+
+		/* This is used to keep memory usage down.  We don't read in
+		 * the actual data until we are writing the output file. */
+struct swap_ {
+	file *f;
+	long pos;
+	long len;			/* in longs */
+};
+typedef struct swap_ swap;
+
+		/* When we need a list of lists. */
+struct listlist_ {
+	struct MinNode	node;		/* linkage */
+	int 		id;
+	struct List	list;
+};
+typedef struct listlist_ listlist;
+
+typedef char flag;			/* TRUE or FALSE only */
+
+/* tracing system */
+#define MAXTRACEVAR	7
+extern char trace[MAXTRACEVAR];
+#define LIST		if(trace[0])		/* -t0=1 */
+#define HASHSTAT	if(trace[1])		/* -t1=1 */
+#define HASHTBL		if(trace[1]>1)		/* -t1=2 */
+#define NAME		if(trace[2])		/* -t2=1 */
+#define OUT		if(trace[3])		/* -t3=1 */
+#define PROC		if(trace[4])		/* -t4=1 */
+#define LIB		if(trace[5])		/* -t5=1 */
+#define VLIB		if(trace[5]>1)		/* -t5=2 */
+#define OVER		if(trace[6])		/* -t6=1 */
+
+/* name_ (symbol table) system */
+#define HSIZE	128		/* MUST be power of two */
+#define HMASK	(HSIZE-1)
+
+struct nentry_ {		/* a name entry */
+	struct MinNode	next;	/* next ref or def in bucket */
+	struct hunk_ *defh;	/* hunk where defined, else 0 */
+	long defo;		/* offset value of definition */
+	char *name;		/* name */
+	short len;		/* len of name */
+	unsigned refflag:1;	/* just for input_check */
+	unsigned linkvar:1;	/* linker variable */
+	unsigned inroot:1;	/* forced into root node */
+};
+typedef struct nentry_ nentry;
+
+/* hunk numbers in the overlay file start at this value: */
+#define OVRHUNK_BASE 0x40000000
+#define OVRHUNK_MASK 0x0fffffff
+
+/* Lists */
+#define LIST_P struct List *
+#define NODE_P struct Node *
+
+struct Node *Head(struct List *);
+struct Node *Tail(struct List *);
+struct Node *Next(struct Node *);
+struct Node *Prev(struct Node *);
+
+extern flag read_any_bss;
+extern flag overlaying;
+
+extern struct List *_fortemp;
+#define foreach(n,lp,t)	_fortemp=(struct List *)(lp);if(_fortemp)	\
+			for(n= t Head(_fortemp);n;			\
+			  n= t Next((struct Node *)(n)))
+
+/* privates for splitter */
+
+/* structs */
+struct hheader {
+	int hcount;		/* table size */
+	int first;		/* first hunk # */
+	int last;		/* last hunk # */
+	int (*sizes)[];		/* size of each hunk */
+};
+struct shunk {
+	struct hunk_ *h;		/* linker hunk info */
+};
+
+/* externs */
+extern char *ssubst(char *,const char *);
+extern void panic(char *);
+extern char *eos(char *);
+extern void read_load_file(char *);
+extern void write_code_file(void);
+extern void write_data_file(void);
+extern void write_dir_file(void);
+extern int write_split_file(int);
+extern void write_lreloc(struct hunk_ *,struct listlist_ *);
+extern void wsf_hunk(struct hunk_ *);
+extern void renumber(void);
+extern int renumber2(int,int);
+extern void write_header(void);
+extern void owrite(void*,long);
+extern void owrite_long(long);
+extern void owrite_short(int);
+extern void out_start(char *);
+extern void out_stop(void);
+extern void new_file(void);
+
+void print_text_block(char *,struct block_ *);
+void print_bin_block(struct block_ *);
+struct file_ *NewFile(char *);
+struct punit_ *NewPunit(void);
+struct hunk_ *NewHunk(void);
+struct listlist_ *NewListList(void);
+struct block_ *NewBlock(void);
+long *NewData(long);
+int rderror(void);	/* should be void, but needs return val for ?: */
+struct block_ *ReadSimpleBlock(struct file_ *, long );
+int TossSimpleBlock(struct file_ *);
+struct hunk_ *ReadHunk(struct file_ *);
+void ReadReloc(struct file_ *,long,struct List *);
+long block_size(struct block_ *);
diff -Pru nethack-3.4.1/sys/amiga/splitter/splitter.c nethack/sys/amiga/splitter/splitter.c
--- nethack-3.4.1/sys/amiga/splitter/splitter.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/splitter/splitter.c	Thu Jan 10 16:43:25 2002
@@ -0,0 +1,778 @@
+/*    SCCS Id: @(#)splitter.c		3.1   95/07/25
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993, 1995 */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#define SOUT				/* split output files */
+#define SPLITSIZE (800 * 1024)		/* somewhat < one floppy */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+
+#include <proto/exec.h>
+#include <exec/types.h>
+#include <exec/nodes.h>
+#include <exec/lists.h>
+
+#include "split.h"
+#include "amiout.h"
+#include "arg.h"
+
+int main(int,char **);
+char *stripname(char *);
+
+char *code_proto="%n.c%C";
+char *data_proto="%n.d%D";
+char *dir_proto="%n.dir";
+
+char trace[MAXTRACEVAR];		/* debugging info */
+char *basename;
+int datacount;				/* for ssubst - should be replaced */
+int codecount;
+int data_file_count=0;			/* actual maxima */
+int code_file_count=0;
+struct hheader hheader;
+struct shunk (*hlist)[];
+char buf[80];
+int wsf_count;
+
+main(argc,argv)
+    int argc;
+    char **argv;
+{
+    int cur_arg;
+
+    arg_init("C:D:d:t:T",argc,argv);
+    while((cur_arg=arg_next())!=ARG_DONE){
+	switch(cur_arg){
+	case 'C':	/* code prototype */
+		code_proto=strdup(argarg);break;
+	case 'D':	/* data prototype */
+		data_proto=strdup(argarg);break;
+	case 'd':	/* directions prototype */
+		dir_proto=strdup(argarg);break;
+	case 't':	/* trace (debug) */
+		{
+		int dtype=0,dlevel=0;	/* rude defaults */
+		sscanf(argarg,"%d=%d",&dtype,&dlevel);
+		if(dtype<0 || dtype>=MAXTRACEVAR){
+		    fprintf(stderr,"-t: bad trace num ignored\n");
+		}else{
+		    trace[dtype]=dlevel?dlevel:1;
+		}
+		break;
+		}
+	case 'T':	/* trace everything */
+		{
+		int dtype;
+		for(dtype=0;dtype<MAXTRACEVAR;dtype++)trace[dtype]=255;
+		}
+		break;
+	default:
+		fprintf(stderr,"Unrecognized option.\n");
+		/* FALLTHROUGH */
+	case ARG_ERROR:
+		panic("Error processing arguments.");
+	case ARG_FREE:
+		basename=strdup(argarg);
+			/*
+			 * Force the output files into the current directory.
+			 * Note that this leaks memory from the start of the
+			 * string (but we don't care in this case).
+			 */
+		basename=stripname(basename);
+		read_load_file(argarg);break;
+	}
+    }
+    renumber();
+
+    out_start(code_proto);
+    write_header();
+    write_code_file();
+    out_stop();
+
+    out_start(data_proto);
+    write_data_file();
+    out_stop();
+
+    write_dir_file();
+    exit(0);
+}
+
+char *
+ssubst(buf,pat)
+    char *buf;
+    const char *pat;
+{
+    char *buf1=buf;
+
+    while(*pat){
+	if(*pat!='%'){
+	    *buf++=*pat++;
+	} else {
+	    pat++;
+	    switch(*pat++){
+	    case '%': *buf++='%';break;
+	    case 'n': strcpy(buf,basename);buf=eos(buf);break;
+	    case 'D': sprintf(buf,"%02d",datacount);buf=eos(buf);break;
+	    case 'C': sprintf(buf,"%02d",codecount);buf=eos(buf);break;
+	    default:  panic("pattern substitution error");
+	    }
+	}
+    }
+    *buf='\0';
+    return buf1;
+}
+
+void
+panic(s)
+    char *s;
+{
+    fprintf(stderr,"\npanic: %s\n",s);
+    exit(1);
+}
+
+char *
+eos(s)
+    char *s;
+{
+    while(*s)s++;
+    return s;
+}
+
+/*
+ * input routines
+ */
+
+	/* macro for reading the next long.  If e==EOF_OK, caller MUST check
+	 * for EOF condition via hreadval or assure it can't occur */
+static int hreadval=0;		/* macro internal temporary */
+#define EOF_OK	1
+#define EOF_BAD	0
+#define READLONG(e)	\
+	((4!=(hreadval=read(f->fd,&(READLONGx),4)))		\
+	?((0==hreadval && (e)					\
+		?0						\
+		:rderror()))					\
+	:READLONGx)
+static long READLONGx;
+#define READSHORT(e)	\
+	((2!=(hreadval=read(f->fd,&(READSHORTx),2)))		\
+	?((0==hreadval && (e)					\
+		?0						\
+		:rderror()))					\
+	:READSHORTx)
+static short READSHORTx;
+
+#define LONGLEN(x)	(strlen(x)+3 >>2)	/* # longs for a string */
+
+void
+read_load_file(name)
+    char *name;
+{
+    int t;
+    int hc;
+    file *f=NewFile(name);
+
+		/* read HUNK_HEADER */
+    t=READLONG(EOF_BAD);if(t!=HUNK_HEADER)panic("no HUNK_HEADER");
+    t=READLONG(EOF_BAD);if(t)while(t--)READLONG(EOF_BAD); /* eat any name */
+    hheader.hcount=READLONG(EOF_BAD);
+    hheader.first=READLONG(EOF_BAD);
+    hheader.last=READLONG(EOF_BAD);
+    if(hheader.hcount !=(hheader.last-hheader.first+1))panic("can't count");
+    hheader.sizes=calloc(hheader.hcount,sizeof(int*));
+    for(t=0;t<hheader.hcount;t++)
+	(*hheader.sizes)[t]=READLONG(EOF_BAD);
+
+    hlist=calloc(hheader.hcount,sizeof(struct shunk));
+    for(hc=0;hc<hheader.hcount;hc++){
+	struct shunk *th = &(*hlist)[hc];
+			/* read each hunk */
+	th->h=ReadHunk(f);
+    }
+    close(f->fd);
+}
+
+/*
+ * write routines
+ */
+#define S_CODE	0
+#define S_DATA	1
+
+void
+write_header(){
+    int x;
+    int target=0;
+
+    owrite_long(HUNK_HEADER);
+    owrite_long(0);
+    owrite_long(hheader.hcount);
+    owrite_long(hheader.first);
+    owrite_long(hheader.last);
+
+    for(x=0;x<hheader.hcount;x++){
+	hunk *hp = (*hlist)[x].h;
+	if(hp->hunknum==target){
+	    owrite_long((*hheader.sizes)[x]);
+	    target++;
+	}
+    }
+    for(x=0;x<hheader.hcount;x++){
+	hunk *hp = (*hlist)[x].h;
+	if(hp->hunknum==target){
+	    owrite_long((*hheader.sizes)[x]);
+	    target++;
+	}
+    }
+    if(target!=hheader.hcount)panic("lost hunks?");
+}
+
+void
+write_code_file(){
+    code_file_count=write_split_file(S_CODE)-1;
+}
+
+void
+write_data_file(){
+    data_file_count=write_split_file(S_DATA)-1;
+}
+
+void
+write_dir_file(){
+    int x;
+    FILE *fp=fopen(ssubst(buf,dir_proto),"w");
+
+    fprintf(fp,"# split binary direction file\n");
+    fprintf(fp,"# Each line consists of:\n");
+    fprintf(fp,"#   A single C or D for the type of the file (Code or Data)\n");
+    fprintf(fp,"#   The full path of the file.\n");
+
+    for(x=0;x<=code_file_count;x++){
+	codecount=x;
+	fprintf(fp,"C %s\n",ssubst(buf,code_proto));
+    }
+    for(x=0;x<=data_file_count;x++){
+	datacount=x;
+	fprintf(fp,"D %s\n",ssubst(buf,data_proto));
+    }
+    fclose(fp);
+}
+
+/* macro to eliminate type bits, leaving the length of a memory allocation */
+#define HT(x)	((x) & ~MEM_OBJ_EXTEND)
+
+int
+write_split_file(fl)
+    int fl;
+{
+    int hc;
+    for(hc=0;hc<hheader.hcount;hc++){
+	hunk *hp = (*hlist)[hc].h;
+	if(fl==S_CODE && HT(hp->rb->id)==HUNK_CODE){
+	    wsf_hunk(hp);
+	} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_DATA){
+	    wsf_hunk(hp);
+	} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_BSS){
+	    wsf_hunk(hp);
+	}
+    }
+    return wsf_count;
+}
+
+void
+wsf_hunk(hp)
+    hunk *hp;
+{
+    listlist *el;
+
+    switch(HT(hp->rb->id)){
+    case HUNK_CODE:
+    case HUNK_DATA:
+	owrite(hp->rb->b,(2+hp->rb->b[1])*sizeof(long));
+	break;
+    case HUNK_BSS:
+	owrite(hp->rb->b,2*sizeof(long));
+	break;
+    default:panic("wsf_hunk: bad type");
+    }
+    foreach(el,&(hp->reloc),(listlist*)){
+	write_lreloc(hp,el);
+    }
+    owrite_long(HUNK_END);
+}
+
+void
+write_lreloc(hp,ll)
+    hunk *hp;listlist *ll;
+    {
+    block *bp;
+
+#ifdef EMIT_32s
+    int x;
+    ULONG *p;
+
+		/* can we write the entire block with a HUNK_RELOC32s? */
+    foreach(bp,&(ll->list),(block*)){
+	if((((*hlist)[bp->b[1]]).h->hunknum)>0xffff)goto no_32s; /* no */
+	for(p= &(bp->b[2]), x=bp->b[0];x;x--,p++){
+	    	if(*p>0xffff)goto no_32s;	/* no, offset too big */
+	}
+    }
+		/* yes */
+    owrite_long(HUNK_RELOC32s);
+    foreach(bp,&(ll->list),(block*)){
+	owrite_long(bp->b[0]);
+	owrite_short(((*hlist)[bp->b[1]]).h->hunknum);
+	for(p= &(bp->b[2]), x=bp->b[0];x;x--,p++){
+	    owrite_short(*p);
+	}
+			/* force long alignment.  Not documented, but makes
+			 * reading dumps easier */
+	if((bp->b[0] & 1) == 0){	/* note hunknum also short */
+	    owrite_short(0);
+	}
+    }
+    owrite_long(0);
+    return;
+no_32s:
+#endif
+    owrite_long(HUNK_RELOC32);
+    foreach(bp,&(ll->list),(block*)){
+	owrite_long(bp->b[0]);
+	owrite_long(((*hlist)[bp->b[1]]).h->hunknum);
+	owrite(&(bp->b[2]),bp->b[0]*sizeof(long));
+    }
+    owrite_long(0);
+}
+
+void
+renumber()
+{
+    int n;
+    n=renumber2(S_CODE,0);
+    renumber2(S_DATA,n);
+}
+
+renumber2(fl,n)
+    int fl;
+    int n;
+{
+    int hc;
+    for(hc=0;hc<hheader.hcount;hc++){
+	hunk *hp = (*hlist)[hc].h;
+	if(fl==S_CODE && HT(hp->rb->id)==HUNK_CODE){
+	    hp->hunknum=n++;
+	} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_DATA){
+	    hp->hunknum=n++;
+	} else if(fl==S_DATA && HT(hp->rb->id)==HUNK_BSS){
+	    hp->hunknum=n++;
+	}
+    }
+    return n;
+}
+
+/*
+ * output package
+ */
+#ifndef SOUT
+/* NB - this version does NOT cope with multiple output files per type
+ *      define SOUT to do that
+ */
+int ofile;
+
+void
+out_start(prot)
+    char *prot;
+{
+    datacount=codecount=0;
+    file=open(ssubst(buf,prot),O_WRONLY|O_CREAT|O_TRUNC);
+    if(ofile<0)panic("can't open output file");
+}
+
+void
+out_stop(){
+    close(ofile);
+}
+
+void
+owrite_long(literal)
+    long literal;
+{
+    long x=literal;
+    owrite(&x,sizeof(x));
+}
+
+void
+owrite_short(literal)
+    short literal;
+{
+    short x=literal;
+    owrite(&x,sizeof(x));
+}
+
+void
+owrite(where,len)
+    void *where;
+    long len;
+{
+    write(ofile,where,len);
+}
+#else /* SOUT */
+/* split output files - these are read via multi.  This code will eventually
+ * migrate into multi as well.
+ */
+int ofile=0;
+int osize;
+char *oprot;
+void
+out_start(prot)
+    char *prot;
+{
+    datacount=codecount=wsf_count=0;
+    oprot=prot;
+    new_file();
+}
+
+void
+out_stop(){
+    close(ofile);
+    ofile=0;
+}
+
+void
+owrite_long(literal)
+    long literal;
+{
+    long x=literal;
+    if((osize+sizeof(x))>SPLITSIZE)new_file();
+    owrite(&x,sizeof(x));
+    osize += sizeof(x);
+}
+
+void
+owrite_short(literal)
+    int literal;
+{
+    short x=literal;
+    if((osize+sizeof(x))>SPLITSIZE)new_file();
+    owrite(&x,sizeof(x));
+    osize += sizeof(x);
+}
+
+void
+owrite(where,len)
+    void *where;
+    long len;
+{
+    while((osize+len)>SPLITSIZE){
+	write(ofile,where,SPLITSIZE-osize);
+	len -= (SPLITSIZE-osize);
+	where = (void *)((char *)where + SPLITSIZE-osize);
+	new_file();
+    }
+    write(ofile,where,len);
+    osize += len;
+}
+
+void
+new_file(){
+    if(ofile)close(ofile);
+    ofile=open(ssubst(buf,oprot),O_WRONLY|O_CREAT|O_TRUNC);
+    if(ofile<0)panic("can't open output file");
+    wsf_count++,datacount++,codecount++;
+    osize=0;
+}
+#endif /* SOUT */
+
+/*
+ * list functions with error checking
+ */
+struct Node *Head(l)
+    struct List *l;
+{
+    if(!l)panic("Head(NULL)\n");
+    return l->lh_Head->ln_Succ?l->lh_Head:0;
+}
+struct Node *Tail(l)
+    struct List *l;
+{
+    if(!l)panic("Tail(NULL)\n");
+    return (l->lh_TailPred==(NODE_P)l)?0:l->lh_TailPred;
+}
+struct Node *Next(n)
+    struct Node *n;
+{
+    if(!n)printf("Warning: Next(NULL)\n");
+    return n?(n->ln_Succ->ln_Succ?n->ln_Succ:0):0;
+}
+struct Node *Prev(n)
+    struct Node *n;
+{
+    if(!n)printf("Warning: Prev(NULL)\n");
+    return n?(n->ln_Pred->ln_Pred?n->ln_Pred:0):0;
+}
+
+struct List *_fortemp;	/* scratch for foreach macro */
+
+#if 0
+/* debugging routines - enable if needed */
+void
+dump_after_read(struct List *root){
+    file *f;
+    foreach(f,root,(file *)){
+        punit *p;
+        printf("FILE '%s'\n",f->name);
+        foreach(p,&(f->punits),(punit *)){
+	    hunk *h;
+	    print_text_block("\tPUNIT %.*s\n",p->unit_header);
+	    if(p->libsize){
+		printf("\tlibsize=%08x\n",p->libsize);
+	    } else {
+		/* */
+	    }
+	    foreach(h,&(p->hunks),(hunk *)){
+		print_text_block("\t\tHUNK %.*s",h->name);
+		printf(" @%08x\n",h);
+		print_bin_block(h->rb);
+		printf("\t\t\tCode Reloc\n");
+		printf("\t\t\tData Reloc\n");
+		if(h->merge)printf("\t\t\tmerge(%08x)\n",h->merge);
+		if(h->hunkstart)printf("\t\t\thunkstart\n");
+		if(h->hunkchain)printf("\t\t\thunkchain\n");
+		if(h->hunkgone)printf("\t\t\thunkgone\n");
+		printf("\t\t\toverlay(%08x) hunknum(%08x) offset(%08x)\n",
+		  h->overlay,h->hunknum,h->hunkoffset);
+	    }
+        }
+    }
+}
+
+void
+print_text_block(char *fmt,block *b){
+    if(!b){
+	printf(fmt,10,"(no block)");
+    } else {
+	if(b->sw){
+	    printf(fmt,13,"(swapped out)");
+	} else {
+	    if(!(b->b[1]) || !*(char*)&(b->b[2])){
+		printf(fmt,6,"(null)");
+	    } else {
+		printf(fmt,b->b[1]*4,&(b->b[2]));
+	    }
+	}
+    }
+}
+
+void
+print_bin_block(block *b){
+    if(b->sw){
+	printf("\t\t\t(swapped out)\n");
+    } else {
+	printf("\t\t\tid1=%08x id2=%08x len=%08x\n", b->id,b->b[0],b->b[1]);
+    }
+}
+#endif
+
+/*
+ * read routines
+ */
+
+/*
+ * ReadSimpleBlock
+ * If the given id is recognized as a simple block (id, length, data),
+ * allocate and fill in a block structure.  Include the id in the block.
+ */
+block *ReadSimpleBlock(f,id)
+    file *f;
+    long id;
+{
+    long len;
+    long hid;
+    block *b;
+
+    hid=id & 0x0fffffff;
+    if(	hid !=HUNK_UNIT && hid != HUNK_NAME && hid != HUNK_CODE &&
+    	hid != HUNK_DATA && hid != HUNK_BSS && hid != HUNK_DEBUG
+      ){
+	printf("%08x\n",id);
+	panic("ReadSImpleBlock");
+    }
+
+    len=READLONG(EOF_BAD);
+    b=NewBlock();
+    b->id=id;
+    b->sw=0;
+    b->b=NewData((hid==HUNK_BSS)?2:len+2);
+    b->b[0]=id;
+    b->b[1]=len;
+    if(hid != HUNK_BSS)read(f->fd,&(b->b[2]),len*4);
+    return(b);
+}
+
+/*
+ * TossSimpleBlock
+ * Skip past something we don't need.
+ */
+int TossSimpleBlock(f)
+    file *f;
+{
+    long len=READLONG(EOF_BAD);
+
+    if(len)if( lseek(f->fd,len*4,1) == -1)panic("Toss failed\n");
+    return(len);
+}
+
+/*
+ * ReadHunk
+ * Read an entire hunk, building lists of each block type in the given hunk
+ * structure.  If we are listing, do the listing as we read so we can see
+ * where things die if we hit a type code we don't recognize.
+ */
+hunk *ReadHunk(f)
+    file *f;
+{
+    long id;
+    hunk *h=NewHunk();
+
+    while(1){
+	id=READLONG(EOF_OK);
+	switch(id & 0x0fffffff){	/* ignore memory type bits */
+	case 0: return 0;		/* EOF - not good test */
+	case HUNK_RELOC32:
+	    LIST{printf("Reloc32:\n");}
+	    ReadReloc(f,id,&h->reloc);break;
+	case HUNK_CODE:
+	    h->rb=ReadSimpleBlock(f,id);
+	    LIST{printf("Code size %d\n",block_size(h->rb)*4);};
+	    break;
+	case HUNK_DATA:
+	    h->rb=ReadSimpleBlock(f,id);
+	    LIST{printf("Data size %d\n",block_size(h->rb)*4);};
+	    break;
+	case HUNK_BSS:
+	    h->rb=ReadSimpleBlock(f,id);
+	    LIST{printf("Bss size %d\n",block_size(h->rb)*4);};
+	    break;
+	case HUNK_SYMBOL:
+	    while(TossSimpleBlock(f))READLONG(EOF_BAD);
+	    LIST{printf("Symbols skipped\n");};
+	    break;
+	case HUNK_DEBUG:
+	    (void)TossSimpleBlock(f);
+	    LIST{printf("Debug hunk skipped\n");};
+	    break;
+	case HUNK_END:	LIST{printf("End of hunk\n");};return h;
+	case HUNK_BREAK:LIST{printf("End of overlay\n");};break;
+	default:
+			printf("Lost id=0x%x\n",id);exit(2);
+	}
+    }
+    return 0;
+}
+
+/*
+ * ReadReloc
+ * Read a relocation block and build a linked list of the sections.
+ * If we are listing, do that now.
+ */
+void ReadReloc(f,id,ls)
+    file *f;
+    long id;
+    struct List *ls;
+{
+    long len;
+    block *cur;
+    listlist *blist=NewListList();
+
+    AddTail(ls, (struct Node *)blist);
+    blist->id=id;
+    len=READLONG(EOF_BAD);
+    while(len){
+	cur=NewBlock();
+	cur->b=NewData(len+2);
+	read(f->fd,&(cur->b[1]),len*4+4);
+	cur->b[0]=len;
+	LIST{printf("\thunk #%d - %d items\n",cur->b[1],len);}
+	AddTail(&blist->list, (struct Node *)cur);
+	len=READLONG(EOF_BAD);
+    }
+}
+
+int rderror(){
+    panic("read error\n");
+    return 0;	/* just to make it quiet - NOTREACHED */
+}
+
+long block_size(blk)
+    block *blk;
+{
+    return(blk->b[1]);
+}
+
+/* Allocation routines - if this was C++ then this code would be buried in the
+ * constructors.  Doing it this way means we can re-write the allocation later
+ * to allocate things we'll need lots of in larger blocks to avoid the time and
+ * space penalties of malloc. */
+file *NewFile(fname)
+    char *fname;
+    {
+    file *ret=calloc(sizeof(file),1);
+
+    NewList(&ret->punits);
+    ret->name=strdup(fname);
+    ret->fd= open(fname,O_RDONLY);
+    return(ret);
+}
+
+punit *NewPunit(){
+	punit *ret=calloc(sizeof(punit),1);
+	NewList(&ret->hunks);
+	return(ret);
+}
+
+hunk *NewHunk(){
+    hunk *ret=calloc(sizeof(hunk),1);
+
+    NewList(&ret->reloc);
+    NewList(&ret->dreloc);
+    NewList(&ret->extsym);
+    ret->overlay=UNASSIGNED_HUNK;
+    return(ret);
+}
+
+block *NewBlock(){
+    return calloc(sizeof(block),1);
+}
+
+listlist *NewListList(){
+    listlist *ret=calloc(sizeof(listlist),1);
+
+    NewList(&ret->list);
+    return(ret);
+}
+
+long *NewData(longs)
+    long longs;	
+    {
+    return(malloc(longs*4));
+}
+
+/* filename cleanup */
+char *
+stripname(p)
+    char *p;
+    {
+    char *n;
+
+    while(n=strchr(p,':')){
+	p=n+1;
+    }
+    while(n=strchr(p,'/')){
+	p=n+1;
+    }
+
+    return p;
+}
diff -Pru nethack-3.4.1/sys/amiga/string.uu nethack/sys/amiga/string.uu
--- nethack-3.4.1/sys/amiga/string.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/string.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,18 @@
+begin 777 string.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "K     E  8#_    
+M 0     !      ES=')I;F<N8P           0 "$ X   )   4 !?____\ 
+M                                 @?&A*@       $   $ .0!  @X 
+M'P %  7_____     0 'T\6X $T #P&V  H   (#  0'T\,\            
+M    !]/#:   !]/#F/____\#   %!]/#3            ;<   &W  L    +
+M              !D " @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
+M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(#@     
+M>*H *>)     0@ IXM@ U  / !@      0H   (!!\;/$ ?&S\ 'QL_0!\;0
+M< ?&T( 'R+NP    "E-T<E-T<FEN9P     !      $      RTQ      $ 
+M     0        D #P X  H    #  $'T\7D      ?)]O              
+M!]/&$/____\#   %!]/%]            #D    Y  L    +           #
+M      0  0     'R-L           =#86YC96P     "@    $'R-U !\C?
+M& ?)^T@'R?XP!\MRT ?-!:@    !      $      0     ",0     !    
+#  $ 
+ 
+end
diff -Pru nethack-3.4.1/sys/amiga/wb.c nethack/sys/amiga/wb.c
--- nethack-3.4.1/sys/amiga/wb.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wb.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,3956 @@
+/*    SCCS Id: @(#)wb.c     2.1   93/01/08			  */
+/*    Copyright (c) Kenneth Lorber, Bethesda Maryland, 1991	  */
+/*    Copyright (c) Gregg Wonderly, Naperville IL, 1992, 1993	  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/* Friendly Intuition interface for NetHack 3.1 on the Amiga */
+
+#ifdef AZTEC_C
+/* Aztec doesn't recognize __chip syntax */
+# define __chip
+#endif
+
+
+#include "patchlevel.h"
+
+#include "NH:sys/amiga/wbdefs.h"		/* Miscellany information */
+#ifdef  INTUI_NEW_LOOK
+#define NewWindow   ExtNewWindow
+#define NewScreen   ExtNewScreen
+#endif
+#include "NH:sys/amiga/wbstruct.h"
+#include "NH:sys/amiga/wbprotos.h"
+
+#include "NH:sys/amiga/wbdata.c"		/* All structures and global data */
+#include "NH:sys/amiga/wbwin.c"		/* Has static definitions */
+
+#define	OPTION_LISTS_ONLY
+#include <time.h>
+#include "hack.h"
+#undef exit
+#include "NH:src/options.c"
+
+#include "NH:sys/amiga/wbgads.c"
+
+#ifdef _DCC
+/* DICE doesn't have a putenv() */
+void putenv(varstr)
+char *varstr;
+{
+	FILE *f;
+	char var[64],str[256];
+	int i,j;
+
+	for(i = 0; varstr[i] != '='; i++);
+	for(j = i - 1; varstr[j] == ' '; j--);
+	strncpy(var, varstr, j+1); var[j+1] = 0;
+	while(varstr[++i] == ' ');
+	varstr += i;
+	i = 0;
+	if(*varstr == '"') {
+		while(varstr[++i] != '"');
+		strncpy(str, varstr+1, i-1); str[i-1] = 0;
+	} else
+		strcpy(str, varstr);
+	setenv(var, str);
+}
+#endif
+
+#define C_GREY  0
+#define C_BLACK 1
+#define C_WHITE 2
+#define C_BLUE  3
+
+#if !defined(__SASC_60) && !defined(_DCC)
+extern char *sys_errlist[];
+#endif
+extern int errno;
+
+#ifdef	static
+static can not be redefined for this file to compile correctly
+#endif
+
+char pubscreen[ 80 ] = { "HackWB" };
+
+#ifdef  INTUI_NEW_LOOK
+int scrlocked = 0;
+UWORD scrnpens[] = {
+	0,
+	1,
+	2,
+	2,
+	1,
+	3,
+	2,
+	0,
+	3,
+};
+
+struct TagItem scrntags[] =
+{
+    (Tag)SA_Pens, (ULONG)scrnpens,
+    TAG_DONE, 0,
+    TAG_DONE, 0,
+    TAG_DONE, 0,
+    TAG_DONE, 0,
+    TAG_DONE, 0,
+    TAG_DONE, 0,
+    TAG_DONE, 0,
+};
+#endif
+
+char scrntitle[ 90 ];
+
+#define SPLIT			/* use splitter, if available */
+#ifdef SPLIT
+int running_split=0;		/* if 0, using normal LoadSeg/UnLoadSeg */
+#endif
+
+#ifdef AZTEC_C
+extern char *strdup(char *);
+#endif
+
+#ifndef max
+# define max(a, b) ((a) > (b) ? (a) : (b))
+#endif
+#ifndef min
+# define min(x,y) ((x) < (y) ? (x) : (y))
+#endif
+
+void diskobj_filter(struct DiskObject *);
+static void UpdateInfoWin( struct Window *cwin );
+BPTR s_LoadSeg(char *);
+void s_UnLoadSeg(void);
+
+#ifdef _DCC
+/* Provide DICE with the wbmain() entry point it wants. */
+wbmain(struct WBStartup *WBMsg)
+{
+	main(0, (char **)WBMsg);
+}
+#endif
+
+main( argc, argv )
+    int argc;
+    char **argv;
+{
+    long mask, rmask;
+    struct WBStartup *wbs;
+    struct WBArg *wba;
+    GPTR gptr;
+    struct IntuiMessage *imsg;
+    struct IntuiMessage mimsg;
+    int i;
+
+    /* Initialize and load libraries. */
+    InitWB( argc, (struct WBStartup *)argv );
+
+    /* open window, build menus */
+    SetupWB( );
+
+    /* Initialize the bool and comp option values */
+    ZapOptions();
+
+    errmsg( NO_FLASH, "Welcome to NetHack Version %d.%d.%d!",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
+
+    CopyRight( );
+
+    ReadConfig( );
+
+    /* Initially, no game selected so disable menu items */
+
+    ChgGameItems( &MenuList1, 0 );
+
+    MapGadgets( R_DISK, 1 ); /* Display the icons */
+
+    /* Wait till user quits */
+
+    while( !quit )
+    {
+	/* Wait for a message */
+
+	mask = ( 1L << dosport->mp_SigBit ) ;
+	if( wbopen )
+	    mask |= ( 1L << win->UserPort->mp_SigBit );
+
+	rmask = Wait( mask );
+
+	/* Process the messages on the port unless the workbench is
+	 * shutdown by a request to play a game.
+	 */
+
+	while( wbopen && ( imsg = ( struct IntuiMessage * )
+	    GetMsg( win->UserPort ) ) )
+	{
+	    /* Copy the message.  This does not guarantee that all
+	     * fields will still be valid, but appears to work
+	     * here.  Note that we have to reply to the message
+	     * before the workbench window is closed.
+	     */
+
+	    mimsg = *imsg;
+	    ReplyMsg( (struct Message *)imsg );
+
+	    switch( mimsg.Class )
+	    {
+	    case NEWSIZE:
+		((struct Border *) Message.GadgetRender)->XY[2] =
+		    win->Width - win->BorderLeft -
+		    win->BorderRight - 1;
+		RefreshGList( &Message, win, NULL, 1 );
+		MapGadgets( R_SCROLL, 1 ); /* redisplay the icons */
+#ifdef  INTUI_NEW_LOOK
+		if( IntuitionBase->LibNode.lib_Version >= 37 )
+		    RefreshWindowFrame( win );
+#endif
+		break;
+
+	    case MENUPICK:
+		if( errup > 0 )
+		{
+		    errmsg( NO_FLASH, "" );
+		    errup = -1;
+		}
+		do_menu( &MenuList1, mimsg.Code );
+		flushIDCMP( win->UserPort );
+		break;
+
+	    case RAWKEY:
+		if( mimsg.Code == 0x5f )
+		{
+		    if( errup > 0 )
+		    {
+			errmsg( NO_FLASH, "" );
+			errup = -1;
+		    }
+
+		    /* Pick the correct help message */
+
+		    SetPointer( win, waitPointer, 16, 16, -6, 0 );
+		    if( lastgaddown == NULL )
+		    {
+			text_requester( &Help1_NewWindowStructure7,
+			    &Help1_IntuiTextList7 );
+		    }
+		    else
+		    {
+			text_requester( &Help2_NewWindowStructure8,
+			    &Help2_IntuiTextList8 );
+		    }
+		    ClearPointer( win );
+		}
+		flushIDCMP( win->UserPort );
+		break;
+
+	    case CLOSEWINDOW:
+		SetPointer( win, waitPointer, 16, 16, -6, 0 );
+		if( Ask( "Ready to Quit?" ) )
+		    do_closewindow( );
+		ClearPointer( win );
+		break;
+
+	    case GADGETDOWN:
+		if( errup > 0 )
+		{
+		    errmsg( NO_FLASH, "" );
+		    errup = -1;
+		}
+		do_gadgetdown( &mimsg );
+		break;
+
+	    case GADGETUP:
+		do_gadgetup( &mimsg );
+		break;
+
+	    case DISKINSERTED:
+		if( errup > 0 )
+		{
+		    errmsg( NO_FLASH, "" );
+		    errup = -1;
+		}
+		MapGadgets( R_DISK, 1 );
+		break;
+
+	    case MOUSEBUTTONS:
+		if( errup > 0 )
+		{
+		    errmsg( NO_FLASH, "" );
+		    errup = -1;
+		}
+		do_buttons( &mimsg );
+		flushIDCMP( win->UserPort );
+		break;
+	    }
+	}
+	if( errup == -1 )
+	    errup = 0;
+
+	if( rmask & ( 1L << dosport->mp_SigBit ) )
+	{
+	    /* Get process termination messages */
+
+	    while( wbs = (struct WBStartup *) GetMsg( dosport ) )
+	    {
+		/* Find the game that has terminated */
+
+		for( gptr = gamehead; gptr && gptr->seglist != wbs->sm_Segment;)
+		    gptr = gptr->next;
+
+		/* Make sure it is there */
+
+		if( gptr )
+		{
+#ifdef SPLIT
+		    if(!running_split)
+#endif
+		    {
+			/* Unload the code */
+			UnLoadSeg( wbs->sm_Segment );
+		    }
+
+		    /* Free the startup message resources */
+		    wba = (struct WBArg *)
+			((long)wbs + sizeof( struct WBStartup ));
+		    for( i = 0; i < wbs->sm_NumArgs; ++i )
+		    {
+			FreeMem( wba[i].wa_Name,
+			    strlen( wba[i].wa_Name ) + 1 );
+			UnLock( wba[i].wa_Lock );
+		    }
+		    FreeMem( wbs, wbs->sm_Message.mn_Length );
+		    wbs = NULL;
+
+		    /* Say the game has completed */
+
+		    gptr->prc = NULL;
+		    gptr->active = 0;
+		    active_count--;
+		}
+		else
+		{
+		    errmsg( FLASH, "Game termination detected, but game not found" );
+		}
+	    }
+
+	    /* If the workbench was closed, open it back up */
+
+	    if( !wbopen )
+		SetupWB( );
+
+	    /* Reload to clear any deleted games */
+
+	    MapGadgets( R_DISK, 1 );
+	}
+    }
+    cleanup( 0 );
+}
+
+void
+flushIDCMP( port )
+	struct MsgPort *port;
+{
+	struct Message *msg;
+
+	while( msg = GetMsg( port ) )
+		ReplyMsg( msg );
+
+	SetSignal( 0L, ( 1L << port->mp_SigBit ) );
+}
+
+void CopyRight( )
+{
+    extern char *copyright_text[];
+    int line;
+
+    SetDrMd( win->RPort, JAM2 );
+    SetAPen( win->RPort, C_WHITE );
+    SetBPen( win->RPort, C_GREY );
+
+    for(line=0;copyright_text[line];line++){
+	Move( win->RPort, ORIGINX+3, ORIGINY + win->RPort->TxBaseline +
+		(line*win->RPort->TxHeight));
+	if(copyright_text[line][0])
+	     RPText( win->RPort, copyright_text[line]);
+    }
+
+    Delay( 150 );
+    ClearWindow( win );
+}
+
+/*
+ * Do the one time initialization things.
+ */
+
+void
+InitWB( argc, wbs )
+    int argc;
+    register struct WBStartup *wbs;
+{
+    register int c, i, j;
+    BPTR odir;
+    char *s, **tools, **argv;
+    register struct DiskObject *dobj;
+    register struct WBArg *wba;
+
+    /* Open Libraries */
+    GfxBase= (struct GfxBase *) OldOpenLibrary("graphics.library");
+    IconBase= OldOpenLibrary("icon.library");
+    DiskfontBase= (struct DiskfontBase *)OldOpenLibrary("diskfont.library");
+    IntuitionBase= (struct IntuitionBase *)OldOpenLibrary("intuition.library");
+
+    if(!GfxBase || !IconBase || !DiskfontBase || !IntuitionBase)
+    {
+	error("library open failed");
+	cleanup( 1 );
+    }
+
+    /* Get Port for replied WBStartup messages */
+
+    if( ( dosport = CreatePort( NULL, 0 ) ) == NULL )
+    {
+	error("failed to create dosport" );
+	cleanup( 1 );
+    }
+
+    /* If started from CLI */
+    if( argc != 0 )
+    {
+	argv = (char **)wbs;
+	for( i = 1; i < argc; ++i )
+	{
+	    if( argv[i][0] == '?' )goto usage;
+	    if( argv[i][0] != '-' )
+		break;
+	    for( j = 1; c = argv[i][j]; ++j )
+	    {
+		switch( c )
+		{
+		case 'm':   /* Close screen and window during game to
+			     * save memory  */
+		    shutdown++;
+		    break;
+
+		case 'c':       /* Configuration to load */
+		    if( i + 1 < argc && argv[i][j+1] == 0 )
+		    {
+			strcpy( StrConf, argv[ ++i ] );
+			goto nextargv;
+		    }
+		    else
+		    {
+			fprintf( stderr,
+			    "%s: missing config name after -c\n",
+			    argv[ 0 ] );
+			cleanup( 1 );
+		    }
+		    break;
+
+		case 'N':       /* Public screen name */
+		    if( i + 1 < argc && argv[i][j+1] == 0 )
+		    {
+			strcpy( pubscreen, argv[ ++i ] );
+			goto nextargv;
+		    }
+		    else
+		    {
+			fprintf( stderr,
+			    "%s: missing screen name after -N\n",
+			    argv[ 0 ] );
+			cleanup( 1 );
+		    }
+		    break;
+
+		default:
+		    fprintf( stderr, "%s: invalid option %c\n",
+			argv[0], c );
+usage:
+		    fprintf( stderr,
+"usage: %s [-m] [-f .def filename] [-c config filename] [ -N screen]\n",
+			argv[ 0 ] );
+		    cleanup( 1 );
+		}
+	    }
+nextargv:;
+	}
+    }
+    else
+    {
+	/* Process icon's ToolTypes */
+
+	wba = wbs->sm_ArgList;
+	odir = CurrentDir( wba->wa_Lock );
+	if( dobj = GetDiskObject( wba->wa_Name ) )
+	{
+	    tools = (char **) dobj->do_ToolTypes;
+
+	    if( s = FindToolType( tools, "OPTIONS" ) )
+	    {
+		/* OPTIONS=SHUTDOWN will cause the screen to be closed
+		 * when a game is started
+		 */
+		if( MatchToolValue( s, "SHUTDOWN" ) )
+		    ++shutdown;
+	    }
+
+	    /* A different configuration file name */
+
+	    if( s = FindToolType( tools, "CONFIG" ) )
+	    {
+		strcpy( StrConf, s );
+	    }
+
+	    /* A Public screen to open onto */
+
+	    if( s = FindToolType( tools, "SCREEN" ) )
+	    {
+		strcpy( pubscreen, s );
+	    }
+
+	    FreeDiskObject( dobj );
+	}
+	if( odir )
+	    CurrentDir( odir );
+    }
+}
+
+/*
+ * Read a nethack.cnf like file and collect the configuration
+ * information from it.
+ */
+void ReadConfig()
+{
+    register FILE *fp;
+    register char *buf, *t;
+
+    /* Use a dynamic buffer to limit stack use */
+
+    if( ( buf = xmalloc( 1024 ) ) == NULL )
+    {
+	error( "Can't alloc space to read config file" );
+	cleanup( 1 );
+    }
+
+    /* If the file is not there, can't load it */
+
+    if( ( fp = fopen( StrConf, "r" ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't load config file %s", StrConf );
+	free( buf );
+	return;
+    }
+
+    /* Read the lines... */
+
+    while( fgets( buf, 1024, fp ) != NULL )
+    {
+	if( *buf == '#' )
+	    continue;
+
+	if( ( t = strchr( buf, '\n' ) ) != NULL )
+	    *t = 0;
+
+	if( strnicmp( buf, "PATH=", 5 ) == 0 )
+	{
+	    setoneopt( PATH_IDX, buf + 5 );
+	}
+	else if( strnicmp( buf, "PENS=", 4 ) == 0 )
+	{
+	    setoneopt( PENS_IDX, buf + 5 );
+	}
+	else if( strnicmp( buf, "OPTIONS=", 8 ) == 0 )
+	{
+	    setoneopt( OPTIONS_IDX, buf + 8 );
+	    ParseOptionStr( buf + 8 );
+	}
+	else if( strnicmp( buf, "HACKDIR=", 8 ) == 0 )
+	{
+	    setoneopt( HACKDIR_IDX, buf + 8 );
+	}
+	else if( strnicmp( buf, "LEVELS=", 7 ) == 0 )
+	{
+	    setoneopt( LEVELS_IDX, buf + 7 );
+	}
+	else if( strnicmp( buf, "SAVE=", 5 ) == 0 )
+	{
+	    setoneopt( SAVE_IDX, buf + 5 );
+	}
+	else
+	{
+	    /* We don't allow manipulation of the other information */
+	}
+    }
+    fclose( fp );
+    free( buf );
+}
+
+/*
+ * Read a nethack.cnf like file and process the OPTIONS
+ * information from it.
+ */
+void ReadCfgOptions( void )
+{
+    register FILE *fp;
+    register char *buf, *t;
+
+    /* Use a dynamic buffer to limit stack use */
+
+    if( ( buf = xmalloc( 1024 ) ) == NULL )
+    {
+	error( "Can't alloc space to read config file" );
+	cleanup( 1 );
+    }
+
+    /* If the file is not there, can't load it */
+
+    if( ( fp = fopen( StrConf, "r" ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't load config file %s", StrConf );
+	free( buf );
+	return;
+    }
+
+    /* Read the lines... */
+
+    while( fgets( buf, 1024, fp ) != NULL )
+    {
+	if( *buf == '#' )
+	    continue;
+
+	if( ( t = strchr( buf, '\n' ) ) != NULL )
+	    *t = 0;
+
+	/* Set options based on parsing them. */
+	if( strnicmp( buf, "OPTIONS=", 8 ) == 0 )
+	    ParseOptionStr( buf + 8 );
+    }
+    fclose( fp );
+    free( buf );
+}
+
+/* Close the workbench screen and window */
+
+void CloseDownWB( )
+{
+    ((struct Process *)FindTask( NULL ))->pr_WindowPtr = (APTR)oldwin;
+
+    if( win && win->RPort->TmpRas )
+    {
+	FreeRaster( tmprasp, width, height );
+    }
+
+    if( win )
+	SafeCloseWindow( win );
+
+#ifdef  INTUI_NEW_LOOK
+    if( IntuitionBase->LibNode.lib_Version >= 37 )
+    {
+	while( !scrlocked && CloseScreen( scrn ) == FALSE )
+	{
+	    Ask("Close all vistor Windows to exit" );
+	}
+    }
+    else
+#endif
+    {
+	CloseScreen( scrn );
+    }
+    wbopen = 0;
+}
+
+/* Open the workbench screen and window. */
+
+char mytitle[ 90 ];
+void SetupWB( )
+{
+    int cpyrwid, i;
+    int txtdiff;
+#ifdef  INTUI_NEW_LOOK
+    int pubopen = 0;
+#endif
+    static int once = 0;
+
+    scrlocked = 0;
+#ifdef  INTUI_NEW_LOOK
+    NewScreenStructure.Extension = scrntags;
+    NewScreenStructure.Type |= NS_EXTENDED;
+#endif
+
+    NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
+    NewScreenStructure.Height = GfxBase->NormalDisplayRows;
+
+    {
+    sprintf(scrntitle,"WorkBench for V%d.%d.%d of NetHack",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
+    NewScreenStructure.DefaultTitle = scrntitle;
+    }
+
+#ifdef  INTUI_NEW_LOOK
+    if( IntuitionBase->LibNode.lib_Version < 37 )
+    {
+#endif
+	if( ( scrn = OpenScreen( (void *)
+		&NewScreenStructure ) ) == NULL )
+	{
+	    error( "Can't create screen" );
+	    cleanup( 1 );
+	}
+
+	/* Only set the pens on the screen we open */
+	LoadRGB4( &scrn->ViewPort, Palette, PaletteColorCount );
+#ifdef  INTUI_NEW_LOOK
+    }
+    else
+    {
+    	struct DimensionInfo dims;
+    	ULONG modeid;
+    	DisplayInfoHandle handle;
+    	struct DisplayInfo disp;
+
+	/* No tags beyond here yet */
+	scrntags[1].ti_Tag = TAG_DONE;
+
+	if( *pubscreen != 0 )
+	{
+	    if( ( scrn = LockPubScreen( pubscreen ) ) == 0 )
+	    {
+		/* Now add our pub screen name */
+		scrntags[1].ti_Tag = SA_PubName;
+		scrntags[1].ti_Data = (ULONG) pubscreen;
+		scrntags[2].ti_Tag = TAG_DONE;
+
+		/* Get the default pub screen's size */
+		scrn = LockPubScreen( NULL );
+		modeid = GetVPModeID( &scrn->ViewPort );
+		if( modeid == INVALID_ID ||
+		    ModeNotAvailable( modeid ) ||
+		    ( handle = FindDisplayInfo( modeid ) ) == NULL ||
+		    GetDisplayInfoData( handle, (char *)&dims, sizeof( dims ),
+			DTAG_DIMS, modeid ) <= 0 ||
+		    GetDisplayInfoData( handle, (char *)&disp, sizeof( disp ),
+			DTAG_DISP, modeid ) <= 0 )
+		{
+		    /* If the display database seems to not work, use the screen
+		     * dimensions
+		     */
+		    NewScreenStructure.Height = scrn->Height;
+		    NewScreenStructure.Width = scrn->Width;
+		
+		    /*
+		     * Request LACE if it looks laced.  For 2.1/3.0, we will get
+		     * promoted to the users choice of modes (if promotion is allowed)
+		     * If the user is using a dragable screen, things will get hosed
+		     * but that is life...
+		     */
+		    if( NewScreenStructure.Height > 300 )
+			    NewScreenStructure.ViewModes |= LACE;
+		}
+		else
+		{
+		    /* Use the display database to get the correct information */
+		    if( disp.PropertyFlags & DIPF_IS_LACE )
+			NewScreenStructure.ViewModes |= LACE;
+		    NewScreenStructure.Height = dims.StdOScan.MaxY;
+		    NewScreenStructure.Width = dims.StdOScan.MaxX;
+		    scrntags[2].ti_Tag = SA_DisplayID;
+		    scrntags[2].ti_Data = modeid;
+		    scrntags[3].ti_Tag = TAG_DONE;
+		}
+		UnlockPubScreen( NULL, scrn );
+
+		if( ( scrn = OpenScreen( (void *)
+		    &NewScreenStructure ) ) == NULL )
+		{
+		    NewScreenStructure.Height = GfxBase->NormalDisplayRows;
+		    NewScreenStructure.Width = GfxBase->NormalDisplayColumns;
+		    if( ( scrn = OpenScreen( (void *)
+			&NewScreenStructure ) ) == NULL )
+		    {
+			error( "Can't create screen" );
+			cleanup( 1 );
+		    }
+		}
+
+		/* Only set the pens on the screen we open */
+		LoadRGB4( &scrn->ViewPort, Palette, PaletteColorCount );
+
+		pubopen = 1;
+		scrlocked = 0;
+	    }
+	    else
+	    {
+		pubopen = 0;
+		scrlocked = 1;
+	    }
+	}
+	else
+	{
+	    if( ( scrn = LockPubScreen( NULL ) ) == 0 )
+	    {
+		error( "Can't lock Workbench screen" );
+		cleanup( 1 );
+	    }
+	    scrlocked = 1;
+	}
+    }
+#endif
+
+    cpyrwid = 0;
+    for( i = 0; copyright_text[i]; ++i )
+	{
+		int len = strlen( copyright_text[i] );
+		cpyrwid = max(cpyrwid, len );
+	}
+
+    /* 28 is magic for the width of the sizing gadget under 2.04 and
+     * later.
+     */
+    NewWindowStructure1.Width = (cpyrwid * scrn->RastPort.TxWidth) +
+	    scrn->WBorLeft + scrn->WBorRight + 28;
+
+    width = NewWindowStructure1.Width;
+
+    if( NewWindowStructure1.LeftEdge + width > scrn->Width )
+    {
+	if( width > scrn->Width )
+	{
+	    NewWindowStructure1.LeftEdge = 0;
+	    NewWindowStructure1.Width = scrn->Width;
+	}
+	else
+	{
+	    NewWindowStructure1.LeftEdge = (scrn->Width - width)/2;
+	}
+    }
+    height = NewWindowStructure1.Height;
+    NewWindowStructure1.Screen = scrn;
+
+    txtdiff = scrn->RastPort.TxHeight - 8;
+
+    if( scrlocked )
+	sprintf( mytitle, "NetHack WB %d.%d.%d - Select a GAME or press HELP",
+	  VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
+
+    else
+	strcpy( mytitle, "Select a GAME or press HELP" );
+
+    NewWindowStructure1.Title = mytitle;
+#ifdef  INTUI_NEW_LOOK
+    if( IntuitionBase->LibNode.lib_Version >= 37 )
+	((struct PropInfo *)Scroll.SpecialInfo)->Flags |= PROPNEWLOOK;
+#endif
+
+    if( !once )
+    {
+	((struct Border *) Message.GadgetRender)->XY[2] =
+		NewWindowStructure1.Width +
+		Message.Width - Message.LeftEdge;
+	Message.TopEdge = scrn->RastPort.TxHeight + scrn->WBorTop + 1;
+	Message.Height = scrn->RastPort.TxHeight + 3;
+	    ((struct Border *) Message.GadgetRender)->XY[1] =
+	    (((struct Border *) Message.GadgetRender)->XY[3] +=
+		scrn->RastPort.TxHeight - 6 );
+    }
+
+    if( ( win = MyOpenWindow( &NewWindowStructure1 ) ) == NULL )
+    {
+#ifdef  INTUI_NEW_LOOK
+	if( IntuitionBase->LibNode.lib_Version >= 37 )
+	{
+	    if( scrlocked )
+		UnlockPubScreen( NULL, scrn );
+	}
+#endif
+	error( "Can't create window" );
+	cleanup( 1 );
+    }
+#ifdef  INTUI_NEW_LOOK
+    if( IntuitionBase->LibNode.lib_Version >= 37 )
+    {
+	/* If we did not create this screen, unlock it.
+	 * otherwise, advertise it for other applications
+	 * to use.
+	 */
+	if( scrlocked )
+	    UnlockPubScreen( NULL, scrn );
+	else if( pubopen )
+	    PubScreenStatus( scrn, 0 );
+    }
+#endif
+
+    ((struct Border *) Message.GadgetRender)->XY[2] =
+	    win->Width - win->BorderLeft -
+		win->BorderRight - 1;
+
+    RefreshGList( &Message, win, NULL, 1 );
+#ifdef  INTUI_NEW_LOOK
+    if( IntuitionBase->LibNode.lib_Version >= 37 )
+	RefreshWindowFrame( win );
+#endif
+
+    oldwin = (struct Window *)((struct Process *)FindTask( NULL ))->pr_WindowPtr;
+    ((struct Process *)FindTask( NULL ))->pr_WindowPtr = (APTR)win;
+
+    if( ( tmprasp = (void *) AllocRaster( width, height ) ) == NULL )
+    {
+	win->RPort->TmpRas = NULL;
+	fprintf( stderr, "No Space for raster %d x %d\n", height, width );
+	cleanup( 1 );
+    }
+
+    InitTmpRas( &tmpras, tmprasp, RASSIZE( width, height ) );
+
+    win->RPort->TmpRas = &tmpras;
+
+    SetUpMenus( &MenuList1, scrn );
+    SetMenuStrip( win, &MenuList1 );
+    wbopen = 1;
+    once = 1;
+}
+
+/* Map the gadgets onto the screen at the correct location */
+
+void MapGadgets( reason, update )
+    int reason;
+    int update;
+{
+    GPTR gptr;
+
+    if( active_count != 0 )
+    {
+    	errmsg( FLASH, "Can't reload games while a game is running" );
+    	return;
+    }
+
+    /* Make sure that any down gadget is popped back up */
+
+    if( lastgaddown )
+	SetGadgetUP( &lastgaddown->dobj->do_Gadget );
+    lastgaddown = NULL;
+
+    /* Grey Menu Items, no Game icon will be selected */
+
+    ChgGameItems( &MenuList1, 0 );
+
+    /* Remove them first */
+
+    for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
+    {
+	RemoveGadget( win, &gptr->dobj->do_Gadget );
+    }
+    windowgads = NULL;
+
+    /* Remove any non-existant games */
+
+    ClearDelGames( );
+
+    /* If disk changed, reload existing icons */
+
+    if( reason == R_DISK )
+    {
+	LoadIcons( );
+    }
+
+    /* Always move back to home unless we were scrolling */
+
+    if( reason != R_SCROLL )
+    {
+	curcol = 0;
+    }
+
+    /* Calculate locations and display gadgets */
+
+    CalcLocs( update );
+}
+
+void ClearWindow( win )
+    struct Window *win;
+{
+    /* Clear the old gadgets from the window */
+
+    SetAPen( win->RPort, C_GREY );
+    SetOPen( win->RPort, C_GREY );
+    SetDrPt( win->RPort, 0xffff );
+    SetDrMd( win->RPort, JAM2 );
+
+    RectFill( win->RPort, ORIGINX, ORIGINY, CORNERX-1, CORNERY-1 );
+}
+
+/* Calculate the place for and attach the gadgets to the window */
+
+void
+CalcLocs( update )
+    int update;
+{
+    register GPTR gptr;
+    register USHORT ox, oy, cx, cy;
+    int gadid = GADNEWGAME;
+    int addx = 0, sizex, sizey;
+
+    cols = vcols = 0;
+    scol = -1;
+
+    /* Upper left corner of window */
+
+    ox = ORIGINX;
+    oy = ORIGINY;
+
+    /* Lower right corner of window */
+
+    cx = CORNERX;
+
+    /* Account for text labels at the bottom by pulling the bottom up. */
+    cy = CORNERY - win->RPort->TxHeight;
+
+    ClearWindow( win );
+
+    /* Map the current list */
+
+    for( gptr = gamehead; gptr; gptr = gptr->next )
+    {
+	/* If not to the horizontal offset yet, don't display */
+
+	sizex = GADWIDTH( &gptr->dobj->do_Gadget );
+	sizey = gptr->dobj->do_Gadget.Height;
+	addx = max( sizex, addx );
+
+	/* If the current column comes before the visible column... */
+	if( cols < curcol )
+	{
+	    oy += sizey + GADINCY + 3;
+	    if( gptr->next )
+	    {
+		if( oy + gptr->next->dobj->do_Gadget.Height + 3 >= cy )
+		{
+		    cols++;
+		    ox += addx + GADINCX;
+		    if( GADWIDTH( &gptr->next->dobj->do_Gadget ) >
+			gptr->next->dobj->do_Gadget.Width )
+		    {
+			ox += ( GADWIDTH( &gptr->next->dobj->do_Gadget ) -
+			gptr->next->dobj->do_Gadget.Width ) / 2 + 1;
+		    }
+		    oy = ORIGINY;
+		    addx = 0;
+		}
+	    }
+	    continue;
+	}
+
+	if( scol == -1 )
+	{
+	    ox = ORIGINX;
+	    scol = cols;
+	}
+
+	/* If visible, draw it */
+
+	if( ox + sizex + GADINCX < cx )
+	{
+	    /* Link to mapped gadgets list */
+
+	    gptr->nextwgad = windowgads;
+	    windowgads = gptr;
+
+	    /* Set screen locations, if text is longer, scoot the
+	     * gadget over to make room for it.
+	     */
+
+	    if( GADWIDTH( &gptr->dobj->do_Gadget ) >
+		    gptr->dobj->do_Gadget.Width )
+	    {
+		gptr->dobj->do_Gadget.LeftEdge = ox +
+		    ( GADWIDTH( &gptr->dobj->do_Gadget ) -
+			gptr->dobj->do_Gadget.Width ) / 2 + 1;
+	    }
+	    else
+		gptr->dobj->do_Gadget.LeftEdge = ox;
+	    addx = max( addx, GADWIDTH( &gptr->dobj->do_Gadget) );
+	    gptr->dobj->do_Gadget.TopEdge = oy;
+	    gptr->dobj->do_Gadget.GadgetID = gadid++;
+
+	    AddGadget( win, &gptr->dobj->do_Gadget, 0 );
+	}
+
+	/* Stack vertically first, then horizontally */
+
+	if( gptr->next )
+	{
+	    oy += sizey + GADINCY + 3;
+	    if( oy + gptr->next->dobj->do_Gadget.Height + 3 >= cy )
+	    {
+		ox += addx + GADINCX;
+		cols++;
+		if( ox + GADWIDTH( &gptr->next->dobj->do_Gadget) < cx )
+		    vcols++;
+		addx = 0;
+		oy = ORIGINY;
+	    }
+	}
+    }
+
+    /* Display all of the gadgets */
+
+    RefreshGList( win->FirstGadget, win, NULL, -1 );
+
+    /* Set up the slider if forcing a new position, otherwise
+     * the slider was probably moved and its position should be
+     * left where the user put it instead of jerking it around
+     */
+    if( update )
+	UpdatePropGad( win, &Scroll, vcols+1, cols+1, scol );
+}
+
+/* Open the indicated window and place the IntuiText list passed in that
+ * window.  Then wait for the OKAY gadget to be clicked on.
+ */
+void text_requester( newwin, tlist )
+    register struct NewWindow *newwin;
+    struct IntuiText *tlist;
+{
+    register struct Window *win;
+    register struct IntuiMessage *imsg;
+    register struct Gadget *gd;
+    int done = 0;
+    int i;
+    long class;
+    struct NewWindow **aonce;
+    static struct NewWindow *once[ 6+1 ];
+    int lines[ 10 ], lcnt = 0, avone = -1;
+    register int txtdiff = scrn->RastPort.TxHeight - 8;
+
+    newwin->Screen = scrn;
+
+    /* See if we have already configured this window for the current font */
+    for( i = 0; i < 6; ++i )
+    {
+	if( newwin == once[i] )
+	    break;
+	if( once[i] == 0 && avone == -1 )
+	    avone = i;
+    }
+    aonce = &once[avone];
+
+    /* If spacing not correct, fix it up now */
+    if( *aonce == NULL )
+    {
+	register struct IntuiText *ip = tlist;
+	for( ; ip; ip = ip->NextText )
+	{
+	    if( lcnt == 0 )
+		lines[ lcnt++ ] = ip->TopEdge;
+	    else
+	    {
+		register found = 0;
+		for( i = 0; i < lcnt; ++i )
+		{
+		    if( lines[ i ] > ip->TopEdge )
+			break;
+		    if( lines[ i ] == ip->TopEdge )
+		    {
+			found = 1;
+			break;
+		    }
+		}
+
+		if( !found )
+		{
+		    if( i < lcnt )
+		    {
+			int j;
+			for( j = lcnt; j > i; --j )
+			    lines[ j ] = lines[ j - 1 ];
+		    }
+		    lcnt++;
+		    lines[ i ] = ip->TopEdge;
+		}
+	    }
+	}
+
+	for( ip = tlist; ip; ip = ip->NextText )
+	{
+	    for( i = 0; i < lcnt; ++i )
+	    {
+		if( ip->TopEdge == lines[ i ] )
+		{
+		    ip->TopEdge += txtdiff*i;
+		    break;
+		}
+	    }
+	}
+
+	gd = FindGadget( NULL, newwin, GADHELPOKAY );
+	gd->TopEdge += (lcnt+1)*txtdiff;
+	gd->Height += txtdiff;
+	SetBorder( gd, -1 );
+	newwin->Height += txtdiff * (lcnt+2);
+	*aonce = newwin;
+    }
+
+    if( ( win = MyOpenWindow( newwin ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create window" );
+	return;
+    }
+
+    PrintIText( win->RPort, tlist, 0, txtdiff );
+
+    while( !done )
+    {
+	WaitPort( win->UserPort );
+	while( ( imsg = (struct IntuiMessage * )
+	    GetMsg( win->UserPort ) ) != NULL )
+	{
+	    class = imsg->Class;
+	    ReplyMsg( (struct Message *) imsg );
+	    switch( class )
+	    {
+		case CLOSEWINDOW: done = 1; break;
+		case VANILLAKEY: done = 1; break;
+		/* Should be GADHELPOKAY */
+		case GADGETUP: done = 1; break;
+	    }
+	}
+    }
+    SafeCloseWindow( win );
+}
+
+/* Scroll through a file which is passed by name */
+
+char title[90];
+void help_requester( file )
+    char *file;
+{
+    register struct Window *win;
+    register struct IntuiMessage *imsg;
+    register struct Gadget *gd;
+    FILE *fp;
+    int done = 0, line = 0, lines, topline, tlines, i;
+    static int once = 0, lastdown;
+    char buf[ 100 ];
+    long loff[ 100 ];
+    long class, code;
+    int txtdiff = scrn->RastPort.TxHeight - 8;
+
+    if( ( fp = fopen( file, "r" ) ) == NULL )
+    {
+#if defined(__SASC_60) || defined(_DCC)
+	errmsg( FLASH, "Can't open %s: %s", file, strerror(errno) );
+#else
+	errmsg( FLASH, "Can't open %s: %s", file, sys_errlist[errno] );
+#endif
+	return;
+    }
+    for( tlines = 0; tlines < 100 ; ++tlines )
+    {
+	loff[ tlines ] = ftell( fp );
+	if( fgets( buf, sizeof( buf ), fp ) == NULL )
+	    break;
+    }
+
+    if( !once )
+    {
+	for( gd = Help3_NewWindowStructure10.FirstGadget;
+		    gd; gd = gd->NextGadget )
+	{
+	    if( gd->GadgetID != 0 )
+	    {
+		if( gd->GadgetID == GADHELPFRWD ||
+		    gd->GadgetID == GADHELPBKWD )
+		{
+		    gd->Height += txtdiff;
+		}
+		SetBorder( gd, -1 );
+	    }
+	}
+	once = 1;
+	Help3_NewWindowStructure10.Height += txtdiff;
+    }
+
+    {
+    sprintf(title,"Help for NetHack WorkBench V%d.%d.%d",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
+    Help3_NewWindowStructure10.Title = title;
+    }
+
+    Help3_NewWindowStructure10.Screen = scrn;
+    if( ( win = MyOpenWindow( &Help3_NewWindowStructure10 ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create requester window" );
+	fclose( fp );
+	return;
+    }
+    lines = ( (win->Height - win->BorderTop - 25 ) / win->RPort->TxHeight );
+    topline = win->BorderTop + win->RPort->TxBaseline + 2;
+    Move( win->RPort, win->BorderLeft, topline );
+
+    SetAPen( win->RPort, C_BLACK );
+    SetBPen( win->RPort, C_GREY );
+    SetDrMd( win->RPort, JAM2 );
+
+    for( i = 0; i < min( lines, tlines ); ++i )
+    {
+	getline( fp, loff, i, buf, sizeof( buf ) );
+	Move( win->RPort, win->BorderLeft + 2,
+	    topline + (i * win->RPort->TxHeight) );
+	Text( win->RPort, buf, strlen( buf )-1 );
+    }
+
+    while( !done )
+    {
+	WaitPort( win->UserPort );
+	while( ( imsg = (void *) GetMsg( win->UserPort ) ) != NULL )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    gd = (struct Gadget *)imsg->IAddress;
+
+	    ReplyMsg( (struct Message *) imsg );
+
+	    switch( class )
+	    {
+		case VANILLAKEY:
+		    if( code == 'u' || code == ('U'-64))
+		    {
+			goto bkwd;
+		    }
+		    else if( code == 'd' || code == ('D'-64))
+		    {
+			goto frwd;
+		    }
+		    else if( code == '\33' || code == 'q' )
+		    {
+			done = 1;
+		    }
+		    break;
+
+		case CLOSEWINDOW:
+		    done = 1;
+		    break;
+
+		case MOUSEBUTTONS:
+		case INACTIVEWINDOW:
+		case ACTIVEWINDOW:
+		case GADGETUP:
+		    lastdown = 0;
+		    break;
+
+		case GADGETDOWN:
+		    lastdown = gd->GadgetID;
+		    break;
+
+		case INTUITICKS:
+		    if( lastdown == GADHELPFRWD )
+		    {
+			frwd:
+			if( line + lines < tlines )
+			{
+			    line++;
+			    WaitTOF();
+			    ScrollRaster( win->RPort, 0,
+				win->RPort->TxHeight,
+				win->BorderLeft,
+				win->BorderTop + 2,
+				win->Width - win->BorderRight - 1,
+				win->BorderTop + 1 +
+				(lines*win->RPort->TxHeight) );
+			    getline( fp, loff, line + lines - 1,
+				buf, sizeof( buf ) );
+			    Move( win->RPort, win->BorderLeft + 2,
+				topline + ( ( lines - 1 ) *
+				win->RPort->TxHeight ) );
+			    WaitTOF();
+			    Text( win->RPort, buf, strlen( buf )-1 );
+			}
+			else
+			{
+			    /* EOF */
+			    DisplayBeep( scrn );
+			    lastdown = 0;
+			}
+		    }
+		    else if( lastdown == GADHELPBKWD )
+		    {
+			bkwd:
+			if( line > 0 )
+			{
+			    line--;
+			    WaitTOF();
+			    ScrollRaster( win->RPort, 0,
+				-win->RPort->TxHeight,
+				win->BorderLeft,
+				win->BorderTop + 2,
+				win->Width - win->BorderRight - 1,
+				win->BorderTop + 1 +
+				(lines*win->RPort->TxHeight) );
+			    getline( fp, loff, line, buf, sizeof( buf ) );
+			    Move( win->RPort, win->BorderLeft + 2, topline );
+			    WaitTOF();
+			    Text( win->RPort, buf, strlen( buf )-1 );
+			}
+			else
+			{
+			    DisplayBeep( scrn );
+			    lastdown = 0;
+			}
+		    }
+		    break;
+
+	    }
+	}
+    }
+    SafeCloseWindow( win );
+    fclose( fp );
+}
+
+/* Act on the menu item number passed */
+
+void
+do_menu( mptr, mcode)
+    struct Menu *mptr;
+    register int mcode;
+{
+    SetPointer( win, waitPointer, 16, 16, -6, 0 );
+    while( mcode != MENUNULL )
+    {
+	switch(MENUNUM(mcode))
+	{
+	    case MENU_PROJECT:
+		switch(ITEMNUM(mcode))
+		{
+		    case ITEM_HELP:
+			help_requester( "NetHack:HackWB.hlp" );
+			break;
+
+		    case ITEM_ABOUT:
+			text_requester( &About_NewWindowStructure9,
+				&About_IntuiTextList9 );
+			break;
+
+		    case ITEM_SCORES:
+			menu_scores( );
+			break;
+
+		    case ITEM_RECOVER:
+			menu_recover( );
+			break;
+
+		    case ITEM_CONFIG:
+			menu_config( );
+			break;
+
+		    case ITEM_QUIT:
+			quit = Ask( "Ready to Quit?" );
+			break;
+
+		}
+		break;
+
+	    case MENU_GAME:
+		switch( ITEMNUM( mcode ) )
+		{
+
+		    case ITEM_INFO:
+			menu_info( );
+			break;
+
+		    case ITEM_COPYOPT:
+			menu_copyopt( );
+			break;
+
+		    case ITEM_DISCARD:
+			menu_discard( );
+			break;
+
+		    case ITEM_RENAME:
+			menu_rename( );
+			break;
+		}
+	}
+        mcode = ((struct MenuItem *)ItemAddress( mptr, (long)mcode ))->NextSelect;
+    }
+    ClearPointer( win );
+}
+
+void
+menu_discard()
+{
+    register GPTR gptr;
+
+    if( ( gptr = NeedGame() ) == NULL )
+	return;
+
+    if( Ask("Discard Selected Game?") )
+    {
+	lastgaddown = NULL;
+	if( DeleteGame( gptr ) == 0 )
+	{
+	    errmsg( FLASH, "Discard may have failed for %s",
+		    GameName( gptr, NULL ) );
+	}
+
+	MapGadgets( R_DISK, 1 );
+    }
+}
+
+char tw[90];
+
+void
+run_game( gptr )
+    register GPTR gptr;
+{
+    extern UWORD __chip waitPointer[];
+    struct Task *ctask;
+    register struct MsgPort *proc = NULL;
+    char buf[ 100 ];
+    char namebuf[ 100 ];
+    int once, tidx;
+
+    if( gptr->active )
+    {
+	errmsg( FLASH, "%s is already in progress", gptr->name );
+	return;
+    }
+
+    if( running_split && active_count > 0 )
+    {
+	errmsg( FLASH, "A game is already in progress" );
+	return;
+    }
+
+    tidx = 0;
+
+    /* If newgame gadget, then check game name */
+
+    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
+    {
+	once = 0;
+	sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], gptr->name );
+	while( access( buf, 0 ) == 0 )
+	{
+	    if( StrRequest( "Game Already Exists, Enter a New Name",
+		namebuf, once ? namebuf : gptr->gname ) == 0 )
+	    {
+		return;
+	    }
+	    once = 1;
+	    sprintf( buf, "%s/%s.sav", options[ SAVE_IDX ], namebuf );
+	}
+    }
+    gptr->gname = xmalloc( 20 + strlen( gptr->name ) );
+
+    /*
+     * options[] are no longer put into the tooltypes because they are in the options
+     * string now.
+     */
+
+    gptr->wbs = AllocMem( sizeof( struct WBStartup ) +
+	    ( sizeof( struct WBArg ) * 2 ), MEMF_PUBLIC | MEMF_CLEAR );
+
+    /* Check if we got everything */
+
+    if( !gptr->gname || !gptr->wbs )
+    {
+	fprintf( stderr, "Can't allocate memory\n" );
+	goto freemem;
+    }
+
+    /* Get the arguments structure space */
+
+    gptr->wba = ( struct WBArg * ) ((long)gptr->wbs +
+		sizeof( struct WBStartup ) );
+
+    /* Close down window and screen if requested */
+
+    if( shutdown )
+	CloseDownWB( );
+
+    SetPointer( win, waitPointer, 16, 16, -6, 0 );
+
+    /* Load the game into memory */
+
+#ifdef SPLIT
+    /* Which version do we run? */
+    {
+	char gi[80];
+
+	sprintf( gi, "%s.dir", GAMEIMAGE );
+	if( access( gi, 0 ) == 0 ){
+	    gptr->seglist = (BPTR)s_LoadSeg( gi );
+	    if( gptr->seglist ) running_split=1;
+	}else{
+	    gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
+	}
+    }
+#else
+    gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
+#endif
+    ClearPointer( win );
+
+    if( gptr->seglist == NULL)
+    {
+	if( !wbopen )
+	    SetupWB( );
+	errmsg( FLASH, "Can't load %s", GAMEIMAGE );
+	goto freemem;
+    }
+    /* Build WBStartup from current game info */
+
+    /* Set the game name for the status command */
+
+    sprintf( gptr->gname, "NetHack %d.%d.%d %s",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL, gptr->name );
+
+    /* Create a process for the game to execute in */
+
+    ctask = FindTask( NULL );
+    proc = CreateProc( gptr->gname, ctask->tc_Node.ln_Pri,
+	gptr->seglist, GAMESTACK );
+
+    /* Check if the create failed */
+
+    if( proc == NULL )
+    {
+    fprintf(stderr, "Error creating process %d\n", IoErr() );
+#ifdef SPLIT
+	if(!running_split)
+#endif
+	    UnLoadSeg( gptr->seglist );
+freemem:
+    if( gptr->gname ) free( gptr->gname );
+    gptr->gname = NULL;
+
+    if( gptr->wbs ) FreeMem( gptr->wbs,
+	sizeof( struct WBStartup ) + sizeof( struct WBArg ) * 2 );
+    gptr->wbs = NULL;
+    if( !wbopen )
+	SetupWB( );
+    return;
+    }
+
+    /* Get the Process structure pointer */
+
+    gptr->prc = (struct Process *) (((long)proc) - sizeof( struct Task ));
+
+    /* Set the current directory */
+
+    gptr->prc->pr_CurrentDir=((struct Process *)FindTask(NULL))->pr_CurrentDir;
+
+    /* Fill in the startup message */
+
+    gptr->wbs->sm_Process = proc;
+    gptr->wbs->sm_Segment = gptr->seglist;
+    gptr->wbs->sm_NumArgs = 2;
+    sprintf(tw,"con:0/0/350/50/Amiga NetHack %d.%d.%d",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
+    gptr->wbs->sm_ToolWindow = tw;
+    gptr->wbs->sm_ArgList = gptr->wba;
+
+    /* Fill in the args */
+
+    gptr->wba[0].wa_Name = Strdup( GAMEIMAGE );
+    gptr->wba[0].wa_Lock = Lock( dirname( GAMEIMAGE ), ACCESS_READ );
+
+    gptr->wba[1].wa_Name = Strdup( gptr->name );
+    gptr->wba[1].wa_Lock = Lock( "t:", ACCESS_READ );
+    if( gptr->wba[1].wa_Lock == NULL )
+	gptr->wba[1].wa_Lock = Lock( gptr->dname, ACCESS_READ );
+    else
+    {
+	/* Write the updated tools types entries */
+	WriteDObj( gptr, gptr->wba[1].wa_Lock );
+    }
+
+    /* Set the message fields correctly */
+
+    gptr->wbs->sm_Message.mn_Node.ln_Type = NT_MESSAGE;
+    gptr->wbs->sm_Message.mn_Node.ln_Pri = 0;
+    gptr->wbs->sm_Message.mn_ReplyPort = dosport;
+    gptr->wbs->sm_Message.mn_Length =
+	sizeof( struct WBStartup ) + ( sizeof( struct WBArg ) * 2 );
+
+    /* mark game as in use */
+
+    active_count++;
+    gptr->active = 1;
+
+    /* Send the WB Startup message to let the game go... */
+
+    PutMsg( proc, &gptr->wbs->sm_Message );
+}
+
+void CloseLibraries( )
+{
+    if( IntuitionBase )     CloseLibrary( (void *) IntuitionBase );
+    IntuitionBase = 0;
+    if( DiskfontBase )      CloseLibrary( (void *) DiskfontBase );
+    DiskfontBase = 0;
+    if( IconBase )          CloseLibrary(  IconBase );
+    IconBase = 0;
+    if( GfxBase )           CloseLibrary( (void *) GfxBase );
+    GfxBase = 0;
+}
+
+void cleanup( code )
+    int code;
+{
+    if( active_count )
+    {
+	errmsg( FLASH, "There %s still %d game%s active...",
+		active_count > 1 ? "are" : "is",
+		active_count,
+		active_count > 1 ? "s" : "" );
+	return;
+    }
+
+    if( dosport ) DeletePort( dosport );
+    dosport = NULL;
+
+    CloseDownWB( );
+    CleanUpLists( );
+    CloseLibraries( );
+
+#ifdef SPLIT
+    if(running_split)s_UnLoadSeg();
+#endif
+    exit( code );
+}
+
+GPTR AllocGITEM( )
+{
+    register GPTR gptr;
+
+    if( gameavail )
+    {
+	gptr = gameavail;
+	gameavail = gameavail->next;
+    }
+    else
+    {
+	gptr = xmalloc( sizeof( GAMEITEM ) );
+    }
+
+    if( gptr )
+	memset( gptr, 0, sizeof( GAMEITEM ) );
+
+    return( gptr );
+}
+
+void FreeGITEM( gptr )
+    register GPTR gptr;
+{
+    /* Free all of the pieces first */
+
+    if( gptr->talloc )
+	FreeTools( gptr );
+    gptr->talloc = 0;
+
+    if( gptr->dobj )
+	FreeDObj( gptr->dobj );
+    gptr->dobj = NULL;
+
+    if( gptr->name )
+	free( gptr->name );
+    gptr->name = NULL;
+
+    if( gptr->dname )
+	free( gptr->dname );
+    gptr->dname = NULL;
+
+    if( gptr->fname )
+	free( gptr->fname );
+    gptr->fname = NULL;
+
+    /* Connect it to free list */
+
+    gptr->next = gameavail;
+    gameavail = gptr;
+}
+
+struct DiskObject *AllocDObj( str )
+    register char *str;
+{
+    register struct DiskObject *doptr;
+    register char *t, *t1;
+
+    if( ( t = strrchr( str, '.' ) ) && stricmp( t, ".info" ) == 0 )
+	*t = 0;
+    else
+	t = NULL;
+
+    if( doptr = GetDiskObject( str ) )
+    {
+	struct IntuiText *ip;
+
+	diskobj_filter(doptr);  /* delete INTERNALCLI */
+
+	if( ip = xmalloc( sizeof( struct IntuiText ) ) )
+	{
+	    memset( ip, 0, sizeof( struct IntuiText ) );
+	    ip->FrontPen = C_BLACK;
+	    ip->DrawMode = JAM1;
+	    ip->LeftEdge = (doptr->do_Gadget.Width -
+		( strlen( str ) * win->RPort->TxWidth ))/2;
+	    ip->TopEdge = doptr->do_Gadget.Height;
+	    ip->IText = strdup( str );
+	    doptr->do_Gadget.GadgetText = ip;
+
+	    /* Trim any .sav off of the end. */
+
+	    if( ( t1 = strrchr( ip->IText, '.' ) ) &&
+		    stricmp( t1, ".sav" ) == 0 )
+	    {
+		*t1 = 0;
+		ip->LeftEdge += (2 * win->RPort->TxWidth);
+	    }
+	}
+    }
+    if( t ) *t = '.';
+
+    return( doptr );
+}
+
+void LoadIcons( )
+{
+    register GPTR gptr, newgame;
+    register BPTR savedir;
+    register char *t;
+    register struct FileInfoBlock *finfo;
+    char buf[ 200 ];
+
+    /* Check if we can access the new save directory */
+
+    if( t = strchr( options[ SAVE_IDX ], ';' ) )
+    {
+	strncpy( buf, options[ SAVE_IDX ], sizeof( buf ) - 1 );
+	buf[ sizeof( buf ) - 1 ] = 0;
+	if( ( t = strchr( buf, ';' ) ) && strcmp( t, ";n" ) == 0 )
+	    *t = 0;
+	if( ( savedir = Lock( buf, ACCESS_READ ) ) == NULL )
+	{
+	    errmsg( FLASH,
+		    "Can't access save directory: %s", buf );
+	    return;
+	}
+    }
+    else if( ( savedir = Lock( options[ SAVE_IDX ], ACCESS_READ ) ) == NULL )
+    {
+	errmsg( FLASH,
+		"Can't access save directory: %s", options[ SAVE_IDX ] );
+	return;
+    }
+
+    if( ( finfo = (struct FileInfoBlock *)
+		    xmalloc( sizeof( struct FileInfoBlock ) ) ) == NULL )
+    {
+	UnLock( savedir );
+	errmsg( FLASH, "Can't alloc memory" );
+	return;
+    }
+
+    if( ( newgame = gamehead ) && newgame->dobj->do_Gadget.GadgetID == GADNEWGAME )
+	gamehead = gamehead->next;
+    else
+	newgame = NULL;
+
+    if( !Examine( savedir, finfo ) )
+    {
+	UnLock( savedir );
+	free( finfo );
+	errmsg( FLASH, "Can't Examine save directory" );
+	return;
+    }
+
+    /* Collect all of the entries */
+
+    while( ExNext( savedir, finfo ) )
+    {
+	/* If already got this game, continue */
+
+	if( gptr = FindGame( finfo->fib_FileName ) )
+	    continue;
+
+	/* Get just the ones we are interested in */
+
+	if( ( t = strrchr( finfo->fib_FileName, '.' ) ) == NULL ||
+		    stricmp( t, ".info" ) != 0 )
+	    continue;
+
+	if( t == finfo->fib_FileName )
+	    continue;
+
+	/* Get a gadget item */
+
+	if( gptr = GetWBIcon( savedir, options[ SAVE_IDX ], finfo ) )
+	{
+	    gptr->next = gamehead;
+	    gamehead = gptr;
+	}
+    }
+
+    /* Get the NewGame gadget */
+
+    UnLock( savedir );
+    if( newgame == NULL )
+    {
+	/* Pick up the new game if not there yet. */
+
+	sprintf( buf, "%sNewGame.info", options[ HACKDIR_IDX ] );
+	if( savedir = Lock( buf, ACCESS_READ ) )
+	{
+	    if( Examine( savedir, finfo ) )
+	    {
+		UnLock( savedir );
+		savedir = Lock( options[ HACKDIR_IDX ], ACCESS_READ );
+		if( gptr = GetWBIcon( savedir,
+			options[ HACKDIR_IDX ], finfo ) )
+		{
+		    gptr->next = gamehead;
+		    gamehead = gptr;
+		}
+	    }
+	    UnLock( savedir );
+	    free( finfo );
+	}
+	else
+	{
+	    errmsg( FLASH, "No access to %s", buf );
+	}
+    }
+    else
+    {
+	newgame->next = gamehead;
+	gamehead = newgame;
+    }
+}
+
+void menu_recover()
+{
+    int execit = 1;
+    long class, code;
+    struct Gadget *gd, *lastact = 0;
+    int done = 0;
+    struct IntuiMessage *imsg;
+    struct Window *w;
+    static int once = 0;
+    int txtdiff = scrn->RastPort.TxHeight - 8;
+    struct IntuiText *ip;
+
+    if( !once )
+    {
+	for( gd = Rst_NewWindowStructure11.FirstGadget;
+		    gd; gd = gd->NextGadget )
+	{
+	    switch( gd->GadgetID )
+	    {
+		case GADRESTDIR:
+		    gd->TopEdge += txtdiff;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    strcpy(RstDir,options[LEVELS_IDX]);
+		    break;
+		case GADRESTOLD:
+		    gd->TopEdge += txtdiff*2;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    strcpy(RstOld,"levels");
+		    break;
+		case GADRESTNEW:
+		    gd->TopEdge += txtdiff*3;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADRESTOKAY:
+		    gd->TopEdge += txtdiff*4;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADRESTCAN:
+		    gd->TopEdge += txtdiff*4;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+	    }
+	}
+	Rst_NewWindowStructure11.Height += txtdiff*5;
+	for( ip = &Rst_IntuiTextList11; ip; ip = ip->NextText )
+	{
+	    if( *ip->IText == 'O' )
+		ip->TopEdge += txtdiff;
+	    else if( *ip->IText == 'N' )
+		ip->TopEdge += txtdiff*2;
+	}
+	once = 1;
+    }
+
+    Rst_NewWindowStructure11.Screen = scrn;
+    if( ( w = MyOpenWindow( &Rst_NewWindowStructure11 ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create requester window" );
+	return;
+    }
+    PrintIText( w->RPort, &Rst_IntuiTextList11, 0, txtdiff );
+    lastact = FindGadget( w, NULL, GADRESTDIR );
+
+    while( !done )
+    {
+	WaitPort( w->UserPort );
+	while( imsg = (struct IntuiMessage *) GetMsg( w->UserPort ) )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    gd = (struct Gadget *)imsg->IAddress;
+	    ReplyMsg( (struct Message *) imsg );
+	    switch( class )
+	    {
+		case CLOSEWINDOW:
+		    done = 1;
+		    execit = 0;
+		    break;
+
+		case ACTIVEWINDOW:
+		    ActivateGadget( lastact, w, NULL );
+		    break;
+
+		case GADGETUP:
+		    if( gd->GadgetID == GADRESTOKAY )
+			done = 1;
+		    else if( gd->GadgetID == GADRESTCAN )
+		    {
+			execit = 0;
+			done = 1;
+		    }
+		    else if( gd->GadgetID == GADRESTDIR )
+		    {
+			if( gd = FindGadget( w, NULL, GADRESTOLD ) )
+			    ActivateGadget( lastact = gd, w, NULL );
+		    }
+		    else if( gd->GadgetID == GADRESTOLD )
+		    {
+			if( gd = FindGadget( w, NULL, GADRESTNEW ) )
+			    ActivateGadget( lastact = gd, w, NULL );
+		    }
+		    break;
+
+		case VANILLAKEY:
+		    if( code == '\33' )
+		    {
+			done = 1;
+			execit = 0;
+		    }
+		    break;
+	    }
+	}
+    }
+
+    SafeCloseWindow( w );
+
+    if( execit )
+    {
+	char buf[255];
+	sprintf( buf, "stack 65000\nNetHack:Recover -d %s %s", RstDir, RstOld );
+	Execute( buf, NULL, NULL );
+	MapGadgets( R_DISK, 1);
+    }
+}
+
+void menu_config()
+{
+    register struct Window *cwin;
+    int done = 0, quit;
+    long class, code, qual;
+    register struct IntuiMessage *imsg;
+    struct IntuiText *ip;
+    register struct Gadget *gd;
+    static int once = 0;
+    int txtdiff = scrn->RastPort.TxHeight - 8;
+    char *env;
+
+    strcpy( StrPath, options[ PATH_IDX ] );
+    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
+    strcpy( StrPens, options[ PENS_IDX ] );
+    strcpy( StrLevels, options[ LEVELS_IDX ] );
+    strcpy( StrSave, options[ SAVE_IDX ] );
+
+    if( !once )
+    {
+	for( gd = Conf_NewWindowStructure4.FirstGadget;
+		    gd; gd = gd->NextGadget )
+	{
+	    switch( gd->GadgetID )
+	    {
+		case GADSTRPATH:
+		    /* Look for "Path:" string */
+		    for( ip = &Conf_IntuiTextList4;
+			    ip && *ip->IText != 'P'; )
+			ip = ip->NextText;
+		    gd->TopEdge += txtdiff;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADSTRHACKDIR:
+		    /* Look for "Hackdir:" string */
+		    for( ip = &Conf_IntuiTextList4;
+			    ip && *ip->IText != 'H'; )
+			ip = ip->NextText;
+		    if( ip )
+			ip->TopEdge += txtdiff;
+		    gd->TopEdge += txtdiff*2;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADSTRPENS:
+		    /* Look for "Pens:" string */
+		    for( ip = &Conf_IntuiTextList4; ip &&
+			!(*ip->IText == 'P' && ip->IText[1] == 'e'); )
+		    {
+			ip = ip->NextText;
+		    }
+		    if( ip )
+			ip->TopEdge += txtdiff*2;
+		    gd->TopEdge += txtdiff*3;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADSTRLEVELS:
+		    /* Look for "Levels:" string */
+		    for( ip = &Conf_IntuiTextList4; ip && *ip->IText != 'L'; )
+			ip = ip->NextText;
+		    if( ip )
+			ip->TopEdge += txtdiff*3;
+		    gd->TopEdge += txtdiff*4;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADSTRSAVE:
+		    /* Look for "Save Dir:" string */
+		    for( ip = &Conf_IntuiTextList4; ip && *ip->IText != 'S'; )
+			ip = ip->NextText;
+		    if( ip )
+			ip->TopEdge += txtdiff*4;
+		    gd->TopEdge += txtdiff*5;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADCONFLOAD:
+		case GADCONFSAVE:
+		    gd->TopEdge += txtdiff*6;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+		case GADCONFNAME:
+		    for( ip = &Conf_IntuiTextList4; ip && *ip->IText != 'C'; )
+			ip = ip->NextText;
+		    if( ip )
+			ip->TopEdge += txtdiff*6;
+		    gd->TopEdge += txtdiff*7;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+
+		default:
+		    break;
+	    }
+	}
+	Conf_NewWindowStructure4.Height += txtdiff*8;
+	if( Conf_NewWindowStructure4.TopEdge +
+	    Conf_NewWindowStructure4.Height > scrn->Height )
+	{
+	    Conf_NewWindowStructure4.TopEdge -=
+		( Conf_NewWindowStructure4.TopEdge +
+		Conf_NewWindowStructure4.Height ) - scrn->Height + 1;
+	    if( Conf_NewWindowStructure4.TopEdge < 0 )
+	    {
+		Conf_NewWindowStructure4.TopEdge = 0;
+		Conf_NewWindowStructure4.Height = scrn->Height - 1;
+	    }
+	}
+	once = 1;
+    }
+
+    Conf_NewWindowStructure4.Screen = scrn;
+    if( ( cwin = MyOpenWindow( &Conf_NewWindowStructure4 ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create requester window" );
+	return;
+    }
+
+    PrintIText( cwin->RPort, &Conf_IntuiTextList4, 0, txtdiff );
+    while( !done )
+    {
+	WaitPort( cwin->UserPort );
+	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    qual = imsg->Qualifier;
+	    gd = (struct Gadget *)imsg->IAddress;
+
+	    ReplyMsg( (struct Message *)imsg );
+
+	    switch( class )
+	    {
+		case VANILLAKEY:
+		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)))
+		    {
+			done = 0;
+			quit = 1;
+		    }
+		    break;
+
+		case ACTIVEWINDOW:
+		    if( gd = FindGadget( cwin, NULL, GADCONFNAME ) )
+			ActivateGadget( gd, cwin, NULL );
+		    break;
+
+		case CLOSEWINDOW:
+		    done = 1;
+		    quit = 0;
+		    break;
+
+		case GADGETUP:
+		    switch( gd->GadgetID )
+		    {
+			case GADSTRPATH:
+			    if( gd = FindGadget( cwin, NULL,GADSTRHACKDIR) )
+				ActivateGadget( gd, cwin, NULL );
+			    break;
+			case GADSTRHACKDIR:
+			    if( gd = FindGadget( cwin, NULL,GADSTRPENS) )
+				ActivateGadget( gd, cwin, NULL );
+			    break;
+			case GADSTRPENS:
+			    if( gd = FindGadget( cwin, NULL,GADSTRLEVELS) )
+				ActivateGadget( gd, cwin, NULL );
+			    break;
+			case GADSTRLEVELS:
+			    if( gd = FindGadget( cwin, NULL, GADSTRSAVE ) )
+				ActivateGadget( gd, cwin, NULL );
+			    break;
+			case GADSTRSAVE:
+			    if( gd = FindGadget( cwin, NULL, GADCONFNAME ) )
+				ActivateGadget( gd, cwin, NULL );
+			    break;
+
+			case GADCONFNAME:	/* Do nothing... */
+			    break;
+
+			case GADCONFLOAD:
+			    ReadConfig( );
+                            env = malloc( strlen( StrConf ) + 3 +
+						strlen( "NETHACKOPTIONS" ) );
+			    sprintf( env, "NETHACKOPTIONS=@%s", StrConf );
+			    putenv( env );
+			    free( env );
+			    strcpy( StrPath, options[ PATH_IDX ] );
+			    strcpy( StrHackdir, options[ HACKDIR_IDX ] );
+			    strcpy( StrPens, options[ PENS_IDX ] );
+			    strcpy( StrLevels, options[ LEVELS_IDX ] );
+			    strcpy( StrSave, options[ SAVE_IDX ] );
+			    RefreshGList( cwin->FirstGadget, cwin, NULL, -1 );
+			    break;
+
+			case GADCONFSAVE:
+        		    {
+        		    	FILE *fp, *nfp;
+        		    	char buf[ 300 ], *t, nname[ 100 ], oname[100], *b;
+
+                                setoneopt( PATH_IDX, StrPath );
+                                setoneopt( HACKDIR_IDX, StrHackdir );
+                                setoneopt( PENS_IDX, StrPens );
+                                setoneopt( LEVELS_IDX, StrLevels );
+                                setoneopt( SAVE_IDX, StrSave );
+
+        			fp = fopen( StrConf, "r" );
+        			if( !fp )
+        			{
+				    fp = fopen( "NetHack:NetHack.cnf", "r" );
+				    strcpy( StrConf, "NetHack:NetHack.cnf" );
+				}
+        			if( !fp )
+        			{
+                        	    errmsg( FLASH, "Can't open config file" );
+                        	    break;
+                        	}
+
+                          	t = dirname( StrConf );
+                        	b = basename( StrConf );
+                          	if( t[ strlen(t)-1 ] == ':' )
+                          	{
+                          	    sprintf( nname, "%snew_%s", t, b);
+                          	    sprintf( oname, "%sold_%s", t, b);
+                        	}
+                     		else
+				{
+                            	    sprintf( oname, "%s/old_%s", t, b);
+                            	    sprintf( nname, "%s/new_%s", t, b);
+                        	}
+
+        			nfp = fopen( nname, "w" );
+        			if( !nfp )
+        			{
+                        	    errmsg( FLASH, "Can't open new config file for write" );
+                        	    fclose( fp );
+                        	    break;
+                        	}
+
+        			while( fgets( buf, sizeof( buf ), fp ) )
+        			{
+        			    if( strncmp( buf, "PATH=", 5 ) == 0 )
+        			    	fprintf( nfp, "PATH=%s\n",
+						options[ PATH_IDX ] );
+        			    else if( strncmp( buf, "LEVELS=", 7 ) == 0 )
+        			    	fprintf( nfp, "LEVELS=%s\n",
+						options[ LEVELS_IDX ] );
+        			    else if( strncmp( buf, "PENS=", 5 ) == 0 )
+        			    	fprintf( nfp, "PENS=%s\n",
+						options[ PENS_IDX ] );
+        			    else if( strncmp( buf, "SAVE=", 5 ) == 0 )
+        			    	fprintf( nfp, "SAVE=%s\n",
+						options[ SAVE_IDX ] );
+        			    else if( strncmp( buf, "HACKDIR=", 8 ) == 0 )
+        			    	fprintf( nfp, "HACKDIR=%s\n",
+						options[ HACKDIR_IDX ] );
+        			    else
+        			    {
+        			    	fputs( buf, nfp );
+        			    }
+        			}
+        			fclose( fp );
+        			fclose( nfp );
+        			unlink( oname );
+        			rename( StrConf, oname );
+        			rename( nname, StrConf );
+        		    }
+			    break;
+
+			default:
+			    break;
+		    }
+		    break;
+	    }
+	}
+    }
+
+    setoneopt( PATH_IDX, StrPath );
+    setoneopt( HACKDIR_IDX, StrHackdir );
+    setoneopt( PENS_IDX, StrPens );
+    setoneopt( LEVELS_IDX, StrLevels );
+    setoneopt( SAVE_IDX, StrSave );
+
+    SafeCloseWindow( cwin );
+
+    /* Display icons in possibly new save directory */
+
+    MapGadgets( R_DISK, 1 );
+}
+
+void
+UpdateCnfFile()
+{
+    FILE *fp, *nfp;
+    char buf[ 300 ];
+    char path=0,option=0,dir=0,pens=0,levels=0,save=0;
+    char oname[ 300 ], nname[ 300 ];
+
+    setoneopt( PATH_IDX, StrPath );
+    setoneopt( HACKDIR_IDX, StrHackdir );
+    setoneopt( PENS_IDX, StrPens );
+    setoneopt( LEVELS_IDX, StrLevels );
+    setoneopt( SAVE_IDX, StrSave );
+
+    strcpy( oname, dirname( StrConf ) );
+    if( oname[ strlen(oname)-1 ] != ':' )
+    {
+	sprintf( nname, "%s/new_nethack.cnf", oname );
+	strcat( oname, "/" );
+	strcat( oname, "old_nethack.cnf" );
+    }
+    else
+    {
+	sprintf( nname, "%snew_nethack.cnf", oname );
+	strcat( oname, "old_nethack.cnf" );
+    }
+
+    fp = fopen( StrConf, "r" );
+    if( !fp )
+    {
+        errmsg( FLASH, "Can't open nethack.cnf" );
+		return;
+    }
+    nfp = fopen( nname, "w" );
+    if( !nfp )
+    {
+        sprintf( buf, "Can't open %s for write", nname );
+        errmsg( FLASH, buf );
+        fclose( fp );
+        return;
+    }
+    while( fgets( buf, sizeof( buf ), fp ) )
+    {
+        if( strncmp( buf, "PATH=", 5 ) == 0 )
+	{
+            fprintf( nfp, "PATH=%s\n", options[ PATH_IDX ] );
+	    path=1;
+	}
+        else if( strncmp( buf, "LEVELS=", 7 ) == 0 )
+	{
+            fprintf( nfp, "LEVELS=%s\n", options[ LEVELS_IDX ] );
+	    levels=1;
+	}
+        else if( strncmp( buf, "OPTIONS=", 8 ) == 0 )
+	{
+            fprintf( nfp, "OPTIONS=%s\n", options[ OPTIONS_IDX ] );
+	    option=1;
+	}
+        else if( strncmp( buf, "PENS=", 5 ) == 0 )
+	{
+            fprintf( nfp, "PENS=%s\n", options[ PENS_IDX ] );
+	    pens=1;
+	}
+        else if( strncmp( buf, "SAVE=", 5 ) == 0 )
+	{
+            fprintf( nfp, "SAVE=%s\n", options[ SAVE_IDX ] );
+	    save=1;
+	}
+        else if( strncmp( buf, "HACKDIR=", 8 ) == 0 )
+	{
+            fprintf( nfp, "HACKDIR=%s\n", options[ HACKDIR_IDX ] );
+	    dir=1;
+	}
+        else
+        {
+       	    fputs( buf, nfp );
+        }
+    }
+
+    /* Write any that weren't already in the file */
+    if( !path )
+        fprintf( nfp, "PATH=%s\n", options[ PATH_IDX ] );
+    if( !levels )
+        fprintf( nfp, "LEVELS=%s\n", options[ LEVELS_IDX ] );
+    if( !pens )
+        fprintf( nfp, "PENS=%s\n", options[ PENS_IDX ] );
+    if( !option )
+        fprintf( nfp, "OPTIONS=%s\n", options[ OPTIONS_IDX ] );
+    if( !save )
+        fprintf( nfp, "SAVE=%s\n", options[ SAVE_IDX ] );
+    if( !dir )
+        fprintf( nfp, "HACKDIR=%s\n", options[ HACKDIR_IDX ] );
+
+    /* Close up and rename files */
+    fclose( fp );
+    fclose( nfp );
+    unlink( oname );
+    if( filecopy( StrConf, oname ) == 0 )
+	filecopy( nname, StrConf );
+}
+
+filecopy( from, to )
+    char *from, *to;
+{
+    char *buf;
+    int i = 0;
+
+    buf = malloc( strlen(to) + strlen(from) + 20 );
+    if( buf )
+    {
+    	sprintf( buf, "c:copy \"%s\" \"%s\" clone", from, to );
+
+    	/* Check SysBase instead?  Shouldn't matter  */
+	if( IntuitionBase->LibNode.lib_Version >= 37 )
+	    i = System( buf, NULL );
+	else
+	    Execute( buf, NULL, NULL );
+    	free( buf );
+    }
+    else
+    {
+    	errmsg( FLASH, "Failed to allocate memory for copy command" );
+    	return( -1 );
+    }
+    return( i );
+}
+
+void do_gadgetup( imsg )
+    register struct IntuiMessage *imsg;
+{
+    register struct Gadget *gd;
+    register unsigned long hid;
+    int ncol, pot;
+
+    gd = (struct Gadget *) imsg->IAddress;
+
+    switch( gd->GadgetID )
+    {
+	case GADSCROLL:
+	    hid = max( cols - vcols, 0 );
+	    pot = ( ( struct PropInfo * ) gd->SpecialInfo )->HorizPot;
+	    ncol = (hid * pot) / MAXPOT;
+	    if( ncol != curcol )
+	    {
+		curcol = ncol;
+		MapGadgets( R_SCROLL, 0 ); /* redisplay the icons */
+	    }
+	    break;
+    }
+}
+
+void do_buttons( imsg )
+    register struct IntuiMessage *imsg;
+{
+    if( imsg->Code == SELECTDOWN || imsg->Code == SELECTUP )
+    {
+	if( lastgaddown )
+	{
+	    SetGadgetUP( &lastgaddown->dobj->do_Gadget );
+	    lastgaddown->secs = 0;
+	    lastgaddown->mics = 0;
+	}
+	lastgaddown = NULL;
+	ChgGameItems( &MenuList1, 0 );
+    }
+}
+
+void do_gadgetdown( imsg )
+    register struct IntuiMessage *imsg;
+{
+    register GPTR gptr;
+    register struct Gadget *gd;
+
+    gd = (struct Gadget *) imsg->IAddress;
+
+    /* Don't do anything for these gadgets */
+
+    if( gd->GadgetID < GADNEWGAME )
+    {
+	return;
+    }
+
+    /* Check just to make sure we got it */
+
+    for( gptr = windowgads; gptr &&
+	gptr->dobj->do_Gadget.GadgetID != gd->GadgetID; )
+    {
+	gptr = gptr->nextwgad;
+    }
+
+    if( !gptr )
+    {
+	errmsg( FLASH, "Bad GadgetID for GadgetDOWN" );
+	return;
+    }
+
+    /* Fix the gadget images */
+
+    if( lastgaddown && &lastgaddown->dobj->do_Gadget != gd )
+    {
+	SetGadgetUP( &lastgaddown->dobj->do_Gadget );
+	gptr->secs = 0;
+	gptr->mics = 0;
+    }
+    SetGadgetDOWN( &((lastgaddown = gptr)->dobj->do_Gadget) );
+
+    /* Only allow game gadgets to be manipulated */
+
+    if( lastgaddown->dobj->do_Gadget.GadgetID == GADNEWGAME )
+	ChgNewGameItems( &MenuList1, 1 );
+    else
+	ChgGameItems( &MenuList1, 1 );
+
+    /* Check if this gadget has been double clicked */
+
+    if( DoubleClick( gptr->secs, gptr->mics, imsg->Seconds, imsg->Micros ) )
+    {
+	run_game( gptr );
+	gptr->secs = 0;
+	gptr->mics = 0;
+	return;
+    }
+
+    gptr->secs = imsg->Seconds;
+    gptr->mics = imsg->Micros;
+}
+
+/* move the tooltypes options to the options data, edit the options, and then
+ * move the settings back into the tooltypes.
+ */
+void setopt( gptr )
+    register GPTR gptr;
+{
+    ZapOptions();		/* Set boolean options to defaults and empty all strings */
+    ReadCfgOptions();		/* Set options based on NetHack.cnf. */
+    CopyOptions( gptr );	/* Put the ToolTypes into the options structures */
+    if( EditOptions( gptr ) )	/* Let the user change them around */
+	PutOptions( gptr );		/* Put everything back into the ToolTypes. */
+}
+
+void ZapOptions()
+{
+    int i;
+
+    AllocCompVals();
+    for( i = 0; boolopt[ i ].name; ++i )
+    {
+	if( boolopt[ i ].addr != NULL )
+	    *boolopt[ i ].addr = boolopt[ i ].initvalue;
+    }
+
+    for( i = 0; compvals && compvals[ i ]; ++i )
+    {
+    	*compvals[ i ] = 0;
+    }
+}
+
+void menu_info()
+{
+    int itemno;
+    register struct IntuiMessage *imsg;
+    char *t;
+    register GPTR gptr, ggptr;
+    register struct Gadget *gd;
+    register struct FileInfoBlock *finfo;
+    register struct Window *cwin;
+    register int i;
+    int done = 0;
+    long lock, olock;
+    char **sp;
+    static int once = 0;
+    long code, class, qual;
+    static struct IntuiText itext[ 2 ];
+    char commentstr[ 100 ], *s;
+    int txtdiff = scrn->RastPort.TxHeight - 8;
+
+    if( ( gptr = NeedGame() ) == NULL )
+	return;
+
+    if( ( lock = Lock( GameName( gptr, NULL ), ACCESS_READ ) ) == NULL )
+    {
+	/* Can't get lock, reload and return */
+
+	errmsg( FLASH, "Can't Lock game save file: %s",
+		GameName( gptr, NULL ) );
+	MapGadgets( R_DISK, 1 );
+	return;
+    }
+
+    finfo = (struct FileInfoBlock *)xmalloc(sizeof(struct FileInfoBlock));
+    Examine( lock, finfo );
+    UnLock( lock );
+    strncpy( commentstr, finfo->fib_Comment, sizeof( finfo->fib_Comment ) );
+    commentstr[ sizeof( finfo->fib_Comment ) ] = 0;
+    free( finfo );
+
+    ReallocTools( gptr, 0 );
+    Info_NewWindowStructure6.Screen = scrn;
+
+    if( !once )
+    {
+	/* These are static, so just do this once */
+	for( i = 0; i < 2; ++i )
+	{
+	    itext[ i ].FrontPen = C_BLACK;
+	    itext[ i ].BackPen = C_GREY;
+	    itext[ i ].DrawMode = JAM2;
+	    itext[ i ].TopEdge = 2;
+	    itext[ i ].LeftEdge = 4;
+	}
+
+    	Info_Comment.TopEdge += txtdiff*2;
+	Info_NewWindowStructure6.Height += txtdiff * 7;
+	for( gd = Info_NewWindowStructure6.FirstGadget;
+		gd; gd = gd->NextGadget )
+	{
+	    if( gd->GadgetID != GADTOOLUP && gd->GadgetID != GADTOOLDOWN )
+		gd->Height += txtdiff;
+	    gd->TopEdge += txtdiff;
+	    switch( gd->GadgetID )
+	    {
+		case 0:
+		    break;
+
+		case GADEDITOPTS:
+		    gd->TopEdge += txtdiff*3;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADTOOLTYPES:
+		    gd->TopEdge += txtdiff*4;
+		    if( scrn->Height > 300 )
+			gd->TopEdge += 2;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADDELTOOL:
+		    gd->TopEdge += txtdiff*3;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADADDTOOL:
+		    gd->TopEdge += txtdiff*3;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADSAVEINFO:
+		    gd->TopEdge += txtdiff*5;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADQUITINFO:
+		    gd->TopEdge += txtdiff*5;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADUSEINFO:
+		    gd->TopEdge += txtdiff*5;
+		    SetBorder( gd, -1 );
+		    break;
+
+		case GADTOOLUP:
+		    gd->TopEdge += txtdiff*4;
+		    gd->Flags &= ~GADGHIGHBITS;
+		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
+		    if( scrn->Height > 300 )
+		    {
+			gd->GadgetRender = (APTR)&tall_up_selectimage;
+			gd->SelectRender = (APTR)&tall_up_renderimage;
+			gd->Height *= 2;
+			if( txtdiff == 0 )
+			    gd->TopEdge -= 2;
+		    }
+		    else
+		    {
+			gd->GadgetRender = (APTR)&up_selectimage;
+			gd->SelectRender = (APTR)&up_renderimage;
+		    }
+		    break;
+
+		case GADTOOLDOWN:
+		    gd->TopEdge += txtdiff*5;
+		    gd->Flags &= ~GADGHIGHBITS;
+		    gd->Flags |= GADGIMAGE|GADGHIMAGE;
+		    if( scrn->Height > 300 )
+		    {
+			gd->GadgetRender = (APTR)&tall_down_selectimage;
+			gd->SelectRender = (APTR)&tall_down_renderimage;
+			gd->Height *= 2;
+			if( txtdiff == 0 )
+			    gd->TopEdge += 4;
+		    }
+		    else
+		    {
+			gd->GadgetRender = (APTR)&down_selectimage;
+			gd->SelectRender = (APTR)&down_renderimage;
+		    }
+		    break;
+
+		default:
+		    if( gd == &Info_Class )
+			SetBorder( gd, 2 );
+		    else
+			SetBorder( gd, -1 );
+	    }
+	}
+
+	itext[ 0 ].NextText = Info_Class.GadgetText;
+	Info_Class.GadgetText = &itext[ 0 ];
+	++once;
+    }
+
+    strncpy( Sbuff( &Info_Comment ), commentstr, 100 );
+
+    /* The players name */
+
+    strncpy( StrPlayer, ToolsEntry( gptr, "NAME" ), 100 );
+    if( *StrPlayer == 0 )
+	strncpy( StrPlayer, gptr->name, 99 );
+
+    if( ( t = strrchr( StrPlayer, '.' ) ) && stricmp( t, ".sav" ) == 0 )
+	*t = 0;
+
+    /* The character class of the player */
+
+    itext[ 0 ].IText = ToolsEntry( gptr, "CHARACTER" );
+
+    /* DCF - Changed "itext[ i ].IText == NULL" to "itext[ 0 ].Itext == NULL" */
+    if( itext[ 0 ].IText == NULL || *itext[ 0 ].IText == 0 )
+    {
+	itext[ 0 ].IText = players[ 0 ];
+	SetToolLine( gptr, "CHARACTER", "" );
+    }
+
+    /* If there are ToolTypes entries, put the first one into the gadget */
+
+    sp = gptr->dobj->do_ToolTypes;
+    if( sp && *sp )
+	strcpy( StrTools, *sp );
+
+    if( IsEditEntry( StrTools, gptr ) )
+	Info_ToolTypes.Flags &= ~GADGDISABLED;
+    else
+	Info_ToolTypes.Flags |= GADGDISABLED;
+
+    if( ( cwin = MyOpenWindow( &Info_NewWindowStructure6 ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create info window" );
+	return;
+    }
+
+    itemno = 0;
+    if( s = FindToolType( (char **) gptr->dobj->do_ToolTypes, "CHARACTER" ) )
+    {
+	s += 10;
+	for( itemno = 0; players[ itemno ]; ++itemno )
+	{
+	    if( strnicmp( s, players[ itemno ], strlen( s ) ) == 0 )
+		break;
+	}
+    }
+    if( !players[ itemno ] )
+	itemno = 0;
+
+    CheckOnly( &Info_MenuList6, 0, itemno );
+    SetUpMenus( &Info_MenuList6, scrn );
+    SetMenuStrip( cwin, &Info_MenuList6 );
+
+    while( !done )
+    {
+	WaitPort( cwin->UserPort );
+	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    qual = imsg->Qualifier;
+	    gd = (struct Gadget *)imsg->IAddress;
+
+	    ReplyMsg( (struct Message *)imsg );
+
+	    switch( class )
+	    {
+		case VANILLAKEY:
+		    if( code == '\33' || (code == 'b' && (qual&AMIGALEFT)) )
+		    {
+			done = 1;
+		    }
+		    break;
+
+		case CLOSEWINDOW:
+		    if( sp )
+		    {
+			if( *sp )
+			    free( *sp );
+			*sp = strdup( StrTools );
+		    }
+		    done = 1;
+		    break;
+
+		case GADGETUP:
+		    switch( gd->GadgetID )
+		    {
+		    case GADSAVEINFO:
+			/* Write icon and quit. */
+			SetToolLine( gptr, "NAME", StrPlayer );
+			UpdateGameIcon( gptr );
+			lock = Lock( gptr->dname, ACCESS_READ );
+			if( lock )
+			{
+			    olock = CurrentDir( lock );
+			    SetComment( gptr->fname, Sbuff( &Info_Comment ) );
+			    if( olock ) CurrentDir( olock );
+			    done = 1;
+			    UnLock( lock );
+			}
+			else
+			{
+			    errmsg( FLASH, "Can't access icon's directory" );
+			    sp = gptr->dobj->do_ToolTypes;
+			    strcpy( StrTools, *sp ? *sp : "" );
+			    UpdateInfoWin( cwin );
+			}
+			break;
+
+		    case GADUSEINFO:
+			/* Quit this loop. */
+			done = 1;
+			break;
+
+		    case GADQUITINFO:
+			/* Reload icon and quit this loop. */
+			for( ggptr = windowgads; ggptr; ggptr = ggptr->nextwgad )
+			    RemoveGadget( win, &ggptr->dobj->do_Gadget );
+			windowgads = NULL;
+			RemoveGITEM( gptr );
+			lastgaddown = NULL; /* very important... */
+			MapGadgets( R_DISK, 1 );
+			done = 1;
+			break;
+
+		    case GADEDITOPTS:
+			SetPointer( cwin, waitPointer, 16, 16, -6, 0 );
+			setopt( gptr );
+			sp = gptr->dobj->do_ToolTypes;
+			strcpy( StrTools, *sp ? *sp : "" );
+			UpdateInfoWin( cwin );
+			ClearPointer( cwin );
+			break;
+
+		    case GADADDTOOL:
+			FreeTools( gptr );
+			ReallocTools( gptr, 2 );
+			sp = gptr->dobj->do_ToolTypes;
+			for( i = 0; sp[ i ]; ++i )
+			    ;
+			sp[i] = strdup( "" );
+			sp[i+1] = NULL;
+			itext[ 0 ].IText =
+			    ToolsEntry( gptr, "CHARACTER" );
+			*StrTools = 0;
+			Info_ToolTypes.Flags &= ~GADGDISABLED;
+			UpdateInfoWin( cwin );
+			sp += i;
+			break;
+
+		    case GADDELTOOL:
+			while( *sp = sp[1] )
+			    ++sp;
+			sp = gptr->dobj->do_ToolTypes;
+			strcpy( StrTools, *sp ? *sp : "" );
+			Info_ToolTypes.Flags &= ~GADGDISABLED;
+			UpdateInfoWin( cwin );
+			break;
+
+		    case GADTOOLTYPES:
+			if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
+			{
+			    if( *sp )
+				free( *sp );
+			    *sp = strdup( StrTools );
+			}
+			break;
+
+		    case GADTOOLDOWN:
+			if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
+			{
+			    if( *sp )
+				free( *sp );
+			    *sp = strdup( StrTools );
+			}
+
+			if( sp && sp[0] && sp[1] )
+			{
+			    ++sp;
+			    strcpy( StrTools, *sp );
+			    if( IsEditEntry( StrTools, gptr ) )
+				Info_ToolTypes.Flags &= ~GADGDISABLED;
+			    else
+				Info_ToolTypes.Flags |= GADGDISABLED;
+			}
+			else
+			{
+			    if( sp && *sp )
+				strcpy( StrTools, *sp );
+			    DisplayBeep( NULL );
+			}
+			break;
+
+		    case GADTOOLUP:
+			if( sp && *sp && CheckAndCopy( StrTools, *sp ) )
+			{
+			    if( *sp )
+				free( *sp );
+			    *sp = strdup( StrTools );
+			}
+			if( sp && sp > gptr->dobj->do_ToolTypes )
+			{
+			    --sp;
+			    if( *sp )
+			    {
+				strcpy( StrTools, *sp );
+				if( IsEditEntry( StrTools, gptr ) )
+				    Info_ToolTypes.Flags &= ~GADGDISABLED;
+				else
+				    Info_ToolTypes.Flags |= GADGDISABLED;
+			    }
+			}
+			else
+			{
+			    DisplayBeep( NULL );
+			}
+			break;
+
+		    case GADPLNAME:
+			SetToolLine( gptr, "NAME", StrPlayer );
+			sp = gptr->dobj->do_ToolTypes;
+			strcpy( StrTools, *sp ? *sp : "" );
+			UpdateInfoWin( cwin );
+			break;
+		    }
+		    RefreshGList( &Info_ToolTypes, cwin, NULL, 1 );
+		    break;
+
+	    	case MENUPICK:
+	    	    while( code != MENUNULL )
+	    	    {
+			int idx = ITEMNUM( code );
+
+			if( idx == 0 )
+			{
+			    SetToolLine( gptr, "CHARACTER", "" );
+			}
+			else
+			{
+			    SetToolLine( gptr, "CHARACTER", players[ idx ] );
+			}
+			itext[ 0 ].IText = players[ idx ];
+			sp = gptr->dobj->do_ToolTypes;
+			strcpy( StrTools, (sp && *sp) ? *sp : "" );
+			UpdateInfoWin( cwin );
+			code = ((struct MenuItem *)ItemAddress(
+				&Info_MenuList6, (long)code ))->NextSelect;
+		    }
+		    break;
+	    }
+	}
+    }
+
+    SafeCloseWindow( cwin );
+}
+
+static void
+UpdateInfoWin( cwin )
+    struct Window *cwin;
+{
+    SetAPen( cwin->RPort, 0 );
+    SetBPen( cwin->RPort, 0 );
+    SetDrMd( cwin->RPort, JAM2 );
+    RectFill( cwin->RPort,
+	Info_Class.LeftEdge,
+	Info_Class.TopEdge,
+	Info_Class.LeftEdge + Info_Class.Width-1,
+	Info_Class.TopEdge + Info_Class.Height-1 );
+    RefreshGList( cwin->FirstGadget, cwin, NULL, -1 );
+}
+
+char embuf[ 300 ];
+void
+errmsg(int flash, char *str, ...)
+{
+    int wid;
+    va_list vp;
+
+    va_start( vp, str );
+
+    if( !win || !wbopen )
+    {
+	vprintf( str, vp );
+	va_end( vp );
+	return;
+    }
+    errup = 1;
+    wid = ( win->Width + Message.LeftEdge - win->BorderRight - 3 ) /
+		    win->RPort->TxWidth;
+    vsprintf( embuf, str, vp );
+    va_end( vp );
+
+    SetAPen( win->RPort, 0 );
+    SetBPen( win->RPort, 0 );
+    SetDrMd( win->RPort, JAM2 );
+    RectFill( win->RPort, Message.LeftEdge, Message.TopEdge,
+	win->Width + Message.Width,
+	Message.TopEdge + Message.Height - 1 );
+
+    Message.GadgetText->IText = embuf;
+    RefreshGList( &Message, win, 0, 1 );
+
+    if( flash == FLASH )
+	DisplayBeep( scrn );
+}
+
+/*
+ * Issue an error message to the users window because it can not be done
+ * any other way.
+ */
+
+void error( str )
+    register const char *str;
+{
+    char s[ 50 ];
+    if( scrn ) ScreenToBack( scrn );
+    Delay( 10 );
+    fprintf( stderr, "%s\n", str );
+    fprintf( stderr, "Hit Return: " );
+    fflush( stderr );
+    gets( s );
+    if( scrn ) ScreenToFront( scrn );
+}
+
+/*
+ * Make the gadget deselected
+ */
+
+void SetGadgetUP( gad )
+    register struct Gadget *gad;
+{
+    if( gad->Flags & GADGIMAGE )
+    {
+	DrawImage( win->RPort, (struct Image *)gad->GadgetRender,
+		gad->LeftEdge, gad->TopEdge );
+    }
+#if 0
+    RemoveGadget( win, gad );
+    gad->Flags &= ~(SELECTED|GADGHIGHBITS);
+    gad->Flags |= GADGHIMAGE|GADGIMAGE;
+    gad->Activation |= TOGGLESELECT;
+    AddGadget( win, gad, 0 );
+    RefreshGList( gad, win, NULL, 1 );
+    RemoveGadget( win, gad );
+    gad->Flags &= ~(GADGHIGHBITS);
+    gad->Flags |= GADGHNONE;
+    gad->Activation &= ~TOGGLESELECT;
+    AddGadget( win, gad, 0 );
+#endif
+}
+
+/*
+ * Make the gadget selected
+ */
+
+void SetGadgetDOWN( gad )
+    register struct Gadget *gad;
+{
+    if( gad->Flags & GADGHIMAGE )
+    {
+	DrawImage( win->RPort, (struct Image *)gad->SelectRender,
+		gad->LeftEdge, gad->TopEdge );
+    }
+}
+
+/*
+ * Generate a requester for a string value.
+ */
+
+int StrRequest( prompt, buff, val )
+    char *prompt, *buff, *val;
+{
+    struct Window *cwin;
+    struct IntuiMessage *imsg;
+    int done = 0, notcan = 1;
+    long class, code, qual;
+    struct Gadget *gd;
+    static int once = 0;
+    int txtdiff = scrn->RastPort.TxHeight - 8;
+
+    *StrString = 0;
+    if( val )
+	strcpy( StrString, val );
+    Str_NewWindowStructure5.Title = prompt;
+
+    if( !once )
+    {
+	for( gd = Str_NewWindowStructure5.FirstGadget;
+		    gd; gd = gd->NextGadget )
+	{
+	    if( gd->GadgetID != 0 )
+	    {
+		gd->TopEdge += txtdiff;
+		gd->Height += txtdiff;
+		SetBorder( gd, -1 );
+	    }
+	}
+	++once;
+	Str_NewWindowStructure5.Height += txtdiff * 2;
+    }
+
+    Str_NewWindowStructure5.Screen = scrn;
+    if( ( cwin = MyOpenWindow( &Str_NewWindowStructure5 ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create requester window" );
+	return( 0 );
+    }
+
+    while( !done )
+    {
+	WaitPort( cwin->UserPort );
+	while( ( imsg = (void *) GetMsg( cwin->UserPort ) ) != NULL )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    qual = imsg->Qualifier;
+	    gd = (struct Gadget *) imsg->IAddress;
+	    ReplyMsg( (struct Message *) imsg );
+	    switch( class )
+	    {
+		case ACTIVEWINDOW:
+		    ActivateGadget( &Str_String, cwin, NULL );
+		    break;
+
+		case GADGETUP:
+		    switch( gd->GadgetID )
+		    {
+			case GADSTRCANCEL:
+			    notcan = 0;
+			    done = 1;
+			    break;
+
+			default:
+			    strcpy( buff, StrString );
+			    done = 1;
+			    break;
+		    }
+		    break;
+
+		case CLOSEWINDOW:
+		    strcpy( buff, StrString );
+		    done = 1;
+		    break;
+
+		case VANILLAKEY:
+		    if( code == '\33' || code == 'b' && (qual&AMIGALEFT) )
+		    {
+			done = 1;
+			notcan = 0;
+		    }
+		    break;
+	    }
+	}
+    }
+
+    SafeCloseWindow( cwin );
+    return( notcan );
+}
+
+/*
+ * Ask the user if they really want to do something.
+ */
+
+Ask( quest )
+    char *quest;
+{
+    register struct Window *qwin;
+    register struct Gadget *gd;
+    register struct IntuiMessage *imsg;
+    register int done = 0, quit = 1;
+    int txtdiff;
+    long class, code, qual;
+    static int once = 0;
+    static WORD areabuffer[ 80 ];
+    static USHORT apat[] = { 0x5555, 0xaaaa };
+    static struct AreaInfo areaInfo = { 0 };
+    PLANEPTR pp;
+    struct TmpRas tmpras;
+
+    Quest_NewWindowStructure2.Screen = scrn;
+    txtdiff = scrn->RastPort.TxHeight - 8;
+    if( !once )
+    {
+	Quest_IntuiTextList2.TopEdge += txtdiff;
+	Quest_Borders2.TopEdge += txtdiff;
+	Quest_NewWindowStructure2.Height += txtdiff * 2;
+	SetBorder( &Quest_Borders2, 3 );
+	Quest_Yes.TopEdge += txtdiff;
+	Quest_Yes.Height += txtdiff;
+	SetBorder( &Quest_Yes, -1 );
+	Quest_No.TopEdge += txtdiff;
+	Quest_No.Height += txtdiff;
+	SetBorder( &Quest_No, -1 );
+    }
+
+    memset( areabuffer, 0, sizeof( areabuffer ) );
+    if( ( qwin = MyOpenWindow( &Quest_NewWindowStructure2 ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't create requester window" );
+	return( 1 );
+    }
+
+    pp = AllocRaster( qwin->Width, qwin->Height );
+    if( pp )
+    {
+	InitArea( &areaInfo, areabuffer, 160/5 );
+	qwin->RPort->AreaInfo = &areaInfo;
+
+	InitTmpRas( &tmpras, pp, RASSIZE( qwin->Width, qwin->Height ) );
+	qwin->RPort->TmpRas = &tmpras;
+
+	SetAPen( qwin->RPort, C_WHITE );
+	SetBPen( qwin->RPort, C_GREY );
+	SetDrMd( qwin->RPort, JAM2 );
+	SetAfPt( qwin->RPort, apat, 1 );
+
+	AreaMove( qwin->RPort, qwin->BorderLeft, qwin->BorderTop );
+	AreaDraw( qwin->RPort, qwin->Width-qwin->BorderRight, qwin->BorderTop );
+	AreaDraw( qwin->RPort, qwin->Width - qwin->BorderRight,
+		qwin->Height - qwin->BorderBottom );
+	AreaDraw( qwin->RPort, qwin->BorderLeft,
+		qwin->Height - qwin->BorderBottom );
+	AreaDraw( qwin->RPort, qwin->BorderLeft, qwin->BorderTop );
+	AreaEnd( qwin->RPort );
+
+	SetAPen( qwin->RPort, C_GREY );
+	SetBPen( qwin->RPort, C_GREY );
+	SetDrMd( qwin->RPort, JAM2 );
+	SetAfPt( qwin->RPort, NULL, 0 );
+
+	RectFill( qwin->RPort,
+		Quest_Borders2.LeftEdge,
+		Quest_Borders2.TopEdge,
+		Quest_Borders2.LeftEdge + Quest_Borders2.Width - 1,
+		Quest_Borders2.TopEdge + Quest_Borders2.Height - 1 );
+	RectFill( qwin->RPort,
+		Quest_No.LeftEdge,
+		Quest_No.TopEdge,
+		Quest_No.LeftEdge + Quest_No.Width - 1,
+		Quest_No.TopEdge + Quest_No.Height - 1 );
+	RectFill( qwin->RPort,
+		Quest_Yes.LeftEdge,
+		Quest_Yes.TopEdge,
+		Quest_Yes.LeftEdge + Quest_Yes.Width - 1,
+		Quest_Yes.TopEdge + Quest_Yes.Height - 1 );
+	RefreshGList( qwin->FirstGadget, qwin, NULL, -1 );
+    }
+
+    Quest_IntuiTextList2.LeftEdge = ( qwin->Width -
+	( qwin->RPort->TxWidth * strlen( quest ) ) ) / 2;
+    Quest_IntuiTextList2.IText = quest;
+    PrintIText( qwin->RPort, &Quest_IntuiTextList2, 0, 0 );
+    while( !done )
+    {
+	WaitPort( qwin->UserPort );
+	while( ( imsg = (void *) GetMsg( qwin->UserPort ) ) != NULL )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    qual = imsg->Qualifier;
+	    gd = (struct Gadget *)imsg->IAddress;
+
+	    ReplyMsg( (struct Message *)imsg );
+
+	    switch( class )
+	    {
+		case VANILLAKEY:
+		    if( imsg->Qualifier & AMIGALEFT )
+		    {
+			switch( imsg->Code )
+			{
+			    case 'v': done = 1; quit = 0; break;
+			    case '\33':
+			    case 'b': done = 1; quit = 1; break;
+			}
+		    }
+		    break;
+
+		case CLOSEWINDOW:
+		    done = 1; quit = 1; break;
+		    break;
+
+		case GADGETUP:
+		    switch( gd->GadgetID )
+		    {
+			case GADQUESTYES: done = 1; quit = 0; break;
+			case GADQUESTNO: done = 1; quit = 1; break;
+		    }
+		    break;
+	    }
+	}
+    }
+
+    if( pp )
+	FreeRaster( pp, qwin->Width, qwin->Height );
+    once = 1;
+    SafeCloseWindow( qwin );
+    return( quit == 0 );
+}
+
+/* Make sure that a game icon is selected and return the pointer to
+ * the GPTR structure associated with it.
+ */
+
+GPTR NeedGame()
+{
+    register GPTR gptr;
+
+    if( lastgaddown == NULL )
+    {
+	errmsg( FLASH, "Must select a game" );
+	return( NULL );
+    }
+
+    for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
+    {
+	if( &gptr->dobj->do_Gadget == &lastgaddown->dobj->do_Gadget )
+	    break;
+    }
+
+    if( !gptr )
+    {
+	errmsg( FLASH, "BUG: invalid gadget selected for processing" );
+	return( NULL );
+    }
+    return( gptr );
+}
+
+/* Set menu items SELECT flag based on 'enable' */
+
+void ChgGameItems( menup, enable )
+    struct Menu *menup;
+    int enable;
+{
+    struct MenuItem *ip;
+    int i;
+    int ino;
+
+    /* Make sure the 'Game' menu is there. */
+
+    if( !menup || !(menup = menup->NextMenu) || !( ip = menup->FirstItem ) )
+    {
+	errmsg( FLASH, "BUG: invalid menu to disable with" );
+	return;
+    }
+
+    /* Go through all items */
+
+    for( i = 0; ip; ip = ip->NextItem, ++i )
+    {
+	switch( i )
+	{
+	    case ITEM_INFO:
+	    case ITEM_COPYOPT:
+	    case ITEM_DISCARD:
+	    case ITEM_RENAME:
+		ino = MENUITEMNO( 1,i,NOSUB );
+		if( enable )
+		    OnMenu( win, ino );
+		else
+		    OffMenu( win, ino );
+		break;
+	}
+    }
+}
+
+/* Set menu items SELECT flag based on 'enable' for NEWGAME gadget */
+
+void ChgNewGameItems( menup, enable )
+    struct Menu *menup;
+    int enable;
+{
+    struct MenuItem *ip;
+    int i;
+    int ino;
+
+    /* Make sure the 'Game' menu is there. */
+
+    if( !menup || !(menup = menup->NextMenu) || !( ip = menup->FirstItem ) )
+    {
+	errmsg( FLASH, "BUG: invalid menu to disable with" );
+	return;
+    }
+
+    /* Go through all items */
+
+    for( i = 0; ip; ip = ip->NextItem, ++i )
+    {
+	switch( i )
+	{
+	    case ITEM_RENAME:
+	    case ITEM_DISCARD:
+		ino = MENUITEMNO( 1,i,NOSUB );
+		OffMenu( win, ino );
+		break;
+
+	    case ITEM_COPYOPT:
+	    case ITEM_INFO:
+		ino = MENUITEMNO( 1,i,NOSUB );
+		if( enable )
+		    OnMenu( win, ino );
+		else
+		    OffMenu( win, ino );
+		break;
+	}
+    }
+}
+
+/* Edit the OPTIONS= lines with a window. */
+
+USHORT lastoptx, lastopty, lastoptw, lastopth;
+int EditOptions( gptr )
+    GPTR gptr;
+{
+    int txtdiff = scrn->RastPort.TxHeight - 8;
+    struct RastPort *rp;
+    struct Gadget *gd, *lastgad = 0;
+    struct TextAttr textfont;
+    long code, class;
+    int done = 0, save = 0;
+    struct IntuiMessage *imsg;
+    struct Window *w;
+    int cury = -1, gadid = 1, compgadid;
+    struct OPTGAD *gp;
+    struct OPTGAD *boolgads, *compgads;
+    static int once = 0;
+
+    Options_NewWindowStructure3.Screen = scrn;
+    Options_NewWindowStructure3.TopEdge = 0;
+    Options_NewWindowStructure3.LeftEdge = 0;
+    Options_NewWindowStructure3.Width = scrn->Width;
+    Options_NewWindowStructure3.Height = scrn->Height;
+    Options_NewWindowStructure3.Title = "Edit Options";
+
+    if( lastoptw != 0 )
+    {
+	Options_NewWindowStructure3.LeftEdge = lastoptx;
+	Options_NewWindowStructure3.TopEdge = lastopty;
+	Options_NewWindowStructure3.Width = lastoptw;
+	Options_NewWindowStructure3.Height = lastopth;
+    }
+
+    if( !once )
+    {
+	for( gd = Options_NewWindowStructure3.FirstGadget;
+		gd; gd = gd->NextGadget )
+	{
+	    switch( gd->GadgetID )
+	    {
+		case GADOPTOKAY:
+		case GADOPTCANCEL:
+		    gd->TopEdge -= txtdiff;
+		    gd->Height += txtdiff;
+		    SetBorder( gd, -1 );
+		    break;
+	    }
+	}
+	once = 1;
+    }
+
+    w = MyOpenWindow( (void *)&Options_NewWindowStructure3 );
+    if( w )
+    {
+    	rp = w->RPort;
+	textfont.ta_Name = w->RPort->Font->tf_Message.mn_Node.ln_Name;
+	textfont.ta_YSize = w->RPort->Font->tf_YSize;
+	textfont.ta_Style = w->RPort->Font->tf_Style;
+	textfont.ta_Flags = w->RPort->Font->tf_Flags;
+
+	boolgads = LayoutBoolOpts( w->Width - w->BorderLeft - w->BorderRight - 3,
+			w->Height - w->BorderTop - w->BorderBottom - 6,
+			w->RPort, &cury, &gadid );
+
+	if( boolgads )
+	{
+	    for( gp = boolgads; gp; gp = gp->next )
+	    {
+		gd = &gp->gad;
+		if( *boolopt[ gd->GadgetID - 1 ].addr != FALSE )
+		    gd->Flags |= SELECTED;
+		else
+		    gd->Flags &= ~SELECTED;
+		AddGList( w, gd, 0, 1, NULL );
+		RefreshGList( gd, w, NULL, 1 );
+		if( ( gd->Flags & SELECTED ) == 0 )
+		{
+		    SetAPen( rp, 0 );
+		    SetBPen( rp, 0 );
+		    SetDrMd( rp, JAM2 );
+		    RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+				    gd->LeftEdge + gd->Width - 1,
+				    gd->TopEdge + gd->Height - 1 );
+		    PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+		}
+		else
+		{
+		    SetAPen( rp, 3 );
+		    SetBPen( rp, 3 );
+		    SetDrMd( rp, JAM2 );
+		    RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+				    gd->LeftEdge + gd->Width - 1,
+				    gd->TopEdge + gd->Height - 1 );
+		    PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+		}
+  	    }
+	}
+
+	/* Save the base gadget ID for composite/string gadgets */
+
+	compgadid = gadid;
+	compgads = LayoutCompOpts( w->Width - w->BorderLeft - w->BorderRight - 3,
+			w->Height - w->BorderTop - w->BorderBottom - 6, w->RPort,
+			&cury, &gadid );
+
+	if( compgads )
+	{
+	    for( gp = compgads; gp; gp = gp->next )
+		AddGList( w, &gp->gad, 0, 1, NULL );
+	}
+	SetUpMenus( &Options_MenuList3, scrn );
+	SetMenuStrip( w, &Options_MenuList3 );
+	WindowLimits( w, -1, cury + 2 + 20, -1, -1 );
+
+	/*
+	 * This will force us through the code in the NEWSIZE case below, but
+	 * since boolgads != NULL, we won't layout the gadgets again.
+	 */
+	SizeWindow( w, 0, ( cury + 5 + 20 ) - w->Height );
+    }
+
+    while( !done && w )
+    {
+	WaitPort( w->UserPort );
+	while( imsg = (struct IntuiMessage *) GetMsg( w->UserPort ) )
+	{
+	    class = imsg->Class;
+	    code = imsg->Code;
+	    gd = (struct Gadget *)imsg->IAddress;
+	    if( class != SIZEVERIFY )
+		ReplyMsg( (struct Message *)imsg );
+	    if( class == MENUPICK )
+	    {
+		if( ITEMNUM( code ) == 0 )
+		    save = 1;
+		done = 1;
+	    }
+	    else if( class == MOUSEBUTTONS )
+	    {
+	    	if( code == SELECTUP && lastgad )
+	    	{
+		    gd = lastgad;
+		    if( ( gd->Flags & SELECTED ) == 0 )
+		    {
+			SetAPen( rp, 0 );
+			SetBPen( rp, 0 );
+			SetDrMd( rp, JAM2 );
+			RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+					gd->LeftEdge + gd->Width - 1,
+					gd->TopEdge + gd->Height - 1 );
+			PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+		    }
+		    else
+		    {
+			SetAPen( rp, 3 );
+			SetBPen( rp, 3 );
+			SetDrMd( rp, JAM2 );
+			RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+					gd->LeftEdge + gd->Width - 1,
+					gd->TopEdge + gd->Height - 1 );
+			PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+		    }
+		    lastgad = 0;
+	    	}
+	    }
+	    else if( class == GADGETUP )
+	    {
+	    	if( gd->GadgetID == GADOPTOKAY )
+	    	{
+		    save = 1;
+		    done = 1;
+	    	}
+	    	else if( gd->GadgetID == GADOPTCANCEL )
+	    	{
+		    done = 1;
+	    	}
+		else if( ( gd->Flags & SELECTED ) == 0 && gd->GadgetID < compgadid )
+		{
+		    SetAPen( rp, 0 );
+		    SetBPen( rp, 0 );
+		    SetDrMd( rp, JAM2 );
+		    RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+				    gd->LeftEdge + gd->Width - 1,
+				    gd->TopEdge + gd->Height - 1 );
+		    PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+		    lastgad = 0;
+		}
+	    }
+	    else if( class == GADGETDOWN )
+	    {
+		if( ( gd->Flags & SELECTED ) != 0 && gd->GadgetID < compgadid )
+		{
+		    SetAPen( rp, 3 );
+		    SetBPen( rp, 3 );
+		    SetDrMd( rp, JAM2 );
+		    RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+				    gd->LeftEdge + gd->Width - 1,
+				    gd->TopEdge + gd->Height - 1 );
+		    PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+		    lastgad = gd;
+		}
+	    }
+	    else if( class == CLOSEWINDOW )
+	    {
+		done = 1;
+	    }
+	    else if( class == SIZEVERIFY )
+	    {
+	    	/*
+	    	 * When the window is to be resized, we need to remove all of the gadgets
+	    	 * that are attached to get the gadget imagery from overwriting the
+	    	 * window borders.  In 2.04 and later we have RefreshWindowFrame(),
+	    	 * but still, this looks cleaner on the screen.
+	    	 */
+		for( gp = boolgads; gp; gp = gp->next )
+		{
+		    gd = &gp->gad;
+		    if( ( gd->Flags & SELECTED ) != 0 )
+			*boolopt[ gd->GadgetID - 1 ].addr = TRUE;
+		    else
+			*boolopt[ gd->GadgetID - 1 ].addr = FALSE;
+		    RemoveGList( w, gd, 1 );
+		}
+		FreeBoolOpts( boolgads );
+		/*
+		 * This tells the code in NEWSIZE below to layout the gadgets
+		 * again and reattach them to the window.
+		 */
+		boolgads = 0;
+		for( gp = compgads; gp; gp = gp->next )
+		    RemoveGList( w, &gp->gad, 1 );
+		FreeCompOpts( compgads );
+		ReplyMsg( (struct Message *)imsg );
+	    }
+	    else if( class == NEWSIZE )
+	    {
+		/* Save the last position information */
+		lastoptx = w->LeftEdge;
+		lastopty = w->TopEdge;
+		lastoptw = w->Width;
+		lastopth = w->Height;
+
+		/* If the gadgets are not currently bound, put them back. */
+		if( boolgads == NULL )
+		{
+		    cury = -1;
+		    gadid = 1;
+		    SetAPen( w->RPort, 0 );
+		    SetBPen( w->RPort, 0 );
+		    SetDrMd( w->RPort, JAM2 );
+		    RectFill( w->RPort, w->BorderLeft, w->BorderTop,
+					w->Width - w->BorderRight - 1,
+					w->Height - w->BorderBottom - 1 );
+		    SetAPen( w->RPort, 1 );
+		    SetBPen( w->RPort, 0 );
+		    boolgads = LayoutBoolOpts( w->Width - w->BorderLeft - w->BorderRight - 3,
+			w->Height - w->BorderTop - w->BorderBottom - 6, w->RPort,
+			    &cury, &gadid );
+		    for( gp = boolgads; gp; gp = gp->next )
+		    {
+			gd = &gp->gad;
+			AddGList( w, gd, 0, 1, NULL );
+			RefreshGList( gd, w, NULL, 1 );
+			if( ( gd->Flags & SELECTED ) == 0 )
+			{
+			    SetAPen( rp, 0 );
+			    SetBPen( rp, 0 );
+			    SetDrMd( rp, JAM2 );
+			    RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+					    gd->LeftEdge + gd->Width - 1,
+					    gd->TopEdge + gd->Height - 1 );
+			    PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+			}
+			else
+			{
+			    SetAPen( rp, 3 );
+			    SetBPen( rp, 3 );
+			    SetDrMd( rp, JAM2 );
+			    RectFill( rp, gd->LeftEdge + 1, gd->TopEdge + 1,
+					    gd->LeftEdge + gd->Width - 1,
+					    gd->TopEdge + gd->Height - 1 );
+			    PrintIText( rp, gd->GadgetText, gd->LeftEdge, gd->TopEdge );
+			}
+		    }
+		    compgadid = gadid;
+		    compgads = LayoutCompOpts( w->Width - w->BorderLeft - w->BorderRight - 3,
+			w->Height - w->BorderTop - w->BorderBottom - 6, w->RPort,
+			    &cury, &gadid );
+		    for( gp = compgads; gp; gp = gp->next )
+			AddGList( w, &gp->gad, 0, 1, NULL );
+		}
+		RefreshGList( w->FirstGadget, w, NULL, -1 );
+		WindowLimits( w, -1, cury + 2 + 20, -1, -1 );
+	    }
+	}
+    }
+
+    if( w )
+    {
+	/* Make sure we get the latest position too */
+	lastoptx = w->LeftEdge;
+	lastopty = w->TopEdge;
+	lastoptw = w->Width;
+	lastopth = w->Height;
+
+	/* Close the window */
+	SafeCloseWindow( w );
+    }
+
+    /* Copy boolean gads settings into data table.
+     * The compgads data is stored in the global compvals[]
+     * string array, so we just leave the strings there
+     * since options don't get added while we are running.
+     */
+    for( gp = boolgads; gp; gp = gp->next )
+    {
+	gd = &gp->gad;
+	if( gd->Flags & SELECTED )
+	    *boolopt[ gd->GadgetID - 1 ].addr = TRUE;
+	else
+	    *boolopt[ gd->GadgetID - 1 ].addr = FALSE;
+    }
+
+    /* Free the gadgets */
+    if( boolgads ) FreeBoolOpts( boolgads );
+    if( compgads ) FreeCompOpts( compgads );
+
+    return( save );
+}
+
+/*
+ * Put options in boolopt[] and compvals[] into separate OPTIONS= tooltypes entries
+ * in the GAME structure passed.
+ */
+
+void PutOptions( gptr )
+    register GPTR gptr;
+{
+    char buf[ 200 ];
+    extern char **compvals;
+    int i;
+
+    DelToolLines( gptr, "OPTIONS" );
+    for( i = 0; boolopt[i].name; ++i )
+    {
+	if( boolopt[i].addr == 0 )
+	    continue;
+	if( *boolopt[ i ].addr != boolopt[ i ].initvalue )
+	{
+	    sprintf( buf, "%s%s", *boolopt[i].addr ? "" : "!",
+				    boolopt[i].name );
+	    AddToolLine( gptr, "OPTIONS", buf );
+	}
+    }
+
+    for( i = 0; compvals && compvals[i]; ++i )
+    {
+	/* If a value was provided, put the value into a tooltypes entry */
+	if( *compvals[ i ] )
+	{
+	    sprintf( buf, "%s:%s", compopt[i].name, compvals[i] );
+	    AddToolLine( gptr, "OPTIONS", buf );
+	}
+    }
+}
+
+char *basename( str )
+    char *str;
+{
+    char *t;
+
+    t = strrchr( str, '/' );
+    if( !t )
+	t = strrchr( str, ':' );
+    if( !t )
+	t = str;
+    else
+	++t;
+    return( t );
+}
+
+/* This OPTIONS=!xxx or OPTIONS=catname:toby string value is parsed, the correct
+ * buffer area, boolopt[] or compvals[] is then updated to reflect the value
+ * that was in the options string.
+ */
+void ParseOptionStr( str )
+    char *str;
+{
+    char *s, *t, buf[ 100 ];
+    int i, sidx, state = 0;
+    int done = 0;
+
+    s = buf;
+    *buf = 0;
+    sidx = -1;
+
+    /* Start past the 'options=' part */
+    for( t = str; *str && !done; ++t )
+    {
+	if( state == 0 && isspace( *t ) )
+	    continue;
+
+	/* If at end remember so... */
+	if( !*t )
+	    done = 1;
+
+	/* If looking for an option value */
+	if( state == 0 )
+	{
+	    /* If found string value... */
+	    if( *t == ':' )
+	    {
+		*s = 0;
+		state = 1;
+		sidx = -1;
+
+		/* Look for the particular named option */
+		for( i = 0; compopt[i].name; ++i )
+		{
+		    if( stricmp( (char *)compopt[i].name, buf ) == 0 )
+		    {
+			sidx = i;
+			break;
+		    }
+		}
+
+		/* Set buffer pointer */
+		*(s = buf) = 0;
+
+		if( sidx == -1 )
+		{
+		    errmsg( FLASH, "Invalid string valued option name %s", buf );
+		    return;
+		}
+		continue;
+	    }
+	}
+
+	/* If at end of string or comma and we have some text... */
+	if( ( !*t || *t == ',' ) && *buf )
+	{
+	    /* Mark end */
+	    *s = 0;
+
+	    /* If have collected string option value... */
+	    if( sidx != -1 )
+	    {
+	    	if( compvals && compvals[ sidx ] != NULL )
+		    strcpy( compvals[ sidx ], buf );
+		sidx = -1;
+	    }
+	    else
+	    {
+		/* Look for boolean option */
+		s = buf;
+		if( *s == '!' )
+		    ++s;
+		for( i = 0; boolopt[ i ].name; ++i )
+		{
+		    if( stricmp( (char *)boolopt[ i ].name, s ) == 0 )
+			break;
+		}
+
+		if( boolopt[i].name && boolopt[i].addr )
+		{
+		    *boolopt[i].addr = *buf != '!';
+		}
+		else
+		{
+		    errmsg( FLASH, "Unrecognized option `%s'", buf );
+		    return;
+		}
+	    }
+	    *(s = buf) = 0;
+	    state = 0;
+	}
+	else
+	{
+	    if( *t == ',' )
+		*(s = buf) = 0;
+	    else
+		*s++ = *t;
+	}
+    }
+}
diff -Pru nethack-3.4.1/sys/amiga/wbcli.c nethack/sys/amiga/wbcli.c
--- nethack-3.4.1/sys/amiga/wbcli.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbcli.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,2118 @@
+/*    SCCS Id: @(#)wbcli.c  2.1   93/01/08			  */
+/*    Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1991	  */
+/*    Copyright (c) Gregg Wonderly, Naperville, IL, 1992, 1993    */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/* Friendly Intuition interface for NetHack 3.1 on the Amiga */
+
+/*
+ * This file contains many routines common to the CLI and WB interfaces,
+ * along with a few specific to each.  #defining CLI supports the CLI
+ * interface; not #defining it supports (along with wb.c) the WB interface.
+ */
+
+#include "NH:include/date.h"		/* this gives us the version string */
+#include "NH:include/patchlevel.h"	/* and the individual bits */
+
+const char amiga_version_string[] = AMIGA_VERSION_STRING;
+
+#ifdef AZTEC_C
+/* Aztec doesn't recognize __chip syntax */
+# define __chip
+#endif
+
+#include "NH:sys/amiga/wbdefs.h"       /* Miscellany information */
+#ifdef  INTUI_NEW_LOOK
+#define NewWindow   ExtNewWindow
+#define NewScreen   ExtNewScreen
+#endif
+#include "NH:sys/amiga/wbstruct.h"
+#include "NH:sys/amiga/wbprotos.h"
+
+#ifdef CLI
+#include "NH:sys/amiga/wbdata.c"       /* All structures and global data */
+
+#undef NetHackCnf
+char NetHackCnf[50]="NetHack:NetHack.cnf";
+#endif  /* CLI */
+void error( register const char *str );
+
+#define C_GREY  0
+#define C_BLACK 1
+#define C_WHITE 2
+#define C_BLUE  3
+
+#if !defined(__SASC_60) && !defined(_DCC)
+extern char *sys_errlist[];
+#endif
+extern int errno;
+extern char scrntitle[ 90 ];
+
+#define SPLIT           /* use splitter, if available */
+
+void diskobj_filter(struct DiskObject *);
+BPTR s_LoadSeg(char *);
+void s_UnLoadSeg(void);
+void append_slash(char *);
+
+/*DCF - GetWBIcon() needs these to be available in both WB and CLI modes */
+int amibbs=0;           /* BBS mode flag */
+char *bbsuid=NULL;      /* Unique user identifier for bbs mode. */
+
+#ifdef CLI
+char *cnfsavedir="NetHack:save";    /* unless overridden in cnf file */
+char argline[255];  /* no overflow - bigger than ADOS will pass */
+
+void WaitEOG(GPTR);
+char *eos(char *);
+void condaddslash(char *);
+
+/*DCF - Copies NewGame.info to new game. */
+void CopyGameIcon(char *desticon);
+
+# ifdef SPLIT
+int running_split=0;        /* if 0, using normal LoadSeg/UnLoadSeg */
+# endif
+#else
+extern char *options[NUMIDX+1];
+extern GPTR gamehead,gameavail;
+extern struct Window *win;
+#endif  /* CLI */
+
+#ifdef AZTEC_C
+extern char *strdup(char *);
+
+/*
+ * Aztec has a strnicmp, but it doesn't work properly.
+ *
+ * Note: this came out of NH:src/hacklib.c
+ */
+static char
+lowc(c)         /* force 'c' into lowercase */
+    char c;
+{
+    return ('A' <= c && c <= 'Z') ? (c | 040) : c;
+}
+
+int
+strnicmp(s1, s2, n)
+    register const char *s1, *s2;
+    register int n;
+{
+    register char t1, t2;
+
+    while (n--) {
+	if (!*s2) return (*s1 != 0);    /* s1 >= s2 */
+	else if (!*s1) return -1;   /* s1  < s2 */
+	t1 = lowc(*s1++);
+	t2 = lowc(*s2++);
+	if (t1 != t2) return (t1 > t2) ? 1 : -1;
+    }
+    return 0;               /* s1 == s2 */
+}
+#endif
+
+#ifndef max
+# define max(a, b) ((a) > (b) ? (a) : (b))
+#endif
+#ifndef min
+# define min(x,y) ((x) < (y) ? (x) : (y))
+#endif
+
+char *copyright_text[]={
+	COPYRIGHT_BANNER_A,
+	COPYRIGHT_BANNER_B,
+	COPYRIGHT_BANNER_C,
+	0
+};
+
+#ifdef CLI
+
+main( argc, argv )
+    int argc;
+    char **argv;
+{
+    GPTR gptr;
+    BPTR lc,lc2;
+    struct FileInfoBlock finfo;
+    char *name=0;
+    char namebuf[50];
+    struct WBStartup *wbs = (struct WBStartup *)argv;
+    char newcmdline[80]="";
+    char forcenewcmd=0;
+
+    /*ZapOptions( );*/
+    InitWB( argc, wbs );
+    errmsg( NO_FLASH, "Welcome to NetHack Version %d.%d.%d!\n",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL );
+    CopyRight( );
+
+    ReadConfig( );
+
+    /* check for BBS mode */
+    if (argc>1 && argv[1][0]==':'){
+	amibbs=1;
+	sprintf(newcmdline,":%08x %08x ;%s ",Input(),Output(),&argv[1][1]);
+
+	/* DCF - Set BBS mode user identifier */
+	bbsuid = &argv[1][1];
+	argv++;argc--;
+    }
+
+		/* check/re-assemble initial command line */
+    {
+    int c;
+				/* slow but easy - not a critical path */
+    for(c=1;c<argc;c++){
+	if(strlen(newcmdline)+strlen(argv[c])>=sizeof(newcmdline)){
+	    forcenewcmd=1;
+	    break;
+	}
+	strcpy(eos(newcmdline),argv[c]);
+	if(!strncmp(argv[c],"-u",2)){
+	    if(!strcmp(argv[c],"-u")){
+		name= argv[c+1];
+	    }else{
+		name= &argv[c][2];
+	    }
+	    if(!name){
+		errmsg(NO_FLASH, "No name found.\n");
+		newcmdline[0]='\0';	/* don't leave -u as default */
+		forcenewcmd=1;
+	    }
+	}
+	if(c<argc)strcpy(eos(newcmdline)," ");
+    }
+    eos(newcmdline)[-1]='\0';
+    strcpy(argline,newcmdline);
+    }
+
+    /* Wait till user quits */
+    while( !quit )
+    {
+	char tbuf[80];
+	char *p=tbuf;
+	char *dirname=cnfsavedir;
+/* play a game */
+
+	if(forcenewcmd)
+	    goto build_new_argline;	/* allow initial args to be wrong */
+#undef TESTCMDLINE
+#ifdef TESTCMDLINE
+__builtin_printf("sending '%s'\n",argline);
+#else
+	/* DCF - If the user provided a name, try to get the icon for this
+	 * game.  If there is no icon, try to find the NewGame.info
+	 * icon and copy it to match the appropriate name.
+	 */
+	strcpy(namebuf,cnfsavedir);
+	append_slash(namebuf);
+
+	/* DAN - In BBS mode, prepend the bbsuid on the front of the player
+	 * name.  This will make the icon match the format used by the
+	 * Nethack executable when saving the game.
+	 */
+
+	if ((amibbs) && (bbsuid))
+	{
+	    strcat(namebuf,bbsuid);
+	    strcat(namebuf,"_");
+	}
+
+	if(!name)
+	    strcat(namebuf,"NewGame");
+	else
+	    strcat(namebuf,name);
+
+	strcat(namebuf,".info");
+
+	lc=Lock(namebuf,ACCESS_READ);
+
+	if (!lc) /* && name) */
+	{
+	    /* If no icon found, this is probably a new game.  Build a new
+	     * icon for the game based on the NewGame.info. */
+
+	    CopyGameIcon(namebuf); /* copies the NewGame.info to namebuf */
+	    lc = Lock(namebuf,ACCESS_READ);
+	}
+
+	if(!lc){
+	    dirname="NetHack:";
+	    strcpy(namebuf,dirname);
+	    strcat(namebuf,"NewGame.info");
+	    lc=Lock(namebuf,ACCESS_READ);
+	    if(!lc){
+		errmsg(NO_FLASH,"Can't find NewGame.info");
+		cleanup(1);
+	    }
+	}
+	if(!Examine(lc,&finfo)){
+	    errmsg(NO_FLASH,"Can't find info file.\n");
+	    cleanup(1);
+	}
+	lc2=ParentDir(lc);
+	UnLock(lc);
+	gptr=GetWBIcon(lc2,dirname,&finfo);
+	if(!gptr)cleanup(1);
+	UnLock(lc2);
+	run_game(gptr);
+
+/* wait for game to end */
+	if(gptr->wbs)
+	    WaitEOG(gptr);
+	/* else load failed */
+
+	FreeGITEM(gptr);
+#endif /* TESTCMDLINE */
+/* ask about another? */
+build_new_argline:
+	forcenewcmd=0;
+	if(amibbs) {
+	    quit = 1;		/* bbs mode aborts after one game */
+	} else
+	{
+	char *x=argline;
+	while(isspace(*x))x++;
+	if(*x){			/* non-blank argline */
+		printf("%s %s %s",
+		  "Enter options for next game.  Default:\n\t", argline,
+		  "\n(space return to clear) or Q to quit:\n");
+	} else {
+		printf("Enter options for next game or Q to quit:\n");
+	}
+	fgets(tbuf,sizeof(tbuf),stdin);
+	tbuf[strlen(tbuf)-1]='\0';		/* kill \n */
+	if(strlen(tbuf)==1 && (*p=='q' || *p=='Q')){
+	    quit=1;
+		} else
+	    if(strlen(tbuf))strcpy(argline,tbuf);
+	}
+    }
+    cleanup(0);
+}
+
+/* CLI */
+
+void
+WaitEOG(target)
+    GPTR target;
+{
+    long mask, rmask;
+    struct WBStartup *wbs;
+    struct WBArg *wba;
+    int i;
+	/* Get a message */
+    while(1){
+	mask = ( 1L << dosport->mp_SigBit ) ;
+	rmask = Wait( mask );
+
+
+	if( rmask & ( 1L << dosport->mp_SigBit ) )
+	{
+	    /* Get process termination messages */
+
+	    while( wbs = (struct WBStartup *) GetMsg( dosport ) )
+	    {
+		/* Find the game that has terminated */
+
+		if(target->seglist == wbs->sm_Segment)
+		{
+#ifdef SPLIT
+		    if(!running_split)
+#endif
+		    /* Unload the code */
+		    UnLoadSeg( wbs->sm_Segment );
+		    /* Free the startup message resources */
+
+		    wba = (struct WBArg *)
+			((long)wbs + sizeof( struct WBStartup ));
+		    for( i = 0; i < wbs->sm_NumArgs; ++i )
+		    {
+			FreeMem( wba[i].wa_Name, strlen( wba[i].wa_Name ) + 1 );
+			UnLock( wba[i].wa_Lock );
+		    }
+		    FreeMem( wbs, wbs->sm_Message.mn_Length );
+		    wbs = NULL;
+
+		    return;
+		}
+	    }
+
+	}
+    }
+}
+
+/* CLI */
+
+void CopyRight()
+{
+    int line;
+    for(line=0;copyright_text[line];line++){
+	printf("%s\n",copyright_text[line]);
+    }
+}
+
+/* CLI */
+
+/*
+ * Do the one time initialization things.
+ */
+
+void
+InitWB( argc, wbs )
+    int argc;
+    register struct WBStartup *wbs;
+{
+    char **argv=(char **)wbs;
+
+    /* Open Libraries */
+    GfxBase= (struct GfxBase *) OldOpenLibrary("graphics.library");
+    IconBase= OldOpenLibrary("icon.library");
+    DiskfontBase= (struct DiskfontBase *)OldOpenLibrary("diskfont.library");
+    IntuitionBase= (struct IntuitionBase *)OldOpenLibrary("intuition.library");
+
+    if(!GfxBase || !IconBase || !DiskfontBase || !IntuitionBase)
+    {
+	error("library open failed");
+	cleanup( 1 );
+    }
+
+    /* Get Port for replied WBStartup messages */
+
+    if( ( dosport = CreatePort( NULL, 0 ) ) == NULL )
+    {
+	error("failed to create dosport" );
+	cleanup( 1 );
+    }
+
+    /* If started from CLI */
+    if( argc == 0 ){
+	printf("Run this program from CLI only.\n");
+	DisplayBeep(0);     /* could be more specific */
+	Delay(400);
+	cleanup(1);
+    }
+/* we should include hack.h but due to conflicting options to sc
+ * we can't parse tradstdc.h and clib/graphics_protos.h - fake it
+ */
+#define NEWS
+#define WIZARD
+    if (argc>1 && argv[1][0]=='?'){
+	    (void) printf(
+"\nUsage:\n %s [:uname] [-d dir] -s [-[%s]] [maxrank] [name]...",
+		argv[0], classes);
+	    (void) printf("\n or");
+	    (void) printf("\n %s [-d dir] [-u name] [-[%s]]",
+		argv[0], classes);
+	    (void) printf(" [-[DX]]");
+#ifdef NEWS
+	    (void) printf(" [-n]");
+#endif
+#ifndef AMIGA
+	    (void) printf(" [-I] [-i] [-d]");
+#endif
+#ifdef MFLOPPY
+# ifndef AMIGA
+	    (void) printf(" [-r]");
+# endif
+#endif
+#ifdef AMIGA
+	    (void) printf(" [-[lL]]");
+#endif
+	    putchar('\n');
+	    cleanup(1);
+	}
+}
+
+/* CLI */
+
+/*
+ * Read a nethack.cnf like file and collect the configuration
+ * information from it.
+ */
+void ReadConfig()
+{
+    register FILE *fp;
+    register char *buf, *t;
+
+    /* Use a dynamic buffer to limit stack use */
+
+    if( ( buf = xmalloc( 1024 ) ) == NULL )
+    {
+	error( "Can't alloc space to read config file" );
+	cleanup( 1 );
+    }
+
+    /* If the file is not there, can't load it */
+
+    if( ( fp = fopen( NetHackCnf, "r" ) ) == NULL )
+    {
+	errmsg( FLASH, "Can't load config file %s", NetHackCnf );
+	free( buf );
+	return;
+    }
+
+    /* Read the lines... */
+
+    while( fgets( buf, 1024, fp ) != NULL )
+    {
+	if( *buf == '#' )
+	    continue;
+
+	if( ( t = strchr( buf, '\n' ) ) != NULL )
+	    *t = 0;
+
+	if( strnicmp( buf, "SAVE=", 5 ) == 0 )
+	{
+	    cnfsavedir=strdup(buf+5);
+	}
+	else
+	{
+	    /* We don't care about the rest */
+	}
+    }
+    fclose( fp );
+    free( buf );
+}
+
+/* CLI */
+
+void
+run_game( gptr )
+    register GPTR gptr;
+{
+    struct Task *ctask;
+    register struct MsgPort *proc = NULL;
+    int tidx;
+
+    tidx = 0;
+
+    gptr->gname = xmalloc( 20 + strlen( gptr->name ) );
+
+    SetToolLine(gptr, "INTERNALCLI", argline);
+    gptr->wbs = AllocMem( sizeof( struct WBStartup ) +
+	( sizeof( struct WBArg ) * 2 ), MEMF_PUBLIC | MEMF_CLEAR );
+
+    /* Check if we got everything */
+
+    if( !gptr->gname || !gptr->wbs )
+    {
+	fprintf( stderr, "Can't allocate memory\n" );
+	goto freemem;
+    }
+
+    /* Get the arguments structure space */
+
+    gptr->wba = ( struct WBArg * ) ((long)gptr->wbs + 
+	sizeof( struct WBStartup ) );
+    /* Load the game into memory */
+#ifdef SPLIT
+	/* Which version do we run? */
+    {
+    char gi[80];
+    BPTR tmplock;
+
+    sprintf( gi, "%s.dir", GAMEIMAGE );
+    tmplock=Lock( gi, ACCESS_READ );
+    if( tmplock ){
+	UnLock( tmplock );
+	gptr->seglist = (BPTR)s_LoadSeg( gi );
+	if(gptr->seglist)running_split=1;
+    }else{
+	gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
+    }
+    }
+#else
+    gptr->seglist = (BPTR)LoadSeg( GAMEIMAGE );
+#endif
+
+    if( gptr->seglist == NULL)
+    {
+	errmsg( FLASH, "Can't load %s", GAMEIMAGE );
+	goto freemem;
+    }
+
+    /* Set the game name for the status command */
+    sprintf( gptr->gname, "NetHack %d.%d.%d %s",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL, gptr->name );
+
+    /* Create a process for the game to execute in */
+    ctask = FindTask( NULL );
+    proc = CreateProc( gptr->gname, ctask->tc_Node.ln_Pri,
+		    gptr->seglist, GAMESTACK );
+
+    /* Check if the create failed */
+
+    if( proc == NULL )
+    {
+	fprintf(stderr, "Error creating process %d\n", IoErr() );
+#ifdef SPLIT
+	if(!running_split)
+#endif
+	    UnLoadSeg( gptr->seglist );
+freemem:
+	if( gptr->gname ) free( gptr->gname );
+	gptr->gname = NULL;
+
+	if( gptr->wbs ) FreeMem( gptr->wbs,
+	    sizeof( struct WBStartup ) + sizeof( struct WBArg ) * 2 );
+	gptr->wbs = NULL;
+	return;
+    }
+
+    /* Get the Process structure pointer */
+    gptr->prc = (struct Process *) (((long)proc) - sizeof( struct Task ));
+
+    /* Set the current directory */
+    gptr->prc->pr_CurrentDir=((struct Process *)FindTask(NULL))->pr_CurrentDir;
+
+    /* Fill in the startup message */
+    gptr->wbs->sm_Process = proc;
+    gptr->wbs->sm_Segment = gptr->seglist;
+    gptr->wbs->sm_NumArgs = 2;
+    {
+    static char title[90];	/* some slack */
+    sprintf(title,"con:0/0/100/300/NetHack %d.%d.%d console",
+      VERSION_MAJOR, VERSION_MINOR, PATCHLEVEL);
+    gptr->wbs->sm_ToolWindow = title;
+    }
+    gptr->wbs->sm_ArgList = gptr->wba;
+
+    /* Fill in the args */
+
+    gptr->wba[0].wa_Name = Strdup( GAMEIMAGE );
+    gptr->wba[0].wa_Lock = Lock( dirname( GAMEIMAGE ), ACCESS_READ );
+
+    gptr->wba[1].wa_Name = Strdup( gptr->name );
+    gptr->wba[1].wa_Lock = Lock( "t:", ACCESS_READ );
+
+    /* Write the updated tools types entries into t: so that the icon is not
+     * mysteriously updated behind the users back.
+     */
+
+    WriteDObj( gptr, gptr->wba[1].wa_Lock );
+
+    /* Set the message fields correctly */
+
+    gptr->wbs->sm_Message.mn_Node.ln_Type = NT_MESSAGE;
+    gptr->wbs->sm_Message.mn_Node.ln_Pri = 0;
+    gptr->wbs->sm_Message.mn_ReplyPort = dosport;
+    gptr->wbs->sm_Message.mn_Length =
+	sizeof( struct WBStartup ) + ( sizeof( struct WBArg ) * 2 );
+
+    /* Send the WB Startup message to let the game go... */
+
+    PutMsg( proc, &gptr->wbs->sm_Message );
+}
+
+#else   /* CLI */
+
+void RPText( rp, s )
+    struct RastPort *rp;
+    register char *s;
+{
+    Text( rp, s, strlen( s ) );
+}
+
+/* !CLI */
+
+void
+SetUpMenus( mp, scrn )
+    register struct Menu *mp;
+    register struct Screen *scrn;
+{
+    register struct MenuItem *mip;
+    register int i, leftoff = 0, horiz=0, len;
+    register int com, chk;
+
+    for( ; mp; mp = mp->NextMenu )
+    {
+	i = 0;
+	horiz = (scrn->RastPort.TxWidth*strlen(mp->MenuName))+16;
+	/*mp->LeftEdge = leftoff;*/
+	com = chk = 0;
+	for( mip = mp->FirstItem; mip; mip = mip->NextItem )
+	{
+	    if( mip->Flags & COMMSEQ )
+		com = scrn->RastPort.TxWidth * 6;
+	    if( mip->Flags & CHECKIT )
+		chk = scrn->RastPort.TxWidth * 3;
+	}
+	for( mip = mp->FirstItem; mip; mip = mip->NextItem )
+	{
+	    mip->Height = scrn->RastPort.TxHeight;
+	    mip->TopEdge = scrn->RastPort.TxHeight * i++;
+
+	    len = IntuiTextLength((struct IntuiText *)
+		    (mip->ItemFill))+8+com+chk;
+	    horiz = max( horiz,len );
+	}
+
+	for( mip = mp->FirstItem; mip; mip = mip->NextItem )
+	{
+	    mip->Width = horiz;
+	}
+	leftoff += horiz;
+    }
+}
+
+/* !CLI */
+
+/* Get a text line from the indicated file based on an array of per
+ * line offsets.
+ */
+
+void getline( fp, offarr, which, buf, size )
+    FILE *fp;
+    long *offarr;
+    int which, size;
+    char *buf;
+{
+    fseek( fp, offarr[ which ], 0 );
+    fgets( buf, size, fp );
+}
+
+/* !CLI */
+
+void
+do_closewindow()
+{
+    /*set close flag - cleanup must be done elsewhere*/
+    cleanup( 0 );
+}
+
+/* !CLI */
+
+void
+menu_copyopt()
+{
+    GPTR gptr;
+    char newname[ 100 ], oldname[ 100 ], cmd[ 300 ], dir[ 100 ];
+
+    if( ( gptr = NeedGame() ) == NULL )
+	return;
+
+    if( StrRequest( "Enter new player name", newname, gptr->name ) == 0 )
+	return;
+
+    if( strcmp( newname, gptr->name ) == 0 )
+    {
+	errmsg( FLASH, "Copying aborted, new name same as old" );
+	return;
+    }
+
+    strcpy( oldname, GameName( gptr, NULL ) );
+
+    strcpy( dir, options[ SAVE_IDX ] );
+    if( strchr( "/:", dir[strlen(dir)-1] ) == 0 && *dir )
+	strcat( dir, "/" );
+    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
+	sprintf( cmd, "c:copy \"%s\" \"%s%s.cfg.info\"", oldname, dir, newname );
+    else
+	sprintf( cmd, "c:copy \"%s\" \"%s%s.info\"", oldname, dir, newname );
+    Execute( cmd, NULL, NULL );
+    MapGadgets( R_DISK, 1 );
+}
+
+/* !CLI */
+
+void
+menu_rename()
+{
+    register GPTR gptr;
+    char newname[ 100 ], oldname[ 100 ], cmd[ 200 ], name[100], *t;
+
+    if( ( gptr = NeedGame() ) == NULL )
+	return;
+
+    strcpy( newname, gptr->name );
+    if( t = strrchr( newname, '.' ) )
+    {
+	if( strcmp( t, ".sav" ) == 0 )
+	    *t = 0;
+    }
+
+    if( StrRequest( "Enter New Name For Game", name, newname ) == 0)
+	return;
+
+    /* Name can only be this long to allow inclusion of appropriate suffix */
+    name[ 30 - strlen( ".sav.info " ) ] = '\0';
+
+    if( strcmp( name, newname ) == 0 )
+    {
+	errmsg( FLASH, "Rename aborted, name unchanged from %s", newname );
+	return;
+    }
+
+    strcat( name, ".sav" );
+
+    strcpy( oldname, GameName( gptr, NULL ) );
+
+    strcpy( newname, GameName( gptr, name ) );
+    strcat( newname, ".info" );
+
+    /* Rename icon file */
+    sprintf( cmd, "c:rename \"%s\" \"%s\"", oldname, newname );
+    Execute( cmd, NULL, NULL );
+
+    strcpy( oldname, GameName( gptr, gptr->name ) );
+
+    strcpy( newname, GameName( gptr, name ) );
+
+    /* Rename save file if it is actually there */
+    if( access( oldname, 0 ) == 0 )
+    {
+	sprintf( cmd, "c:rename \"%s\" \"%s\"", oldname, newname );
+	Execute( cmd, NULL, NULL );
+    }
+
+    MapGadgets( R_DISK, 1 );
+}
+
+#endif  /* CLI */
+
+void CleanUpLists( )
+{
+    register GPTR gptr;
+
+    while( gptr = gamehead )
+    {
+	gamehead = gamehead->next;
+	FreeGITEM( gptr );
+    }
+
+    while( gptr = gameavail )
+    {
+	gameavail = gameavail->next;
+	free( gptr );
+    }
+}
+
+#ifndef CLI
+
+void SafeCloseWindow( window )
+    register struct Window *window;
+{
+    register struct Message *msg;
+
+    if( !window )
+	return;
+
+    /* Remove any attached menu */
+
+    if( window->MenuStrip )
+    {
+	ClearMenuStrip( window );
+    }
+
+    Forbid();
+    while( window->UserPort != NULL &&
+	    ( msg = GetMsg( window->UserPort) ) != NULL )
+    {
+	ReplyMsg( msg );
+    }
+
+    CloseWindow( window );
+    Permit();
+}
+
+void RemoveGITEM( ggptr )
+    register GPTR ggptr;
+{
+    register GPTR gptr, pgptr = NULL;
+
+    for( gptr = gamehead; gptr; pgptr = gptr, gptr = gptr->next )
+    {
+	if( gptr == ggptr )
+	{
+	    if( pgptr )
+		pgptr->next = gptr->next;
+	    else
+		gamehead = gptr->next;
+	    FreeGITEM( gptr );
+	    return;
+	}
+    }
+}
+
+
+#else   /* CLI */
+
+void CloseLibraries( )
+{
+    if( IntuitionBase )     CloseLibrary( (void *) IntuitionBase );
+    IntuitionBase = 0;
+    if( DiskfontBase )      CloseLibrary( (void *) DiskfontBase );
+    DiskfontBase = 0;
+    if( IconBase )          CloseLibrary(  IconBase );
+    IconBase = 0;
+    if( GfxBase )           CloseLibrary( (void *) GfxBase );
+    GfxBase = 0;
+}
+
+/* CLI */
+
+void cleanup( code )
+    int code;
+{
+    if( dosport ) DeletePort( dosport );
+    dosport = NULL;
+
+    CleanUpLists( );
+    CloseLibraries( );
+
+#ifdef SPLIT
+    if(running_split){
+	s_UnLoadSeg();
+    }
+#endif
+    exit( code );
+}
+
+/* CLI */
+
+GPTR AllocGITEM( )
+{
+    register GPTR gptr;
+
+    if( gameavail )
+    {
+	gptr = gameavail;
+	gameavail = gameavail->next;
+    }
+    else
+    {
+	gptr = xmalloc( sizeof( GAMEITEM ) );
+    }
+
+    if( gptr )
+	memset( gptr, 0, sizeof( GAMEITEM ) );
+
+    return( gptr );
+}
+
+/* CLI */
+
+void FreeGITEM( gptr )
+    register GPTR gptr;
+{
+    /* Free all of the pieces first */
+
+    if( gptr->talloc )
+	FreeTools( gptr );
+    gptr->talloc = 0;
+
+    if( gptr->dobj )
+	FreeDObj( gptr->dobj );
+    gptr->dobj = NULL;
+
+    if( gptr->name )
+	free( gptr->name );
+    gptr->name = NULL;
+
+    if( gptr->dname )
+	free( gptr->dname );
+    gptr->dname = NULL;
+
+    if( gptr->fname )
+	free( gptr->fname );
+    gptr->fname = NULL;
+
+    /* Connect it to free list */
+
+    gptr->next = gameavail;
+    gameavail = gptr;
+}
+
+/* CLI */
+
+struct DiskObject *AllocDObj( str )
+    register char *str;
+{
+    register struct DiskObject *doptr;
+    register char *t, *t1;
+
+    if( ( t = strrchr( str, '.' ) ) && stricmp( t, ".info" ) == 0 )
+    {
+	*t = 0;
+    } else {
+	t = NULL;
+    }
+
+    if( doptr = GetDiskObject( str ) )
+    {
+	struct IntuiText *ip;
+
+	diskobj_filter(doptr);  /* delete all but INTERNALCLI */
+
+	if( ip = xmalloc( sizeof( struct IntuiText ) ) )
+	{
+	    memset( ip, 0, sizeof( struct IntuiText ) );
+	    ip->FrontPen = C_BLACK;
+	    ip->DrawMode = JAM1;
+	    ip->IText = strdup( str );
+	    doptr->do_Gadget.GadgetText = ip;
+
+		/* Trim any .sav off of the end. */
+
+	    if( ( t1 = strrchr( ip->IText, '.' ) ) &&
+		stricmp( t1, ".sav" ) == 0 )
+	    {
+		*t1 = 0;
+		ip->LeftEdge = (2 * win->RPort->TxWidth);
+	    }
+        }
+    }
+    if( t ) *t = '.';
+
+    return( doptr );
+}
+
+#endif  /* CLI */
+
+void FreeDObj( doptr )
+    register struct DiskObject *doptr;
+{
+    if( doptr->do_Gadget.GadgetText )
+    {
+	free( doptr->do_Gadget.GadgetText->IText );
+	free( doptr->do_Gadget.GadgetText );
+    }
+    doptr->do_Gadget.GadgetText = NULL;
+    FreeDiskObject( doptr );
+}
+
+#ifdef CLI
+#ifdef AZTEC_C
+void errmsg(int flash, char *str, ...)
+#else
+void errmsg( flash, str )
+char *str;
+int flash;
+#endif
+{
+    va_list vp;
+
+    va_start( vp, str );
+
+/*  if( !win || !wbopen ) */
+    {
+	vprintf( str, vp );
+	va_end( vp );
+	printf("\n");
+	return;
+    }
+
+}
+
+/* CLI */
+
+/*
+ * Issue an error message to the users window because it can not be done
+ * any other way.
+ */
+
+void error( str )
+    register const char *str;
+{
+    char s[ 50 ];
+    if( scrn ) ScreenToBack( scrn );
+    Delay( 10 );
+    fprintf( stderr, "%s\n", str );
+    fprintf( stderr, "Hit Return: " );
+    fflush( stderr );
+    gets( s );
+    if( scrn ) ScreenToFront( scrn );
+}
+
+#else   /* CLI */
+
+void menu_scores()
+{
+    register char buf1[50];
+    register char **oldtools;
+    register GPTR gptr;
+    int oldalloc;
+    extern GPTR windowgads;
+
+    if( StrRequest( "Scores for whom?", buf1, "all" ) != 0 )
+    {
+	for( gptr = windowgads; gptr; gptr = gptr->nextwgad )
+	{
+	    if( gptr->dobj->do_Gadget.GadgetID == GADNEWGAME )
+		break;
+	}
+
+	if( !gptr )
+	{
+	    errmsg( FLASH, "Can't find NewGame icon" );
+	    return;
+	}
+
+	/* Save current tools */
+	oldtools = gptr->dobj->do_ToolTypes;
+
+	/* Force a new tooltypes array to be allocated */
+	if( oldalloc = gptr->talloc )
+	{
+	    gptr->dobj->do_ToolTypes = gptr->otools;
+	    gptr->talloc = 0;
+	}
+
+	/* Add the scores entry */
+	SetToolLine( gptr, "SCORES", *buf1 ? buf1 : "all" );
+
+	/* Get the scores */
+	run_game( gptr );
+
+	/* Free the tools which contain "SCORES=" */
+	FreeTools( gptr );
+
+	/* Restore the old tools.  When this game exits, the tools
+	 * will be written back out to disk to update things
+	 */
+	gptr->dobj->do_ToolTypes = oldtools;
+	gptr->talloc = oldalloc;
+	Delay( 100 );
+	UpdateGameIcon( gptr );
+    }
+}
+
+/* !CLI */
+
+CheckAndCopy( gadstr, origstr )
+    char *gadstr, *origstr;
+{
+    char *t;
+    int i;
+
+    if( t = strchr( gadstr, '=' ) )
+    {
+	i = t - gadstr;
+	/* Check for original string and don't allow one line to be replaced with
+	 * another.
+	 */
+	if( *origstr != 0 && strncmp( gadstr, origstr, i ) != 0 )
+	{
+	    strcpy( gadstr, origstr );
+	    DisplayBeep( NULL );
+	    return( 0 );
+	}
+    }
+    else
+    {
+	/* If added an equals, there wasn't one previously, so signal an error */
+	if( t = strchr( origstr, '=' ) )
+	{
+	    strcpy( gadstr, origstr );
+	    DisplayBeep( NULL );
+	    return( 0 );
+	}
+    }
+    return( 1 );
+}
+
+/* !CLI */
+
+int IsEditEntry( str, gptr )
+    char *str;
+    register GPTR gptr;
+{
+    if( strncmp( str, "CHARACTER=", 10 ) == 0 )
+	return( 0 );
+    return( 1 );
+}
+
+/* !CLI */
+
+void menu_comment( )
+{
+    register GPTR gptr;
+    struct FileInfoBlock *finfo;
+    BPTR lock;
+    char commentstr[ 100 ];
+
+    if( ( gptr = NeedGame() ) == NULL )
+	return;
+
+    if( ( lock = Lock( GameName( gptr, NULL ), ACCESS_READ ) ) == NULL )
+    {
+	/* Can't get lock, reload and return */
+
+	errmsg( FLASH, "Can't Lock game save file: %s",
+		    GameName( gptr, NULL ) );
+	MapGadgets( R_DISK, 1 );
+	return;
+    }
+
+    finfo = (struct FileInfoBlock *) xmalloc(sizeof(struct FileInfoBlock));
+    Examine( lock, finfo );
+    UnLock( lock );
+    strncpy( commentstr, finfo->fib_Comment, sizeof( finfo->fib_Comment ) );
+    commentstr[ sizeof( finfo->fib_Comment ) ] = 0;
+    free( finfo );
+
+    /* Set the correct size */
+    if( StrRequest( "Edit Comment as Desired",
+		commentstr, commentstr ) == 0 )
+    {
+	return;
+    }
+
+    SetComment( GameName( gptr, NULL ), commentstr );
+}
+
+/* !CLI */
+
+/*
+ * Make the proportional gadget position match the values passed
+ */
+
+void UpdatePropGad( win, gad, vis, total, top )
+    struct Window *win;
+    struct Gadget *gad;
+    register long vis, total, top;
+{
+    register long hidden;
+    register int body, pot;
+
+    hidden = max( total-vis, 0 );
+
+    if( top > hidden )
+	top = hidden;
+
+    if( hidden > 0 )
+	body = (ULONG) (vis * MAXBODY) / total;
+    else
+	body = MAXBODY;
+
+    if( hidden > 0 )
+	pot = (top * MAXPOT) / hidden;
+    else
+	pot = 0;
+
+    NewModifyProp( gad, win, NULL,
+		AUTOKNOB|FREEHORIZ, pot, 0, body, MAXBODY, 1 );
+}
+
+#endif  /* CLI */
+
+/*
+ * Allocate some memory
+ */
+
+void *xmalloc( nbytes )
+    unsigned nbytes;
+{
+    return( malloc( nbytes ) );
+}
+
+#ifndef CLI
+/*
+ * Delete the game associated with the GAME structure passed
+ */
+
+int DeleteGame( gptr )
+    register GPTR gptr;
+{
+    register int err;
+
+    err = DeleteFile( GameName( gptr, gptr->name ) );
+    err += DeleteFile( GameName( gptr, NULL ) );
+    return( err );
+}
+#endif  /* CLI */
+
+/*
+ * Look through the list of games for one named 'name'
+ */
+
+GPTR FindGame( name )
+    char *name;
+{
+    register GPTR gptr;
+
+    for( gptr = gamehead; gptr; gptr = gptr->next )
+    {
+	if( stricmp( gptr->fname, name ) == 0 )
+	    break;
+    }
+
+    return( gptr );
+}
+/*
+ * Set the option string indicated by idx to 'str'
+ */
+
+void setoneopt( idx, str )
+    int idx;
+    char *str;
+{
+    /* This space accumulates, but is recovered at process exit */
+
+    options[ idx ] = strdup( str );
+}
+
+/*
+ * Get just the directory name of str
+ */
+
+char *dirname( str )
+    char *str;
+{
+    static char buf[ 300 ];
+    char *t;
+
+    strncpy( buf, str, sizeof( buf ) );
+    buf[ sizeof( buf ) - 1 ] = 0;
+
+    if( (t = strrchr( buf, '/' ) ) == NULL ||
+		(t = strrchr( buf, ':' ) ) == NULL )
+    {
+	return( "/" );
+    }
+    *t = 0;
+    return( buf );
+}
+
+#ifndef CLI
+
+/*
+ * Make sure that only itemno is checked in 'menu' off of menuptr
+ */
+
+void CheckOnly( menuptr, menu, itemno )
+    register struct Menu *menuptr;
+    register int menu, itemno;
+{
+    register struct MenuItem *ip;
+
+    while( menuptr && menu-- )
+	menuptr = menuptr->NextMenu;
+
+    if( menuptr )
+    {
+	for( ip = menuptr->FirstItem; ip && itemno; itemno--)
+	{
+	    ip->Flags &= ~CHECKED;
+	    ip = ip->NextItem;
+	}
+
+	if( ip )
+	{
+	    ip->Flags |= CHECKED;
+	    ip = ip->NextItem;
+	}
+
+	while( ip )
+	{
+	    ip->Flags &= ~CHECKED;
+	    ip = ip->NextItem;
+	}
+    }
+}
+
+/* !CLI */
+
+int FindChecked( menuptr, menu )
+    register struct Menu *menuptr;
+    register int menu;
+{
+    register int itemno;
+    register struct MenuItem *ip;
+
+    while( menuptr && menu-- )
+	menuptr = menuptr->NextMenu;
+
+    if( menuptr )
+    {
+	for( itemno = 0, ip = menuptr->FirstItem; ip; ip = ip->NextItem )
+	{
+	    if( ip->Flags & CHECKED )
+		return( itemno );
+	    ++itemno;
+	}
+    }
+    return( 0 );
+}
+
+/* !CLI */
+
+/*
+ * Create a file name based in the GAMEs directory.  If file is NULL,
+ * the file name is the icon file.  Otherwise it is 'file'.
+ */
+
+char *GameName( gptr, file )
+    GPTR gptr;
+    char *file;
+{
+    static char buf[200];
+
+    if( file == NULL )
+	file = gptr->fname;
+
+    if( strchr( "/:", gptr->dname[ strlen( gptr->dname ) - 1 ] ) )
+	sprintf( buf, "%s%s", gptr->dname, file );
+    else
+	sprintf( buf, "%s/%s", gptr->dname, file );
+    return( buf );
+}
+
+#endif  /* CLI */
+
+/*
+ * Allocate a new GAME structure for the file passed and fill it in
+ */
+
+GPTR GetWBIcon( lock, dir, finfo )
+    register BPTR lock;
+    register char *dir;
+    register struct FileInfoBlock *finfo;
+{
+    register BPTR odir;
+    register char *t;
+    register GPTR gptr;
+
+    /* DCF */
+    char *bbsptr=NULL;
+
+    if( ( gptr = AllocGITEM( ) ) == NULL )
+	goto noitems;
+
+    if( ( gptr->dname = strdup( dir ) ) == NULL )
+	goto outofmem;
+
+    if( ( gptr->fname = strdup( finfo->fib_FileName ) ) == NULL )
+	goto outofmem;
+
+    /* Strip the .info off. */
+    if( t = strrchr( finfo->fib_FileName, '.' ) )
+    {
+	if( stricmp( t, ".info" ) == 0 )
+	    *t = 0;
+	else
+	    t = NULL;
+    }
+
+    gptr->name = xmalloc(strlen(finfo->fib_FileName)+1+9);
+
+    /* DCF - This is wrong:
+     * sprintf(gptr->name,"%s_%08x",finfo->fib_FileName,FindTask(0));
+     *
+     * We don't want to append the taskID, we want to append the
+     * unique user identifier passed to the cmd line in BBS mode.
+     * if one is not available, (i.e. we are not in BBS mode),
+     * then only use the player name (or "NewGame" if not given)
+     * with no additions.
+     */
+
+    if(amibbs)
+    {
+	/* BBS names are of the form <bbsuid>_<playerName> */
+	/* e.g.: SYSOP_SuperHacker */
+
+	bbsptr = strstr(finfo->fib_FileName,"_");
+	++bbsptr;
+	strcpy(gptr->name,bbsptr);
+    }
+    else
+	strcpy(gptr->name,finfo->fib_FileName);
+
+    /* If removed .info, put it back */
+
+    if( t )
+	*t = '.';
+
+    /* Change to saved game directory */
+
+    odir = CurrentDir( lock );
+
+    /* Allocate a diskobj structure */
+
+    if( ( gptr->dobj = AllocDObj( finfo->fib_FileName ) ) == NULL )
+    {
+	(void) CurrentDir( odir );
+outofmem:
+	FreeGITEM( gptr );
+noitems:
+	errmsg( FLASH, "Can't get Disk Object: %s", finfo->fib_FileName );
+	return( NULL );
+    }
+    gptr->oflag = gptr->dobj->do_Gadget.Flags;
+    gptr->oact = gptr->dobj->do_Gadget.Activation;
+    gptr->dobj->do_Gadget.Activation |=
+	    ( RELVERIFY | GADGIMMEDIATE | FOLLOWMOUSE );
+    gptr->dobj->do_Gadget.Flags &= ~(GADGHIGHBITS);
+    gptr->dobj->do_Gadget.Flags |= GADGHNONE;
+
+    /* Make sure gptr->dobj->do_ToolTypes is not NULL */
+    ReallocTools( gptr, 0 );
+
+    (void) CurrentDir( odir );
+    return( gptr );
+}
+
+#ifndef CLI
+
+/*
+ * Put a 3-D motif border around the gadget.  String gadgets or those
+ * which do not have highlighting are rendered down.  Boolean gadgets
+ * are rendered in the up position by default.
+ */
+
+void
+SetBorder( gd, val )
+    register struct Gadget *gd;
+    int val;
+{
+    register struct Border *bp;
+    register short *sp;
+    register int i;
+    int borders = 6;
+
+    /* Allocate two border structures one for up image and one for down
+     * image, plus vector arrays for the border lines.
+     */
+
+    if( val == 0 || val == 2 ||
+	gd->GadgetType == STRGADGET || ( gd->GadgetType == BOOLGADGET &&
+		( gd->Flags & GADGHIGHBITS ) == GADGHNONE ) )
+    {
+	borders = 12;
+    }
+
+    if( ( bp = xmalloc( ( ( sizeof( struct Border ) * 2 ) +
+	    ( sizeof( short ) * borders ) ) * 2 ) ) == NULL )
+    {
+	return;
+    }
+
+    /* Remove any special rendering flags to avoid confusing intuition
+     */
+
+    gd->Flags &= ~(GADGHIGHBITS|GADGIMAGE);
+		/*|(GRELWIDTH|GRELHEIGHT|GRELRIGHT|GRELBOTTOM);*/
+
+    sp = (short *)(bp + 4);
+    if( val == 0 || val == 2 ||
+	gd->GadgetType == STRGADGET || ( gd->GadgetType == BOOLGADGET &&
+		( gd->Flags & GADGHIGHBITS ) == GADGHNONE ) )
+    {
+	/* For a string gadget, we expand the border beyond the area where
+	 * the text will be entered.
+	 */
+
+	sp[0] = -1;
+	sp[1] = gd->Height - 1;
+	sp[2] = -1;
+	sp[3] = -1;
+	sp[4] = gd->Width-1;
+	sp[5] = -1;
+
+	sp[6] = gd->Width + 1;
+	sp[7] = -2;
+	sp[8] = gd->Width + 1;
+	sp[9] = gd->Height + 1;
+	sp[10] = -2;
+	sp[11] = gd->Height + 1;
+
+	sp[12] = -2;
+	sp[13] = gd->Height;
+	sp[14] = -2;
+	sp[15] = -2;
+	sp[16] = gd->Width;
+	sp[17] = -2;
+	sp[18] = gd->Width;
+	sp[19] = gd->Height;
+	sp[20] = -2;
+	sp[21] = gd->Height;
+
+	for( i = 0; i < 3; ++i )
+	{
+	    bp[ i ].LeftEdge = bp[ i ].TopEdge = -1;
+	    if( val == 2 )
+		bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? C_WHITE : C_BLACK;
+	    else
+		bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? C_BLACK : C_WHITE;
+
+	    /* Have to use JAM2 so that the old colors disappear. */
+	    bp[ i ].BackPen = C_GREY;
+	    bp[ i ].DrawMode = JAM2;
+	    bp[ i ].Count = ( i == 0 || i == 1 ) ? 3 : 5;
+	    bp[ i ].XY = &sp[ i*6 ];
+	    bp[ i ].NextBorder = ( i == 2 ) ? NULL : &bp[ i + 1 ];
+	}
+
+	/* Set the up image */
+	gd->GadgetRender = (APTR) bp;
+
+	/* Same image for select image */
+	gd->SelectRender = (APTR) bp;
+
+	if( gd->Flags & GRELRIGHT )
+	    gd->LeftEdge--;
+	else
+	    gd->LeftEdge++;
+	if( gd->Flags & GRELBOTTOM )
+	    gd->TopEdge--;
+	else
+	    gd->TopEdge++;
+	gd->Flags |= GADGHCOMP;
+    }
+    else
+    {
+	/* Create the border vector values for up and left side, and
+	 * also the lower and right side.
+	 */
+
+	sp[0] = 0;
+	sp[1] = gd->Height;
+	sp[2] = 0;
+	sp[3] = 0;
+	sp[4] = gd->Width;
+	sp[5] = 0;
+
+	sp[6] = gd->Width;
+	sp[7] = 0;
+	sp[8] = gd->Width;
+	sp[9] = gd->Height;
+	sp[10] = 0;
+	sp[11] = gd->Height;
+
+	/* We are creating 4 sets of borders, the two sides of the
+	 * rectangle share the border vectors with the opposite image,
+	 * but specify different colors.
+	 */
+
+	for( i = 0; i < 4; ++i )
+	{
+	    bp[ i ].TopEdge = bp[ i ].LeftEdge = 0;
+
+	    /* A GADGHNONE is always down */
+
+	    if( val != 3 && gd->GadgetType == BOOLGADGET &&
+		( gd->Flags & GADGHIGHBITS ) != GADGHNONE )
+	    {
+		bp[ i ].FrontPen =
+		    ( i == 1 || i == 2 ) ? C_BLACK : C_WHITE;
+	    }
+	    else
+	    {
+		bp[ i ].FrontPen =
+		    ( i == 1 || i == 3 ) ? C_WHITE : C_BLACK;
+	    }
+
+	    /* Have to use JAM2 so that the old colors disappear. */
+	    bp[ i ].BackPen = C_GREY;
+	    bp[ i ].DrawMode = JAM2;
+	    bp[ i ].Count = 3;
+	    bp[ i ].XY = &sp[ 6 * ((i &1) != 0) ];
+	    bp[ i ].NextBorder =
+		( i == 1 || i == 3 ) ? NULL : &bp[ i + 1 ];
+	}
+
+	/* bp[0] and bp[1] two pieces for the up image */
+	gd->GadgetRender = (APTR) bp;
+
+	/* bp[2] and bp[3] two pieces for the down image */
+	gd->SelectRender = (APTR) (bp + 2);
+	gd->Flags |= GADGHIMAGE;
+    }
+}
+
+/* !CLI */
+
+struct Gadget *FindGadget( window, newwindow, id )
+    struct Window *window;
+    struct NewWindow *newwindow;
+    int id;
+{
+    struct Gadget *gd = NULL;
+
+    if( window )
+	gd = window->FirstGadget;
+    else if( newwindow )
+	gd = newwindow->FirstGadget;
+
+    while( gd )
+    {
+	if( gd->GadgetID == id )
+	    break;
+	gd = gd->NextGadget;
+    }
+
+    return( gd );
+}
+
+#endif  /* CLI */
+
+#ifndef CLI
+
+/*
+ * Copy Options from GAMES OPTIONS= tooltypes element to the gadgets
+ */
+void CopyOptions( gptr )
+    GPTR gptr;
+{
+    char **sp;
+
+    for( sp = gptr->dobj->do_ToolTypes; sp && *sp; ++sp )
+    {
+    	if( strnicmp( *sp, "OPTIONS=", 8 ) == 0 )
+	    ParseOptionStr( (*sp) + 8 );
+    }
+}
+
+/* !CLI */
+
+void
+UpdateGameIcon( gptr )
+    register GPTR gptr;
+{
+    register long lock;
+
+    if( lock = Lock( gptr->dname, ACCESS_READ ) )
+    {
+	/* Write out the DiskObject */
+
+	WriteDObj( gptr, lock );
+	UnLock( lock );
+    }
+    else
+    {
+	errmsg( FLASH, "Can't change directory to %s", gptr->dname );
+    }
+}
+
+#endif  /* CLI */
+
+char *ToolsEntry( gptr, name )
+    GPTR gptr;
+    char *name;
+{
+    char *str;
+
+    if( ! ( str = FindToolType( (char **) gptr->dobj->do_ToolTypes, name ) ) )
+	str = "";
+
+    return( str );
+}
+
+/* Reallocate the toolstype information into dynamic memory so that some
+ * parts of it can be easily changed, but we can still do "FreeDiskObject"
+ * later to clean up whatever "GetDiskObject" allocated.
+ */
+void ReallocTools( gptr, add )
+    register GPTR gptr;
+    register int add;
+{
+    register int i, cnt;
+    register char **sp, **tp;
+
+    /* Already allocated */
+    if( gptr->talloc && add == 0 )
+    	return;
+
+    for( cnt = 0, tp = gptr->dobj->do_ToolTypes; tp && *tp ; ++tp )
+	++cnt;
+
+    if( !tp || cnt == 0 )
+    {
+	if( gptr->talloc )
+	    free( gptr->dobj->do_ToolTypes );
+	/* If no tooltypes array, fudge something to start with */
+	if( sp = xmalloc( 2 * sizeof( char * ) ) )
+	{
+	    sp[0] = strdup("HACKDIR=NetHack:");
+	    sp[1] = NULL;
+	}
+    }
+    else if( sp = xmalloc( (cnt+1+add) * sizeof( char * ) ) )
+    {
+	for( i = 0, tp = gptr->dobj->do_ToolTypes;
+		    tp && *tp && i < cnt; ++tp )
+	{
+	    sp[i++] = strdup( *tp );
+	}
+
+	if( gptr->talloc && gptr->dobj->do_ToolTypes )
+	    free( gptr->dobj->do_ToolTypes );
+	while( i < cnt+add+1 )
+	    sp[ i++ ] = NULL;
+    }
+    if( ! gptr->talloc )
+	gptr->otools = gptr->dobj->do_ToolTypes;
+    gptr->dobj->do_ToolTypes = sp;
+    gptr->toolcnt = cnt + 1;
+    gptr->talloc = 1;
+}
+
+void FreeTools( gptr )
+    register GPTR gptr;
+{
+    register int i;
+    register char **sp;
+
+    if( !gptr->talloc )
+	return;
+
+    for( i = 0, sp = gptr->dobj->do_ToolTypes; sp[i]; ++i )
+    {
+	free( sp[ i ] );
+	sp[ i ] = NULL;
+    }
+    free( sp );
+    gptr->dobj->do_ToolTypes = gptr->otools;
+    gptr->talloc = 0;
+}
+
+void DelToolLines( gptr, name )
+    GPTR gptr;
+    char *name;
+{
+    char **sp;
+    int i, j, len;
+
+    sp = gptr->dobj->do_ToolTypes;
+    len = strlen( name );
+
+    /* Find any previous definitions and delete them */
+    for( i = 0; sp[i] && i < gptr->toolcnt - 1; )
+    {
+	if( strnicmp( name, sp[i], len ) == 0 && sp[i][len] == '=' )
+	{
+	    for( j = i; j < gptr->toolcnt && (sp[ j ] = sp[ j + 1 ]); ++j )
+	    	continue;
+	}
+	else
+	{
+	    ++i;
+	}
+    }
+}
+
+/* Add a tooltypes line that might be a duplicate of the existing ones. */
+void AddToolLine( gptr, name, value )
+    GPTR gptr;
+    char *name, *value;
+{
+    char **sp;
+    int i;
+
+    /* Realloc ToolTypes to be in memory we know how to manage */
+    ReallocTools( gptr, 1 );
+
+    sp = gptr->dobj->do_ToolTypes;
+    for( i = 0; sp[ i ] && i < gptr->toolcnt - 1; ++i )
+    	continue;
+
+    /* Allocate the space needed */
+    if( value == NULL )
+	sp[ i ] = xmalloc( strlen( name ) + 1 );
+    else
+	sp[ i ] = xmalloc( strlen (value) + strlen( name ) + 2 );
+
+    /* Set the string */
+    if( sp[ i ] != NULL )
+	sprintf( sp[ i ], value ? "%s=%s" : "%s", name, value );
+    else
+	errmsg( FLASH, "Could not allocate string for value" );
+}
+
+void SetToolLine( gptr, name, value )
+    GPTR gptr;
+    char *name, *value;
+{
+    char **sp, **osp;
+    int i, len;
+
+    /* Realloc ToolTypes to be in memory we know how to manage */
+    ReallocTools( gptr, 0 );
+
+    sp = gptr->dobj->do_ToolTypes;
+    len = strlen( name );
+
+    /* Find any previous definition */
+    for( i = 0; sp[i] && i < gptr->toolcnt - 1; ++i )
+    {
+	if( strnicmp( name, sp[i], len ) == 0 && sp[i][len] == '=' )
+	    break;
+    }
+
+    /* Free up the space, or allocate new space if not there */
+    if( sp[ i ] )
+	free( sp[ i ] );
+    else
+    {
+	/* Check for need to realloc */
+
+	if( i >= gptr->toolcnt - 1 )
+	{
+	    int j=i;
+	    osp = sp;
+	    sp = xmalloc( ( i + 2 ) * sizeof( char * ) );
+	    gptr->toolcnt = i + 2;
+	    sp[ i + 1 ] = NULL;
+	    while( j >= 0 )
+	    {
+		sp[ j ] = osp[ j ];
+		--j;
+	    }
+	    free( osp );
+	    /* i = gptr->toolcnt - 1; */
+	    gptr->dobj->do_ToolTypes = sp;
+	}
+	else
+	{
+	    sp[ i + 1 ] = NULL;
+	}
+    }
+
+    /* Allocate the space needed */
+    if( value == NULL )
+	sp[i] = xmalloc( strlen( name ) + 1 );
+    else
+	sp[ i ] = xmalloc( strlen (value) + strlen( name ) + 2 );
+
+    /* Set the string */
+    if( sp[ i ] != NULL )
+	sprintf( sp[i], value ? "%s=%s" : "%s", name, value );
+    else
+	errmsg( FLASH, "Could not allocate string for value" );
+}
+
+void WriteDObj( gptr, lock )
+    register GPTR gptr;
+    long lock;
+{
+    register long odir;
+    long flag, act;
+
+    /* Don't write gadget out as selected */
+
+    flag = gptr->dobj->do_Gadget.Flags;
+    act = gptr->dobj->do_Gadget.Activation;
+    gptr->dobj->do_Gadget.Flags = gptr->oflag;
+    gptr->dobj->do_Gadget.Activation = gptr->oact;
+    odir = CurrentDir( lock );
+
+    if( PutDiskObject( gptr->name, gptr->dobj ) == 0 )
+	errmsg( FLASH, "Could not write disk object values" );
+
+    gptr->dobj->do_Gadget.Flags = flag;
+    gptr->dobj->do_Gadget.Activation = act;
+
+    if( odir )
+	(void) CurrentDir( odir );
+}
+
+char *Strdup( str )
+    char *str;
+{
+    char *t;
+
+    if( t = AllocMem( strlen( str ) + 1, MEMF_PUBLIC ) )
+	strcpy( t, str );
+    return( t );
+}
+
+#ifdef CLI
+
+char *
+eos(s)
+    char *s;
+{
+    while(*s)s++;
+    return s;
+}
+
+
+/*
+ * Add a slash to any name not ending in / or :.  There must
+ * be room for the /.
+ * NB: Duplicated from amidos.c
+ */
+void
+append_slash(name)
+char *name;
+{
+    char *ptr;
+
+    if (!*name)return;
+
+    ptr = eos(name) - 1;
+    if (*ptr != '/' && *ptr != ':') {
+	*++ptr = '/';
+	*++ptr = '\0';
+    }
+}
+
+#if 0
+/* for debug only */
+#define BP __builtin_printf
+dumptools(sp,i)
+    char **sp;
+    int i;
+{
+    int x;
+    BP("Dumptools: cnt=%d\n",i);
+    for(x=0;sp[x];x++)
+	BP("%d: '%s'\n",x,sp[x]);
+}
+#endif
+
+#else   /* CLI */
+
+void ClearDelGames()
+{
+    register GPTR gptr, pgptr = NULL;
+
+    for( gptr = gamehead; gptr; )
+    {
+	/* Skip New Game */
+
+	if( gptr->fname == NULL )
+	{
+	    gptr = gptr->next;
+	    continue;
+	}
+
+	/* If gone, then remove structures */
+
+	if( access( GameName( gptr, NULL ), 0 ) == -1 )
+	{
+	    if( pgptr )
+		pgptr->next = gptr->next;
+	    else
+		gamehead = gptr->next;
+
+	    FreeGITEM( gptr );
+	    gptr = pgptr ? pgptr : gamehead;
+	}
+	else
+	{
+	    pgptr = gptr;
+	    gptr = gptr->next;
+	}
+    }
+}
+
+/* !CLI */
+
+struct TagItem tags[] =
+{
+    {WA_ScreenTitle, (ULONG) scrntitle},
+    {TAG_DONE, 0l },
+};
+
+struct Window *
+MyOpenWindow( nw )
+#ifdef  INTUI_NEW_LOOK
+    struct ExtNewWindow *nw;
+#else
+    struct NewWindow *nw;
+#endif
+{
+#ifdef  INTUI_NEW_LOOK
+    /*nw->Extension = tags;
+    nw->Flags = WFLG_NW_EXTENDED;*/
+#endif
+#undef  NewWindow
+    return( OpenWindow( (struct NewWindow *) nw ) );
+}
+
+#endif  /* CLI */
+
+void
+diskobj_filter( dobj )
+    struct DiskObject *dobj;
+{
+    char **ta=dobj->do_ToolTypes;
+    int x;
+
+    /* if nothing there, just return. */
+    if( !ta )
+    	return;
+
+#ifdef CLI
+	/* kill everything except INTERNALCLI */
+
+    for(x=0;ta[x];x++){
+	if(!strncmp(ta[x],"INTERNALCLI=",12)){
+	    ta[0]=ta[x];
+	    ta[1]=0;
+	    return;
+	}
+    }
+    ta[0]=0;
+#else
+	/* kill INTERNALCLI */
+    for(x=0;ta[x];x++){
+        int offset=0;
+	while(ta[x+offset] && !strncmp(ta[x+offset],"INTERNALCLI=",12)){
+	    offset++;
+        }
+        ta[x]=ta[x+offset];
+    }
+#endif
+}
+
+/* DCF - This copies the NewGame.info file to the specified filename.
+ *       Used to make an icon for a new game.
+ */
+
+#ifdef CLI
+void CopyGameIcon(char *desticon)
+{
+    BPTR in,out;
+    char *filen=NULL;
+    struct FileInfoBlock *fib=NULL;
+    UBYTE *buf=NULL;
+
+    in = Open("Nethack:NewGame.info", MODE_OLDFILE);
+    if (!in)
+    {
+	filen = xmalloc(strlen(cnfsavedir)+15);
+	if (filen)
+	{
+	    strcat(filen,"/NewGame.info");
+	    /* Try the save dir. */
+	    in = Open(filen,MODE_OLDFILE);
+	    free(filen);
+	    if (!in)
+	    {
+		return; /* failed.  Oh well. */
+	    }
+	}
+	else
+	    return; /* No memory */
+    }
+
+    out = Open(desticon,MODE_NEWFILE);
+    if (!out)
+    {
+	/* Should print error: can't copy icon */
+	Close(in);
+	in = NULL;
+	return;
+    }
+    else
+    {
+	/* Copy the file. */
+	fib = (struct FileInfoBlock *) AllocDosObject(DOS_FIB,TAG_DONE);
+	ExamineFH(in,fib);
+	buf = xmalloc (fib->fib_Size);
+	FRead(in,buf,fib->fib_Size,1);
+	Close(in);
+	FWrite(out,buf,fib->fib_Size,1);
+	free(buf);
+	Close(out);
+	FreeDosObject(DOS_FIB,fib);
+    }
+}
+
+#endif /* CLI */
+
+
diff -Pru nethack-3.4.1/sys/amiga/wbdata.c nethack/sys/amiga/wbdata.c
--- nethack-3.4.1/sys/amiga/wbdata.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbdata.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,440 @@
+/*    SCCS Id: @(#)wbdata.c     3.1    2000/01/12
+/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
+/* NetHack may be freely redistributed.  See license for details. */
+/*
+struct IntuitionBase *IntuitionBase;
+struct GfxBase *GfxBase;
+struct Library *IconBase;
+struct DiskfontBase *DiskfontBase;
+*/
+struct Screen *scrn;
+struct Window *oldwin;
+char *classes = "ABCEHKPRSTVW";
+struct TmpRas tmpras;
+
+UWORD __chip waitPointer[] =
+{
+    0x0000,0x0000,
+
+    0x0400,0x07c0,
+    0x0000,0x07c0,
+
+    0x0100,0x0380,
+    0x0000,0x07e0,
+
+    0x07c0,0x1ff8,
+    0x1ff0,0x3fec,
+
+    0x3ff8,0x7fde,
+    0x3ff8,0x7fbe,
+
+    0x7ffc,0xff7f,
+    0x7efc,0xffff,
+
+    0x7ffc,0xffff,
+    0x3ff8,0x7ffe,
+
+    0x3ff8,0x7ffe,
+    0x1ff0,0x3ffc,
+
+    0x07c0,0x1ff8,
+    0x0000,0x07e0,
+
+    0x0000,0x0000
+};
+
+OPTIONS curopts[] =
+{
+    { 0, 1, "checkpoint", NULL, GADOCHKPOINT },
+    { 0, 1, "color", NULL, GADOCOLOR },
+    { 0, 1, "confirm", NULL, GADOCONFIRM },
+    { 0, 1, "disclose", NULL, GADODISCLOSE },
+    { 0, 0, "female", NULL, GADOFEMALE },
+    { 0, 1, "fixinv", NULL, GADOFIXINV },
+    { 0, 0, "flush", NULL, GADOFLUSH },
+    { 0, 1, "help", NULL, GADOHELP },
+    { 0, 1, "hilite_pet", NULL, GADOHILITEPET },
+    { 0, 0, "ignintr", NULL, GADOIGNINTR },
+    { 0, 1, "legacy", NULL, GADOLEGACY },
+    { 0, 0, "lit_corridor", NULL, GADOLITCORRIDOR },
+    { 0, 1, "news", NULL, GADONEWS },
+    { 0, 0, "number_pad", NULL, GADONUMBERPAD },
+    { 0, 1, "null", NULL, GADONULL },
+    { 0, 1, "autopickup", NULL, GADOPICKUP },
+    { 0, 0, "rest_on_space", NULL, GADORESTONSPACE },
+    { 0, 1, "safepet", NULL, GADOSAFEPET },
+    { 0, 0, "showexp", NULL, GADOSHOWEXP },
+    { 0, 0, "showscore", NULL, GADOSHOWSCORE },
+    { 0, 1, "silent", NULL, GADOSILENT },
+    { 0, 1, "sortpack", NULL, GADOSORTPACK },
+    { 0, 1, "sound", NULL, GADOSOUND },
+    { 0, 0, "standout", NULL, GADOSTANDOUT },
+    { 0, 0, "time", NULL, GADOTIME },
+    { 0, 1, "tombstone", NULL, GADOTOMBSTONE },
+    { 0, 1, "verbose", NULL, GADOVERBOSE },
+    { 0, 0, "asksavedisk", NULL, GADOASKSAVE },
+    { 0, 0, "name", "", GADONAME },
+    { 0, 0, "score", "", GADOSCORE },
+    { 0, 0, "palette", "", GADOPALETTE },
+    { 0, 0, "windowtype", "", GADOWINDOWTYPE },
+    { 0, 0, "msghistory", "", GADOMSGHISTORY },
+    { 0, 0, "pickup_types", "", GADOPICKUPTYPES },
+    { 0, 0, "pettype", "", GADOPETTYPE },
+    { 0, 0, "packorder", "", GADOPACKORDER },
+    { 0, 0, "dogname", "", GADODOGNAME },
+    { 0, 0, "catname", "", GADOCATNAME },
+    { 0, 0, "fruit", "", GADOFRUIT },
+    { 0, 0, "objects", "", GADOOBJECTS },
+    { 0, 0, NULL, NULL, -1 }
+};
+
+char *players[ ] =
+{
+    "Random",
+    "Archeologist",
+    "Barbarian",
+    "CaveMan",
+    "Elf",
+    "Healer",
+    "Knight",
+/*    "Monk", */
+    "Priest",
+    "Rogue",
+/*    "Ranger", */
+    "Samurai",
+    "Tourist",
+    "Valkyrie",
+    "Wizard",
+    NULL
+};
+
+char *options[ NUMIDX + 1 ] =
+{
+    "Nethack:",				/* PATH_IDX */
+    "",					/* OPTIONS_IDX */
+    "Nethack:",				/* HACKDIR_IDX */
+    "Nethack:levels",			/* LEVELS_IDX */
+    "Nethack:save",			/* SAVE_IDX */
+    "AAA,FFF,620,B08,181,C06,23E,D00",	/* PENS_IDX */
+
+    NULL,				/* Terminating option */
+};
+
+USHORT __chip up_renderdata[] = {
+/* Plane 0 */
+   0xfff0,
+   0x8700,
+   0x8f80,
+   0xbfe0,
+   0x8000,
+
+/* Plane 1 */
+   0x0008,
+   0x0708,
+   0x0f88,
+   0x3fe8,
+   0x7ff8,
+
+};
+
+USHORT __chip tall_up_renderdata[] = {
+/* Plane 0 */
+   0xfff0,
+   0x8700,
+   0x8700,
+   0x8700,
+   0x8f80,
+   0x8f80,
+   0xbfe0,
+   0xbfe0,
+   0xbfe0,
+   0x8000,
+
+/* Plane 1 */
+   0x0008,
+   0x0708,
+   0x0708,
+   0x0708,
+   0x0f88,
+   0x0f88,
+   0x3fe8,
+   0x3fe8,
+   0x3fe8,
+   0x7ff8,
+
+};
+
+struct Image tall_up_renderimage = {
+   0, 0,
+   13, 10, 2,
+   tall_up_renderdata,
+   3,0,
+   NULL
+};
+
+struct Image up_renderimage = {
+   0, 0,
+   13, 5, 2,
+   up_renderdata,
+   3,0,
+   NULL
+};
+
+USHORT __chip tall_up_selectdata[] = {
+/* Plane 0 */
+   0x0008,
+   0x78f8,
+   0x78f8,
+   0x78f8,
+   0x7078,
+   0x7078,
+   0x4018,
+   0x4018,
+   0x4018,
+   0xfff8,
+/* Plane 1 */
+   0xfff0,
+   0xf8f0,
+   0xf8f0,
+   0xf8f0,
+   0xf070,
+   0xf070,
+   0xc010,
+   0xc010,
+   0xc010,
+   0x0000
+};
+
+USHORT __chip up_selectdata[] = {
+/* Plane 0 */
+   0x0008,
+   0x78f8,
+   0x7078,
+   0x4018,
+   0xfff8,
+/* Plane 1 */
+   0xfff0,
+   0xf8f0,
+   0xf070,
+   0xc010,
+   0x0000
+};
+
+struct Image up_selectimage = {
+   0, 0,
+   13, 5, 2,
+   up_selectdata,
+   3,0,
+   NULL
+};
+
+struct Image tall_up_selectimage = {
+   0, 0,
+   13, 10, 2,
+   tall_up_selectdata,
+   3,0,
+   NULL
+};
+
+USHORT __chip down_renderdata[] = {
+/* Plane 0 */
+   0xfff0,
+   0xbfe0,
+   0x8f80,
+   0x8700,
+   0x8000,
+
+/* Plane 1 */
+   0x0008,
+   0x3fe8,
+   0x0f88,
+   0x0708,
+   0x7ff8,
+
+};
+
+USHORT __chip tall_down_renderdata[] = {
+/* Plane 0 */
+   0xfff0,
+   0xbfe0,
+   0xbfe0,
+   0xbfe0,
+   0x8f80,
+   0x8f80,
+   0x8700,
+   0x8700,
+   0x8700,
+   0x8000,
+
+/* Plane 1 */
+   0x0008,
+   0x3fe8,
+   0x3fe8,
+   0x3fe8,
+   0x0f88,
+   0x0f88,
+   0x0708,
+   0x0708,
+   0x0708,
+   0x7ff8
+};
+
+struct Image tall_down_renderimage = {
+   0, 0,
+   13, 10, 2,
+   tall_down_renderdata,
+   3,0,
+   NULL
+};
+
+struct Image down_renderimage = {
+   0, 0,
+   13, 5, 2,
+   down_renderdata,
+   3,0,
+   NULL
+};
+
+USHORT __chip down_selectdata[] = {
+/* Plane 0 */
+   0x0008,
+   0x4018,
+   0x7078,
+   0x78f8,
+   0x7ff8,
+/* Plane 1 */
+   0xfff0,
+   0xc010,
+   0xf070,
+   0xf8f0,
+   0x8000
+};
+
+USHORT __chip tall_down_selectdata[] = {
+/* Plane 0 */
+   0x0008,
+   0x4018,
+   0x4018,
+   0x4018,
+   0x7078,
+   0x7078,
+   0x78f8,
+   0x78f8,
+   0x78f8,
+   0x7ff8,
+/* Plane 1 */
+   0xfff0,
+   0xc010,
+   0xc010,
+   0xc010,
+   0xf070,
+   0xf070,
+   0xf8f0,
+   0xf8f0,
+   0xf8f0,
+   0x8000
+};
+
+struct Image tall_down_selectimage = {
+   0, 0,
+   13, 10, 2,
+   tall_down_selectdata,
+   3,0,
+   NULL
+};
+
+struct Image down_selectimage = {
+   0, 0,
+   13, 5, 2,
+   down_selectdata,
+   3,0,
+   NULL
+};
+
+USHORT __chip leftimg[] =
+{
+    0x0380, 0x0000,
+    0x0f80, 0x0000,
+    0x3fff, 0xff00,
+    0xffff, 0xff00,
+    0x3fff, 0xff00,
+    0x0f80, 0x0000,
+    0x0380, 0x0000
+};
+
+USHORT __chip rightimg[] =
+{
+    0x0001, 0xc000,
+    0x0001, 0xf000,
+    0xffff, 0xfc00,
+    0xffff, 0xff00,
+    0xffff, 0xfc00,
+    0x0001, 0xf000,
+    0x0001, 0xc000
+};
+
+struct Image leftarrow =
+{
+    0, 0,
+    24, 7, 1,
+    leftimg,
+    2, 0,
+    NULL
+};
+
+struct Image rightarrow =
+{
+    0, 0,
+    24, 7, 1,
+    rightimg,
+    2, 0,
+    NULL
+};
+
+struct Image dnleftarrow =
+{
+    0, 0,
+    24, 7, 1,
+    leftimg,
+    1, 0,
+    NULL
+};
+
+struct Image dnrightarrow =
+{
+    0, 0,
+    24, 7, 1,
+    rightimg,
+    1, 0,
+    NULL
+};
+
+struct MsgPort
+    *dosport;
+
+PLANEPTR
+    tmprasp;
+
+GPTR
+    lastgaddown,	/* Last game gadget user selected */
+    globgptr,
+    windowgads,		/* What is currently attached to the window */
+    gamehead,		/* Pointer to active games */
+    gameavail;		/* Pointer to available allocations */
+
+int
+    wbopen = 0,		/* Is workbench open? */
+    shutdown = 0,	/* Close down workbench during game option */
+    errup = 0,		/* Error message on line */
+    cols = 0,		/* Total columns */
+    vcols = 0,		/* Columns visible */
+    scol = -1,		/* Starting column */
+    height,		/* Height of window */
+    width,		/* Width of window */
+    curcol = 0,		/* Offset to first display column */
+    active_count;	/* Number of games active */
+
+flag
+    quit=0;		/* time to cleanup */
+
+struct Window *win;	/* the window we create */
diff -Pru nethack-3.4.1/sys/amiga/wbdefs.h nethack/sys/amiga/wbdefs.h
--- nethack-3.4.1/sys/amiga/wbdefs.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbdefs.h	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,228 @@
+/*    SCCS Id: @(#)wbdefs.h     3.1    93/01/08
+/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#include <exec/types.h>
+#include <exec/memory.h>
+#include <graphics/gfxmacros.h>
+#include <graphics/gfxbase.h>
+#include <workbench/workbench.h>
+#include <workbench/startup.h>
+#include <intuition/intuition.h>
+#include <intuition/intuitionbase.h>
+
+#ifdef AZTEC_C
+#include <libraries/dosextens.h>
+#include <functions.h>
+#else
+#ifdef _DCC
+#include <clib/exec_protos.h>
+#include <clib/dos_protos.h>
+#include <clib/intuition_protos.h>
+#include <clib/icon_protos.h>
+#include <clib/graphics_protos.h>
+#else
+#include <proto/exec.h>
+#include <proto/dos.h>
+#include <proto/intuition.h>
+#include <proto/icon.h>
+#include <proto/graphics.h>
+#endif
+#endif
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+
+#ifdef  IDCMP_CLOSEWINDOW
+#include <graphics/displayinfo.h>
+#ifndef	INTUI_NEW_LOOK
+#define INTUI_NEW_LOOK  1
+#endif
+#endif
+
+#define R_DISK		1   /* Refresh reasons */
+#define R_WINDOW	2
+#define R_SCROLL	3
+
+#define PLAYERMENU	0
+
+#define MENU_PROJECT	0   /* so we can shuffle them around easily */
+#define ITEM_HELP	0
+#define ITEM_ABOUT	1
+#define ITEM_SCORES	2
+#define ITEM_RECOVER	3
+#define ITEM_CONFIG	4
+#define ITEM_QUIT	5
+
+#define MENU_GAME	1
+#define ITEM_INFO	0
+#define ITEM_COPYOPT	1
+#define ITEM_DISCARD	2
+#define ITEM_RENAME	3
+
+#define GADSCROLL	1   /* The scroll bar */
+#define GADNEWGAME	2   /* New Game requested */
+
+#define GADSCRLUP	3   /* Scroll Up Gadget */
+#define GADSCRLDOWN	4   /* Scroll Down Gadget */
+#define GADINFOSCRL	5   /* The scroll bar */
+
+#define GADQUESTYES	6
+#define GADQUESTNO	7
+
+#define GADCOMSTR	8
+
+#define GADCHARNAME	9
+#define GADOUTFILE	10
+#define GADCATNAME	11
+#define GADDOGNAME	12
+
+#define GADSTRSAVE	15
+#define GADSTRLEVELS	16
+#define GADSTRPATH	17
+#define GADSTRPENS	18
+#define GADSTRHACKDIR	19
+#define GADCONFSAVE	21
+#define GADCONFLOAD	22
+#define GADCONFNAME	23
+#define GADTOOLUP	24
+#define GADTOOLDOWN	25
+#define GADADDTOOL	26
+#define GADDELTOOL	27
+#define GADTOOLTYPES	28
+#define GADSTRCANCEL	29
+#define GADHELPOKAY	30
+#define GADHELPFRWD	31
+#define GADHELPBKWD	32
+#define GADEDITOPTS	33
+
+#define GADRESTDIR	34
+#define GADRESTOLD	35
+#define GADRESTNEW	36
+#define GADRESTCAN	37
+#define GADRESTOKAY	38
+#define GADSAVEINFO	39
+#define GADUSEINFO	40
+#define GADQUITINFO	41
+#define GADPLNAME	42
+
+#define GADOPTOKAY	243
+#define GADOPTCANCEL	244
+
+/*
+ *  Option gadgets GadgetID's
+ */
+#define GADOCOLOR	101
+#define GADOCONFIRM	102
+#define GADODISCLOSE	103
+#define GADOFIXINV	104
+#define GADONULL	105
+#define GADOTIME	106
+#define GADONEWS	107
+#define GADOHELP	108
+#define GADOFLUSH	109
+#define GADORESTONSPACE	110
+#define GADOPICKUP	111
+#define GADOSOUND	112
+#define GADONUMBERPAD	113
+#define GADOSAFEPET	114
+#define GADOSILENT	115
+#define GADOTOMBSTONE	116
+#define GADOVERBOSE	117
+#define GADOSTANDOUT	118
+#define GADOSORTPACK	119
+#define GADOFEMALE	120
+#define GADOIGNINTR	121
+#define GADOPACKORDER	122
+#define GADODOGNAME	123
+#define GADOCATNAME	124
+#define GADOFRUIT	125
+#define GADOOBJECTS	126
+#define GADOASKSAVE	127
+#define GADOCANCEL	128
+#define GADOOKAY	129
+#define GADOCHKPOINT	130
+#define GADOHILITEPET	131
+#define GADOLEGACY	132
+#define GADOLITCORRIDOR	133
+#define GADOSHOWEXP	134
+#define GADOSHOWSCORE	135
+#define	GADONAME	136
+#define	GADOSCORE	137
+#define	GADOPALETTE	138
+#define	GADOWINDOWTYPE	139
+#define	GADOMSGHISTORY	140
+#define	GADOPICKUPTYPES	141
+#define	GADOPETTYPE	142
+
+/* Definition of workbench size layout */
+
+#define ORIGINX ( win->BorderLeft + 5 )
+#define ORIGINY ( win->BorderTop + Message.Height + 5 )
+#define CORNERX ( win->Width - win->BorderRight )
+#define CORNERY ( win->Height - win->BorderBottom )
+
+/* String buffer in String Gadget */
+
+#define Sbuff(gd)	(((struct StringInfo*)((gd)->SpecialInfo))->Buffer)
+
+/* The string gadgets' buffers */
+
+#define StrPath		(Sbuff(&Conf_StrPath))
+#define StrOptions	(Sbuff(&Conf_StrOptions))
+#define StrHackdir	(Sbuff(&Conf_StrHackdir))
+#define StrPens		(Sbuff(&Conf_StrPens))
+#define StrLevels	(Sbuff(&Conf_StrLevels))
+#define StrSave		(Sbuff(&Conf_StrSave))
+#define StrConf		(Sbuff(&Conf_ConfigName))
+
+#define RstDir		(Sbuff(&Rst_RestDir))
+#define RstOld		(Sbuff(&Rst_RestOld))
+#define RstNew		(Sbuff(&Rst_RestNew))
+
+#define StrString	(Sbuff(&Str_String))
+
+#define StrTools	(Sbuff(&Info_ToolTypes))
+#define StrPlayer	(Sbuff(&Info_Player))
+
+#define GAMEIMAGE	"HackExe:NetHack"
+#define GAMESTACK	50000
+
+#define PATH_IDX	0
+#define OPTIONS_IDX	1
+#define HACKDIR_IDX	2
+#define LEVELS_IDX	3
+#define SAVE_IDX	4
+#define PENS_IDX	5
+
+#define NUMIDX		6
+
+#define PL_RANDOM	0
+#define PL_ARCHEOLOGIST	1
+#define PL_BARBARIAN	2
+#define PL_CAVEMAN	3
+#define PL_ELF		4
+#define PL_HEALER	5
+#define PL_KNIGHT	6
+#define PL_PRIEST	7
+#define PL_ROGUE	8
+#define PL_SAMURAI	9
+#define PL_TOURIST	10
+#define PL_VALKYRIE	11
+#define PL_WIZARD	12
+
+#define MENUITEMNO( menu, itm, sitm ) FULLMENUNUM( menu, itm, sitm )
+#define GADWIDTH( gad )     max((gad)->Width, \
+		    strlen((gad)->GadgetText->IText) * win->RPort->TxWidth)
+
+/* Horizontal space between gadgets */
+#define GADINCX		10
+
+/* Vertical space between gadgets */
+#define GADINCY		(win->RPort->TxHeight + 1)
+
+#define NO_FLASH	0
+#define FLASH		1
diff -Pru nethack-3.4.1/sys/amiga/wbgads.c nethack/sys/amiga/wbgads.c
--- nethack-3.4.1/sys/amiga/wbgads.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbgads.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,654 @@
+/*    SCCS Id: @(#)wbgads.c     1.0   93/04/18			  */
+/*    Copyright (c) Gregg Wonderly, Naperville IL, 1993	  	  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/* wbgads.c */
+static void GadSpaceOut(struct OPTGAD *gads , int row , int maxx);
+static void CompSpaceOut(struct OPTGAD *gads , int row , int maxx);
+
+extern NEARDATA struct flag flags;
+
+#define INITX	7
+#define GADBORD	3
+#define	YSPACE	2
+#define XSPACE	3
+
+#define MAXGADSTRLEN	2000
+
+static char undobuffer[ MAXGADSTRLEN + 1 ];
+
+static struct TextAttr textfont;
+static int compgadid;
+
+char **compvals;
+
+#ifdef	TESTING
+void SetBorder( register struct Gadget *gd, int val );
+
+main( argc, argv )
+    int argc;
+    char **argv;
+{
+    int done = 0;
+    struct IntuiMessage *imsg;
+    struct Window *w;
+    struct Screen *screen;
+    int cury = -1, gadid = 1;
+    struct OPTGAD *gp, *boolgads, *compgads;
+
+    screen = LockPubScreen( NULL );
+    UnlockPubScreen( NULL, screen );
+
+    w = OpenWindowTags( NULL,
+	WA_IDCMP, IDCMP_CLOSEWINDOW|IDCMP_NEWSIZE|IDCMP_SIZEVERIFY,
+	WA_Flags, WFLG_DRAGBAR|WFLG_SIZEGADGET|WFLG_DEPTHGADGET|
+		  WFLG_CLOSEGADGET,
+	WA_SmartRefresh, 1,
+	WA_NoCareRefresh, 1,
+	WA_MinWidth, 100,
+	WA_MinHeight, 50,
+	WA_PubScreen, screen,
+	WA_Width, 640,
+	WA_Height, 400,
+	WA_Top, 0,
+	WA_Left, 0,
+	TAG_DONE );
+
+    if( w )
+    {
+	textfont.ta_Name = w->RPort->Font->tf_Message.mn_Node.ln_Name;
+	textfont.ta_YSize = w->RPort->Font->tf_YSize;
+	textfont.ta_Style = w->RPort->Font->tf_Style;
+	textfont.ta_Flags = w->RPort->Font->tf_Flags;
+	boolgads = LayoutBoolOpts( w->Width - w->BorderLeft - w->BorderRight - 5,
+			w->Height - w->BorderTop - w->BorderBottom - 6,
+			w->RPort, &cury, &gadid );
+	if( boolgads )
+	{
+	    for( gp = boolgads; gp; gp = gp->next )
+		AddGList( w, &gp->gad, 0, 1, NULL );
+	    RefreshGList( w->FirstGadget, w, NULL, -1 );
+	}
+	compgads = LayoutCompOpts( w->Width - w->BorderLeft - w->BorderRight - 5,
+			w->Height - w->BorderTop - w->BorderBottom - 6, w->RPort,
+			&cury, &gadid );
+	if( compgads )
+	{
+	    for( gp = compgads; gp; gp = gp->next )
+		AddGList( w, &gp->gad, 0, 1, NULL );
+	    RefreshGList( w->FirstGadget, w, NULL, -1 );
+	}
+    }
+
+    while( !done && w )
+    {
+	WaitPort( w->UserPort );
+	while( imsg = (struct IntuiMessage *) GetMsg( w->UserPort ) )
+	{
+	    if( imsg->Class == CLOSEWINDOW )
+		    done = 1;
+	    else if( imsg->Class == SIZEVERIFY )
+	    {
+		for( gp = boolgads; gp; gp = gp->next )
+		    RemoveGList( w, &gp->gad, 1 );
+		FreeBoolOpts( boolgads );
+		for( gp = compgads; gp; gp = gp->next )
+		    RemoveGList( w, &gp->gad, 1 );
+		FreeCompOpts( compgads );
+	    }
+	    else if( imsg->Class == NEWSIZE )
+	    {
+	    	cury = -1;
+		gadid = 1;
+		SetAPen( w->RPort, 0 );
+		SetBPen( w->RPort, 0 );
+		SetDrMd( w->RPort, JAM2 );
+		RectFill( w->RPort, w->BorderLeft, w->BorderTop,
+				    w->Width - w->BorderRight - 1,
+				    w->Height - w->BorderBottom - 1 );
+		SetAPen( w->RPort, 1 );
+		SetBPen( w->RPort, 0 );
+		boolgads = LayoutBoolOpts( w->Width - w->BorderLeft - w->BorderRight - 5,
+		    w->Height - w->BorderTop - w->BorderBottom - 6, w->RPort,
+			&cury, &gadid );
+		for( gp = boolgads; gp; gp = gp->next )
+		    AddGList( w, &gp->gad, 0, 1, NULL );
+		compgads = LayoutCompOpts( w->Width - w->BorderLeft - w->BorderRight - 5,
+		    w->Height - w->BorderTop - w->BorderBottom - 6, w->RPort,
+			&cury, &gadid );
+		for( gp = compgads; gp; gp = gp->next )
+		    AddGList( w, &gp->gad, 0, 1, NULL );
+		RefreshGList( w->FirstGadget, w, NULL, -1 );
+	    }
+
+	    ReplyMsg( (struct Message *)imsg );
+	}
+    }
+    if( w ) CloseWindow( w );
+    if( boolgads ) FreeBoolOpts( boolgads );
+    if( compgads ) FreeCompOpts( compgads );
+
+    return( 0 );
+}
+
+#endif
+
+int AllocCompVals( void )
+{
+    int i;
+    if( compvals == 0 )
+    {
+	for( i = 0; compopt[ i ].name; ++i )
+	    continue;
+	compvals = malloc( (i+1) * sizeof( char * ) );
+	if( compvals == 0 )
+	    return 0;
+	for( i = 0; compopt[ i ].name; ++i )
+	{
+	    if( ( compvals[ i ] = malloc( compopt[ i ].size + 1 ) ) == NULL )
+		return 0;
+	    *compvals[ i ] = 0;
+	}
+
+	/* Create a null pointer terminator */
+	compvals[ i ] = 0;
+    }
+    return 1;
+}
+
+struct OPTGAD *
+LayoutCompOpts( maxx, maxy, rp, cury, gadid )
+    int maxx, maxy;
+    struct RastPort *rp;
+    int *cury;
+    int *gadid;
+
+{
+    int len;
+    struct OPTGAD *gp;
+    char *bp;
+    struct Gadget *gd;
+    struct StringInfo *sp;
+    struct OPTGAD *compgads;
+    struct IntuiText *ip;
+    int i, curx;
+    int incy;
+
+    compgadid = *gadid;
+    incy = rp->TxHeight + GADBORD + YSPACE;
+
+    compgads = 0;
+    curx = INITX;
+
+    /* The value of 8 used here is not related to GADBORD!
+     * It is an estimate of screen->WBorTop + 1, with some
+     * extra white space for a border between the top
+     * of the window and the gadgets.
+     */
+
+    textfont.ta_Name = rp->Font->tf_Message.mn_Node.ln_Name;
+    textfont.ta_YSize = rp->Font->tf_YSize;
+    textfont.ta_Style = rp->Font->tf_Style;
+    textfont.ta_Flags = rp->Font->tf_Flags;
+
+    if( *cury == -1 )
+	*cury = rp->TxHeight + 4;
+
+    if( AllocCompVals() == 0 )
+    	return( NULL );
+    
+    for( i = 0; compopt[ i ].name; ++i )
+    {
+	len = ( ( maxx - 20 - GADBORD ) / 2 ) + GADBORD;
+
+	if( curx + len > maxx )
+	{
+	    CompSpaceOut( compgads, *cury, maxx );
+	    curx = INITX;
+	    *cury += incy;
+	}
+
+	gp = malloc( sizeof( *gp ) );
+	ip = malloc( sizeof( *ip ) );
+	sp = malloc( sizeof( *sp ) );
+	bp = malloc( compopt[i].size + 1 );
+	if( !gp || !ip || !sp || !bp )
+	{
+	    if( gp ) free( gp );
+	    if( ip ) free( ip );
+	    if( sp ) free( sp );
+	    if( bp ) free( bp );
+	    FreeCompOpts( compgads );
+	    return( NULL );
+	}
+	memset( gp, 0, sizeof( *gp ) );
+	memset( ip, 0, sizeof( *ip ) );
+	memset( sp, 0, sizeof( *sp ) );
+	gd = &gp->gad;
+	gd->LeftEdge = curx + TextLength( rp, (char *)compopt[ i ].name,
+			    strlen( (char *)compopt[ i ].name ) ) + 10;
+	curx += len + GADBORD;
+	gd->Width = len - (TextLength( rp, (char *)compopt[ i ].name,
+			    strlen( (char *)compopt[ i ].name ) ) + 10 );
+	gd->TopEdge = *cury;
+	gd->Height = incy - (YSPACE * 2);
+	gd->Flags = GADGHCOMP;
+	gd->Activation = RELVERIFY;
+	gd->GadgetType = STRGADGET;
+	gd->GadgetRender = gd->SelectRender = 0;
+	gd->GadgetText = ip;
+	gd->MutualExclude = 0;
+	gd->SpecialInfo = (APTR)sp;
+
+	sp->Buffer = bp;
+	memcpy( bp, compvals[ i ], compopt[i].size );
+	bp[ compopt[i].size ] = 0;
+	sp->UndoBuffer = undobuffer;
+	sp->MaxChars = compopt[i].size;
+	gp->val = bp;
+
+	gd->GadgetID = (*gadid)++;
+	gd->UserData = 0;
+	gp->next = compgads;
+	compgads = gp;
+
+	ip->FrontPen = 1;
+	ip->BackPen = 0;
+	ip->DrawMode = JAM1;
+	ip->LeftEdge = -( TextLength( rp, (char *)compopt[ i ].name,
+			    strlen( (char *)compopt[ i ].name ) ) + 10);
+	ip->TopEdge = ((gd->Height - rp->TxHeight)/2);
+	ip->ITextFont = &textfont;	/* rp->Font will be used */
+	ip->IText = (char *)compopt[ i ].name;
+	ip->NextText = 0;
+	SetBorder( gd, 0 );
+    }
+
+    /* Perhaps leave last row ragged? */
+    if( curx != INITX )
+	CompSpaceOut( compgads, *cury, maxx );
+
+    *cury += incy;
+    return( compgads );
+}
+
+struct OPTGAD *
+LayoutBoolOpts( maxx, maxy, rp, cury, gadid )
+    int maxx, maxy;
+    struct RastPort *rp;
+    int *cury;
+    int *gadid;
+{
+    int len;
+    struct OPTGAD *gp;
+    struct Gadget *gd;
+    struct OPTGAD *boolgads;
+    struct IntuiText *ip;
+    int i, curx;
+    int incy;
+
+    incy = rp->TxHeight + GADBORD + YSPACE;
+
+    boolgads = 0;
+    curx = INITX;
+
+    /* The value of 5 used here is not related to GADBORD!
+     * It is an estimate of screen->WBorTop + 1, with some
+     * extra white space for a border are between the top
+     * of the window and the gadgets.
+     */
+
+    if( *cury == -1 )
+	*cury = rp->TxHeight + 5;
+
+    textfont.ta_Name = rp->Font->tf_Message.mn_Node.ln_Name;
+    textfont.ta_YSize = rp->Font->tf_YSize;
+    textfont.ta_Style = rp->Font->tf_Style;
+    textfont.ta_Flags = rp->Font->tf_Flags;
+
+    for( i = 0; boolopt[ i ].name; ++i )
+    {
+    	/* Null pointers indicate options which we do not have available to us */
+    	if( boolopt[ i ].addr == NULL )
+    	{
+	    (*gadid)++;
+	    continue;
+    	}
+	len = TextLength( rp, (char *)boolopt[ i ].name,
+			    strlen( (char *)boolopt[ i ].name ) );
+
+	if( curx + len > maxx )
+	{
+	    GadSpaceOut( boolgads, *cury, maxx );
+	    curx = INITX;
+	    *cury += incy;
+	}
+
+	gp = malloc( sizeof( *gp ) );
+	ip = malloc( sizeof( *ip ) );
+	if( !gp || !ip )
+	{
+	    if( gp ) free( gp );
+	    if( ip ) free( ip );
+	    FreeBoolOpts( boolgads );
+	    return( NULL );
+	}
+	memset( gp, 0, sizeof( *gp ) );
+	memset( ip, 0, sizeof( *ip ) );
+	gd = &gp->gad;
+	gd->LeftEdge = curx;
+	curx += len + GADBORD + XSPACE;
+	gd->Width = len + GADBORD;
+	gd->TopEdge = *cury;
+	gd->Height = incy - YSPACE;
+	gd->Flags = GFLG_GADGHCOMP;
+	if( *boolopt[ i ].addr == TRUE )
+	    gd->Flags |= GFLG_SELECTED;
+	gd->Activation = GACT_IMMEDIATE|GACT_TOGGLESELECT|GACT_RELVERIFY;
+	gd->GadgetType = GTYP_BOOLGADGET;
+	gd->GadgetRender = gd->SelectRender = 0;
+	gd->GadgetText = ip;
+	gd->MutualExclude = 0;
+	gd->SpecialInfo = 0;
+	gd->GadgetID = (*gadid)++;
+	gd->UserData = 0;
+	gp->next = boolgads;
+	boolgads = gp;
+
+	ip->FrontPen = 1;
+	ip->BackPen = 0;
+	ip->DrawMode = JAM1;
+	ip->LeftEdge = (gd->Width - len)/2;
+	ip->TopEdge = ((gd->Height - rp->TxHeight)/2) + 1;
+	ip->ITextFont = &textfont;	/* rp->Font will be used */
+	ip->IText = (char *)boolopt[ i ].name;
+	ip->NextText = 0;
+	SetBorder( gd, 1 );
+    }
+
+    /* Perhaps leave last row ragged? */
+    if( curx != INITX )
+	GadSpaceOut( boolgads, *cury, maxx );
+
+    *cury += incy + GADBORD;
+    return( boolgads );
+}
+
+static void
+CompSpaceOut( gads, row, maxx )
+    struct OPTGAD *gads;
+    int row, maxx;
+{
+    struct Gadget *gd;
+    struct OPTGAD *gp;
+    int cnt, tlen;
+
+    tlen = cnt = 0;
+
+    for( gp = gads; gp; gp = gp->next )
+    {
+	if( gp->gad.TopEdge == row+1 )
+	    ++cnt;
+    }
+
+    if( cnt > 1)
+    {
+	for( gp = gads; gp; gp = gp->next )
+	{
+	    gd = &gp->gad;
+	    if( gd->TopEdge == row+1 && cnt != 0 )
+	    {
+		if( gd->LeftEdge > maxx/2 )
+		    gd->LeftEdge += maxx - (gd->LeftEdge + gd->Width) + 2;
+	    }
+	}
+    }
+}
+
+static void
+GadSpaceOut( gads, row, maxx )
+    struct OPTGAD *gads;
+    int row, maxx;
+{
+    struct Gadget *gd;
+    struct OPTGAD *gp;
+    int cnt, tlen, mod, inc;
+
+    tlen = cnt = 0;
+
+    for( gp = gads; gp; gp = gp->next )
+    {
+	gd = &gp->gad;
+	if( gd->TopEdge == row )
+	{
+	    ++cnt;
+	    tlen += gd->Width + XSPACE;
+	}
+    }
+
+    if( tlen < maxx && cnt > 1)
+    {
+    	inc = ( maxx - tlen ) / (cnt-1);
+    	mod = ( maxx - tlen ) % (cnt-1);
+
+	for( gp = gads; gp; gp = gp->next )
+	{
+	    gd = &gp->gad;
+	    if( gd->TopEdge == row && cnt != 0 )
+	    {
+		gd->LeftEdge += (inc * --cnt);
+		if( mod )
+		    gd->LeftEdge += --mod;
+	    }
+	}
+    }
+}
+
+void
+FreeCompOpts( compgads )
+    register struct OPTGAD *compgads;
+{
+    register struct OPTGAD *gp;
+    register struct IntuiText *ip;
+    struct StringInfo *sp;
+    struct Gadget *gd;
+
+    while( gp = compgads )
+    {
+	compgads = compgads->next;
+	gd = &gp->gad;
+
+	if( ip = gd->GadgetText )
+	{
+	    if( ip->IText ) free( ip->IText );
+	    free( ip );
+	}
+	if( sp = (struct StringInfo *)gd->SpecialInfo )
+	{
+	    if( sp->Buffer )
+	    {
+		memcpy( compvals[ gd->GadgetID - compgadid ], sp->Buffer, sp->MaxChars );
+		free( sp->Buffer );
+	    }
+	    free( sp );
+	}
+	free( gp );
+    }
+}
+
+void
+FreeBoolOpts( boolgads )
+    register struct OPTGAD *boolgads;
+{
+    register struct OPTGAD *gp;
+    register struct IntuiText *ip;
+
+    while( gp = boolgads )
+    {
+	boolgads = boolgads->next;
+
+	if( ip = gp->gad.GadgetText )
+	{
+	    if( ip->IText ) free( ip->IText );
+	    free( ip );
+	}
+	free( gp );
+    }
+}
+
+#ifdef	TESTING
+/*
+ * Put a 3-D motif border around the gadget.  String gadgets or those
+ * which do not have highlighting are rendered down.  Boolean gadgets
+ * are rendered in the up position by default.
+ */
+
+void SetBorder( gd, val )
+    register struct Gadget *gd;
+    int val;
+{
+    register struct Border *bp;
+    register short *sp;
+    register int i;
+    int borders = 6;
+
+    /* Allocate two border structures one for up image and one for down
+     * image, plus vector arrays for the border lines.
+     */
+
+    if( gd->GadgetType == STRGADGET )
+	borders = 12;
+
+    if( ( bp = malloc( ( ( sizeof( struct Border ) * 2 ) +
+	    ( sizeof( short ) * borders ) ) * 2 ) ) == NULL )
+    {
+	return;
+    }
+
+    /* Remove any special rendering flags to avoid confusing intuition
+     */
+
+    gd->Flags &= ~(GADGHIGHBITS|GADGIMAGE|GRELWIDTH|
+		    GRELHEIGHT|GRELRIGHT|GRELBOTTOM);
+
+    sp = (short *)(bp + 4);
+    if( val == 0 || val == 2 ||
+	gd->GadgetType == STRGADGET || ( gd->GadgetType == BOOLGADGET &&
+		( gd->Flags & GADGHIGHBITS ) == GADGHNONE ) )
+    {
+	/* For a string gadget, we expand the border beyond the area where
+	 * the text will be entered.
+	 */
+
+	sp[0] = -1;
+	sp[1] = gd->Height - 1;
+	sp[2] = -1;
+	sp[3] = -1;
+	sp[4] = gd->Width + 1;
+	sp[5] = -1;
+
+	sp[6] = gd->Width + 3;
+	sp[7] = -2;
+	sp[8] = gd->Width + 3;
+	sp[9] = gd->Height + 1;
+	sp[10] = -2;
+	sp[11] = gd->Height + 1;
+
+	sp[12] = -2;
+	sp[13] = gd->Height;
+	sp[14] = -2;
+	sp[15] = -2;
+	sp[16] = gd->Width + 2;
+	sp[17] = -2;
+	sp[18] = gd->Width + 2;
+	sp[19] = gd->Height;
+	sp[20] = -2;
+	sp[21] = gd->Height;
+
+	for( i = 0; i < 3; ++i )
+	{
+	    bp[ i ].LeftEdge = bp[ i ].TopEdge = -1;
+	    if( val == 2 )
+		bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? 2 : 1;
+	    else
+		bp[ i ].FrontPen = ( i == 0 || i == 1 ) ? 1 : 2;
+
+	    /* Have to use JAM2 so that the old colors disappear. */
+	    bp[ i ].BackPen = 0;
+	    bp[ i ].DrawMode = JAM2;
+	    bp[ i ].Count = ( i == 0 || i == 1 ) ? 3 : 5;
+	    bp[ i ].XY = &sp[ i*6 ];
+	    bp[ i ].NextBorder = ( i == 2 ) ? NULL : &bp[ i + 1 ];
+	}
+
+	/* Set the up image */
+	gd->GadgetRender = (APTR) bp;
+
+	/* Same image for select image */
+	gd->SelectRender = (APTR) bp;
+
+	gd->LeftEdge++;
+	gd->TopEdge++;
+	gd->Flags |= GADGHCOMP;
+    }
+    else
+    {
+	/* Create the border vector values for up and left side, and
+	 * also the lower and right side.
+	 */
+
+	sp[0] = 0;
+	sp[1] = gd->Height-1;
+	sp[2] = 0;
+	sp[3] = 0;
+	sp[4] = gd->Width-1;
+	sp[5] = 0;
+
+	sp[6] = gd->Width-1;
+	sp[7] = 0;
+	sp[8] = gd->Width-1;
+	sp[9] = gd->Height-1;
+	sp[10] = 0;
+	sp[11] = gd->Height-1;
+
+	/* We are creating 4 sets of borders, the two sides of the
+	 * rectangle share the border vectors with the opposite image,
+	 * but specify different colors.
+	 */
+
+	for( i = 0; i < 4; ++i )
+	{
+	    bp[ i ].TopEdge = bp[ i ].LeftEdge = 0;
+
+	    /* A GADGHNONE is always down */
+
+	    if( val != 3 && gd->GadgetType == BOOLGADGET &&
+		( gd->Flags & GADGHIGHBITS ) != GADGHNONE )
+	    {
+		bp[ i ].FrontPen =
+		    ( i == 1 || i == 2 ) ? 2 : 1;
+	    }
+	    else
+	    {
+		bp[ i ].FrontPen =
+		    ( i == 1 || i == 3 ) ? 1 : 2;
+	    }
+
+	    /* Have to use JAM2 so that the old colors disappear. */
+	    bp[ i ].BackPen = 0;
+	    bp[ i ].DrawMode = JAM2;
+	    bp[ i ].Count = 3;
+	    bp[ i ].XY = &sp[ 6 * ((i &1) != 0) ];
+	    bp[ i ].NextBorder =
+		( i == 1 || i == 3 ) ? NULL : &bp[ i + 1 ];
+	}
+
+	/* bp[0] and bp[1] two pieces for the up image */
+	gd->GadgetRender = (APTR) bp;
+
+	/* bp[2] and bp[3] two pieces for the down image */
+	gd->SelectRender = (APTR) (bp + 2);
+	gd->Flags |= GADGHIMAGE;
+    }
+}
+#endif
diff -Pru nethack-3.4.1/sys/amiga/wbprotos.h nethack/sys/amiga/wbprotos.h
--- nethack-3.4.1/sys/amiga/wbprotos.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbprotos.h	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,120 @@
+/*    SCCS Id: @(#)wbprotos.h   3.1    93/01/08
+/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#ifdef __STDC__
+# define P(s) s
+#else
+# define P(s) ()
+#endif
+
+
+/* wb.c */
+int main P(( int argc , char **argv ));
+void CopyRight P(( void ));
+void InitWB P(( int argc , struct WBStartup *wbs ));
+void ReadConfig P(( void ));
+void CloseDownWB P(( void ));
+void SetupWB P(( void ));
+void MapGadgets P(( int reason , int update ));
+void ClearWindow P(( struct Window *win ));
+void CalcLocs P(( int update ));
+void text_requester P(( struct NewWindow *newwin , struct IntuiText *tlist ));
+void getline P(( FILE *fp , long *offarr , int which , char *buf , int size ));
+void help_requester P(( char *file ));
+void do_closewindow P(( void ));
+void do_menu P(( struct Menu *mptr, int mcode ));
+void menu_discard P(( void ));
+void menu_copyopt P(( void ));
+void menu_rename P(( void ));
+void run_game P(( GPTR gptr ));
+void CleanUpLists P(( void ));
+void CloseLibraries P(( void ));
+void cleanup P(( int code ));
+void SafeCloseWindow P(( struct Window *window ));
+GPTR AllocGITEM P(( void ));
+void FreeGITEM P(( GPTR gptr ));
+void RemoveGITEM P(( GPTR ));
+struct DiskObject *AllocDObj P(( char *str ));
+void FreeDObj P(( struct DiskObject *doptr ));
+void LoadIcons P(( void ));
+void menu_scores P(( void ));
+void menu_recover P(( void ));
+void menu_config P(( void ));
+void menu_editdef P(( int newgame ));
+void do_gadgetup P(( struct IntuiMessage *imsg ));
+void do_buttons P(( struct IntuiMessage *imsg ));
+void do_gadgetdown P(( struct IntuiMessage *imsg ));
+int ask_request P(( char *str ));
+void setopt P(( GPTR ));
+void menu_info P(( void ));
+int IsEditEntry P(( char *, GPTR ));
+void menu_comment P(( void ));
+void text_request P(( char *str , char *file ));
+void errmsg P(( int flash , char *str, ... ));
+void SetGadgetUP P(( struct Gadget *gad ));
+void SetGadgetDOWN P(( struct Gadget *gad ));
+void UpdatePropGad P(( struct Window *win , struct Gadget *gad , long vis ,
+    long total , long top ));
+void *xmalloc P(( unsigned nbytes ));
+int DeleteGame P(( GPTR gptr ));
+GPTR FindGame P(( char *name ));
+void setoneopt P(( int idx , char *str ));
+char *dirname P(( char *str ));
+int StrRequest P(( char *prompt , char *buff , char *val ));
+int LoadDefaults P(( char *player ));
+void SaveDefaults P(( char *player ));
+void CopyDefs2Gad P(( void ));
+void CopyGad2Defs P(( void ));
+void UpdateTypes P(( struct Window *cwin ));
+void CheckOnly P(( struct Menu *menuptr , int menu , int itemno ));
+int Ask P(( char *quest ));
+char *GameName P(( GPTR gptr , char *file ));
+GPTR GetWBIcon P(( BPTR lock , char *dir , struct FileInfoBlock *finfo ));
+void SetBorder P(( struct Gadget *gd, int val ));
+GPTR NeedGame P(( void ));
+void ChgGameItems P(( struct Menu *menup , int enable ));
+void ChgNewGameItems P(( struct Menu *menup , int enable ));
+void ZapOptions P(( void ));
+int EditOptions P(( GPTR gptr ));
+struct Gadget *FindGadget P(( struct Window *window ,
+    struct NewWindow *newwindow , int id ));
+void CopyOptions P(( GPTR gptr ));
+void ParseOptionStr P(( char *str ));
+void SetOptions P(( GPTR gptr ));
+void PutOptions P(( GPTR gptr ));
+char *ToolsEntry P(( GPTR gptr , char *name ));
+void ReallocTools P(( GPTR gptr, int ));
+void FreeTools P(( GPTR gptr ));
+void DelToolLines P(( GPTR gptr , char *name ));
+void AddToolLine P(( GPTR gptr , char *name , char *value ));
+void SetToolLine P(( GPTR gptr , char *name , char *value ));
+void WriteDObj P(( GPTR gptr , long lock ));
+void UpdateGameIcon P(( GPTR gptr ));
+char *Strdup P(( char *str ));
+void Game2Defs P(( GPTR gptr ));
+int CheckAndCopy P(( char *, char * ));
+void ClearDelGames P(( void ));
+int FindChecked P(( register struct Menu *menuptr, register int menu ));
+void RPText P(( struct RastPort *rp, register char *s ));
+#ifdef  INTUI_NEW_LOOK
+struct Window *MyOpenWindow P(( struct ExtNewWindow *nw ));
+#else
+struct Window *MyOpenWindow P(( struct NewWindow *nw ));
+#endif
+void SetUpMenus( register struct Menu *mp, register struct Screen *scrn );
+void UpdateCnfFile( void );
+char *basename( char * );
+void flushIDCMP( struct MsgPort *);
+filecopy( char *, char * );
+/*void error(const char *);*/
+
+/* wbgads.c */
+struct OPTGAD * LayoutCompOpts( int maxx, int maxy, struct RastPort *rp,
+				int *cury, int *gadid );
+struct OPTGAD *LayoutBoolOpts( int maxx, int maxy, struct RastPort *rp,
+			    int *cury, int *gadid );
+void FreeBoolOpts( struct OPTGAD *boolgads );
+void FreeCompOpts( struct OPTGAD *compgads );
+
+#undef P
diff -Pru nethack-3.4.1/sys/amiga/wbstruct.h nethack/sys/amiga/wbstruct.h
--- nethack-3.4.1/sys/amiga/wbstruct.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbstruct.h	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,52 @@
+/*    SCCS Id: @(#)wbstruct.h   3.1    93/01/08
+/* Copyright (c) Kenneth Lorber, Bethesda, Maryland, 1992, 1993.  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * The NetHack WorkBench's typedef/struct definitions.
+ */
+typedef unsigned char flag;
+
+typedef struct GAMEITEM
+{
+    struct DiskObject *dobj;	/* Icon structure pointer */
+    char
+	*gname,			/* Process name running this game */
+	*name,			/* name of icon without .info */
+	*dname,			/* Directory where save file is */
+	*fname;			/* File name on disk with .sav */
+    struct GAMEITEM *nextwgad;  /* Next in list current visible */
+    struct GAMEITEM *next;      /* Next in complete list */
+    struct Process *prc;        /* Process running this game */
+    struct MsgPort *port;       /* Port to send message to */
+    struct MsgPort *prcport;    /* Port for process termination */
+    long secs, mics;		/* Double click times */
+    long oact, oflag;		/* orig Flags and activation for diskobj */
+    struct WBStartup *wbs;	/* WorkBench startup message to send */
+    struct WBArg *wba;		/* WorkBench args */
+    char **otools;		/* Original dobj->do_ToolTypes pointer */
+    BPTR lock;			/* Lock on game file */
+    int toolcnt;		/* Number of pointers allocated in dobj */
+    BPTR seglist;		/* Seglist of loaded game */
+    flag talloc;		/* ToolTypes have been reallocated */
+    flag active;		/* Is this game active */
+} GAMEITEM, *GPTR;
+
+typedef struct OPTIONS
+{
+    char optval;		/* Options current boolean value */
+    char defval;		/* The default boolean value nethack assumes */
+    char *name;			/* Name of the option. */
+    char *optstr;		/* Options current string value or "" */
+    int id;			/* GadgetID of gadget manipulating this
+				 * options value.
+				 */
+} OPTIONS, *OPTR;
+
+typedef struct OPTGAD
+{
+	struct Gadget gad;
+	char *val;
+	struct OPTGAD *next;
+} OPTGAD;
+
diff -Pru nethack-3.4.1/sys/amiga/wbwin.c nethack/sys/amiga/wbwin.c
--- nethack-3.4.1/sys/amiga/wbwin.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbwin.c	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,2460 @@
+static struct NewScreen NewScreenStructure = {
+	0,0,
+	640,200,
+	2,
+	0,2,
+	HIRES,
+	CUSTOMSCREEN,
+	NULL,
+	"NetHack WorkBench V3.1",
+	NULL,
+	NULL
+};
+
+#define NEWSCREENSTRUCTURE NewScreenStructure
+
+static USHORT Palette[] = {
+	0x0AAA,
+	0x0002,
+	0x0FFF,
+	0x016A
+#define PaletteColorCount 4
+};
+
+#define PALETTE Palette
+
+static UBYTE UNDOBUFFER[300];
+
+static SHORT BorderVectors1[] = {
+	0,0,
+	566,0
+};
+static struct Border Border1 = {
+	-1,11,
+	2,0,JAM1,
+	2,
+	BorderVectors1,
+	NULL
+};
+
+static struct IntuiText IText1 = {
+	3,0,JAM2,
+	6,1,
+	NULL,
+	"  ",
+	NULL
+};
+
+static struct Gadget Message = {
+	NULL,
+	5,12,
+	-26,10,
+	GADGHBOX+GADGHIMAGE+GRELWIDTH,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Border1,
+	NULL,
+	&IText1,
+	NULL,
+	NULL,
+	-1,
+	NULL
+};
+
+static struct PropInfo ScrollSInfo = {
+	AUTOKNOB+FREEHORIZ,
+	-1,-1,
+	-1,-1,
+};
+
+static struct Image Image1 = {
+	0,0,
+	531,2,
+	0,
+	NULL,
+	0x0000,0x0000,
+	NULL
+};
+
+static struct Gadget Scroll = {
+	&Message,
+	5,-7,
+	-26,6,
+	GRELBOTTOM+GRELWIDTH,
+	RELVERIFY+GADGIMMEDIATE+FOLLOWMOUSE+BOTTOMBORDER,
+	PROPGADGET,
+	(APTR)&Image1,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&ScrollSInfo,
+	GADSCROLL,
+	NULL
+};
+
+#define GadgetList1 Scroll
+
+static struct IntuiText IText2 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Rename",
+	NULL
+};
+
+static struct MenuItem MenuItem4 = {
+	NULL,
+	0,24,
+	103,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText2,
+	NULL,
+	'N',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText3 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Discard",
+	NULL
+};
+
+static struct MenuItem MenuItem3 = {
+	&MenuItem4,
+	0,16,
+	103,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText3,
+	NULL,
+	'D',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText4 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Copy Info",
+	NULL
+};
+
+static struct MenuItem MenuItem2 = {
+	&MenuItem3,
+	0,8,
+	103,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText4,
+	NULL,
+	'C',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText5 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Info",
+	NULL
+};
+
+static struct MenuItem MenuItem1 = {
+	&MenuItem2,
+	0,0,
+	103,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText5,
+	NULL,
+	'I',
+	NULL,
+	MENUNULL
+};
+
+static struct Menu Menu2 = {
+	NULL,
+	63,0,
+	35,0,
+	MENUENABLED,
+	"Game",
+	&MenuItem1
+};
+
+static struct IntuiText IText6 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Quit",
+	NULL
+};
+
+static struct MenuItem MenuItem10 = {
+	NULL,
+	0,40,
+	166,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText6,
+	NULL,
+	'Q',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText7 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Edit Configuration",
+	NULL
+};
+
+static struct MenuItem MenuItem9 = {
+	&MenuItem10,
+	0,32,
+	166,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText7,
+	NULL,
+	'E',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText8 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Recover",
+	NULL
+};
+
+static struct MenuItem MenuItem8 = {
+	&MenuItem9,
+	0,24,
+	166,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText8,
+	NULL,
+	'R',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText9 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Top Scores",
+	NULL
+};
+
+static struct MenuItem MenuItem7 = {
+	&MenuItem8,
+	0,16,
+	166,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText9,
+	NULL,
+	'S',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText10 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"About",
+	NULL
+};
+
+static struct MenuItem MenuItem6 = {
+	&MenuItem7,
+	0,8,
+	166,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText10,
+	NULL,
+	'A',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText IText11 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Help",
+	NULL
+};
+
+static struct MenuItem MenuItem5 = {
+	&MenuItem6,
+	0,0,
+	166,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&IText11,
+	NULL,
+	'H',
+	NULL,
+	MENUNULL
+};
+
+static struct Menu Menu1 = {
+	&Menu2,
+	0,0,
+	56,0,
+	MENUENABLED,
+	"Project",
+	&MenuItem5
+};
+
+#define MenuList1 Menu1
+
+static struct NewWindow NewWindowStructure1 = {
+	40,15,
+	565,148,
+	0,2,
+	NEWSIZE+MOUSEBUTTONS+MOUSEMOVE+GADGETDOWN+GADGETUP+MENUPICK+CLOSEWINDOW+RAWKEY+DISKINSERTED,
+	WINDOWSIZING+WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+SIZEBRIGHT+SIZEBBOTTOM+ACTIVATE+NOCAREREFRESH,
+	&Scroll,
+	NULL,
+	"Select Saved Game or New Game",
+	NULL,
+	NULL,
+	170,80,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Quest_BorderVectors2[] = {
+	0,0,
+	275,0,
+	275,22,
+	0,22,
+	0,0
+};
+static struct Border Quest_Border2 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Quest_BorderVectors2,
+	NULL
+};
+
+static struct Gadget Quest_Borders2 = {
+	NULL,
+	12,16,
+	274,21,
+	GADGHBOX+GADGHIMAGE,
+	NULL,
+	BOOLGADGET,
+	(APTR)&Quest_Border2,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	-1,
+	NULL
+};
+
+static SHORT Quest_BorderVectors3[] = {
+	0,0,
+	88,0,
+	88,12,
+	0,12,
+	0,0
+};
+static struct Border Quest_Border3 = {
+	-1,-1,
+	2,0,JAM1,
+	5,
+	Quest_BorderVectors3,
+	NULL
+};
+
+static struct IntuiText Quest_IText12 = {
+	3,0,JAM2,
+	35,2,
+	NULL,
+	"No",
+	NULL
+};
+
+static struct Gadget Quest_No = {
+	&Quest_Borders2,
+	199,43,
+	87,11,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Quest_Border3,
+	NULL,
+	&Quest_IText12,
+	NULL,
+	NULL,
+	GADQUESTNO,
+	NULL
+};
+
+static SHORT Quest_BorderVectors4[] = {
+	0,0,
+	88,0,
+	88,12,
+	0,12,
+	0,0
+};
+static struct Border Quest_Border4 = {
+	-1,-1,
+	2,0,JAM1,
+	5,
+	Quest_BorderVectors4,
+	NULL
+};
+
+static struct IntuiText Quest_IText13 = {
+	3,0,JAM2,
+	32,2,
+	NULL,
+	"Yes",
+	NULL
+};
+
+static struct Gadget Quest_Yes = {
+	&Quest_No,
+	12,43,
+	87,11,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Quest_Border4,
+	NULL,
+	&Quest_IText13,
+	NULL,
+	NULL,
+	GADQUESTYES,
+	NULL
+};
+
+#define Quest_GadgetList2 Quest_Yes
+
+static struct IntuiText Quest_IText14 = {
+	1,0,JAM2,
+	59,21,
+	NULL,
+	"Sure you want to QUIT?",
+	NULL
+};
+
+#define Quest_IntuiTextList2 Quest_IText14
+
+static struct NewWindow Quest_NewWindowStructure2 = {
+	174,60,
+	298,60,
+	0,3,
+	GADGETUP+CLOSEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Quest_Yes,
+	NULL,
+	"NetHack WorkBench Request",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Options_BorderVectors5[] = {
+	0,0,
+	72,0,
+	72,11,
+	0,11,
+	0,0
+};
+static struct Border Options_Border5 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Options_BorderVectors5,
+	NULL
+};
+
+static struct IntuiText Options_IText15 = {
+	3,0,JAM2,
+	15,1,
+	NULL,
+	"CANCEL",
+	NULL
+};
+
+static struct Gadget Options_Gadget7 = {
+	NULL,
+	-96,-15,
+	71,10,
+	GRELBOTTOM+GRELRIGHT,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Options_Border5,
+	NULL,
+	&Options_IText15,
+	NULL,
+	NULL,
+	GADOPTCANCEL,
+	NULL
+};
+
+static SHORT Options_BorderVectors6[] = {
+	0,0,
+	72,0,
+	72,11,
+	0,11,
+	0,0
+};
+static struct Border Options_Border6 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Options_BorderVectors6,
+	NULL
+};
+
+static struct IntuiText Options_IText16 = {
+	3,0,JAM2,
+	21,1,
+	NULL,
+	"OKAY",
+	NULL
+};
+
+static struct Gadget Options_Gadget6 = {
+	&Options_Gadget7,
+	13,-15,
+	71,10,
+	GRELBOTTOM,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Options_Border6,
+	NULL,
+	&Options_IText16,
+	NULL,
+	NULL,
+	GADOPTOKAY,
+	NULL
+};
+
+#define Options_GadgetList3 Options_Gadget6
+
+static struct IntuiText Options_IText17 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Cancel",
+	NULL
+};
+
+static struct MenuItem Options_MenuItem12 = {
+	NULL,
+	0,8,
+	82,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&Options_IText17,
+	NULL,
+	'C',
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Options_IText18 = {
+	3,1,COMPLEMENT,
+	0,0,
+	NULL,
+	"Save",
+	NULL
+};
+
+static struct MenuItem Options_MenuItem11 = {
+	&Options_MenuItem12,
+	0,0,
+	82,8,
+	ITEMTEXT+COMMSEQ+ITEMENABLED+HIGHCOMP,
+	0,
+	(APTR)&Options_IText18,
+	NULL,
+	'S',
+	NULL,
+	MENUNULL
+};
+
+static struct Menu Options_Menu2 = {
+	NULL,
+	0,0,
+	56,0,
+	MENUENABLED,
+	"Project",
+	&Options_MenuItem11
+};
+
+#define Options_MenuList3 Options_Menu2
+
+static struct NewWindow Options_NewWindowStructure3 = {
+	0,21,
+	640,156,
+	0,1,
+	SIZEVERIFY+NEWSIZE+MOUSEBUTTONS+GADGETDOWN+GADGETUP+MENUPICK+CLOSEWINDOW+RAWKEY+DISKINSERTED+DISKREMOVED+ACTIVEWINDOW+VANILLAKEY,
+	WINDOWSIZING+WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Options_Gadget6,
+	NULL,
+	"Edit Options",
+	NULL,
+	NULL,
+	200,50,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Conf_BorderVectors7[] = {
+	0,0,
+	52,0,
+	52,11,
+	0,11,
+	0,0
+};
+static struct Border Conf_Border7 = {
+	-1,-1,
+	2,0,JAM1,
+	5,
+	Conf_BorderVectors7,
+	NULL
+};
+
+static struct IntuiText Conf_IText19 = {
+	1,0,JAM2,
+	10,2,
+	NULL,
+	"Save",
+	NULL
+};
+
+static struct Gadget Conf_Gadget15 = {
+	NULL,
+	73,85,
+	51,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Conf_Border7,
+	NULL,
+	&Conf_IText19,
+	NULL,
+	NULL,
+	GADCONFSAVE,
+	NULL
+};
+
+static SHORT Conf_BorderVectors8[] = {
+	0,0,
+	52,0,
+	52,11,
+	0,11,
+	0,0
+};
+static struct Border Conf_Border8 = {
+	-1,-1,
+	2,0,JAM1,
+	5,
+	Conf_BorderVectors8,
+	NULL
+};
+
+static struct IntuiText Conf_IText20 = {
+	1,0,JAM2,
+	10,2,
+	NULL,
+	"Load",
+	NULL
+};
+
+static struct Gadget Conf_Gadget14 = {
+	&Conf_Gadget15,
+	9,85,
+	51,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Conf_Border8,
+	NULL,
+	&Conf_IText20,
+	NULL,
+	NULL,
+	GADCONFLOAD,
+	NULL
+};
+
+static UBYTE Conf_Conf_ConfigNameSIBuff[50] =
+	"Nethack:NetHack.cnf";
+static struct StringInfo Conf_Conf_ConfigNameSInfo = {
+	Conf_Conf_ConfigNameSIBuff,
+	UNDOBUFFER,
+	0,
+	50,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Conf_BorderVectors9[] = {
+	0,0,
+	242,0,
+	242,10,
+	0,10,
+	0,0
+};
+static struct Border Conf_Border9 = {
+	-1,-1,
+	1,0,JAM1,
+	5,
+	Conf_BorderVectors9,
+	NULL
+};
+
+static struct Gadget Conf_ConfigName = {
+	&Conf_Gadget14,
+	151,100,
+	241,9,
+	NULL,
+	RELVERIFY+STRINGCENTER,
+	STRGADGET,
+	(APTR)&Conf_Border9,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Conf_Conf_ConfigNameSInfo,
+	GADCONFNAME,
+	NULL
+};
+
+static UBYTE Conf_Conf_StrSaveSIBuff[200];
+static struct StringInfo Conf_Conf_StrSaveSInfo = {
+	Conf_Conf_StrSaveSIBuff,
+	UNDOBUFFER,
+	0,
+	200,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Conf_BorderVectors10[] = {
+	0,0,
+	312,0,
+	312,10,
+	0,10,
+	0,0
+};
+static struct Border Conf_Border10 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Conf_BorderVectors10,
+	NULL
+};
+
+static struct Gadget Conf_StrSave = {
+	&Conf_ConfigName,
+	81,70,
+	311,9,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Conf_Border10,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Conf_Conf_StrSaveSInfo,
+	GADSTRSAVE,
+	NULL
+};
+
+static UBYTE Conf_Conf_StrLevelsSIBuff[200];
+static struct StringInfo Conf_Conf_StrLevelsSInfo = {
+	Conf_Conf_StrLevelsSIBuff,
+	UNDOBUFFER,
+	0,
+	200,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Conf_BorderVectors11[] = {
+	0,0,
+	312,0,
+	312,10,
+	0,10,
+	0,0
+};
+static struct Border Conf_Border11 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Conf_BorderVectors11,
+	NULL
+};
+
+static struct Gadget Conf_StrLevels = {
+	&Conf_StrSave,
+	81,56,
+	311,9,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Conf_Border11,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Conf_Conf_StrLevelsSInfo,
+	GADSTRLEVELS,
+	NULL
+};
+
+static UBYTE Conf_Conf_StrPathSIBuff[200];
+static struct StringInfo Conf_Conf_StrPathSInfo = {
+	Conf_Conf_StrPathSIBuff,
+	UNDOBUFFER,
+	0,
+	200,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Conf_BorderVectors12[] = {
+	0,0,
+	311,0,
+	311,10,
+	0,10,
+	0,0
+};
+static struct Border Conf_Border12 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Conf_BorderVectors12,
+	NULL
+};
+
+static struct Gadget Conf_StrPath = {
+	&Conf_StrLevels,
+	81,14,
+	310,9,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Conf_Border12,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Conf_Conf_StrPathSInfo,
+	GADSTRPATH,
+	NULL
+};
+
+static UBYTE Conf_Conf_StrPensSIBuff[200];
+static struct StringInfo Conf_Conf_StrPensSInfo = {
+	Conf_Conf_StrPensSIBuff,
+	UNDOBUFFER,
+	0,
+	200,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Conf_BorderVectors13[] = {
+	0,0,
+	312,0,
+	312,10,
+	0,10,
+	0,0
+};
+static struct Border Conf_Border13 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Conf_BorderVectors13,
+	NULL
+};
+
+static struct Gadget Conf_StrPens = {
+	&Conf_StrPath,
+	81,42,
+	311,9,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Conf_Border13,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Conf_Conf_StrPensSInfo,
+	GADSTRPENS,
+	NULL
+};
+
+static UBYTE Conf_Conf_StrHackdirSIBuff[200];
+static struct StringInfo Conf_Conf_StrHackdirSInfo = {
+	Conf_Conf_StrHackdirSIBuff,
+	UNDOBUFFER,
+	0,
+	200,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Conf_BorderVectors14[] = {
+	0,0,
+	312,0,
+	312,10,
+	0,10,
+	0,0
+};
+static struct Border Conf_Border14 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Conf_BorderVectors14,
+	NULL
+};
+
+static struct Gadget Conf_StrHackdir = {
+	&Conf_StrPens,
+	81,28,
+	311,9,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Conf_Border14,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Conf_Conf_StrHackdirSInfo,
+	GADSTRHACKDIR,
+	NULL
+};
+
+#define Conf_GadgetList4 Conf_StrHackdir
+
+static struct IntuiText Conf_IText26 = {
+	1,0,JAM2,
+	10,101,
+	NULL,
+	"Config File Name:",
+	NULL
+};
+
+static struct IntuiText Conf_IText25 = {
+	3,0,JAM2,
+	7,72,
+	NULL,
+	"Save Dir:",
+	&Conf_IText26
+};
+
+static struct IntuiText Conf_IText24 = {
+	3,0,JAM2,
+	23,58,
+	NULL,
+	"Levels:",
+	&Conf_IText25
+};
+
+static struct IntuiText Conf_IText23 = {
+	3,0,JAM2,
+	39,44,
+	NULL,
+	"Pens:",
+	&Conf_IText24
+};
+
+static struct IntuiText Conf_IText22 = {
+	3,0,JAM2,
+	15,30,
+	NULL,
+	"Hackdir:",
+	&Conf_IText23
+};
+
+static struct IntuiText Conf_IText21 = {
+	3,0,JAM2,
+	39,16,
+	NULL,
+	"Path:",
+	&Conf_IText22
+};
+
+#define Conf_IntuiTextList4 Conf_IText21
+
+static struct NewWindow Conf_NewWindowStructure4 = {
+	126,60,
+	402,114,
+	0,1,
+	GADGETUP+CLOSEWINDOW+ACTIVEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Conf_StrHackdir,
+	NULL,
+	"Edit Game Configuration",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Str_BorderVectors15[] = {
+	0,0,
+	57,0,
+	57,11,
+	0,11,
+	0,0
+};
+static struct Border Str_Border15 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Str_BorderVectors15,
+	NULL
+};
+
+static struct IntuiText Str_IText27 = {
+	3,0,JAM2,
+	4,2,
+	NULL,
+	"Cancel",
+	NULL
+};
+
+static struct Gadget Str_Gadget17 = {
+	NULL,
+	9,15,
+	56,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Str_Border15,
+	NULL,
+	&Str_IText27,
+	NULL,
+	NULL,
+	GADSTRCANCEL,
+	NULL
+};
+
+static UBYTE Str_Str_StringSIBuff[100];
+static struct StringInfo Str_Str_StringSInfo = {
+	Str_Str_StringSIBuff,
+	UNDOBUFFER,
+	0,
+	100,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Str_BorderVectors16[] = {
+	0,0,
+	439,0,
+	439,11,
+	0,11,
+	0,0
+};
+static struct Border Str_Border16 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Str_BorderVectors16,
+	NULL
+};
+
+static struct Gadget Str_String = {
+	&Str_Gadget17,
+	77,15,
+	438,10,
+	NULL,
+	RELVERIFY+STRINGCENTER,
+	STRGADGET,
+	(APTR)&Str_Border16,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Str_Str_StringSInfo,
+	-1,
+	NULL
+};
+
+#define Str_GadgetList5 Str_String
+
+static struct NewWindow Str_NewWindowStructure5 = {
+	55,60,
+	526,31,
+	0,1,
+	GADGETUP+CLOSEWINDOW+ACTIVEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Str_String,
+	NULL,
+	"String Requester",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Info_BorderVectors17[] = {
+	0,0,
+	72,0,
+	72,10,
+	0,10,
+	0,0
+};
+static struct Border Info_Border17 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors17,
+	NULL
+};
+
+static struct IntuiText Info_IText28 = {
+	3,0,JAM2,
+	24,1,
+	NULL,
+	"Use",
+	NULL
+};
+
+static struct Gadget Info_Gadget29 = {
+	NULL,
+	247,78,
+	71,9,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border17,
+	NULL,
+	&Info_IText28,
+	NULL,
+	NULL,
+	GADUSEINFO,
+	NULL
+};
+
+static SHORT Info_BorderVectors18[] = {
+	0,0,
+	72,0,
+	72,10,
+	0,10,
+	0,0
+};
+static struct Border Info_Border18 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors18,
+	NULL
+};
+
+static struct IntuiText Info_IText29 = {
+	3,0,JAM2,
+	20,1,
+	NULL,
+	"Quit",
+	NULL
+};
+
+static struct Gadget Info_Gadget28 = {
+	&Info_Gadget29,
+	474,78,
+	71,9,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border18,
+	NULL,
+	&Info_IText29,
+	NULL,
+	NULL,
+	GADQUITINFO,
+	NULL
+};
+
+static SHORT Info_BorderVectors19[] = {
+	0,0,
+	72,0,
+	72,10,
+	0,10,
+	0,0
+};
+static struct Border Info_Border19 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors19,
+	NULL
+};
+
+static struct IntuiText Info_IText30 = {
+	3,0,JAM2,
+	21,1,
+	NULL,
+	"Save",
+	NULL
+};
+
+static struct Gadget Info_Gadget27 = {
+	&Info_Gadget28,
+	11,78,
+	71,9,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border19,
+	NULL,
+	&Info_IText30,
+	NULL,
+	NULL,
+	GADSAVEINFO,
+	NULL
+};
+
+static SHORT Info_BorderVectors20[] = {
+	0,0,
+	60,0,
+	60,11,
+	0,11,
+	0,0
+};
+static struct Border Info_Border20 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors20,
+	NULL
+};
+
+static struct IntuiText Info_IText31 = {
+	3,0,JAM2,
+	18,1,
+	NULL,
+	"Del",
+	NULL
+};
+
+static struct Gadget Info_Gadget26 = {
+	&Info_Gadget27,
+	78,46,
+	59,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border20,
+	NULL,
+	&Info_IText31,
+	NULL,
+	NULL,
+	GADDELTOOL,
+	NULL
+};
+
+static SHORT Info_BorderVectors21[] = {
+	0,0,
+	59,0,
+	59,11,
+	0,11,
+	0,0
+};
+static struct Border Info_Border21 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors21,
+	NULL
+};
+
+static struct IntuiText Info_IText32 = {
+	3,0,JAM2,
+	18,1,
+	NULL,
+	"Add",
+	NULL
+};
+
+static struct Gadget Info_Gadget25 = {
+	&Info_Gadget26,
+	12,46,
+	58,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border21,
+	NULL,
+	&Info_IText32,
+	NULL,
+	NULL,
+	GADADDTOOL,
+	NULL
+};
+
+static struct IntuiText Info_IText33 = {
+	3,0,JAM2,
+	6,1,
+	NULL,
+	"Edit Game Options",
+	NULL
+};
+
+static struct Gadget Info_EditOpts = {
+	&Info_Gadget25,
+	397,47,
+	148,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	NULL,
+	NULL,
+	&Info_IText33,
+	NULL,
+	NULL,
+	GADEDITOPTS,
+	NULL
+};
+
+static SHORT Info_BorderVectors22[] = {
+	0,0,
+	14,0,
+	14,7,
+	0,7,
+	0,0
+};
+static struct Border Info_Border22 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors22,
+	NULL
+};
+
+static struct Gadget Info_ToolDown = {
+	&Info_EditOpts,
+	97,68,
+	13,6,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border22,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	GADTOOLDOWN,
+	NULL
+};
+
+static SHORT Info_BorderVectors23[] = {
+	0,0,
+	14,0,
+	14,7,
+	0,7,
+	0,0
+};
+static struct Border Info_Border23 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors23,
+	NULL
+};
+
+static struct Gadget Info_ToolUp = {
+	&Info_ToolDown,
+	97,61,
+	13,6,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Info_Border23,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	GADTOOLUP,
+	NULL
+};
+
+static UBYTE Info_Info_ToolTypesSIBuff[200];
+static struct StringInfo Info_Info_ToolTypesSInfo = {
+	Info_Info_ToolTypesSIBuff,
+	UNDOBUFFER,
+	0,
+	200,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Info_BorderVectors24[] = {
+	0,0,
+	430,0,
+	430,10,
+	0,10,
+	0,0
+};
+static struct Border Info_Border24 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors24,
+	NULL
+};
+
+static struct IntuiText Info_IText34 = {
+	3,0,JAM2,
+	-110,1,
+	NULL,
+	"Tool Types:",
+	NULL
+};
+
+static struct Gadget Info_ToolTypes = {
+	&Info_ToolUp,
+	116,63,
+	429,9,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Info_Border24,
+	NULL,
+	&Info_IText34,
+	NULL,
+	(APTR)&Info_Info_ToolTypesSInfo,
+	GADTOOLTYPES,
+	NULL
+};
+
+static SHORT Info_BorderVectors25[] = {
+	0,0,
+	144,0,
+	144,12,
+	0,12,
+	0,0
+};
+static struct Border Info_Border25 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors25,
+	NULL
+};
+
+static struct IntuiText Info_IText35 = {
+	3,0,JAM2,
+	-85,2,
+	NULL,
+	"Character:",
+	NULL
+};
+
+static struct Gadget Info_Class = {
+	&Info_ToolTypes,
+	402,15,
+	143,11,
+	GADGHBOX+GADGHIMAGE,
+	NULL,
+	BOOLGADGET,
+	(APTR)&Info_Border25,
+	NULL,
+	&Info_IText35,
+	NULL,
+	NULL,
+	-1,
+	NULL
+};
+
+static UBYTE Info_Info_PlayerSIBuff[100];
+static struct StringInfo Info_Info_PlayerSInfo = {
+	Info_Info_PlayerSIBuff,
+	NULL,
+	0,
+	100,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Info_BorderVectors26[] = {
+	0,0,
+	197,0,
+	197,12,
+	0,12,
+	0,0
+};
+static struct Border Info_Border26 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors26,
+	NULL
+};
+
+static struct IntuiText Info_IText36 = {
+	3,0,JAM2,
+	-101,2,
+	NULL,
+	"Player Name:",
+	NULL
+};
+
+static struct Gadget Info_Player = {
+	&Info_Class,
+	110,15,
+	196,11,
+	NULL,
+	RELVERIFY,
+	STRGADGET,
+	(APTR)&Info_Border26,
+	NULL,
+	&Info_IText36,
+	NULL,
+	(APTR)&Info_Info_PlayerSInfo,
+	GADPLNAME,
+	NULL
+};
+
+static UBYTE Info_Info_CommentSIBuff[100];
+static struct StringInfo Info_Info_CommentSInfo = {
+	Info_Info_CommentSIBuff,
+	UNDOBUFFER,
+	0,
+	100,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Info_BorderVectors27[] = {
+	0,0,
+	466,0,
+	466,11,
+	0,11,
+	0,0
+};
+static struct Border Info_Border27 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Info_BorderVectors27,
+	NULL
+};
+
+static struct IntuiText Info_IText37 = {
+	3,0,JAM2,
+	-70,1,
+	NULL,
+	"Comment:",
+	NULL
+};
+
+static struct Gadget Info_Comment = {
+	&Info_Player,
+	80,31,
+	465,10,
+	NULL,
+	RELVERIFY+STRINGCENTER,
+	STRGADGET,
+	(APTR)&Info_Border27,
+	NULL,
+	&Info_IText37,
+	NULL,
+	(APTR)&Info_Info_CommentSInfo,
+	-1,
+	NULL
+};
+
+#define Info_GadgetList6 Info_Comment
+
+static struct IntuiText Info_IText38 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Wizard",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem25 = {
+	NULL,
+	0,96,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	4095,
+	(APTR)&Info_IText38,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText39 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Valkyrie",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem24 = {
+	&Info_MenuItem25,
+	0,88,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	6143,
+	(APTR)&Info_IText39,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText40 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Tourist",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem23 = {
+	&Info_MenuItem24,
+	0,80,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	7167,
+	(APTR)&Info_IText40,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText41 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Samurai",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem22 = {
+	&Info_MenuItem23,
+	0,72,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	7679,
+	(APTR)&Info_IText41,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText42 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Rogue",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem21 = {
+	&Info_MenuItem22,
+	0,64,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	7935,
+	(APTR)&Info_IText42,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText43 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Priest",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem20 = {
+	&Info_MenuItem21,
+	0,56,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8063,
+	(APTR)&Info_IText43,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText44 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Knight",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem19 = {
+	&Info_MenuItem20,
+	0,48,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8127,
+	(APTR)&Info_IText44,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText45 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Healer",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem18 = {
+	&Info_MenuItem19,
+	0,40,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8159,
+	(APTR)&Info_IText45,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText46 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Elf",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem17 = {
+	&Info_MenuItem18,
+	0,32,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8175,
+	(APTR)&Info_IText46,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText47 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Caveman",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem16 = {
+	&Info_MenuItem17,
+	0,24,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8183,
+	(APTR)&Info_IText47,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText48 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Barbarian",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem15 = {
+	&Info_MenuItem16,
+	0,16,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8187,
+	(APTR)&Info_IText48,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText49 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Archeologist",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem14 = {
+	&Info_MenuItem15,
+	0,8,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP,
+	8189,
+	(APTR)&Info_IText49,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct IntuiText Info_IText50 = {
+	3,1,COMPLEMENT,
+	19,0,
+	NULL,
+	"Random",
+	NULL
+};
+
+static struct MenuItem Info_MenuItem13 = {
+	&Info_MenuItem14,
+	0,0,
+	103,8,
+	CHECKIT+ITEMTEXT+ITEMENABLED+HIGHCOMP+CHECKED,
+	8190,
+	(APTR)&Info_IText50,
+	NULL,
+	NULL,
+	NULL,
+	MENUNULL
+};
+
+static struct Menu Info_Menu3 = {
+	NULL,
+	0,0,
+	70,0,
+	MENUENABLED,
+	"Character",
+	&Info_MenuItem13
+};
+
+#define Info_MenuList6 Info_Menu3
+
+static struct NewWindow Info_NewWindowStructure6 = {
+	41,51,
+	556,93,
+	0,1,
+	GADGETUP+MENUPICK+CLOSEWINDOW+ACTIVEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Info_Comment,
+	NULL,
+	"Game Information",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static struct IntuiText Help1_IText51 = {
+	1,0,JAM2,
+	7,2,
+	NULL,
+	"Okay",
+	NULL
+};
+
+static struct Gadget Help1_Gadget30 = {
+	NULL,
+	12,34,
+	47,12,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	NULL,
+	NULL,
+	&Help1_IText51,
+	NULL,
+	NULL,
+	GADHELPOKAY,
+	NULL
+};
+
+#define Help1_GadgetList7 Help1_Gadget30
+
+static struct IntuiText Help1_IText53 = {
+	3,0,JAM2,
+	10,22,
+	NULL,
+	"to start a new game or to resume a saved game.",
+	NULL
+};
+
+static struct IntuiText Help1_IText52 = {
+	3,0,JAM2,
+	9,13,
+	NULL,
+	"Click on NewGame Gadget or a Saved Game twice",
+	&Help1_IText53
+};
+
+#define Help1_IntuiTextList7 Help1_IText52
+
+static struct NewWindow Help1_NewWindowStructure7 = {
+	134,60,
+	385,51,
+	0,1,
+	GADGETUP+CLOSEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Help1_Gadget30,
+	NULL,
+	"Help for Game Selection",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static struct IntuiText Help2_IText54 = {
+	1,0,JAM2,
+	7,2,
+	NULL,
+	"Okay",
+	NULL
+};
+
+static struct Gadget Help2_Gadget31 = {
+	NULL,
+	17,42,
+	47,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	NULL,
+	NULL,
+	&Help2_IText54,
+	NULL,
+	NULL,
+	GADHELPOKAY,
+	NULL
+};
+
+#define Help2_GadgetList8 Help2_Gadget31
+
+static struct IntuiText Help2_IText57 = {
+	3,0,JAM2,
+	15,31,
+	NULL,
+	"resume the saved game.",
+	NULL
+};
+
+static struct IntuiText Help2_IText56 = {
+	3,0,JAM2,
+	15,22,
+	NULL,
+	"selected game, or double click on a game to",
+	&Help2_IText57
+};
+
+static struct IntuiText Help2_IText55 = {
+	3,0,JAM2,
+	15,13,
+	NULL,
+	"Use Menu button to select operation on the",
+	&Help2_IText56
+};
+
+#define Help2_IntuiTextList8 Help2_IText55
+
+static struct NewWindow Help2_NewWindowStructure8 = {
+	139,60,
+	372,58,
+	0,1,
+	GADGETUP+CLOSEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Help2_Gadget31,
+	NULL,
+	"Help for Game Manipulation",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static struct IntuiText About_IText58 = {
+	1,0,JAM2,
+	40,2,
+	NULL,
+	"Okay",
+	NULL
+};
+
+static struct Gadget About_Gadget32 = {
+	NULL,
+	163,68,
+	109,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	NULL,
+	NULL,
+	&About_IText58,
+	NULL,
+	NULL,
+	GADHELPOKAY,
+	NULL
+};
+
+#define About_GadgetList9 About_Gadget32
+
+static struct IntuiText About_IText67 = {
+	2,0,JAM2,
+	10,56,
+	NULL,
+	"1992 see NetHack license for details and limitations!",
+	NULL
+};
+
+static struct IntuiText About_IText66 = {
+	2,0,JAM2,
+	20,47,
+	NULL,
+	"HackWB is copyright Gregg Wonderly and Ken Lorber,",
+	&About_IText67
+};
+
+static struct IntuiText About_IText65 = {
+	3,0,JAM2,
+	8,31,
+	NULL,
+	"finished by Gregg...",
+	&About_IText66
+};
+
+static struct IntuiText About_IText64 = {
+	3,0,JAM2,
+	135,22,
+	NULL,
+	"The programming was started by Ken and",
+	&About_IText65
+};
+
+static struct IntuiText About_IText63 = {
+	3,0,JAM2,
+	120,22,
+	NULL,
+	".",
+	&About_IText64
+};
+
+static struct IntuiText About_IText62 = {
+	2,0,JAM2,
+	8,22,
+	NULL,
+	"Gregg Wonderly",
+	&About_IText63
+};
+
+static struct IntuiText About_IText61 = {
+	3,0,JAM2,
+	396,13,
+	NULL,
+	"and",
+	&About_IText62
+};
+
+static struct IntuiText About_IText60 = {
+	2,0,JAM2,
+	310,13,
+	NULL,
+	"Ken Lorber",
+	&About_IText61
+};
+
+static struct IntuiText About_IText59 = {
+	3,0,JAM2,
+	8,13,
+	NULL,
+	"The NetHack WorkBench was designed by",
+	&About_IText60
+};
+
+#define About_IntuiTextList9 About_IText59
+
+static struct NewWindow About_NewWindowStructure9 = {
+	89,60,
+	447,83,
+	0,1,
+	GADGETUP+CLOSEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&About_Gadget32,
+	NULL,
+	"About the NetHack WorkBench",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Help3_BorderVectors28[] = {
+	0,0,
+	489,0
+};
+static struct Border Help3_Border28 = {
+	2,169,
+	1,0,JAM1,
+	2,
+	Help3_BorderVectors28,
+	NULL
+};
+
+static struct Gadget Help3_Gadget35 = {
+	NULL,
+	0,0,
+	1,1,
+	GADGHBOX+GADGHIMAGE,
+	NULL,
+	BOOLGADGET,
+	(APTR)&Help3_Border28,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static struct IntuiText Help3_IText68 = {
+	1,0,JAM2,
+	8,2,
+	NULL,
+	"BKWD",
+	NULL
+};
+
+static struct Gadget Help3_Gadget34 = {
+	&Help3_Gadget35,
+	434,173,
+	47,10,
+	NULL,
+	RELVERIFY+GADGIMMEDIATE,
+	BOOLGADGET,
+	NULL,
+	NULL,
+	&Help3_IText68,
+	NULL,
+	NULL,
+	GADHELPBKWD,
+	NULL
+};
+
+static struct IntuiText Help3_IText69 = {
+	1,0,JAM2,
+	8,2,
+	NULL,
+	"FRWD",
+	NULL
+};
+
+static struct Gadget Help3_Gadget33 = {
+	&Help3_Gadget34,
+	12,173,
+	47,10,
+	NULL,
+	RELVERIFY+GADGIMMEDIATE,
+	BOOLGADGET,
+	NULL,
+	NULL,
+	&Help3_IText69,
+	NULL,
+	NULL,
+	GADHELPFRWD,
+	NULL
+};
+
+#define Help3_GadgetList10 Help3_Gadget33
+
+static struct NewWindow Help3_NewWindowStructure10 = {
+	75,9,
+	494,189,
+	0,1,
+	GADGETDOWN+GADGETUP+CLOSEWINDOW+VANILLAKEY+INTUITICKS,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Help3_Gadget33,
+	NULL,
+	"Help for Nethack WorkBench V3.1",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+static SHORT Rst_BorderVectors29[] = {
+	0,0,
+	58,0,
+	58,11,
+	0,11,
+	0,0
+};
+static struct Border Rst_Border29 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Rst_BorderVectors29,
+	NULL
+};
+
+static struct IntuiText Rst_IText70 = {
+	1,0,JAM1,
+	8,1,
+	NULL,
+	"Cancel",
+	NULL
+};
+
+static struct Gadget Rst_RestCancel = {
+	NULL,
+	230,42,
+	57,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Rst_Border29,
+	NULL,
+	&Rst_IText70,
+	NULL,
+	NULL,
+	GADRESTCAN,
+	NULL
+};
+
+static SHORT Rst_BorderVectors30[] = {
+	0,0,
+	58,0,
+	58,11,
+	0,11,
+	0,0
+};
+static struct Border Rst_Border30 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Rst_BorderVectors30,
+	NULL
+};
+
+static struct IntuiText Rst_IText71 = {
+	1,0,JAM1,
+	12,1,
+	NULL,
+	"Okay",
+	NULL
+};
+
+static struct Gadget Rst_RestOkay = {
+	&Rst_RestCancel,
+	10,42,
+	57,10,
+	NULL,
+	RELVERIFY,
+	BOOLGADGET,
+	(APTR)&Rst_Border30,
+	NULL,
+	&Rst_IText71,
+	NULL,
+	NULL,
+	GADRESTOKAY,
+	NULL
+};
+
+static UBYTE Rst_Rst_RestOldSIBuff[300];
+static struct StringInfo Rst_Rst_RestOldSInfo = {
+	Rst_Rst_RestOldSIBuff,
+	UNDOBUFFER,
+	0,
+	300,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Rst_BorderVectors31[] = {
+	0,0,
+	187,0,
+	187,10,
+	0,10,
+	0,0
+};
+static struct Border Rst_Border31 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Rst_BorderVectors31,
+	NULL
+};
+
+static struct Gadget Rst_RestOld = {
+	&Rst_RestOkay,
+	101,28,
+	186,9,
+	NULL,
+	RELVERIFY+STRINGCENTER,
+	STRGADGET,
+	(APTR)&Rst_Border31,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Rst_Rst_RestOldSInfo,
+	GADRESTOLD,
+	NULL
+};
+
+static UBYTE Rst_Rst_RestDirSIBuff[300];
+static struct StringInfo Rst_Rst_RestDirSInfo = {
+	Rst_Rst_RestDirSIBuff,
+	UNDOBUFFER,
+	0,
+	300,
+	0,
+	0,0,0,0,0,
+	0,
+	0,
+	NULL
+};
+
+static SHORT Rst_BorderVectors32[] = {
+	0,0,
+	187,0,
+	187,10,
+	0,10,
+	0,0
+};
+static struct Border Rst_Border32 = {
+	-1,-1,
+	3,0,JAM1,
+	5,
+	Rst_BorderVectors32,
+	NULL
+};
+
+static struct Gadget Rst_RestDir = {
+	&Rst_RestOld,
+	101,15,
+	186,9,
+	NULL,
+	RELVERIFY+STRINGCENTER,
+	STRGADGET,
+	(APTR)&Rst_Border32,
+	NULL,
+	NULL,
+	NULL,
+	(APTR)&Rst_Rst_RestDirSInfo,
+	GADRESTDIR,
+	NULL
+};
+
+#define Rst_GadgetList11 Rst_RestDir
+
+static struct IntuiText Rst_IText73 = {
+	1,0,JAM1,
+	18,29,
+	NULL,
+	"Old File:",
+	NULL
+};
+
+static struct IntuiText Rst_IText72 = {
+	1,0,JAM1,
+	14,15,
+	NULL,
+	"Directory:",
+	&Rst_IText73
+};
+
+#define Rst_IntuiTextList11 Rst_IText72
+
+static struct NewWindow Rst_NewWindowStructure11 = {
+	177,60,
+	295,57,
+	0,2,
+	GADGETDOWN+GADGETUP+CLOSEWINDOW+ACTIVEWINDOW+VANILLAKEY,
+	WINDOWDRAG+WINDOWDEPTH+WINDOWCLOSE+ACTIVATE+NOCAREREFRESH,
+	&Rst_RestDir,
+	NULL,
+	"Recover Parameters",
+	NULL,
+	NULL,
+	5,5,
+	-1,-1,
+	CUSTOMSCREEN
+};
+
+
+/* end of PowerWindows source generation */
diff -Pru nethack-3.4.1/sys/amiga/wbwin.uu nethack/sys/amiga/wbwin.uu
--- nethack-3.4.1/sys/amiga/wbwin.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/amiga/wbwin.uu	Thu Jan 10 16:43:24 2002
@@ -0,0 +1,305 @@
+begin 777 wbwin.pw
+M4&]W97)7:6YD;W=S('8R+C5C(*DQ.3@W+" Q.3@X(&)Y($E.3U9!5%)/3DE#
+M4RP@24Y#+B @(" @(" @(" @(" @(" @(" @(" @   "K     E  8#_    
+M 0     !      AW8G=I;BYC  ?262       H  R  "  *    /      ?&
+M;>                (    73F5T2&%C:R!7;W)K0F5N8V@@5C,N,0     !
+M      $     #*"@H   (/#P\!!@H     L  A _  "'>@"J %#_____!\;/
+MF                             ('QHBX       !   " "@ #P(U )0 
+M!0 %_____P   !Y396QE8W0@4V%V960@1V%M92!O<B!.97<@1V%M90 'TFL0
+M  7_^?_F  8 *("#  ,'QHEH                !\:*&  $!])JZ/____\#
+M   %!])CW            AP   (<  <    '           "$P "        
+M              $#__________\    * "@ BP?&B,@'QHK(!\:*V ?&C' '
+MQJ" !\:HN     =38W)O;&P      0     !      I'04130U)/3$P     
+M 0     !        !0 ,_^8 "@ C  ,  0?&J5@     !\:O"           
+M  4'TFMH_____P$   4'TFM,           "'    AP "P    L     !\:I
+M6/__  L"   "!\:JX          (      (V   #  $   8  0     'QLPX
+M          ,@(      ( ",  0?&S3 'QLU !\;.. ?&SD@'QL[H!\;.^   
+M  A-97-S86=E      $      0     #+3$      0     !  ?&T$@!$   
+M    !P  !\BY( ?2;0     (4')O:F5C=  'QM!8!\<HX!!(!])KD      0
+M  ?)]I       0(# 0           ,@ "               !4AE;'      
+M 0 'QV!X!\?FH!!!!])KN      0  ?-0^       0(# 0         ( ,@ 
+M"               !D%B;W5T      $ !\BUT ?(PI 04P?2:^      $  '
+MTFP(      $" P$         ( "X  @               M4;W @4V-O<F5S
+M      $ !\C8< ?(VK 04@?2;"@     $  'TFQ0      $" P$         
+M& "X  @               A296-O=F5R      $ !])LF ?(W(@010?2;'  
+M    $  'TFRX      $" P$         ( "X  @              !-%9&ET
+M($-O;F9I9W5R871I;VX      0 'R?IP!\GZ\!!1!])LV      0        
+M     0(# 0         @ ,@ "               !5%U:70      0 'R?W0
+M 1  1@    <   ?2;2          !4=A;64 !\M\\ ?-$L@020?2;4      
+M$  'TFUH      $" P$            (  @               5);F9O    
+M  $ !\U"T ?-%8 00P?2;8@     $  'TFVP      $" P$         " "8
+M  @               I#;W!Y($EN9F\      0 'S4'P!\YFX!!$!])MT   
+M   0  ?2;?@      0(# 0         @ )@ "               "$1I<V-A
+M<F0      0 'TCZ@!](_,!!.!])N&      0             0(# 0      
+M   8 )@ "               !U)E;F%M90     !   "$ X ( )   4 !?__
+M__\     !],:D                        P?28_@       =1=65S=%\ 
+M  , K@ \ 2H /  %  7_____    &DYE=$AA8VL@5V]R:T)E;F-H(%)E<75E
+M<W0 !],8D  , "L 5P +     P !!],7Y      'TQ@0              ?3
+M&##_____ @  !0?3%_0           !8    6  ,    #            P !
+M   @  (     !])FT          $665S      H    !!])RV ?2C!@'TL/X
+M!],86 ?3&' 'TQB     !%EE<P     !      $     #$=!1%%515-46453
+M      $      0 'TQFH ,< *P!7  L    #  $'TQB\      ?3&.@     
+M       $!],9&/____\"   %!],8S            %@   !8  P    ,    
+M       #  $  ",  @     'TQD(          -.;P     *     0?3&4 '
+MTQE0!],98 ?3&7 'TQF(!],9F     -.;P     !      $     "T=!1%%5
+M15-43D\      0     !        #  0 1( %0 #  ,  0?3&=0         
+M              4'TQH _____P,   4'TQGD           !$P   1, %@  
+M !8               @  P  !],:* ?3&D 'TQI0!],:8 ?3&G 'TQJ     
+M"4)O<F1E<G,R      $      0     #+3$      0     !  $  0  .P 5
+M      ?3&K          %U-U<F4@>6]U('=A;G0@=&\@455)5#\   (0#P E
+MAVL R  R_____P?3'F@                            "!])*        
+M"4]P=&EO;G-?   !    %0*  )P !0 %_____P    U%9&ET($]P=&EO;G, 
+M!](_:  -__$ 1P *  @  P !!]-IM      'TCZP              ?3'=#_
+M____ P  !0?3:<0           !(    2  +    "P           P !   5
+M  $     !\U ^          %3TM!60     *  @  0?33>@'TTWX!]-4B ?3
+M3\@'TTYH!]-.>     $      0     !      M'041/4%1/2T%9      $ 
+M     0      _Z#_\0!'  H &  #  $'TC^4      ?20&@             
+M!\U">/____\#   %!](_I            $@   !(  L    +           #
+M  $   \  0     'TD$P          =#04Y#14P     "@ 8  $'QH2 !](^
+MV ?2/N@'TR6@!])@N ?2/O@    !      $      0     -1T%$3U!40T%.
+M0T5,      $      0 'TDKP 1        <   ?3'H@         "%!R;VIE
+M8W0 !],>T ?3'N 04P?3'J@     $  'TQ_       $" P$            (
+M  @               53879E      $ !],@" ?3(!@00P?3'^      $   
+M          $" P$         " !$  @               =#86YC96P     
+M 0   A . "0"0  %  7_____      ?3.$                        @'
+MTQ<H       &0V]N9E\   $ ?@ \ 9( <@ %  7_____    &$5D:70@1V%M
+M92!#;VYF:6=U<F%T:6]N  ?3*@  40 < 3< "0    , ! ?3**P         
+M       'TRFH   'TR@P_____P,   4'TRB\           !.    3@ "@  
+M  H              ,@ (" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
+M(" @(" @(             #__P,! @       "RLU  MK%@      "M4S   
+M   '.  J;W    !" "IP" #)  \ :  ( %(      "IOX@            #_
+M_P,! @       "RLU  MN@@      "M4S      (Z  J;[@   !" "IP4 #)
+M !< :  ( %(      "IP*@            #__P,! @       0H    !!],D
+M^ ?3("@'TR;8!],IV ?3)N@'TRGP    "U-T<DAA8VMD:7(      0     !
+M      Y'04135%)(04-+1$E2      $      0 'TRSH %$ *@$W  D    #
+M  0'TRHL                !],J6   !],JB/____\#   %!],J/       
+M     3@   $X  H    *              #( " @(" @(" @(" @(" @(" @
+M(" @(" @(" @(" @(" @(" @("              __\# 0(        LK-0 
+M+:Q8       K5,P     !S@ *F]P    0@ J< @ R0 / &@ " !2       J
+M;^(             __\# 0(        LK-0 +;H(       K5,P     ".@ 
+M*F^X    0@ J<%  R0 7 &@ " !2       J<"H             __\# 0( 
+M      $*     0?3*K 'TRK !],JT ?3*N 'TRKX!],LV     A3=')096YS
+M      $      0     +1T%$4U124$5.4P     !      $ !],PV !1  X!
+M-@ )     P $!],M%                 ?3+4    ?3+7#_____ P  !0?3
+M+20           $W   !-P *    "@              R  @(" @(" @(" @
+M(" @(" @(" @(" @(" @(" @(" @(" @(" @             /__ P$"    
+M    +*S4 "VL6       *U3,      <X "IO<    $( *G ( ,D #P!H  @ 
+M4@      *F_B             /__ P$"        +*S4 "VZ"       *U3,
+M      CH "ION    $( *G!0 ,D %P!H  @ 4@      *G J            
+M /__ P$"       !"@    $'TRV8!],MJ ?3+;@'TRW(!],MX ?3+?     (
+M4W1R4&%T:      !      $     "T=!1%-44E!!5$@      0     !  ?3
+M,L@ 40 X 3< "0    , ! ?3,00                'TS(    'TS(P____
+M_P,   4'TS$4           !.    3@ "@    H              ,@ (" @
+M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(             #_
+M_P,! @       "RLU  MK%@      "M4S      '.  J;W    !" "IP" #)
+M  \ :  ( %(      "IOX@            #__P,! @       "RLU  MN@@ 
+M     "M4S      (Z  J;[@   !" "IP4 #) !< :  ( %(      "IP*@  
+M          #__P,! @       0H    !!],R6 ?3,G 'TS* !],RD ?3,J@'
+MTS*X    "E-T<DQE=F5L<P     !      $     #4=!1%-44DQ%5D5,4P  
+M   !      $ !],TL !1 $8!-P )     P $!],R]                 ?3
+M,_    ?3-"#_____ P  !0?3,P0           $X   !.  *    "@      
+M        R  @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
+M             /__ P$"        +*S4 "VL6       *U3,      <X "IO
+M<    $( *G ( ,D #P!H  @ 4@      *F_B             /__ P$"    
+M    +*S4 "VZ"       *U3,      CH "ION    $( *G!0 ,D %P!H  @ 
+M4@      *G J             /__ P$"       !"@    $'TS1(!],T6 ?3
+M-&@'TS1X!],TD ?3-*     (4W1R4V%V90     !      $     "T=!1%-4
+M4E-!5D4      0     !  ?3-A  EP!D /$ "0   @, ! ?3--P         
+M       'TS5(   'TS5X_____P$   4'TS3L            \@   /( "@  
+M  H              #).971H86-K.DYE=$AA8VLN8VYF " @(" @(" @("  
+M    !G8 .1_X #C";@           0H   (!!],UH ?3-;@'TS7(!],UV ?3
+M-? 'TS8     "T-O;F9I9TYA;64      0     !      Q'041#3TY&3D%-
+M10     !      $ !],W*  ) %4 ,P *     P !!],V/      'TS9H    
+M          ?3-IC_____ @  !0?3-DP            T    -  +    "P  
+M         0 !   *  (     !],VB          %3&]A9      *     0?3
+M-L 'TS;0!],VX ?3-O 'TS<(!],W&     $      0     !      Q'041#
+M3TY&3$]!1      !      $       !) %4 ,P *     P !!],W5      '
+MTS>               ?3-[#_____ @  !0?3-V0            T    -  +
+M    "P           0 !   *  (     !],WH          %4V%V90     *
+M     0?3-]@'TS?H!],W^ ?3. @'TS@@!],X,     $      0     !    
+M  Q'041#3TY&4T%610     !      $  P !   G !      !],X8 ?3.'  
+M   &4&%T:#H  P !   / !X     !],XD ?3.*@    )2&%C:V1I<CH  P !
+M   G "P     !],XR ?3.-@    &4&5N<SH  P !   7 #H     !],X^ ?3
+M.0@    (3&5V96QS.@ #  $   < 2      'TSDH!],Y0     I3879E($1I
+M<CH  0 !   * &4     !],Y8          20V]N9FEG($9I;&4@3F%M93H 
+M  (0#@ D D  !0 %_____P                                 "!],]
+M0       !5-T<E\   $ -P \ @X 'P %  7_____    $5-T<FEN9R!297%U
+M97-T97( !]-#N !-  \!M@ *   " P $!],^G                 ?3/7  
+M  ?3/SC_____ P  !0?3/JP           &W   !MP +    "P          
+M    9  @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
+M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" X     'BJ "GB0   
+M $( *>+8 -0 #P 8      $*   " 0?3/V 'TS]P!],_@ ?3/Y 'TS^@!],_
+ML     =3=')I;F<      0     !      ,M,0     !      $        )
+M  \ .  *     P !!]-#Y      'TS_               ?31"#_____ P  
+M!0?30_0            Y    .0 +    "P           P !   $  (     
+M!]-$$          '0V%N8V5L      H    !!]-$2 ?31%@'TT1H!]-$> ?3
+M1) 'TT2@     0     !      $     #4=!1%-44D-!3D-%3      !    
+M  $   (0#@ D T  !0 %_____P?3:L@                            ,
+M!]*+R       !DEN9F]?   ! "D ,P(L %T !0 %_____P   !%'86UE($EN
+M9F]R;6%T:6]N  ?30)  4  ? =$ "@   @, ! ?3/*0     !],DH      '
+MTSS0   'TR@(_____P,   4'TSRT           !T@   =( "P    L     
+M      ,  0#_N@ !      ?2B]@         "4-O;6UE;G0Z     &0     
+M      ?/2R    !"!\]0T #)  \ H  ( %(     !\]0J@            #_
+M_P,! @      !]'9_ ?1Y2      !]"!]         ?/4(    !"      #)
+M !< H      !"@   @$'TQ<8!],F: ?3)G@'TR:@!],Y@ ?30(     (0V]M
+M;65N=      !      $      RTQ      $      0 'TU:0 &X #P#$  L 
+M   #  0'TT"\      ?30.@     !]-#<   !]-64/____\#   %!]- S   
+M         ,4   #%  P    ,           #  $ _YL  @     'TT((    
+M      U0;&%Y97(@3F%M93H     9           !\]+(    $('SU#0 ,D 
+M#P"@  @ 4@     'SU"J             /__ P$"       'T=G\!]'E(   
+M   'T('T        !\]0@    $(      ,D %P"@       *     0?30B '
+MTT.@!]-$L ?35G@'TT3X!]-'P     =0;&%Y97(      0     !      I'
+M04103$Y!344      0     !  ?36' !D@ / (\ "P #  ,  0?35KP     
+M!]-6Z              'TU?X_____P,   4'TU;,            D    )  
+M#     P           ,  0#_JP "      ?35^          "T-H87)A8W1E
+M<CH     "  #   'TTCX!]-8( ?36# 'TUA !]-84 ?36&     &0VQA<W, 
+M     0     !      ,M,0     !      $ !]-<4 !T #\!K0 )     P $
+M!]-8G      'TUC(      ?36K    ?36N#_____ P  !0?36*P         
+M  &N   !K@ *    "@           P ! /^2  $     !]-8Z          ,
+M5&]O;"!4>7!E<SH     R  @(" @(" @(" @(" @(" @(" @(" @(" @(" @
+M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @("  (P 0 3P 40  
+M                    +EZ@    0@ N=$@    8 -@ " !6       N="( 
+M    0P      __\# 0(        O%OP +R?Z       O@O0    ABC@ +G/X
+M    0@ N=@@    @ -@ " !2       N=&H                !"@    $'
+MTUO@!]-;^ ?37 @'TUP8!]-<, ?37$     *5&]O;%1Y<&5S      $     
+M 0     -1T%$5$]/3%194$53      $      0 'TUX8 &$ /0 -  8    #
+M  $'TUQ\                        !]-<J/____\#   %!]-<C       
+M      X    .  <    '               *     0?37- 'TUS@!]-<\ ?3
+M7> 'TUWX!]->"     =4;V]L57       0     !      I'04143T],55  
+M     0     !  ?37^  80!$  T !@    ,  0?37D0                 
+M       'TUYP_____P,   4'TUY4            #@    X !P    <     
+M          H    !!]->F ?37K 'TU[ !]->T ?37N@'TU[X    "51O;VQ$
+M;W=N      $      0     ,1T%$5$]/3$1/5TX      0     !  ?38? !
+MC0 O )0 "@    ,  0?38 P     !]-@.              'TV!X_____P, 
+M  4'TV <            E0   )4 "P    L           ,  0  !@ !    
+M  ?38%@         $D5D:70@1V%M92!/<'1I;VYS     !(    !!]-@H ?3
+M8+@'TV#(!]-@V ?38/ 'TV'@    "45D:71/<'1S      $      0     ,
+M1T%$141)5$]05%,      0     !  ?38^  #  N #H "@    ,  0?38AP 
+M    !]-B2              'TV)X_____P,   4'TV(L            .P  
+M #L "P    L           ,  0  $@ !      ?38F@         !$%D9   
+M   *     0?38J 'TV*P!]-BP ?38M 'TV+H!]-B^     $      0     !
+M      M'041!1$143T],      $      0 'TV7@ $X +@ [  H    #  $'
+MTV0,      ?39#@             !]-D:/____\#   %!]-D'           
+M #P    \  L    +           #  $  !(  0     'TV18          1$
+M96P     "@    $'TV20!]-DH ?39+ 'TV3 !]-DV ?39.@    !      $ 
+M     0     +1T%$1$5,5$]/3      !      $ !]-GX  + $X 1P )    
+M P !!]-F#      'TV8X              ?39EC_____ P  !0?39AP     
+M      !(    2  *    "@           P !   5  $     !]-D^       
+M   %4V%V90     *     0?39H 'TV:0!]-FH ?39K 'TV;(!]-FV     $ 
+M     0     !      Q'0413059%24Y&3P     !      $ !]-IX ': $X 
+M1P )     P !!]-H#      'TV;H              ?3:$C_____ P  !0?3
+M:!P           !(    2  *    "@           P !   4  $     !]-H
+M.          %475I=      *     0?3:' 'TVB !]-HD ?3:* 'TVBX!]-H
+MR     $      0     !      Q'041154E424Y&3P     !      $     
+M  #W $X 1P )     P !!]-J#      'TVC8              ?3:CC_____
+M P  !0?3:AP           !(    2  *    "@           P !   8  $ 
+M    !]-H^          $57-E      H    !!]-J8 ?3:G 'TVJ !]-JD ?3
+M:J@'TVJX     0     !      $     "T=!1%5314E.1D\      0     !
+M  ?3:N@!$       !P  !]-KX          *0VAA<F%C=&5R  ?3;"@'TVPX
+M+  'TVP      !  !]-L2   '_X! @,! !,         <P (            
+M   '4F%N9&]M      $ !]-LD ?3;*@D  ?3;&@     $  'TVRX   ?_0$"
+M P$ $P      " !S  @               U!<F-H96]L;V=I<W0      0 '
+MTVU0!]-M:"0 !]-LV      0  ?3;7@  !_[ 0(# 0 3       0 ', "   
+M            "D)A<F)A<FEA;@     !  ?3;< 'TVW0)  'TVV8     !  
+M!]-MX   '_<! @,! !,      !@ <P (               (0V%V96UA;@  
+M   !  ?3;B@'TVXX)  'TVX      !  !]-N2   '^\! @,! !,      "  
+M<P (               $16QF      $ !]-ND ?3;J D  ?3;F@     $  '
+MTVZP   ?WP$" P$ $P      * !S  @               =(96%L97(     
+M 0 'TV[X!]-O""0 !]-NT      0  ?3;Q@  !^_ 0(# 0 3       P ', 
+M"               !TMN:6=H=      !  ?3;V 'TV]P)  'TV\X     !  
+M!]-O@   'W\! @,! !,      #@ <P (               '4')I97-T    
+M  $ !]-OR ?3;]@D  ?3;Z      $  'TV_H   >_P$" P$ $P      0 !S
+M  @               92;V=U90     !  ?3<# 'TW! )  'TW (     !  
+M!]-P4   '?\! @,! !,      $@ <P (               (4V%M=7)A:0  
+M   !  ?3<)@'TW"H)  'TW!P     !  !]-PN   &_\! @,! !,      %  
+M<P (               (5&]U<FES=      !  ?3<0 'TW$8)  'TW#8    
+M !  !]-Q*   %_\! @,! !,      %@ <P (               )5F%L:WER
+M:64      0 'TW%P!]-Q@"0 !]-Q2      0          __ 0(# 0 3    
+M  !@ ', "               !U=I>F%R9      !   "$ X ( )   4 !?__
+M__\     !]/'&                        0?30U@       =(96QP,5\ 
+M  $ A@ \ 8$ ,P %  7_____    &$AE;' @9F]R($=A;64@4V5L96-T:6]N
+M        #  B "\ #     ,  0?3QFP     !]/&F             4'T\:X
+M_____P$   4'T\9\            ,    #  #0    T           $  0  
+M!P "      ?34I          !4]K87D     $@    $'TW&0!]-^^ ?3@2 '
+MT\;@!]/&^ ?3QP@    !      $      0     ,1T%$2$5,4$]+05D     
+M 0     !  ,  0  "0 -      ?3QS@'T\=P    +D-L:6-K(&]N($YE=T=A
+M;64@1V%D9V5T(&]R(&$@4V%V960@1V%M92!T=VEC90 #  $   H %@     '
+MT\>0         "]T;R!S=&%R="!A(&YE=R!G86UE(&]R('1O(')E<W5M92!A
+M('-A=F5D(&=A;64N   "$ X ( )   4 !?____\     !]-1\           
+M             0?3)H@       =(96QP,E\   $ BP \ 70 .@ %  7_____
+M    &TAE;' @9F]R($=A;64@36%N:7!U;&%T:6]N        $0 J "\ "@  
+M  ,  0?35 P     !]-.B             0'TU#(_____P$   4'TU0<    
+M        ,    #  "P    L           $  0  !P "      ?31O@     
+M    !4]K87D     $@    $'TTRX!]-., ?33J@'TU#P!]-.N ?34>     !
+M      $      0     ,1T%$2$5,4$]+05D      0     !  ,  0  #P -
+M      ?3=^@'TU0X    *U5S92!-96YU(&)U='1O;B!T;R!S96QE8W0@;W!E
+M<F%T:6]N(&]N('1H90 #  $   \ %@     'TWDX!]-4J    "QS96QE8W1E
+M9"!G86UE+"!O<B!D;W5B;&4@8VQI8VL@;VX@82!G86UE('1O  ,  0  #P ?
+M      ?3>"          %W)E<W5M92!T:&4@<V%V960@9V%M92X   (0#@ @
+M D  !0 %_____P     'T],@                       !!]-2$       
+M!T%B;W5T7P   0!9 #P!OP!3  4 !?____\    <06)O=70@=&AE($YE=$AA
+M8VL@5V]R:T)E;F-H        HP!$ &T "@    ,  0?3TI0     !]/1(   
+M          4'T]'@_____P$   4'T]*D            ;@   &X "P    L 
+M          $  0  *  "      ?3Q\@         !4]K87D     $@    $'
+MT\P8!]/,P ?3T(@'T]((!]/2P ?3TQ     !      $      0     ,1T%$
+M2$5,4$]+05D      0     !  ,  0  "  -      ?3TY 'T]/     )E1H
+M92!.971(86-K(%=O<FM"96YC:"!W87,@9&5S:6=N960@8GD  @ !  $V  T 
+M    !]/3X ?3U%     +2V5N($QO<F)E<@ #  $  8P #0     'T]- !]/4
+M<     1A;F0  @ !   ( !8     !]/3^ ?3U-     /1W)E9V<@5V]N9&5R
+M;'D  P !  !X !8     !]/4\ ?3U0     "+@ #  $  (< %@     'T]4@
+M!]/54    "=4:&4@<')O9W)A;6UI;F<@=V%S('-T87)T960@8GD@2V5N(&%N
+M9  #  $   @ 'P     'T]5P!]/5D    !5F:6YI<VAE9"!B>2!'<F5G9RXN
+M+@ "  $  !0 +P     'T]6P!]/5\    #-(86-K5T(@:7,@8V]P>7)I9VAT
+M($=R96=G(%=O;F1E<FQY(&%N9"!+96X@3&]R8F5R+  "  $   H .      '
+MT]80         #8Q.3DR('-E92!.971(86-K(&QI8V5N<V4@9F]R(&1E=&%I
+M;',@86YD(&QI;6ET871I;VYS(0   A . & "8  %  7_____            
+M                      ,'TU1X       '2&5L<#-?   ! $L "0'N +T 
+M!0 %_____P   "!(96QP(&9O<B!.971H86-K(%=O<FM"96YC:"!6,RXQ  ?3
+MZX@ # "M "\ "@    ,  0?3@5P     !]-]:             ,'TWWH____
+M_P(   4'TX%L            ,    #  "P    L           $  0  "  "
+M      ?35/@         !4925T0     $@    ,'TWR8!]-]$ ?3?8@'TX)8
+M!]-]F ?3@8@    !      $      0     ,1T%$2$5,4$925T0      0  
+M   !  ?3Z^ !L@"M "\ "@    ,  0?3Z[0     !]."B             0'
+MTX,H_____P(   4'T^O$            ,    #  "P    L           $ 
+M 0  "  "      ?3@J@         !4)+5T0     $@    ,'TX*X!].#4 ?3
+M@]@'T\QP!]/,B ?3T0     !      $      0     ,1T%$2$5,4$)+5T0 
+M     0     !        P@"P "$ "  #  ,  0?3[#@                 
+M    __\'T^Q0_____P,   4'T^P<            (@   "( "0    D     
+M!]/L./] __D!   "!]/1$          (      'I       )  ,  0?3UE '
+MT]I0!]/L> ?3[(@'T^R8!]/LJ     $      0     !      ,M,0     !
+M      $   (0#@ D F  !0 %_____P     'T_HP                    
+M   $!],F0       !5)S=%\   ( L0 \ 2< .0 %  7_____    $U)E8V]V
+M97(@4&%R86UE=&5R<P 'TWM8 &4 #P"Z  D   (#  0'TWC\            
+M    !]-,2   !]-2T/____\#   %!]-Y#            +L   "[  H    *
+M              $L       $ !L  &@H  X_S_B$ $0      H  R/__   E
+M   "$$<            Y!]0            H ![_____  $ "0    $  @ #
+M  @ !  %  < "0 & P !  &:  $      #D((             <    XF:8 
+M 0 XFB8  @ XF>8  P XF28 !  XFF8 !0 XFJ8 !@ XF68       $     
+M  $       $       $       $            !             0      
+M 0       0       0       0                 !       !       !
+M &D ! &W +X  0       A!  #B8.@                      !0     !
+M"@   @$'TR90!]-2^ ?35%@'TU38!]-4: ?3=E@    (4F5S=$1I<@     !
+M      $     "T=!1%)%4U1$25(      0     !  ?3_)  90 < +H "0  
+M @, ! ?3>X0                'TWA    'TWK@_____P,   4'TWN4    
+M        NP   +L "@    H              2P       0 &P  :"@ #C_/
+M^(0 1      "@ #(__\  "4   (01P           #D'U            "@ 
+M'O____\  0 )     0 "  , "  $  4 !P )  8#  $  9H  0      .0@@
+M            !P   #B9I@ ! #B:)@ " #B9Y@ # #B9)@ $ #B:9@ % #B:
+MI@ & #B99@       0       0       0       0       0          
+M  $            !       !       !       !       !            
+M      $       $       $ :0 $ ;< O@ !       "$$  .)@Z        
+M               %      $*   " 0?3=F@'TWAP!]-X@ ?3>=@'TWDH!]-[
+M"     A297-T3VQD      $      0     +1T%$4D535$],1      !    
+M  $ !]/_^  * "H .0 *     P !!]/\O      'TWNP            !0?3
+MY3#_____ P  !0?3_,P            Z    .@ +    "P           0  
+M   ,  $     !]-[T          %3VMA>0     *     0?3>^ 'TWQ !]-\
+M4 ?3@L@'T]B0!]/9D     E297-T3VMA>0     !      $     #$=!1%)%
+M4U1/2T%9      $      0       .8 *@ Y  H    #  $'U  D      ?3
+M]H             &!]/XV/____\#   %!]0 -            #H    Z  L 
+M   +           !      @  0     'T]XP          =#86YC96P     
+M"@    $'T_EH!]/LN ?3^8 'T_F0!]/Z$ ?3^B     +4F5S=$-A;F-E;   
+M   !      $     "T=!1%)%4U1#04X      0     !  $     #@ /    
+M  ?3^^@'T_P     "T1I<F5C=&]R>3H  0     2 !T     !]/\Z       
+-   *3VQD($9I;&4Z $1I
+ 
+end
diff -Pru nethack-3.4.1/sys/mac/old/DCproj.hqx nethack/sys/mac/old/DCproj.hqx
--- nethack-3.4.1/sys/mac/old/DCproj.hqx	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/DCproj.hqx	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,347 @@
+(This file must be converted with BinHex 4.0)
+:$%4REN0[EA!ZF(*[DJ"38Np+5d&)6!%!!!!!!!!!3*E6m3!!!!!"!!!!2NX!!$e
+,!!!#5`!!!-N!B!!!!!)(r`!!&ZB!D!!!!!%!!!!!!!!!!!!!$%4REN0[EA!ZF(*
+[DM!#!!!!8&*25NY"5%`"!!"S!)!!!&"56dT,38K-!3!!D!#!!!!!!!!!!!!!!!!
+!!!!!!!!!U@aE8J!!!!!!!%#@!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!r!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!X!!!&D!!#`"3!!4&*@8J!!!!!"j!"bdiJ!!2m`!,B!!!!!!!!!!!!
+!!!!!&!"bdiJ!!!!!!!!!!J!!!!!!!!#8!(,6L!!!!!!!m!"c!!!!DJ!!!!%!!!!
+#!3!!!!!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!BfpbC@0bC@`!!3kFF(0Z)!!
+!!!J!!!!!!!!!!Q&PGR3!!3!"D@jdC@9ZG@d!!!!%Bf&ZFcXl1cYVEf0XG(P`C3!
+!!!434%p$C'&dB9468%)!!!!!!!!!!!!!!!!!D!"bdiJ!!!!!!!!!!!!!!&S!!!!
+!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'&PGR4KEJ"b!!%1R("
+cEL!!!!!)!!!!!!!!!!*KCACd!!%!!6Xl1cX!DJ!!!!!!!!!8!(,6L!!!rc!!YJ!
+!!!!!!!!!!"4"8&"-2cmr2`!!!!!"JJ!!!!J!&Ip1!0)!2!!!!"C24`!#!S*%594
+-!!)#TNP$!!!!!!,+!!!!!!!!!!S!!!!'#!!!"JJ!!!!!B!!!!(!!!!!!!!!!8!!
+!!#!!)$mm!!'Tm!AZ2c`!!DR`"J)r2!!"UI!'&Mmm!!'Tm!Bb2c`!!DR`"QJr2!!
+"UI!'L$mm!!'Tm!DU2c`!!DR`"XSr2!!"UI!*4$mm!!'Tm!!!!!3!!!!!!!!!"!!
+!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!1!!
+i!$J!1!!i!$J!!!4!!!!!!!!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3)!!J!!!!!!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%#!!F!!!!
+#!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!)!!!!!!!!!'!!!!!8!!!!!!!!!!!!!!!1!!!!1J!!DC`!!!"
+X!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3-!"J!!!!-!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-%!!`!!!!
+!!!!!B!!!!"3!!$*-!!!!!!!!!!i!!!!k!!!!*!!!!'`!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!2!!!!"!!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3-!%!!!!!8!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%$!!3!!!!
+'!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!*!!!!"`!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!`3!!!!!!!!!!"'i!!!!&!!!!!!!!!!
+!!!!!$J!!!(`!!!#%!!!(#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-'!!-!!!!
+!!!!4Z!!!!"3!!!!!!!!!!!!!!!i!!!!%!!!!K!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!$"J!+!!!!#!!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3-!#`!!!!!!!!%J!!!U+!!!!!!!!!!
+!!!!!+J!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)%!!%!!!!
+!!!!"L!!!!"3!!$R`!!!!!!!!!!i!!(LZ!!"TR!!!!'`!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!0!!!!#3!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!J8!$J!!!!S!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)&!!8!!!!
+!!!!!!!!!!!!!"3!!!#!4c-pi6!!!!!!!)fPZBfaeC'8J2%eKBdKPB@4PFR-q!!!
+!!!)"!!!!!##K%(r`d!!!!#0TEQ0XG@4P)$a0B@0)C@&NCA*c+bXq!!!!!(!"!3!
+!!!!MC'9QD@jP)(4bG@8J)#!J)#!J-3dMC'9QD@jP)'CKE(0P)#!J)#!J-!dMC'9
+QD@jP)(*PHL!J)#!J)#!J-3dMC'9QD@jP)'4PFQ9k)#!J)#!J-!dMC'9QD@jP)&4
+)58j,Ae*PHL!J-3d!!!!!Q5%!!!!!!!!!)!!!!!!!!!!!!!!!!!!!!)!3!!J%,Q&
+cE3G85%P15b"$!LjM"e4)58j,)%-$,Q0`$&0jE@&ZG'9M)%-V+`3ZBh"`$&0jE@&
+ZG'9M)%-V+`8ZEQpdC3FJafj[EQA)!Lj[$5!ZEb"$EfjfCA*dCA)#,R)*9%K*6NX
+J8Q9k"5jbFh*M$e*PFfpeFQ0P)%0[F'PPFJ!!!!!!!#J!!2S`&!$k0"3!qM3d!2S
+i,J$k1'3!qMbf!2T"-J$k46!!qN9Q!2T*B!$k5CS!qNR8!2T*pJ$k@"3!!!!!!,)
+!S`!!!!!!+5RB!!#1#!!X!#J"b3%2!Ri!+!(*!Rerr`!T!Rd#IRrr!3i"b3(+Irm
+"$`(+!Rjrrhrr!!!!!!!T+D!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!+5Pi8b"5CA0[GA*MC3!EkJ!!+)!J!!%!!!!N!!#,F#F5!!!!!!$'Dk$
+rrrrr"d&MG'P[ER-!J)!J!!%!!!!N!!#,L#F6!!!!!!$'Dk$rrrrr"deKFQYPFR-
+!!)!J!!%!!!"%!!#,P#F8!0J!%!$'Dk$rrrrp"8CTE'9c(8j[EQ8JEh)JCQPXC5"
+ZEh3JH@9d)'0[EA"TE'9N!!!!!!!SJ#!!!J!!!"J!!)ZJ)(S!"%l3!2Yk-#"-J#!
+!!`!!!'3!!!#X!!353R9TE'3J3A"`E'PMBA4TEfl*&8*eD@aN)%4PFfXJ3@0MCA0
+cEh*jb44#G@PXC#"%CACTBf8J4(*TGQ9bb44#G@PXC#"$Ef4P)&*PFfpeFQ0Pb3"
+)j`!!!!!!!!'`!!#,p!!"!!-!!!!!!!!!!3!&!!!Mh!!!-fJ!!!#i!!!!!!!!!!!
+!!3!"!!%!!!!!!!!!1J!!!"3!!!!)!!!!!!!!!!%!!J!#!!)!'!$&!!!)h!!!'eS
+!!!"!!!!!!!!!!!)!!`!$!!-!#J!!!!!#8!!!!1S!!!!J!!!!!!!!!!-!"!!%!!5
+QS!!0!!!B%J!!&`3!!!")!!!!!!!!!!3!"3!&!!8!!!!!!!!!B!!!!!`!!!!)!!!
+!!!!"!!8!!!!'!!B!"`!#!!!VVJ!!!-i!!!ZS!!!!!!!!!!8!!3!(!!F!#J!G!!!
+EFJ!!!-i!!!L`!!!!!!!!!!B!!J!)!!J!!!!!!!!31!!!!!!!!!,i!!!!!!!"!!3
+!!!!*!!N!#J!#!!"cEJ!!$#)!!!DJ!!!!!!!!!!F!!3!+!!TQp!$'!!"ZNJ!!#qJ
+!!!B)!!!!!!!!!!J!!J!,!!X!aQlJ!!!%f!!!!$S!!!#B!!!!!!!#!!!!!!!-!!`
+!!!!!!!$(bJ!!3&J!!"0`!!!!!!%0!R`j-J!!!!!!!!!S!-AJ!!!!!!!!!!!!!!Q
+B&!!!!!!!!!!3!!#1$!#M!Bb!!!!%!!!!%!!!MH!!S`(I!!!!!!!T*rJ!T!'G!+3
+"h3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#J!!!!!!!!!!!!!!!!!
+!!!!!rrrrrrrrrrqTE&TP!!!!'!!"!!!Cfd&-6%m!!!!(B@aXEf-ZB`!!!DL2c8b
+SMme-U)r06!!!!"`!!J!!$d"0380)!!!"#NeKBdKPB@4PFR-!C3!"U@aD'+PX@KL
+TE&SB!!%!'J!"!!!CN8026NB!!!!)BfpZCQPR,QJ!F`!#U@aD4UPX@NDTE&T'!!)
+!(!!"!!!CN945383!!!!+G(*KC(0dC'-ZD!"P!!1N,E`5T#fm%U3Y[")!!`!D!!)
+!!!rZ8e4%33!!!3KcG'4KFQFZD!"S!!+TE&STU@aD+DPX@LN!"!!D!!%!!"Q44da
+23J!!!!KRE'pLB@`ZD!"S!!1Q`pMiTX2Bq+E$f2J!"3!B!!)!!!rZ8e4%53!!!3G
+cG'4TEbjS!!!%U'J6P+KS%j5SD"18!!B!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ
+!D!!$U@aD'DPX@KQTE&SC!!F!'!!"!!!CN8026e)!!!!(Bfp[FQ3ZD!!!!kPX@LZ
+TE&SVU@aD+`!)!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!!"+PX@N5TE&T%U@a
+D4!!*!"S!!3!!'C&6@908!!!!#(0jFh4PE5jS!!!!"DKeJ-+SGB$#U(@!`J!+!"J
+!!J!!$d&8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E$f33!#`!B!!)!!!rZ9%P
+043!!!3CdD@eP,QJ!!!!%U%FPA+K(*9bS4b9F!!`!'J!#!!!2390&4d`!!!%*Ff9
+RE'pKC#jS!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!2lP084%`!!!%)Fh4NE'PL,QJ
+!!!!&T#h!)U3Y`#+N,F!L!!i!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!%U%F
+P`+K(*F#S4bA!!!m!'J!#!!!239G*6N3!!!%*GfPZC'phFbjS!!!%T$(T3+3ak8#
+N-HP!!"!!'J!#!!!238e&68m!!!%)E@9YEh*j,QJ!!!!%U%FP3UK(*8+S4b9#!"%
+!(!!#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!!%J!D!!)
+!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5'U%FNKUK(*)B!%`!F!!)!!!p"3dp
+19!!!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6!U%FN`!!8!"S!!J!!$d&%58&-!!!
+"#@4TB@a[Ch-ZD!!!"+K(*2DS4b6fU%FNpJ!9!"J!!J!!$d&'6dj8!!!""fC[ER4
+c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!&J!B!!)!!!rZ4N019!!!!3GQBfjdE#jS!$!
+!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU)--%J!!!"B!!J!!$qG"6P0*!!!!"%&
+18dN!BJS!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aEQ3!!!"`!!3!!'Q0%4dj
+I!!!!#Q4REPpjB@0M,Q-!C3!"U)r06+L2c8bSMme-!!!!(!!#!!!23%e"3dJ!!!%
++6@&M5'9KC'9bF`"P!!'TE&SBU@aD'+PX@KJ!!3!D!!%!!"Q43dp14J!!!!KMEfj
+QD@FZD!"c!!+TE&T'U@aD4UPX@NB!!J!F!!%!!"Q49&*"4!!!!!TdFQ&NFh4NBbj
+S!'8!!k3Y["+N,E`5T#fm%J!$!"S!!J!!$qj69%4"!!!"#(0dC'&bCbjS!'J!!UP
+X@LQTE&STU@aD+3!%!"S!!3!!'C&(6%p#!!!!#'GXEf*KE#jS!'J!!kE$f2LQ`pM
+iTX2Bq!!&!"J!!J!!$qj69%4*!!!""h0dC'P[,QJ!!!5SD"18U'J6P+KS%j3!"J!
+D!!)!!!rZ8dPD43!!!!KcDATPAh3ZD!"S!!1TE&SCU@aD'DPX@KN!"`!B!!%!!"Q
+43dp28J!!!!GMEfpbC#jS!!!$U@aD+kPX@LZTE&SV!!J!'J!"!!!CN8e"3d-!!!!
+*E@&MBfpZCLjS!!!%U@aD4+PX@N5TE&T%!!N!'J!"!!!CN90C8e3!!!!)FhPcG'9
+Y,QJ!!!!&U(@!`UKeJ-+SGB$#!!S!'!!#!!!2394C8%8!!!%(G(P`CA-ZD!!!"DE
+$f35Q`pN%TX2C"!!,!"J!!J!!$qj858e&!!!""R4TE@8ZD!!!!!5S4b9FU%FPA+K
+(*9`!$!!D!!)!!!p"8d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pLHTX2BRUE$f*i!$3!
+D!!)!!!rZ8e4%6!!!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3Y`#)!$J!D!!)!!!r
+Z9d0)33!!!!PhBfKKFPpd,QJ!!!5S4bA!U%FP`+K(*F!!$`!D!!)!!!p"9dP14!!
+!!3PhD@jNEhGc,QJ!!!5N-HP!T$(T3+3ak8!!%!!D!!)!!!p"68906`!!!3KYC@e
+[FRNZD!!!!!5S4b9#U%FP3UK(*8)!%3!F!!)!!!p"899*3`!!!3YaG@PMDf4bBAF
+ZD!!!"+CNfF#QC0R!TQ6C`!!5!"S!!J!!$d&&9N91!!!"#'9fC@jdFbjS!#i!"+K
+(*)DS4b5'U%FNKJ!6!"`!!J!!$d&$6dj8!!!"#Q0[ER4bEfac,QJ!!!!%U%FN`+K
+(*-#S4b6!!"3!'J!#!!!2384*38`!!!%*C'PKE'pRFbjS!!!%U%FNpUK(*2DS4b6
+f!"8!'!!#!!!238C26P3!!!%(CQpZG(-ZD!!!"+3arj!!T$(rN!#N-Iq3!!!@!"J
+!!J!!$qj'3dj8!!!""fCMER4X,QJ!!!'TE&SFU@aD(+PX@K`!&`!F!!%!!"Q44%G
+1A`!!!!TNCfjICQPXC5jS!!!!!UPX@K1TE&S6U@aD%`!B!"J!!3!!'C&"6%P(!!!
+!"f&XD@GZ,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&ZA!!!!'J!"!!!
+DBd4(6Pm!!!!*C'GZAfaPH#jM!!!"U)r06+L2c8bSMme-!!!!(!!#!!!23%e"3dJ
+!!!%+6@&M5'9KC'9bF`!!!!'Q`pMiTX2Bq+E$f2J!!3!B!!)!!!rZ8e4%53!!!!G
+cG'4TEbjS!!!#U'J6P+KS%j5SD"18!!)!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ
+!F`!"U@aD'+PX@KLTE&SB!!-!'J!"!!!CN8026NB!!!!)BfpZCQPR,QJ!F`!#U@a
+D4UPX@NDTE&T'!!3!(!!"!!!CN945383!!!!+G(*KC(0dC'-ZD!!!!!1N,E`5T#f
+m%U3Y[")!"3!D!!)!!!rZ8e4%33!!!3KcG'4KFQFZD!"S!!+TE&STU@aD+DPX@LN
+!"J!D!!%!!"Q44da23J!!!!KRE'pLB@`ZD!"S!!1TE&SCU@aD'DPX@KN!"`!B!!%
+!!"Q43dp28J!!!!GMEfpbC#jS!!!$U@aD+kPX@LZTE&SV!!J!'J!"!!!CN8e"3d-
+!!!!*E@&MBfpZCLjS!!!%U@aD4+PX@N5TE&T%!!N!'J!"!!!CN90C8e3!!!!)FhP
+cG'9Y,QJ!!!!&U(@!`UKeJ-+SGB$#!!S!'!!#!!!2394C8%8!!!%(G(P`CA-ZD!!
+!"DE$f35Q`pN%TX2C"!!,!"J!!J!!$qj858e&!!!""R4TE@8ZD!!!!!5S4b9FU%F
+PA+K(*9`!$!!D!!)!!!p"8d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pLHTX2BRUE$f*i
+!$3!D!!)!!!rZ8e4%6!!!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3Y`#)!$J!D!!)
+!!!rZ9d0)33!!!!PhBfKKFPpd,QJ!!!5S4bA!U%FP`+K(*F!!$`!D!!)!!!p"9dP
+14!!!!3PhD@jNEhGc,QJ!!!5N-HP!T$(T3+3ak8!!%!!D!!)!!!p"68906`!!!3K
+YC@e[FRNZD!!!!!5S4b9#U%FP3UK(*8)!%3!F!!)!!!p"899*3`!!!3YaG@PMDf4
+bBAFZD!!!"+CNfF#QC0R!TQ6C`!!5!"S!!J!!$d&&9N91!!!"#'9fC@jdFbjS!#i
+!"+K(*)DS4b5'U%FNKJ!6!"`!!J!!$d&$6dj8!!!"#Q0[ER4bEfac,QJ!!!!%U%F
+N`+K(*-#S4b6!!"3!'J!#!!!2384*38`!!!%*C'PKE'pRFbjS!!!%U%FNpUK(*2D
+S4b6f!"8!'!!#!!!238C26P3!!!%(CQpZG(-ZD!!!"+3arj!!T$(rN!#N-Iq3!!!
+@!"J!!J!!$qj'3dj8!!!""fCMER4X,QJ!!!'TE&Z9U@aEPDPX@j8!&`!F!!%!!"T
+M4%G1A`!!!!TNCfjIBfpYF#jS!!!!!DPX@KbTE&SFU@aD(!!B!"`!!3!!'C&%4dj
+I!!!!#Q4REPpQD@aP,QJ!!!!#U@aD%kPX@K1TE&S6!"N!'!!"!!!CN8&-58F!!!!
+(B@aTCfiZD!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@m-!!!!F!!%!!"U
+!4%G1A`!!!!TNCfjIE@&TELjM!'8!!DL2c8bSMme-U)r06!!!!"`!!J!!$d"0380
+)!!!"#NeKBdKPB@4PFR-!C3!"U@aD'+PX@KLTE&SB!!%!'J!"!!!CN8026NB!!!!
+)BfpZCQPR,QJ!F`!#U@aD4UPX@NDTE&T'!!)!(!!"!!!CN945383!!!!+G(*KC(0
+dC'-ZD!"P!!1N,E`5T#fm%U3Y[")!!`!D!!)!!!rZ8e4%33!!!3KcG'4KFQFZD!"
+S!!+TE&STU@aD+DPX@LN!"!!D!!%!!"Q44da23J!!!!KRE'pLB@`ZD!"S!!1Q`pM
+iTX2Bq+E$f2J!"3!B!!)!!!rZ8e4%53!!!3GcG'4TEbjS!!!%U'J6P+KS%j5SD"1
+8!!B!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ!D!!$U@aD'DPX@KQTE&SC!!F!'!!
+"!!!CN8026e)!!!!(Bfp[FQ3ZD!!!!kPX@LZTE&SVU@aD+`!)!"S!!3!!'C&0380
+$!!!!#@eKBf0[EQBZD!!!"+PX@N5TE&T%U@aD4!!*!"S!!3!!'C&6@908!!!!#(0
+jFh4PE5jS!!!!"DKeJ-+SGB$#U(@!`J!+!"J!!J!!$d&8@9"&!!!""h4jF'9c,QJ
+!!!@Q`pN%TX2C"+E$f33!#`!B!!)!!!rZ9%P043!!!3CdD@eP,QJ!!!!%U%FPA+K
+(*9bS4b9F!!`!'J!#!!!2390&4d`!!!%*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pL
+H!!d!'J!#!!!2lP084%`!!!%)Fh4NE'PL,QJ!!!!&T#h!)U3Y`#+N,F!L!!i!'J!
+#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!%U%FP`+K(*F#S4bA!!!m!'J!#!!!239G
+*6N3!!!%*GfPZC'phFbjS!!!%T$(T3+3ak8#N-HP!!"!!'J!#!!!238e&68m!!!%
+)E@9YEh*j,QJ!!!!%U%FP3UK(*8+S4b9#!"%!(!!#!!!239&958-!!!%,FA9TBfY
+NFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!!%J!D!!)!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!
+Z!!5S4b5'U%FNKUK(*)B!%`!F!!)!!!p"3dp19!!!!3TMEfjdFQpXFbjS!!!!"+K
+(*-#S4b6!U%FN`!!8!"S!!J!!$d&%58&-!!!"#@4TB@a[Ch-ZD!!!"+K(*2DS4b6
+fU%FNpJ!9!"J!!J!!$d&'6dj8!!!""fC[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!
+!&J!B!!)!!!rZ4N019!!!!3GQBfjdE#jS!"!!!!!!!!!!!!!!!!!!!!!!!2rrrrr
+rrrrrU!L)V!!!!"B!!J!!$qG96NPB!!!!"(9ZDAJ!BJS!!!!!!!!!!!!!!!!!!!!
+!!2rrrrrrrrrrU@aEc`!!!"J!!3!!'S"338j*!!!!"h"KEQPM,Q-!!!'SMme-U)r
+06+L2c8`!!!!F!!)!!!p!68&$5!!!!3T0B@0)C@&NCA*c!'8!!DPX@KLTE&SBU@a
+D'!!"!"S!!3!!'C&$6dj'!!!!#'0[EQCTCbjS!(-!!UPX@NDTE&T'U@aD4J!#!"`
+!!3!!'C&88N&%!!!!#R4bB@4cG'4M,QJ!C3!$T#fm%U3Y["+N,E`5!!-!'J!#!!!
+2lP084%%!!!%)Fh4NBA*R,QJ!D!!#U@aD+DPX@LQTE&ST!!3!'J!"!!!CN8G-6d)
+!!!!)Cfa[BQ&X,QJ!D!!$TX2Bq+E$f2LQ`pMi!!8!'!!#!!!2lP084%N!!!%(Fh4
+ND@mZD!!!"+KS%j5SD"18U'J6P!!'!"S!!J!!$qj659T&!!!!#(0THQ9IG#jS!'J
+!!kPX@KQTE&SCU@aD'3!(!"J!!3!!'C&$6dp5!!!!"f0[Eh*N,QJ!!!1TE&SVU@a
+D+kPX@LX!#!!D!!%!!"Q468&$3`!!!!PYB@0MEfjQ,QJ!!!5TE&T%U@aD4+PX@N3
+!#3!D!!%!!"Q48eP69!!!!!KcHA0dC@dZD!!!!!@SGB$#U(@!`UKeJ-)!#J!B!!)
+!!!p"9&P343!!!3GdHA"PFbjS!!!&TX2C"+E$f35Q`pN%!!X!'!!#!!!2lP4*688
+!!!%'G'PYC5jS!!!!"+K(*9bS4b9FU%FPA!!-!"S!!J!!$d&648G-!!!"#A0PCfa
+[B@3ZD!!!"+E$f*kQ`pLHTX2BRJ!0!"S!!J!!$qj69%4-!!!"#(0dC'aTBLjS!!!
+!"D3Y`#+N,F!LT#h!)J!1!"S!!J!!$qjA3dK"!!!!#AGMD'&bAh3ZD!!!"+K(*F#
+S4bA!U%FP`!!2!"S!!J!!$d&A58j%!!!"#AGTEQ4[Gh-ZD!!!"+3ak8#N-HP!T$(
+T3!!3!"S!!J!!$d&048e2!!!"#'ePE@pbH5jS!!!!"+K(*8+S4b9#U%FP3J!4!"`
+!!J!!$d&498P$!!!"#h&eD@0VC(*KGbjS!!!%TQ6C`+CNfF#QC0R!!")!'J!#!!!
+2389@48i!!!%)CACPER4c,QJ!,J!%U%FNKUK(*)DS4b5'!"-!(!!#!!!238026P3
+!!!%+BfpZG(*[E(-ZD!!!!!5S4b6!U%FN`+K(*-!!&!!D!!)!!!p"4%P"6!!!!3P
+ND@&XEfGc,QJ!!!5S4b6fU%FNpUK(*2B!&3!B!!)!!!p"4Np19!!!!3GQEfjdFbj
+S!!!%T$(rN!#N-Iq3!+3arj!!!"B!'!!#!!!2lNC$6P3!!!%(CQ0ZG'`ZD!!!!!!
+!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkJpjc!!!!!D!!)!!!qb68&$9!!!!!K0B@0
+8FQ&`F`!!!!!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqS2HG+!!!!'J!#!!!2XNe
+"3e3!!!!*6@&M9(*KF(-b!!!!!!!!'!!"!!!CN8026e)!!!!!!!%!!!!)"'eKD@i
+J)##TE&SVU@aD+`!)!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!!"+PX@N5TE&T
+%U@aD4!!*!"S!!3!!'C&6@908!!!!#(0jFh4PE5jS!!!!"DKeJ-+SGB$#U(@!`J!
++!"J!!J!!$d&8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E$f33!#`!B!!)!!!r
+Z9%P043!!!3CdD@eP,QJ!!!!%U%FPA+K(*9bS4b9F!!`!'J!#!!!2390&4d`!!!%
+*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!2lP084%`!!!%)Fh4NE'P
+L,QJ!!!!&T#h!)U3Y`#+N,F!L!!i!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!
+%U%FP`+K(*F#S4bA!!!m!'J!#!!!239G*6N3!!!%*GfPZC'phFbjS!!!%T$(T3+3
+ak8#N-HP!!"!!'J!#!!!238e&68m!!!%)E@9YEh*j,QJ!!!!%U%FP3UK(*8+S4b9
+#!"%!(!!#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!!%J!
+D!!)!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5'U%FNKUK(*)B!%`!F!!)!!!p
+"3dp19!!!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6!U%FN`!!8!"S!!J!!$d&%58&
+-!!!"#@4TB@a[Ch-ZD!!!"+K(*2DS4b6fU%FNpJ!9!"J!!J!!$d&'6dj8!!!""fC
+[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!&J!B!!)!!!rZ4N019!!!!3GQBfjdE#j
+S!!!"U@aD(+PX@KbTE&SF!"F!(!!"!!!CN84(6Pm!!!!+C'GZAfCTE'8ZD!!!!!+
+TE&S6U@aD%kPX@K-!'!!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!S!!!!!!!!!!!!
+!!!!!!!!!!2rrrrrrrrrrU@aEP`!!!"S!!3!!'Q0%4djI!!!!#@4REPpXCAJZB`!
+!!DL2c8bSMme-U)r06!!!!"`!!J!!$d"0380)!!!"#NeKBdKPB@4PFR-!!!!"TX2
+Bq+E$f2LQ`pMi!!%!'!!#!!!2lP084%N!!!!(Fh4ND@mZD!!!!UKS%j5SD"18U'J
+6P!!#!"S!!J!!$qj659T&!!!!#(0THQ9IG#jS!(-!!DPX@KLTE&SBU@aD'!!$!"S
+!!3!!'C&$6dj'!!!!#'0[EQCTCbjS!(-!!UPX@NDTE&T'U@aD4J!%!"`!!3!!'C&
+88N&%!!!!#R4bB@4cG'4M,QJ!!!!$T#fm%U3Y["+N,E`5!!8!'J!#!!!2lP084%%
+!!!%)Fh4NBA*R,QJ!D!!#U@aD+DPX@LQTE&ST!!B!'J!"!!!CN8G-6d)!!!!)Cfa
+[BQ&X,QJ!D!!$U@aD'DPX@KQTE&SC!!F!'!!"!!!CN8026e)!!!!(Bfp[FQ3ZD!!
+!!kPX@LZTE&SVU@aD+`!)!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!!"+PX@N5
+TE&T%U@aD4!!*!"S!!3!!'C&6@908!!!!#(0jFh4PE5jS!!!!"DKeJ-+SGB$#U(@
+!`J!+!"J!!J!!$d&8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E$f33!#`!B!!)
+!!!rZ9%P043!!!3CdD@eP,QJ!!!!%U%FPA+K(*9bS4b9F!!`!'J!#!!!2390&4d`
+!!!%*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!2lP084%`!!!%)Fh4
+NE'PL,QJ!!!!&T#h!)U3Y`#+N,F!L!!i!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#j
+S!!!%U%FP`+K(*F#S4bA!!!m!'J!#!!!239G*6N3!!!%*GfPZC'phFbjS!!!%T$(
+T3+3ak8#N-HP!!"!!'J!#!!!238e&68m!!!%)E@9YEh*j,QJ!!!!%U%FP3UK(*8+
+S4b9#!"%!(!!#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!
+!%J!D!!)!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5'U%FNKUK(*)B!%`!F!!)
+!!!p"3dp19!!!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6!U%FN`!!8!"S!!J!!$d&
+%58&-!!!"#@4TB@a[Ch-ZD!!!"+K(*2DS4b6fU%FNpJ!9!"J!!J!!$d&'6dj8!!!
+""fC[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!&J!B!!)!!!rZ4N019!!!!3GQBfj
+dE#jS!!!"U@aEPDPX@j@TE&Z9!"F!(!!"!!!DBd4(6Pm!!!!+C'GZAf0[EA!ZD!!
+!!!'TE&SFU@aD(+PX@K`!'!!F!!%!!"Q44%G1A`!!!!TNCfjICQPXC5jS!!!!!UP
+X@K1TE&S6U@aD%`!C!"J!!3!!'C&"6%P(!!!!"f&XD@GZ,QJ!#J!!!!!!!!!!!!!
+!!!!!!!!!rrrrrrrrrrqTE&[$!!!!(!!"!!!DJ%4(6Pm!!!!+C'GZAfeKD@iZB`"
+P!!'SMme-U)r06+L2c8`!!!!F!!)!!!p!68&$5!!!!3T0B@0)C@&NCA*c!'8!!DP
+X@KLTE&SBU@aD'!!"!"S!!3!!'C&$6dj'!!!!#'0[EQCTCbjS!(-!!UPX@NDTE&T
+'U@aD4J!#!"`!!3!!'C&88N&%!!!!#R4bB@4cG'4M,QJ!C3!$T#fm%U3Y["+N,E`
+5!!-!'J!#!!!2lP084%%!!!%)Fh4NBA*R,QJ!D!!#U@aD+DPX@LQTE&ST!!3!'J!
+"!!!CN8G-6d)!!!!)Cfa[BQ&X,QJ!D!!$TX2Bq+E$f2LQ`pMi!!8!'!!#!!!2lP0
+84%N!!!%(Fh4ND@mZD!!!"+KS%j5SD"18U'J6P!!'!"S!!J!!$qj659T&!!!!#(0
+THQ9IG#jS!'J!!kPX@KQTE&SCU@aD'3!(!"J!!3!!'C&$6dp5!!!!"f0[Eh*N,QJ
+!!!1TE&SVU@aD+kPX@LX!#!!D!!%!!"Q468&$3`!!!!PYB@0MEfjQ,QJ!!!5TE&T
+%U@aD4+PX@N3!#3!D!!%!!"Q48eP69!!!!!KcHA0dC@dZD!!!!!@SGB$#U(@!`UK
+eJ-)!#J!B!!)!!!p"9&P343!!!3GdHA"PFbjS!!!&TX2C"+E$f35Q`pN%!!X!'!!
+#!!!2lP4*688!!!%'G'PYC5jS!!!!"+K(*9bS4b9FU%FPA!!-!"S!!J!!$d&648G
+-!!!"#A0PCfa[B@3ZD!!!"+E$f*kQ`pLHTX2BRJ!0!"S!!J!!$qj69%4-!!!"#(0
+dC'aTBLjS!!!!"D3Y`#+N,F!LT#h!)J!1!"S!!J!!$qjA3dK"!!!!#AGMD'&bAh3
+ZD!!!"+K(*F#S4bA!U%FP`!!2!"S!!J!!$d&A58j%!!!"#AGTEQ4[Gh-ZD!!!"+3
+ak8#N-HP!T$(T3!!3!"S!!J!!$d&048e2!!!"#'ePE@pbH5jS!!!!"+K(*8+S4b9
+#U%FP3J!4!"`!!J!!$d&498P$!!!"#h&eD@0VC(*KGbjS!!!%TQ6C`+CNfF#QC0R
+!!")!'J!#!!!2389@48i!!!%)CACPER4c,QJ!,J!%U%FNKUK(*)DS4b5'!"-!(!!
+#!!!238026P3!!!%+BfpZG(*[E(-ZD!!!!!5S4b6!U%FN`+K(*-!!&!!D!!)!!!p
+"4%P"6!!!!3PND@&XEfGc,QJ!!!5S4b6fU%FNpUK(*2B!&3!B!!)!!!p"4Np19!!
+!!3GQEfjdFbjS!!!%T$(rN!#N-Iq3!+3arj!!!"B!'!!#!!!2lNC$6P3!!!%(CQ0
+ZG'`ZD!!3!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkJ)L+`!!!!@!!)!!!rR98j
+*@!!!!!4eEQPi!')!!!!!!!!!!!!!!!!!!!!!!!!!!!!!@Q@T8&TPU@aDC3!!#J!
+!!!!!!!!!!!!!!!!!!!!!U@aDCDPX@Q@TE&TP!!!!'!!"!!!Cfd&-6%m!!!!(B@a
+XEf-ZB`!!!DL2c8bSMme-U)r06!!!!"`!!J!!$d"0380)!!!"#NeKBdKPB@4PFR-
+!C3!"U@aD'+PX@KLTE&SB!!%!'J!"!!!CN8026NB!!!!)BfpZCQPR,QJ!F`!#U@a
+D4UPX@NDTE&T'!!)!(!!"!!!CN945383!!!!+G(*KC(0dC'-ZD!"P!!1N,E`5T#f
+m%U3Y[")!!`!D!!)!!!rZ8e4%33!!!3KcG'4KFQFZD!"S!!+TE&STU@aD+DPX@LN
+!"!!D!!%!!"Q44da23J!!!!KRE'pLB@`ZD!"S!!1Q`pMiTX2Bq+E$f2J!"3!B!!)
+!!!rZ8e4%53!!!3GcG'4TEbjS!!!%U'J6P+KS%j5SD"18!!B!'J!#!!!2lP0*@N8
+!!!!)FfPkC9pd,QJ!D!!$U@aD'DPX@KQTE&SC!!F!'!!"!!!CN8026e)!!!!(Bfp
+[FQ3ZD!!!!kPX@LZTE&SVU@aD+`!)!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!
+!"+PX@N5TE&T%U@aD4!!*!"S!!3!!'C&6@908!!!!#(0jFh4PE5jS!!!!"DKeJ-+
+SGB$#U(@!`J!+!"J!!J!!$d&8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E$f33
+!#`!B!!)!!!rZ9%P043!!!3CdD@eP,QJ!!!!%U%FPA+K(*9bS4b9F!!`!'J!#!!!
+2390&4d`!!!%*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!2lP084%`
+!!!%)Fh4NE'PL,QJ!!!!&T#h!)U3Y`#+N,3!!#9B!!!!+!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!#`!!!!"#H!T+RFj1ZJ"S6VS!H#`m58j%@%kk"dj(q[r'*Sa
+(q[r%*S41ZJ#!6VS$YNkk#!C1ZJ$b6VS![Nkk!#C#CdKirrp)E`!%5&G)H!!")MV
+rUNkk"9j1Y4J!)'d!E%k3!+Rd)MVrQQF)6VS&5%ke'!"1G9(i#Pj`!%kk"-CR"NU
+3!'F#S%P1G5!i#RKQ$L`m@Np148kk"Y)J$'!'*N!J+`!J4rVr5#D!6R8X2%4"9%&
+1ZJDf)%`LH!N))!5J,Nkk"fT(q[m`*S3X2&088P01ZJDB4rVr(#D-,$a%8N9-6VS
+'L#"-)!4R$%kk!Ui%J!!!!!aQp%lk"c419[rD3IJ*%#*2F##J,R!"d"&D%G,!3IS
+!%R!&S#j9MdK[!!+TPdjH6R8ZFR0bB`"(qJIf*VJ+I#"i#RLar!!!!!"R#%Ik"qB
+QU!!@,cJ+J'B#@)p1G9L251Irq$i[!$K4q!THB!TCMbm)UD8J(k"!-!G1ZJ2@Cfa
+(q[k'*SJJ%'IN)N"+N@BZS#QJ55`m3e*&6%kk"GjR6$i[!$JJ6#!%C`a1ZJ$D")!
+!!!!-C[41ZJD#6VS#I#"krNLJD3J!!!GQ"+"NS#P1ZJ,Q)Qm!0&f*,dN!0NcI(rp
+8MdSi!5eR!URr6R9`$kR*@)mJE`!%$&"1q@B1-#"1ZJ05CqLJ+Nkk!S!ZRdje6VS
+(+Nkk!!j1ZJDB6R91ZJFF6R8J1JF3CJ!!-L"i!UC`$0#3!,#i!UTQ)L"i#ZbJ*5"
+3)NJL''!+3HJ!#(3"K"M3`P(*rr53!)M3L@B#6R8L!+!Z)(J+l#!"S#3L8%r[rm!
+J6d+S!")aD3!%!"DJ&8+R5'N!$#"2UI)b'%kk!ZiN@0A"0"JL''iqCb*53@F58N&
+R*PC"C`!!VP*"C`!!Q%je-LMrp%kk![c68Nje-LMrp%kk!Xc68Nje-LMrp%kk!Y,
+6U[rq6R91ZJ+5-LN!$%TT!!TQ)&4#DK"53QCiF'1Tb9*#C[M68Nje6VS#P0+T!!l
+68Nje6VS#V0+T!!i-3[rmCf*YD&*#CJ668Nje3r8B!Vj4CX`-B6mmCXC53QB'#QS
+!&rrq-L&B35*kr0$5NC*+de*1G6)Srr41ZJ*SdSh6U[rq6R8b+2rd6VS#00+0dkV
+rrNje6VS#+0+T!!l5MG1Urrj1GG+0dkVrrNje3r8B!Vj4C[!-B6mmCZS+DJ!$rr`
+b)9a")RVmG0+4dUVrrT*+08(rrM5m6R&1G6)B6VS"i%Ae'!$9f$3BCc)L''iNC`j
+53@B8-LMrp%kk!HKJ'$)Srr41ZJ'kB!ib+2rd6VS"`Q!'6VS"iY+0dj*1G5)B6VS
+"eY056R8JH[[q)$VlrNUS!!"R+$)S!#KR)L3S!"KC3N2Y!"$6k!!%e9Nbr$mm3KN
+5k!!p-[bTm&&"CZa"k!"!")!!!!"!CXC1G5"kqlSJ1[ZkF[pd!%US!!"R'ViS!$e
+Q&$BS!#K)`fF-e)1bU!!%C33L+!!%3HJ!3!5!!!!!3'E8)(VlPL"3F"#5J1D*--(
+QLJ"#J!!``Nje)&"b!$)B-"J#3(rrjiP$p4JJ0"&J%L)T!!55L$,"-[`r2$,#-[b
+Tm&()rqaJ0L!3S&8J3()!-KJ`'!*!IrrRL82e'#!-D8lj!!*R'$3T!!4J$M)45(!
+3!$,#-[a1q5,I8FMrm#!k!!SJ3'B#B3C1d!!!!!!`2+#pSdBL#$!mU*qR4V+)C`C
+"qJ!XB#!-1!!%!5pP"N(k!#*J%J`i!!)",f8'3IS!''!%3IS!(N2krm)LL%jeS,e
+1GI6i6R91HJ!##-!!!djl!!*1G9Q2,ca$6d4&2`#TS#"I82J+AL!)6R8SH[U5)Nb
+6e1@"fF(6e%je+(VkHX,m!%!L0"JB+(VkJY+86R8SH[TQ`[`!3#)d'!L5Z[TU6R8
+SH[T8`[`!3#)d'"$5Z[T86R8SH[T#`[`!3#)d'!3'J3!!!""1G8kkrk)b+3!-5QN
+!#QB'6VVrZ'!%6VVreY+T!!j1G5"I-KJd',"B9mRrqNT#Crj1m#$m)&mb'$3BX*K
+AbIrk5N*RrNl`)2SJAc)B0"L`3Qi+N!""E3E33%(`!!)`%'Iq6[!!!#![!!3[33!
+%)Lm!##pI!!4)jc`!*!!Q!8K#a--S!#S"5%A)aG4%5%*#3X$"d)*-h`!m)Kp1G5!
+[!!3[33!%)Lm!##pI!!4)jc%!6VS!R%cI!)`L(dje)#m!"#p"!!3L,`!),em!"%M
+R-3"1ZJ"m)!&-h`#-)Kp1G5![!!3[33!%)Lm!##pI!!4)jc%!6VS!,%cI!)`L(dj
+e)#m!"#p"!!3L,`!),em!"%MR-3"1ZJ!-)!&-h`#-)Kp1G8U!DKa+J@S-4)"%J8k
+k!#"%J8je4)"1ZJ!@4)"%J8je5S&U#N5"6VS!"N5!6R8Z2!!!rrqbJ'-')J"`!%j
+eX)GL$)$"5%!b!%*!5%"1GE+(BKSZ!%*!5%#!`8K!5%Fq!%K(MX%`"dK(-JG1G53
+!*J(LL1+*XSGLq)$"`)Fb!m,!,J0)4ml!5%I5Kf8)NS*L"%5"6R963'$NIJ"4q!T
+H@Bm["Mm(UD!J(fF!!+iQ3&Q2,`ZTT5BI)!XS!e*(ldG54cS(B"CCMbm'2`HTS#!
+IC`!!L&*("S3!!(rq9Bm[!+QQ-"m)!!!&CYa3q!THcd@D4fBF)!1J3#m,UD)J%fF
+!!&S[#kQ5+&-J5k!TF!&1G5!%S4iJ#'F!!%)S5#m,UD)J%fF!!$BJ5b!$B"KCMbm
+'2`HTS#!IC`!!)P*()%!J2!!!Iri[##"3)NcC`+!ZUD04cIrDQF3Q6(!"6R8J5dT
+&CJ5J)djeS"p1G6)mUI"$q[N36VS!X$)mUI*$q[Qm6VS!T$)mUI&$q[Q+6VS!Q$)
+mUI0$q[QN)(J+H,(m!!!!!'F3)#J!&QF+)#J!('F86[S!G%kk!(!b2+Rd3rVjG%l
+k!'41ZJ"J-MbTp%2kqA*1qJ"8,`JJE`!),fJ!!J!))$S!GQB!!$`JH!+QF!c3N!#
+`Z!+UCLa1ZJ"Q-MbTm%kk!%)b2+Ra6VS!1M)mUI*1ZJ!b-MbTmdkk!#Sb2+Rd6VS
+!)L"I6R8`!D&'*%K`$+%H-!'J4c$m6VNJb6$m6[NJbNje-!'K4L*S!!LJ(c!")%Q
+J4dje!!!!!!!!!!"1G5!krr4R"#"!3T!!6R8!!!!!!!!"!!!!2NX!!$e,!!!#5`$
+'ES!,"J!!!"`#&J!45%&65!!!!**D6dj&!!!!RNY*6N3!!!#U9da23`!!!,C*6N4
+B!!!!`P0-8e3!!!$13dp%43!%!0T%394"!!!"&P088P-!!!%L4&*&6!!!!5j6@8e
+6!!!"1N014NF!"!&'8dPD43!!!B*%3P08!!!"MN4#9e-!!!'D3e*&6!!#!DC%3P9
+(!!)"bNCA58i!!!(Z!!%!!!!!!!!!aQMS!!$rr`!!#qN!aQYX!!$rr`!!!r3!aQi
+N!!$rr`!!"9)!aQbF!!$rr`!!"M3!aQYJ!!$rr`!!"L!!aQ[!!!$rr`!!"BS!aQY
+i!!2rr`!!"Hi!aQb%!!Arr`!!"IB!aQbN!!6rr`!!"Ii!aQaX!!(rra3!-qd!aQ`
+8!!$rr`!!"JB!aQZ%!!$rr`!!"JS!aQZF!!$rr`!!"Ji!aQZ3!!!!rrm!!!B5!-C
+VU#LK!!B!!!UU!-CVc#(Y!"3!!!U`!-CVf"2A!#%!!!U'!-CVj(-`!#N!!!V8!-C
+Vm!!,rrm!!!Y)!-CV92rr!$-!!!9m!-CV5!#!rrm!!![P!-CVr!#!rrm!!!9H!-C
+X#!!$rrm!!!B@!-CYj!!&rrm!!!BD!-CXH!!%rrm!!!Ti!-CZ#!!$rrm!!!Tm!-C
+XV!!&rrm!!!U!!-CXZ!!%rrm!!$e(!-CXS!#!rrm!!!9i!-CYi!9YDf&SE!dJ,Qm
+J3fpZGQ9bG'9b$&0jE@&ZG'9M)%-V+`G85%P15b"$#94)58j,)&*PHJ%l0LF:
diff -Pru nethack-3.4.1/sys/mac/old/Install.mpw nethack/sys/mac/old/Install.mpw
--- nethack-3.4.1/sys/mac/old/Install.mpw	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/Install.mpw	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,102 @@
+How to make Mac NetHack 3.1 using MPW
+Copyright (c) 1992-11-23 Jon W{tte
+
+
+Please read these instructions through carefully before starting to
+build NetHack for the Macintosh.  Most important is the part about
+keeping the folder structure intact, and how to move a few files
+around.
+
+For me, having done this a few times, steps 1-7 take less than five
+minutes.  Add to that an average compilation time of 25 minutes
+(without VISION_TABLES, see below) and a full build of NetHack from
+scratch doesn't take more than a lunch break.
+
+0)	Requirements:
+	- MPW C 3.2
+	- Mac with 68020 or better CPU (this is required to run MPW 3.2)
+	- 10 MB free disk (at least)
+	- 8 MB memory (using System 6, or a slimmed System 7)
+	  More is quite preferable.
+	- About 7 minutes of time on a Quadra with a RAM disk that fits
+	  the entire compilation.  Less than an hour for an SE/30 with
+	  standard hard disk.
+	- Do NOT use virtual memory, or the compilation will quite possibly
+	  take the whole weekend.  We're serious.
+
+1)	Move all source files onto your hard disk.  Make sure to keep the
+	folder structure the way it is.  You can skip the "tty" "X11" "amiga"
+	"msdos" "os2" and "vms" folders if you are hard pressed for space.
+	Also make sure the files are in native mac text format (i.e. ASCII
+	13 is used for newlines).
+
+2)	De-binhex the file :sys:mac:NHmake.hqx using Stuffit, Compact Pro,
+	tickle, or any other de-binhexer.  Move the resulting file
+	(Nethack.make) into the "top" folder (the one containing the
+	folders "src" "include" etc).
+
+3)	De-binhex the files :sys:mac:NHrez.hqx, :sys:mac:NHrsrc.hqx and
+	:sys:mac:NHsound.hqx. If there is no sound file, or you do not
+	want the sounds (they take up 200K in the final binary) you must
+	create an empty resource file called "Sounds.rsrc" in the folder
+	:sys:mac, using ResEdit.
+	The resulting files should be left in :sys:mac:
+
+4)	Edit the make file Nethack.make to set the Top variable.  If your top
+	folder is called "nh31" and is in the MPW folder, this is not needed.
+
+5)	Create two new folders in the top folder, named "Dungeon" and "Obj".
+
+6)	You may want to edit some of the options in :include:config.h to suit
+	your tastes.  However, using MPW, this file will self-configure for
+	the default Mac distribution.
+
+	NOTE: The make file defines VISION_TABLES, so you should not concern
+	yourself with that option in config.h. However, compiling with the
+	option VISION_TABLES will generate a faster binary, at the expense of
+	the size of the application, and compilation time.
+
+	Your MPW shell will need at least 7000K REAL MEMORY (TempMem
+	won't do) for this compile to work. If you don't have it, you
+	can try removing the VISION_TABLES option in the make file,
+	you will however still need around 3000K for the MPW shell.
+
+7)	Use BuildProgram on the make file. This is Cmd-B for most folks.
+	Sit back and relax. The linker will spew out a lot of warnings
+	about global data size (Error 34) but that's OK. If you don't
+	want the warnings, turn on -model far in the make file; this will
+	make a slightly less efficient program but gives no warnings.
+
+8)	When the build is done, a short melody is played, and the results are
+	in the Dungeon folder.  Enjoy!
+
+9)	If you want to make any changes to the dungeon compiler or the special
+	level compiler, you will need to edit the makefile to remove the
+	dependencies for dgn_comp.h and lev_comp.h.  You should then add 
+	dependencies for dgn_lex.c and lev_lex.c (output by lex) You
+	will also need dependencies for dgn_yacc.c and lev_yacc.c (Output
+	of yacc).  All four of these files should end up in the Top:sys:share
+	folder.  Finally, the y.tab.h output from yacc should end up in
+	the include folder as dgn_comp.h/lev_comp.h.
+	
+
+10)	If, heaven forbid, you experience any configuration problems or make
+	errors, try to fix it yourself (there are several READMEs and the
+	like you can check), but be sure to save a copy of the original files
+	if you change anything.  There should be no problems if you use the
+	correct versions etc. as per step 0 but you never know.  As always,
+	turn off all INITs and re-boot if you have any problems, and they
+	might go away.
+
+	If you experience any bugs, please mail them to the bug report address
+	nethack-bugs@linc.cis.upenn.edu
+	Be sure to include what computer you use, how it is configured, what
+	version of MPW and C and the headers you use, where you got the
+	NetHack code etc. etc.
+
+11)	This code is provided "as is" free of charge, and no warranty of any
+	kind can or will cover it.  Use at your own risk.  This code is
+	protected under copyright law, and may only be re-distributed under
+	the terms of the NetHack license also found in this package, or
+	otherwise with the authors' permission.  (If the license is missing,
+	mail the bug report address for a copy.)
diff -Pru nethack-3.4.1/sys/mac/old/Install.thk nethack/sys/mac/old/Install.thk
--- nethack-3.4.1/sys/mac/old/Install.thk	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/Install.thk	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,278 @@
+Notes on Building NH3.2 with Think C
+
+In General
+
+	What is different between MPW and Think C?
+
+	Think C does not have a shell, :-(.  MPW does.  Ugh.  The lack of
+shell requires the cumbersome task of building the pieces by hand.
+We build NetHack in the top directory but all files are placed in a result
+directory.  The final executable will need to be moved to this result
+directory.  Eventually we hope to modify NetHack to look for its files
+in its resources.
+
+	Life without a shell also requires the NetHack resource file to 
+be put together by hand.  This is one area that Think C 6.0 has improved our
+lives.  Under 6.0, we can now add E.rsrc and E.r files as source to the
+project.  Dot rsrc files will be added to the project rsrc file directly and
+dot r files will be compiled and then added.  For those who are without Think
+6.0, good luck.  The best approach is to use the resource compiler to compile
+the dot r file, and name the result as the projects rsrc file.
+
+	Makedefs is another story.  When run, a command window pops up.  Hit return
+to perform all options.  Otherwise, type in the options you require.
+
+	Needless to say, all of the above stuff that we must do because of
+the lack of shell also implies no Makefile, so we must be aware of what
+files that we have modified and which files are dependent upon these modified
+files.  In other words, we must constantly ask ourselves "gee, do we need to
+run Makedefs again?".  Life is tough; this is to help you get used to it.
+
+	What follows are most of the steps that we take in compiling NH3.2 using
+Think C 6.  If you find something left out, or think a little more detail is
+needed, send us some mail.  We can be reached at nethack-bugs@linc.cis.upenn.edu
+
+The Steps
+
+	-2. Read the Think C manuals.  Know your compiler and your
+	    environment.  They are your friends and you are stuck with them.
+	
+	-1. Get Think Reference or buy a bunch of books that cover
+	    Macintosh programming (the correct number of books can be
+	    determined when you start seeing the same stuff over and over
+	    again -- or you run out of cash).
+		
+	0. Learn C and the standard io library.
+	
+	From here, we will assume that you know how to build and compile
+projects, how file names are resolved, what a project's resource file is
+for, and how the resource compiler works.  If you don't, repeat the above
+steps.
+	
+	1. Grab the sources, maintaining the directory structure.  We will
+refer to the top most directory as 'top'.
+
+	2. Move the project files in :sys:mac to top.  The projects are MakeDefs.proj,
+DgnComp.proj, LevComp.proj and NetHack.proj.
+	
+	3. Delete (or rename) 'sys:mac:hack.h'.  It is used in the MPW
+build and will interfere with the Think C compile.
+
+	4. Create a directory "lib" at the top level.
+
+	5. Build and run MakeDefs.
+
+		You will be presented with a list of options.  Initially choose them all (the
+		default).  Later you may wish to only run a few of them.  The options are
+		"odemvpqrhz", each of which makes a file:
+
+				-o creates :include:onames.h
+				-p creates :include:pm.h
+				-z creates :src:vis_tab.c
+				-m creates :src:monstr.c
+				-e creates :dat:dundeon.pdf
+				-v creates :lib:options
+				-d creates :lib:data
+				-r creates :lib:rumors
+				-h creates :lib:oracles
+				-q creates :lib:quest.dat
+
+	6. Make a precompiled header.  This step is optional.  If you do it, you
+	   will speed up your compile, but it adds complexity.  If you change any
+	   header, you will need to redo this step.  Change the following files:
+
+		include:hack.h
+			a. this file should be renamed 'include:realhack.h'.
+			b. create a new file 'sys:mac:NetHack Headers.c'
+			   with a single line:
+				#include 'realhack.h'
+			c. precompile this new file and save the precompile output
+			   as 'include:hack.h'
+	
+		sys:share:lev_lex.c, sys:share:lev_yacc.c, util:lev_main.c
+			a. change inclusion of 'hack.h' to 'realhack.h'
+
+	7. Copy the following files.  You may want to change News or NHDeflts.
+
+		a. copy ':sys:mac:MacHelp' to ':lib:MacHelp'
+		b. copy ':sys:mac:News' to ':lib:News'
+		c. copy ':sys:mac:NHDeflts' to ':lib:NetHack Defaults'
+
+	8. Build and run DgnComp.
+		This will create a file "dungeon" in the lib directory.
+
+	9. Build and run LevComp.
+		This will build the level files (*.lev) in the lib directory.
+
+	10. Build NetHack.
+		Move NetHack in the lib directory.
+
+
+
+Appendix
+
+A. Futures
+
+	1.	Modify NetHack to look for data files in the folder 'data'.
+	2.	Take advantage of the new scripting abilities of Think C 6.0.
+
+B. Project Contents
+
+All projects should have both far code and far data set.  Set the
+application size of NetHack.proj to a couple of megs.
+
+Set the application size of LevComp.proj to a meg (We suspect that there is a
+memory leak in there somewhere).  All projects should contain the libraries
+MacTraps, ANSI, and unix.
+		
+		MakeDefs.proj should contain the following source files:
+		
+			objects.c
+			monst.c
+			MakeDefs.c
+			
+		DgnComp.proj should contain the following source files:
+			
+			dgn_lex.c
+			dgn_main.c
+			dgn_yacc.c
+			alloc.c
+			panic.c
+
+		LevComp.proj should contain the following source files:
+		
+			monst.c
+			objects.c
+			drawing.c
+			alloc.c
+			panic.c
+			lev_lex.c
+			lev_yacc.c
+			macerrs.c
+			macfile.c
+			decl.c
+			lev_main.c
+			
+			add #define SPEC_LEV to prefix
+			
+		NetHack.proj should contain the following source files:
+
+			allmain.c
+			alloc.c
+			apply.c
+			artifact.c
+			attrib.c
+			ball.c
+			bones.c
+			botl.c
+			cmd.c
+			dbridge.c
+			decl.c
+			detect.c
+			display.c
+			do.c
+			do_name.c
+			do_wear.c
+			dog.c
+			dogmove.c
+			dokick.c
+			dothrow.c
+			drawing.c
+			dungeon.c
+			eat.c
+			end.c
+			engrave.c
+			exper.c
+			explode.c
+			extralev.c
+			files.c
+			fountain.c
+			hack.c
+			hacklib.c
+			invent.c
+			light.c
+			lock.c
+			maccurs.c
+			macerrs.c
+			macfile.c
+			macmain.c
+			macmenu.c
+			macsnd.c
+			macunix.c
+			macwin.c
+			makemon.c
+			mcastu.c
+			mgetline.c
+			mhitm.c
+			mhitu.c
+			minion.c
+			mklev.c
+			mkmap.c
+			mkmaze.c
+			mkobj.c
+			mkroom.c
+			mmodal.c
+			mon.c
+			mondata.c
+			monmove.c
+			monst.c
+			monstr.c NOTE: created by MakeDefs -m, so add it later
+			mplayer.c
+			mstring.c
+			mthrowu.c
+			muse.c
+			music.c
+			o_init.c
+			objects.c
+			objnam.c
+			options.c
+			pager.c
+			pickup.c
+			pline.c
+			polyself.c
+			potion.c
+			pray.c
+			priest.c
+			quest.c
+			questpgr.c
+			random.c
+			read.c
+			rect.c
+			restore.c
+			rip.c
+			rnd.c
+			rumors.c
+			save.c
+			shk.c
+			shknam.c
+			sit.c
+			sounds.c
+			sp_lev.c
+			spell.c
+			steal.c
+			timeout.c
+			mactopl.c
+			topten.c
+			track.c
+			trap.c
+			u_init.c
+			uhitm.c
+			vault.c
+			version.c
+			vision.c
+			vis_tab.c	NOTE: generated by Makedefs -z
+			weapon.c
+			were.c
+			wield.c
+			windows.c
+			wizard.c
+			worm.c
+			worn.c
+			write.c
+			zap.c
+			getline.c
+			topl.c
+			wintty.c
+			mactty.c
+			mttymain.c
+			dprintf.c
diff -Pru nethack-3.4.1/sys/mac/old/LCproj.hqx nethack/sys/mac/old/LCproj.hqx
--- nethack-3.4.1/sys/mac/old/LCproj.hqx	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/LCproj.hqx	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,519 @@
+(This file must be converted with BinHex 4.0)
+:$%aPGN0[EA!ZF(*[DJ"38Np+5d&)6!%!!!!!!!!!B-@8+`!!!!!"!!!!APB!!&e
+@!!!#E`!!!-N!B!!!!!)(r`!!&ZB!D!!!!!%!!!!!!!!!!!!!$%aPGN0[EA!ZF(*
+[DM!#!!!!8&*25NY"5%`"!!"S!3!!!&"56dT,38K-!3!!D!%!!!!!!!!!!!!!!!!
+!!!!!!!!!U@aE@!!!!!!!!'$&!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!r!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!"!!!!&D!!#`"3!!4&*@8J!!!!!"j!"bdiJ!!2m`!,B!!!!!!!!!!!!
+!!!!!&!"bdiJ!!!!!!!!!!J!!!!!!!!#8!(,6L!!!!!!!m!"c!!!!DJ!!!!%!!!!
+#!3!!!!!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!BfpbC@0bC@`!!3kFF(0Z)!!
+!!!J!!!!!!!!!!Q&PGR3!!3!"D@jdC@9ZG@d!!!!%Bf&ZFcXl1cYVEf0XG(P`C3!
+!!!434%p$C'&dB9468%)!!!!!!!!!!!!!!!!!D!"bdiJ!!!!!!!!!!!!!!&S!!!!
+!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'&PGR4KEJ"b!!%1R("
+cEL!!!!!)!!!!!!!!!!*KCACd!!%!!6Xl1cX!DJ!!!!!!!!!8!(,6L!!!rc!!YJ!
+!!!!!!!!!!"4"8&"-2cmr2`!!!!!$k!!!!!J!#2ma!9i!2!!!!"C24`!#!S*%594
+-!!)#TNP$!!!!!!,+!!!!!!!!!!S!!!!2S!!!$k!!!!!!B!!!!(!!!!!!!!!!8!!
+!!#!!)$mm!!'Tm!AZ2c`!!DR`"J)r2!!"UI!'&Mmm!!'Tm!Bb2c`!!DR`"QJr2!!
+"UI!'L$mm!!'Tm!DU2c`!!DR`"XSr2!!"UI!*4$mm!!'Tm!!!!!3!!!!!!!!!"!!
+!!!!!!!!%!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!1!!
+i!$J!1!!i!$J!!!4!!!!!!!!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3)!!J!!!!!!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%#!!i!!!!
+#!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!%!!!!!!!!!'!!!!!8!!!!!!!!!!!!!!!1!!!!1J!!DC`!!!"
+X!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3-!"3!!!!-!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%$!!B!!!!
+%!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!(!!!!"3!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3-!$`!!!!B!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%$!"!!!!!
+(!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!$"J!)!!!!#!!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"!3!#J!!!!N!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-'!!X!!!!
++!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!$"J!-!!!!#`!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!`B!#3!!!!`!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3%!!d!!!!
+0!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!"!`!!!!!!$J!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!J8!!3!!!!m!!!"J!!!!!!!!!!!!!!!
+!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)&!!-!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-!!!!#!3!!!!!JS4"rm0!!!!!MD@j
+ME(9NC5!m6@&M5'9KC'9bFbXV2J!!!!"`!3%!!!!!)f4PCQPZC5"dFR9P)#!J)#!
+J)$%0)f4PCQPZC5"QB@acC5!J)#!J)$!0)f4PCQPZC5"bCASJ)#!J)#!J)$%0)f4
+PCQPZC5"NCA*PHL!J)#!J)$!0)f4PCQPZC5"85%P15ep5CASJ)$%0!!!!!*NK!!!
+!!!!!!#!!!!!!!!!!!!!!!!!!!!#!%!!)"#jKFfd(9%K*6NXJ3`)ZB`G85%P15b"
+$!bjMF!a6H@eKER4PBb"$+bX%,Q0`F!a6H@eKER4PBb"$+bX&,Qj[G'8()-GZEfj
+Pb!)ZE`dJ,QmJ3fpZGQ9bG'9b!Ljb#94)58j,)&*PHJ8ZFR0bB`p5CA0[GA*MC5"
+$Eh"TCA)!!!!!!!")!!$k%"3!qK38!2S80!$k',!!qKNm!2SMA!$k,9)!qMG)!2S
+jI!$k1E)!qN"Z!2T&Z!$k5M3!qNTU!2T+mJ$k5b`!qNYQ!2T,L!$k@"3!!!!!!D`
+"MJ*q!"X"V!*pIrm!(!*p!Rjrr`'0!D`"VArr!Bi"V3*qIrprr`!!!!!!+1G8!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#MR,"T3FQPZG#",CAP
+LEf&bC#"&FA9TGQ&XC@jdF`!Ek`!",3!!!!!(5'9XF#iZ,J!!!!!",3!!!!!54@4
+TG#"@49*6)&*PFfpeFQ0P!"[U!!!SJ#!!!3!!!#3!!)b)*a)!!!!!!-CSl2rrrrm
+(3@0dD@pZF`#!J#!!!3!!!#3!!)[%*a-!!!!!!-CSl2rrrrm(6@&bDf9bF`!!J#!
+!!3!!!%3!!)[S*a3!f!!3!-CSl2rrrrd&4QPXCA-G6QpZC5"[FL"QD@aP)'j[G#"
+jCA3JBfpYF'PXC@3!!!!!!#L!)!!#!!!!'!!!L1`JHJ!%6Y!!qhS`)%b!)!!!!!!
+!+!!!!+J!!Ja-Ef&N)%aTBR*KFRN-6'pKC#"3FQpUC@0d!!!!!!!!!Q3!!)Zi!!%
+!!`!!!!!!!!!"!!B!!(GD!!&26J!!!6!!!!!!!!!!!!!"!!%!!3!!!!!!!!!k!!!
+!&!!!!!J!!!!!!!!!!3!#!!)!!J!B!-8!!!!8!!"jGJ!!!!J!!!!!!!!!!J!$!!-
+!!`!+!!!!!!+Z!!!0V!!!!#J!!!!!!!!!!`!%!!3!"+DJ!!d!!!e!!!"Ed!!!!%!
+!!!!!!!!!"!!&!!8!"3!!!!!!!#rN!!!&L!!!!,!!!!!!!!!!"3!'!!B!"TJ3!!!
+!!$Ff!!"Q`!!!!!J!!!!!!!%!"3!!!!F!"`!)!!)!!#ZZ!!!!cJ!!#kJ!!!!!!!!
+!"J!"!!J!#!!!!!!!!"Yb!!!!cJ!!#,!!!!!!!!!!"`!#!!N!#3$&i!!!!"!i!!!
+!!!!!![J!!!!!!!%!"J!!!!S!#J!,!!3!!!1F!!#Ya!!!!&J!!!!!!!!!#!!"!!X
+!#`!*Q"!!!!-+!!!%L!!!!%!!!!!!!!!!#3!#!!`!$!!!!!!!!!!@!!"AZ!!!!!J
+!!!!!!!!!#J!$!!d!$3!!!"J!!!!B!!"4H!!!!!J!!!!!!!!!#`!%!!i!$Z!!!!S
+!!!"J!!!!$!!!!!J!!!!!!!%!"!!!!!m!$`!3!!)!!(0Z!!!-)J!!"U!!!!!!!!!
+!$!!"!"!!%!!!!!!!!'k5!!!,k!!!"JJ!!!!!!!!!$3!#!"%!%3!!!!!!!!6B!!!
+!1J!!!*J!!!!!!!)!!!!!!")!%J!!!!!!!4lN!!)+!J!!&%!!!!!!!!!!!)[3!!!
+!!!!!!"J!aH!!!!S!!!J!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDC3!!!"J
+!!3!!'GY"6%a2!!!!"f&XE'pM,Q-!!!'TE&SBU@aD'+PX@KJ!!3!D!!%!!"Q43dp
+14J!!!!KMEfjQD@FZD!!!!!+TE&T'U@aD4UPX@NB!!J!F!!%!!"Q49&*"4!!!!!T
+dFQ&NFh4NBbjS!#!!!k3Y["+N,E`5T#fm%J!$!"S!!J!!$qj69%4"!!!"#(0dC'&
+bCbjS!'J!!UPX@LQTE&STU@aD+3!%!"S!!3!!'C&(6%p#!!!!#'GXEf*KE#jS!'J
+!!kE$f2LQ`pMiTX2Bq!!&!"J!!J!!$qj69%4*!!!""h0dC'P[,QJ!!!5SD"18U'J
+6P+KS%j3!"J!D!!)!!!rZ8dPD43!!!!KcDATPAh3ZD!"S!!1TE&SCU@aD'DPX@KN
+!"`!B!!%!!"Q43dp28J!!!!GMEfpbC#jS!!!$U@aD+kPX@LZTE&SV!!J!'J!"!!!
+CN8e"3d-!!!!*E@&MBfpZCLjS!!!%U@aD4+PX@N5TE&T%!!N!'J!"!!!CN90C8e3
+!!!!)FhPcG'9Y,QJ!!!!&U(@!`UKeJ-+SGB$#!!S!'!!#!!!2394C8%8!!!%(G(P
+`CA-ZD!!!"DE$f35Q`pN%TX2C"!!,!"J!!J!!$qj858e&!!!""R4TE@8ZD!!!!!5
+S4b9FU%FPA+K(*9`!$!!D!!)!!!p"8d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pLHTX2
+BRUE$f*i!$3!D!!)!!!rZ8e4%6!!!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3Y`#)
+!$J!D!!)!!!rZ9d0)33!!!!PhBfKKFPpd,QJ!!!5S4bA!U%FP`+K(*F!!$`!D!!)
+!!!p"9dP14!!!!3PhD@jNEhGc,QJ!!!@S4b9#U%FP3UK(*8)!%!!F!!)!!!p"899
+*3`!!!3Y4G@PMDf4bBAFZD!!!"DCNfF#QC0R!TQ6C`!!4!"S!!J!!$d&&9N91!!!
+"#%9fC@jdFbjS!#i!"DK(*)DS4b5'U%FNKJ!5!"`!!J!!$d&$6dj8!!!"#N0[ER4
+bEfac,QJ!!!!%T$(T3+3ak8#N-HP!!"-!'J!#!!!238e&68m!!!%)E@9YEh*j,QJ
+!D!!%U%FP3UK(*8+S4b9#!"3!(!!#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ!!!5
+QC0R!TQ6C`+CNfF!!&3!D!!)!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5'U%F
+NKUK(*)B!&J!F!!)!!!p"3dp19!!!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6!U%F
+N`!!A!"S!!J!!$d&%58&-!!!"#@4TB@a[Ch-ZD!!!"DK(*BbS4b@-U%FPM!!B!"`
+!!J!!$d&849K8!!!"#P4PH(4&C'Pd,QJ!!!!%U%FNpUK(*2DS4b6f!"N!'!!#!!!
+238C26P3!!!%(CQpZG(-ZD!!!"+3arj!!T$(rN!#N-Iq3!!!D!"J!!J!!$qj'3dj
+8!!!""fCMER4X,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&U4!!!!'J!
+"!!!Cfd4539F!!!!*C(*KGfPZCbjM!!!"U@b#!UPXJJ+TE))#!!!!'!!"!!!CN8K
+"3dX!!!!'D'&MDbjS!#i!!DPX@N@TE&T&U@aD43!"!"S!!3!!'C&849*0!!!!#A4
+PFQeMBA!ZD!!)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPXJm)!!!!D!!%!!"T
+M6%9@A`!!!!PXCACIE'9i,Q-!!!'Q`pMiTX2Bq+E$f2J!!3!B!!)!!!rZ8e4%53!
+!!!GcG'4TEbjS!!!#U'J6P+KS%j5SD"18!!)!'J!#!!!2lP0*@N8!!!!)FfPkC9p
+d,QJ!!!!"U@aD+UPX@LUTE&SU!!-!(!!"!!!CN9*&38`!!!!+FQ9KE'KKBfXZD!!
+!!!+TE&SBU@aD'+PX@KJ!"!!D!!%!!"Q43dp14J!!!!KMEfjQD@FZD!"S!!1TE&T
+'U@aD4UPX@NB!"3!F!!%!!"Q49&*"4!!!!!TdFQ&NFh4NBbjS!!!!"+3Y["+N,E`
+5T#fm%J!'!"S!!J!!$qj69%4"!!!"#(0dC'&bCbjS!'J!!kPX@LQTE&STU@aD+3!
+(!"S!!3!!'C&(6%p#!!!!#'GXEf*KE#jS!'J!"+PX@KQTE&SCU@aD'3!)!"J!!3!
+!'C&$6dp5!!!!"f0[Eh*N,QJ!!!5TE&SVU@aD+kPX@LX!#3!D!!%!!"Q468&$3`!
+!!!PYB@0MEfjQ,QJ!!!@TE&T%U@aD4+PX@N3!#J!D!!%!!"Q48eP69!!!!!KcHA0
+dC@dZD!!!!!DSGB$#U(@!`UKeJ-)!#`!B!!)!!!p"9&P343!!!3GdHA"PFbjS!!!
+'TX2C"+E$f35Q`pN%!!`!'!!#!!!2lP4*688!!!%'G'PYC5jS!!!!"DK(*9bS4b9
+FU%FPA!!0!"S!!J!!$d&648G-!!!"#A0PCfa[B@3ZD!!!"DE$f*kQ`pLHTX2BRJ!
+1!"S!!J!!$qj69%4-!!!"#(0dC'aTBLjS!!!!"U3Y`#+N,F!LT#h!)J!2!"S!!J!
+!$qjA3dK"!!!!#AGMD'&bAh3ZD!!!"DK(*F#S4bA!U%FP`!!3!"S!!J!!$d&A58j
+%!!!"#AGTEQ4[Gh-ZD!!!"UK(*8+S4b9#U%FP3J!4!"`!!J!!$d&498P$!!!"#e&
+eD@0VC(*KGbjS!!!'TQ6C`+CNfF#QC0R!!")!'J!#!!!2389@48i!!!%)4ACPER4
+c,QJ!,J!'U%FNKUK(*)DS4b5'!"-!(!!#!!!238026P3!!!%+3fpZG(*[E(-ZD!!
+!!!@N-HP!T$(T3+3ak8!!&!!D!!)!!!p"68906`!!!3KYC@e[FRNZD!"S!!@S4b9
+#U%FP3UK(*8)!&3!F!!)!!!p"899*3`!!!3YaG@PMDf4bBAFZD!!!"DCNfF#QC0R
+!TQ6C`!!@!"S!!J!!$d&&9N91!!!"#'9fC@jdFbjS!#i!"DK(*)DS4b5'U%FNKJ!
+A!"`!!J!!$d&$6dj8!!!"#Q0[ER4bEfac,QJ!!!!&U%FN`+K(*-#S4b6!!"J!'J!
+#!!!2384*38`!!!%*C'PKE'pRFbjS!!!'U%FPM+K(*BbS4b@-!"N!(!!#!!!2394
+&@&3!!!%+9'9iG%9NDA3ZD!!!!!@S4b6fU%FNpUK(*2B!'J!B!!)!!!p"4Np19!!
+!!3GQEfjdFbjS!!!&T$(rN!#N-Iq3!+3arj!!!"X!'!!#!!!2lNC$6P3!!!%(CQ0
+ZG'`ZD!!!!UPX@KkTE&SHU@aD(J!F!"S!!3!!'C&%98j(!!!!#@4eEQGPEfiZD!!
+!!kPX@K1TE&S6U@aD%`!G!"J!!3!!'C&"6%P(!!!!"f&XD@GZ,QJ!!!+TE&SeU@a
+D0DPX@M8!(J!D!!%!!"Q468p18`!!!!KYEfjcH@dZD!!!!!+TE&SaU@aD-DPX@M%
+!(`!D!!%!!"Q468Y56`!!!!KYDh*[EfdZD!!!!!+TE&SjU@aD1DPX@MN!)!!F!!%
+!!"Q46d*+3`!!!!T[BQTME'&cFbjS!!!!!UPX@P'TE&T4U@aD83!K!"S!!3!!'C&
+A58j8!!!!#AGTER4jF'8ZD!!!!UPX@KUTE&SDU@aD'J!L!"J!!3!!'C&%480-!!!
+!"Q4PBf`ZD!!Z!!1TE&SqU@aD2UPX@Mi!)`!B!!%!!"Q4899&8`!!!!GaG@9cG#j
+S!!!$U@aD3UPX@N+TE&T#!#3!'!!"!!!CN90348`!!!!(Fh"PE'`ZD!!!!kPX@KH
+TE&SAU@aD&`!P!"J!!3!!'C&$6da2!!!!"f0[E'pb,QJ!!!1TE&SiU@aD1+PX@MJ
+!*J!@!!%!!"Q46d*+,J!!!!9[BQSZD!!!!kPX@P5TE&T8U@aD9!!R!"B!!3!!'C&
+C6e8Z!!!!"AP[G5jS!!!%U@aD&UPX@KDTE&S@!#J!'J!"!!!CN8&89&)!!!!)BA4
+dFQPL,QJ!!!!%U@aD0+PX@M5TE&Sd!#N!'!!"!!!CN8e26P-!!!!(E@pZFh3ZD!!
+!"+PX@P@TE&T9U@aD93!U!"S!!3!!'C&C6e93!!!!#AP[GA"bEh!ZD!!!"DPX@Mf
+TE&SpU@aD23!V!"J!!3!!'C&38Np3!!!!"R"bEh!ZD!!Z!!@TE&SmU@aD2+PX@M`
+!,!!F!!%!!"Q48%9563!!!!T`CA*YEfjcG#jS!!!!"UPX@M+TE&SbU@aD-J!Y!"S
+!!3!!'C&06dj"!!!!#@e[EQ&dG'XZD!!!"UPX@M1TE&ScU@aD-`!Z!"S!!3!!'C&
+06dj'!!!!#@e[EQCXB@FZD!!!"DPX@M+TE&SbU@aD-J![!"S!!3!!'C&06dj%!!!
+!#@e[EQ4KG'%ZD!!!"DPXJ8kTE)&1U@b"6J!`!"B!!3!!'C&365j)!!!!"("Y,QJ
+!G!!$U@b"4kPXJ8HTE)&(!$%!'J!"!!!CN8p138d!!!!)EfjKE@9c,QJ!!!!#U@a
+D5+PX@NLTE&T)!$)!'!!"!!!CN94539!!!!!'G(*KF#jS!'J!!UPX@LDTE&SQU@a
+D*J!c!"J!!3!!'C&'6%&(!!!!"QCXB@FZD!"S!!+TE&T!U@aD3+PX@N!!0!!@!!%
+!!"Q48NdZ5!!!!!4bE5jS!'J!!UPX@NZTE&T,U@aD5`!e!"S!!3!!'C&@590*!!!
+!#(CTFfP[ELjS!!!!!UPX@KfTE&SGU@aD(3!f!"S!!3!!'C&%5903!!!!#@4TFh"
+XBANZD!!!!UPX@L#TE&SJU@aD)!!h!"S!!3!!'C&&6NG5!!!!#@9ZCh*KGQ8ZD!!
+!!UPX@MqTE&SrU@aD2`!i!"J!!3!!'C&54808!!!!"R*PBh3ZD!!Z!!+TE&SPU@a
+D*DPX@L8!13!D!!%!!"Q449K843!!!!KPH(4PFQiZD!!!!!+TE&T3U@aD8+PX@P!
+!1J!F!!%!!"Q49dP18!!!!!ThD@j`FQpMFbjS!!!!!DPX@jUTE&ZDU@aEQJ!l!"`
+!!3!!'Q0-49CI!!!!#QaPGPpMEfe`,QJ!!!!"U@aD3DPX@N'TE&T"!$`!'J!"!!!
+CN903Ad`!!!!)Fh"IE'9f,QJ!D!!#U@aD%kPX@K1TE&S6!$d!'!!"!!!CN8&-58F
+!!!!(B@aTCfiZD!!)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPXK"-!!!!F!!%
+!!"U!6%9@A`!!!!TXCACIE@&TELjM!'8!!DPX@LUTE&SUU@aD+J!"!"`!!3!!'C&
+548&-!!!!#R*PB@aSB@0V,QJ!C3!#U@aD'+PX@KLTE&SB!!)!'J!"!!!CN8026NB
+!!!!)BfpZCQPR,QJ!D!!$U@aD4UPX@NDTE&T'!!-!(!!"!!!CN945383!!!!+G(*
+KC(0dC'-ZD!"P!!5N,E`5T#fm%U3Y[")!"!!D!!)!!!rZ8e4%33!!!3KcG'4KFQF
+ZD!"S!!1TE&STU@aD+DPX@LN!"3!D!!%!!"Q44da23J!!!!KRE'pLB@`ZD!"S!!5
+Q`pMiTX2Bq+E$f2J!"J!B!!)!!!rZ8e4%53!!!3GcG'4TEbjS!!!&U'J6P+KS%j5
+SD"18!!F!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ!D!!%U@aD'DPX@KQTE&SC!!J
+!'!!"!!!CN8026e)!!!!(Bfp[FQ3ZD!!!"+PX@LZTE&SVU@aD+`!*!"S!!3!!'C&
+0380$!!!!#@eKBf0[EQBZD!!!"DPX@N5TE&T%U@aD4!!+!"S!!3!!'C&6@908!!!
+!#(0jFh4PE5jS!!!!"UKeJ-+SGB$#U(@!`J!,!"J!!J!!$d&8@9"&!!!""h4jF'9
+c,QJ!!!DQ`pN%TX2C"+E$f33!$!!B!!)!!!rZ9%P043!!!3CdD@eP,QJ!!!!&U%F
+PA+K(*9bS4b9F!!d!'J!#!!!2390&4d`!!!%*Ff9RE'pKC#jS!!!&TX2BRUE$f*k
+Q`pLH!!i!'J!#!!!2lP084%`!!!%)Fh4NE'PL,QJ!!!!'T#h!)U3Y`#+N,F!L!!m
+!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!&U%FP`+K(*F#S4bA!!"!!'J!#!!!
+239G*6N3!!!%*GfPZC'phFbjS!!!'U%FP3UK(*8+S4b9#!"%!(!!#!!!239&958-
+!!!%,8A9TBfYNFQ&h,QJ!!!DQC0R!TQ6C`+CNfF!!%J!D!!)!!!p"49C&6J!!!3K
+&GQ9ZG(-ZD!!Z!!DS4b5'U%FNKUK(*)B!%`!F!!)!!!p"3dp19!!!!3T$EfjdFQp
+XFbjS!!!!"D3ak8#N-HP!T$(T3!!8!"S!!J!!$d&048e2!!!"#'ePE@pbH5jS!'J
+!"DK(*8+S4b9#U%FP3J!9!"`!!J!!$d&498P$!!!"#h&eD@0VC(*KGbjS!!!&TQ6
+C`+CNfF#QC0R!!"B!'J!#!!!2389@48i!!!%)CACPER4c,QJ!,J!&U%FNKUK(*)D
+S4b5'!"F!(!!#!!!238026P3!!!%+BfpZG(*[E(-ZD!!!!!@S4b6!U%FN`+K(*-!
+!'!!D!!)!!!p"4%P"6!!!!3PND@&XEfGc,QJ!!!DS4b@-U%FPM+K(*B`!'3!F!!)
+!!!p"9%9B9!!!!3T8CAKd4@4TG#jS!!!!"DK(*2DS4b6fU%FNpJ!D!"J!!J!!$d&
+'6dj8!!!""fC[ER4c,QJ!!!@N-Iq3!+3arj!!T$(rN!!!'`!B!!)!!!rZ4N019!!
+!!3GQBfjdE#jS!!!#U@aD(UPX@KkTE&SH!"`!'J!"!!!CN8496NF!!!!*C(9ZCf9
+[ELjS!!!$U@aD%kPX@K1TE&S6!"d!'!!"!!!CN8&-58F!!!!(B@aTCfiZD!!!!UP
+X@M@TE&SeU@aD03!H!"S!!3!!'C&06dj6!!!!#'e[ER0jE5jS!!!!!UPX@M'TE&S
+aU@aD-3!I!"S!!3!!'C&05e*2!!!!#'eVFQp[E5jS!!!!!UPX@MQTE&SjU@aD13!
+J!"`!!3!!'C&23NT$!!!!#QpLDQ0XBA0c,QJ!!!!#U@aD8DPX@P'TE&T4!#%!'J!
+"!!!CN9G*6P3!!!!*GfPZG(P`C5jS!!!#U@aD'UPX@KUTE&SD!#)!'!!"!!!CN84
+&3d`!!!!'C'9ME#jS!#i!!kPX@MkTE&SqU@aD2J!M!"J!!3!!'C&49896!!!!"h&
+eCA0d,QJ!!!1TE&T#U@aD3UPX@N)!*!!B!!%!!"Q48e"&6!!!!!GcF'9XE#jS!!!
+$U@aD&kPX@KHTE&SA!#8!'!!"!!!CN8026%m!!!!(BfpXEh)ZD!!!!kPX@MLTE&S
+iU@aD1!!Q!"B!!3!!'C&23NSZ!!!!"@pLDLjS!!!$U@aD9+PX@P5TE&T8!#F!&J!
+"!!!CN9P295i!!!!&H@pe,QJ!!!5TE&S@U@aD&UPX@KB!+!!D!!%!!"Q439488J!
+!!!KKG(4bD@)ZD!!!!!5TE&SdU@aD0+PX@M3!+3!B!!%!!"Q468p18`!!!!GYEfj
+cG#jS!!!%U@aD9DPX@P@TE&T9!#S!'J!"!!!CN9P299!!!!!*H@peF(*[F#jS!!!
+&U@aD2DPX@MfTE&Sp!#X!'!!"!!!CN9"56e!!!!!'F(*[F#jS!#i!"DPX@MbTE&S
+mU@aD2!!X!"`!!3!!'C&349*0!!!!#R"PFQe[ER0d,QJ!!!!'U@aD-UPX@M+TE&S
+b!#d!'J!"!!!CN8e26N%!!!!*E@pZBA4dDbjS!!!'U@aD-kPX@M1TE&Sc!#i!'J!
+"!!!CN8e26NB!!!!*E@pZCQaKCbjS!!!&U@aD-UPX@M+TE&Sb!#m!'J!"!!!CN8e
+26N3!!!!*E@pZC'&dB5jS!!!&U@b"6UPXJ8kTE)&1!$!!&J!"!!!CN9"0,NJ!!!!
+%F'dZD!"d!!1TE)&(U@b"4kPXJ8F!-3!D!!%!!"Q46dj"63!!!!K[EQ&YCA-ZD!!
+!!!+TE&T)U@aD5+PX@NJ!-J!B!!%!!"Q49&*"8!!!!!CdFQ&`,QJ!D!!#U@aD*UP
+X@LDTE&SQ!$-!'!!"!!!CN8C-38F!!!!'CQaKCbjS!'J!!UPX@N#TE&T!U@aD3!!
+d!"B!!3!!'C&565j)!!!!"(*Y,QJ!D!!#U@aD5kPX@NZTE&T,!$8!'J!"!!!CN9C
+*8dN!!!!)GQPcD@pZ,QJ!!!!#U@aD(DPX@KfTE&SG!$B!'J!"!!!CN84*8e!!!!!
+*C'PcF'aKH5jS!!!#U@aD)+PX@L#TE&SJ!$F!'J!"!!!CN8914e)!!!!*C@jRFQ&
+fC5jS!!!#U@aD2kPX@MqTE&Sr!$J!'!!"!!!CN9*&3e3!!!!'FQ9MG#jS!#i!!UP
+X@L@TE&SPU@aD*3!j!"S!!3!!'C&&@&4&!!!!#'9iG'9bELjS!!!!!UPX@P#TE&T
+3U@aD8!!k!"`!!3!!'C&A58j3!!!!#RGTER"bEf0c,QJ!!!!"U@aD3DPX@N'TE&T
+"!$X!'J!"!!!CN903Ad`!!!!)Fh"IE'9f,QJ!D!!#U@aD%kPX@K1TE&S6!$`!'!!
+"!!!CN8&-58F!!!!(B@aTCfiZD!!)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkP
+XJq-!!!!F!!%!!"TM6%9@A`!!!!TXCACIH@&MBbjM!'8!!DPX@LUTE&SUU@aD+J!
+"!"`!!3!!'C&548&-!!!!#R*PB@aSB@0V,QJ!C3!#U@aD'+PX@KLTE&SB!!)!'J!
+"!!!CN8026NB!!!!)BfpZCQPR,QJ!D!!$U@aD4UPX@NDTE&T'!!-!(!!"!!!CN94
+5383!!!!+G(*KC(0dC'-ZD!"P!!5N,E`5T#fm%U3Y[")!"!!D!!)!!!rZ8e4%33!
+!!3KcG'4KFQFZD!"S!!1TE&STU@aD+DPX@LN!"3!D!!%!!"Q44da23J!!!!KRE'p
+LB@`ZD!"S!!5Q`pMiTX2Bq+E$f2J!"J!B!!)!!!rZ8e4%53!!!3GcG'4TEbjS!!!
+&U'J6P+KS%j5SD"18!!F!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ!D!!%U@aD'DP
+X@KQTE&SC!!J!'!!"!!!CN8026e)!!!!(Bfp[FQ3ZD!!!"+PX@LZTE&SVU@aD+`!
+*!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!!"DPX@N5TE&T%U@aD4!!+!"S!!3!
+!'C&6@908!!!!#(0jFh4PE5jS!!!!"UKeJ-+SGB$#U(@!`J!,!"J!!J!!$d&8@9"
+&!!!""h4jF'9c,QJ!!!DQ`pN%TX2C"+E$f33!$!!B!!)!!!rZ9%P043!!!3CdD@e
+P,QJ!!!!&U%FPA+K(*9bS4b9F!!d!'J!#!!!2390&4d`!!!%*Ff9RE'pKC#jS!!!
+&TX2BRUE$f*kQ`pLH!!i!'J!#!!!2lP084%`!!!%)Fh4NE'PL,QJ!!!!'T#h!)U3
+Y`#+N,F!L!!m!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!&U%FP`+K(*F#S4bA
+!!"!!'J!#!!!239G*6N3!!!%*GfPZC'phFbjS!!!'U%FP3UK(*8+S4b9#!"%!(!!
+#!!!239&958-!!!%,8A9TBfYNFQ&h,QJ!!!DQC0R!TQ6C`+CNfF!!%J!D!!)!!!p
+"49C&6J!!!3K&GQ9ZG(-ZD!!Z!!DS4b5'U%FNKUK(*)B!%`!F!!)!!!p"3dp19!!
+!!3T$EfjdFQpXFbjS!!!!"D3ak8#N-HP!T$(T3!!8!"S!!J!!$d&048e2!!!"#'e
+PE@pbH5jS!'J!"DK(*8+S4b9#U%FP3J!9!"`!!J!!$d&498P$!!!"#h&eD@0VC(*
+KGbjS!!!&TQ6C`+CNfF#QC0R!!"B!'J!#!!!2389@48i!!!%)CACPER4c,QJ!,J!
+&U%FNKUK(*)DS4b5'!"F!(!!#!!!238026P3!!!%+BfpZG(*[E(-ZD!!!!!@S4b6
+!U%FN`+K(*-!!'!!D!!)!!!p"4%P"6!!!!3PND@&XEfGc,QJ!!!DS4b@-U%FPM+K
+(*B`!'3!F!!)!!!p"9%9B9!!!!3T8CAKd4@4TG#jS!!!!"DK(*2DS4b6fU%FNpJ!
+D!"J!!J!!$d&'6dj8!!!""fC[ER4c,QJ!!!@N-Iq3!+3arj!!T$(rN!!!'`!B!!)
+!!!rZ4N019!!!!3GQBfjdE#jS!!!#U@aD(UPX@KkTE&SH!"`!'J!"!!!CN8496NF
+!!!!*C(9ZCf9[ELjS!!!$U@aD%kPX@K1TE&S6!"d!'!!"!!!CN8&-58F!!!!(B@a
+TCfiZD!!!!UPX@M@TE&SeU@aD03!H!"S!!3!!'C&06dj6!!!!#'e[ER0jE5jS!!!
+!!UPX@M'TE&SaU@aD-3!I!"S!!3!!'C&05e*2!!!!#'eVFQp[E5jS!!!!!UPX@MQ
+TE&SjU@aD13!J!"`!!3!!'C&23NT$!!!!#QpLDQ0XBA0c,QJ!!!!#U@aD8DPX@P'
+TE&T4!#%!'J!"!!!CN9G*6P3!!!!*GfPZG(P`C5jS!!!#U@aD'UPX@KUTE&SD!#)
+!'!!"!!!CN84&3d`!!!!'C'9ME#jS!#i!!kPX@MkTE&SqU@aD2J!M!"J!!3!!'C&
+49896!!!!"h&eCA0d,QJ!!!1TE&T#U@aD3UPX@N)!*!!B!!%!!"Q48e"&6!!!!!G
+cF'9XE#jS!!!$U@aD&kPX@KHTE&SA!#8!'!!"!!!CN8026%m!!!!(BfpXEh)ZD!!
+!!kPX@MLTE&SiU@aD1!!Q!"B!!3!!'C&23NSZ!!!!"@pLDLjS!!!$U@aD9+PX@P5
+TE&T8!#F!&J!"!!!CN9P295i!!!!&H@pe,QJ!!!5TE&S@U@aD&UPX@KB!+!!D!!%
+!!"Q439488J!!!!KKG(4bD@)ZD!!!!!5TE&SdU@aD0+PX@M3!+3!B!!%!!"Q468p
+18`!!!!GYEfjcG#jS!!!%U@aD9DPX@P@TE&T9!#S!'J!"!!!CN9P299!!!!!*H@p
+eF(*[F#jS!!!&U@aD2DPX@MfTE&Sp!#X!'!!"!!!CN9"56e!!!!!'F(*[F#jS!#i
+!"DPX@MbTE&SmU@aD2!!X!"`!!3!!'C&349*0!!!!#R"PFQe[ER0d,QJ!!!!'U@a
+D-UPX@M+TE&Sb!#d!'J!"!!!CN8e26N%!!!!*E@pZBA4dDbjS!!!'U@aD-kPX@M1
+TE&Sc!#i!'J!"!!!CN8e26NB!!!!*E@pZCQaKCbjS!!!&U@aD-UPX@M+TE&Sb!#m
+!'J!"!!!CN8e26N3!!!!*E@pZC'&dB5jS!!!&U@b"6UPXJ8kTE)&1!$!!&J!"!!!
+CN9"0,NJ!!!!%F'dZD!"d!!1TE)&(U@b"4kPXJ8F!-3!D!!%!!"Q46dj"63!!!!K
+[EQ&YCA-ZD!!!!!+TE&T)U@aD5+PX@NJ!-J!B!!%!!"Q49&*"8!!!!!CdFQ&`,QJ
+!D!!#U@aD*UPX@LDTE&SQ!$-!'!!"!!!CN8C-38F!!!!'CQaKCbjS!'J!!UPX@N#
+TE&T!U@aD3!!d!"B!!3!!'C&565j)!!!!"(*Y,QJ!D!!#U@aD5kPX@NZTE&T,!$8
+!'J!"!!!CN9C*8dN!!!!)GQPcD@pZ,QJ!!!!#U@aD(DPX@KfTE&SG!$B!'J!"!!!
+CN84*8e!!!!!*C'PcF'aKH5jS!!!#U@aD)+PX@L#TE&SJ!$F!'J!"!!!CN8914e)
+!!!!*C@jRFQ&fC5jS!!!#U@aD2kPX@MqTE&Sr!$J!'!!"!!!CN9*&3e3!!!!'FQ9
+MG#jS!#i!!UPX@L@TE&SPU@aD*3!j!"S!!3!!'C&&@&4&!!!!#'9iG'9bELjS!!!
+!!UPX@P#TE&T3U@aD8!!k!"`!!3!!'C&A58j3!!!!#RGTER"bEf0c,QJ!!!!"U@a
+D3DPX@N'TE&T"!$X!'J!"!!!CN903Ad`!!!!)Fh"IE'9f,QJ!D!!#U@aD%kPX@K1
+TE&S6!$`!'!!"!!!CN8&-58F!!!!(B@aTCfiZD!!+!!!!!!!!!!!!!!!!!!!!!!$
+rrrrrrrrrrkPX@fd!!!!D!!%!!"T!68&$43!!!!PYB@0PFR*c,Q-!!!'TE))#U@b
+#!UPXJJ)!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,J!"U%FP)UK(*5+S4b8L!!%
+!'J!#!!!238p6993!!!%*6e09G'PXFbjS!!!"U%FNkUK(*1US4b6U!!)!'!!#!!!
+238C*6%8!!!%(CQPXCA-ZD!!!!DKeJ-+SGB$#U(@!`J!$!"J!!J!!$d&8@9"&!!!
+""e4jF'9c,QJ!!!'Rk`3NTqX%*+IV"#3!"!!D!!)!!!qU8%&63`!!!3K`BA0MB@`
+ZD!!!!!'S4b6!U%FN`+K(*-!!"3!D!!)!!!p"4%P"6!!!!3P%D@&XEfGc,QJ!!!'
+S4b8bU%FP-UK(*6)!"J!F!!)!!!p"8%&$5`!!!3T3B@0VB@GPFbjS!'8!!UK(*@D
+S4b9QU%FPCJ!(!#!!!J!!$d&69%&1!!!"$P0dB@jNBA*N4QPXC5jS!!!!!UCNfF#
+QC0R!TQ6C`!!)!"S!!J!!$d&63e**!!!"#&0MFQP`G#jS!'N!!UKaFJkSFA)1U(&
+b$J!*!"B!!J!!$kT#4%-Z!!!""8*%3bjS!!!"U%FPPUK(*CDS4b@@!!S!(!!#!!!
+239426d`!!!%,9'p[E&9dD@ac,QJ!!!'S4b9-U%FP6+K(*8`!#`!F!!)!!!p"8N9
+66`!!!3Y5CA0[GA*MCA-ZD!!`!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkL$$")
+!!!!@!!)!!!rR38j653!!!!4"6P0*!#i)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrr
+rrkPX@YF!!!!B!!%!!"RE68p18`!!!!GYEfjcG#jM!!!"U@aD'+PX@KLTE&SB!!%
+!'J!"!!!CN8026NB!!!!)BfpZCQPR,QJ!!!!#U@aD4UPX@NDTE&T'!!)!(!!"!!!
+CN945383!!!!+G(*KC(0dC'-ZD!!!!!1N,E`5T#fm%U3Y[")!!`!D!!)!!!rZ8e4
+%33!!!3KcG'4KFQFZD!"S!!+TE&STU@aD+DPX@LN!"!!D!!%!!"Q44da23J!!!!K
+RE'pLB@`ZD!"S!!1Q`pMiTX2Bq+E$f2J!"3!B!!)!!!rZ8e4%53!!!3GcG'4TEbj
+S!!!%U'J6P+KS%j5SD"18!!B!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ!D!!$U@a
+D'DPX@KQTE&SC!!F!'!!"!!!CN8026e)!!!!(Bfp[FQ3ZD!!!!kPX@LZTE&SVU@a
+D+`!)!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!!"+PX@N5TE&T%U@aD4!!*!"S
+!!3!!'C&6@908!!!!#(0jFh4PE5jS!!!!"DKeJ-+SGB$#U(@!`J!+!"J!!J!!$d&
+8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E$f33!#`!B!!)!!!rZ9%P043!!!3C
+dD@eP,QJ!!!!%U%FPA+K(*9bS4b9F!!`!'J!#!!!2390&4d`!!!%*Ff9RE'pKC#j
+S!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!2lP084%`!!!%)Fh4NE'PL,QJ!!!!&T#h
+!)U3Y`#+N,F!L!!i!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!%U%FP`+K(*F#
+S4bA!!!m!'J!#!!!239G*6N3!!!%*GfPZC'phFbjS!!!&U%FP3UK(*8+S4b9#!"!
+!(!!#!!!239&958-!!!%,8A9TBfYNFQ&h,QJ!!!@QC0R!TQ6C`+CNfF!!%3!D!!)
+!!!p"49C&6J!!!3K&GQ9ZG(-ZD!!Z!!@S4b5'U%FNKUK(*)B!%J!F!!)!!!p"3dp
+19!!!!3T$EfjdFQpXFbjS!!!!"+3ak8#N-HP!T$(T3!!6!"S!!J!!$d&048e2!!!
+"#'ePE@pbH5jS!'J!"+K(*8+S4b9#U%FP3J!8!"`!!J!!$d&498P$!!!"#h&eD@0
+VC(*KGbjS!!!%TQ6C`+CNfF#QC0R!!"8!'J!#!!!2389@48i!!!%)CACPER4c,QJ
+!,J!%U%FNKUK(*)DS4b5'!"B!(!!#!!!238026P3!!!%+BfpZG(*[E(-ZD!!!!!5
+S4b6!U%FN`+K(*-!!&`!D!!)!!!p"4%P"6!!!!3PND@&XEfGc,QJ!!!@S4b@-U%F
+PM+K(*B`!'!!F!!)!!!p"9%9B9!!!!3T8CAKd4@4TG#jS!!!!"+K(*2DS4b6fU%F
+NpJ!C!"J!!J!!$d&'6dj8!!!""fC[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!'J!
+B!!)!!!rZ4N019!!!!3GQBfjdE#jS!!!"U@aD2+PX@MbTE&Sm!"X!(!!"!!!CN9"
+&8Nd!!!!+F'9bE@pZFh3ZD!!!!!+TE&SbU@aD-UPX@M)!(!!D!!%!!"Q468p133!
+!!!PYEfjKG(4V,QJ!!!+TE&ScU@aD-kPX@M-!(3!D!!%!!"Q468p14J!!!!PYEfj
+QE'&R,QJ!!!+TE&S6U@aD%kPX@K-!(J!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!!
+"U@aD0DPX@M@TE&Se!"m!'J!"!!!CN8e26P-!!!!)E@pZFhPY,QJ!!!!"U@aD)DP
+X@L'TE&SK!#!!'!!"!!!CN8965%X!!!!'CA0SDbjS!'J!!UPX@KkTE&SHU@aD(J!
+K!"S!!3!!'C&%98j(!!!!#@4eEQGPEfiZD!!!!kPX@K1TE&S6U@aD%`!L!"J!!3!
+!'C&"6%P(!!!!"f&XD@GZ,QJ!!!'TE&T+U@aD5UPX@NS!)`!B!!%!!"Q49N&96!!
+!!!GfBA9XG#jS!!!#U@aD(UPX@KkTE&SH!#3!'J!"!!!CN8496NF!!!!*C(9ZCf9
+[ELjS!!!"U@aD)+PX@L#TE&SJ!#8!'!!"!!!CN8938NN!!!!'CA"bD5jS!#i!!UP
+X@KkTE&SHU@aD(J!Q!"S!!3!!'C&%98j(!!!!#@4eEQGPEfiZD!!!!UPX@K1TE&S
+6U@aD%`!R!"J!!3!!'C&"6%P(!!!!"f&XD@GZ,QJ!!!'TE&SAU@aD&kPX@KF!+!!
+B!!%!!"Q43dp-6`!!!!GMEfa[FLjS!!J!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrr
+rU@aDi`!!!"S!!3!!'GY23NT&!!!!#@pLDQ9MG(-ZB`!!!DPX@KLTE&SBU@aD'!!
+"!"S!!3!!'C&$6dj'!!!!#'0[EQCTCbjS!!!!!UPX@NDTE&T'U@aD4J!#!"`!!3!
+!'C&88N&%!!!!#R4bB@4cG'4M,QJ!!!!$T#fm%U3Y["+N,E`5!!-!'J!#!!!2lP0
+84%%!!!%)Fh4NBA*R,QJ!D!!#U@aD+DPX@LQTE&ST!!3!'J!"!!!CN8G-6d)!!!!
+)Cfa[BQ&X,QJ!D!!$TX2Bq+E$f2LQ`pMi!!8!'!!#!!!2lP084%N!!!%(Fh4ND@m
+ZD!!!"+KS%j5SD"18U'J6P!!'!"S!!J!!$qj659T&!!!!#(0THQ9IG#jS!'J!!kP
+X@KQTE&SCU@aD'3!(!"J!!3!!'C&$6dp5!!!!"f0[Eh*N,QJ!!!1TE&SVU@aD+kP
+X@LX!#!!D!!%!!"Q468&$3`!!!!PYB@0MEfjQ,QJ!!!5TE&T%U@aD4+PX@N3!#3!
+D!!%!!"Q48eP69!!!!!KcHA0dC@dZD!!!!!@SGB$#U(@!`UKeJ-)!#J!B!!)!!!p
+"9&P343!!!3GdHA"PFbjS!!!&TX2C"+E$f35Q`pN%!!X!'!!#!!!2lP4*688!!!%
+'G'PYC5jS!!!!"+K(*9bS4b9FU%FPA!!-!"S!!J!!$d&648G-!!!"#A0PCfa[B@3
+ZD!!!"+E$f*kQ`pLHTX2BRJ!0!"S!!J!!$qj69%4-!!!"#(0dC'aTBLjS!!!!"D3
+Y`#+N,F!LT#h!)J!1!"S!!J!!$qjA3dK"!!!!#AGMD'&bAh3ZD!!!"+K(*F#S4bA
+!U%FP`!!2!"S!!J!!$d&A58j%!!!"#AGTEQ4[Gh-ZD!!!"DK(*8+S4b9#U%FP3J!
+3!"`!!J!!$d&498P$!!!"#e&eD@0VC(*KGbjS!!!&TQ6C`+CNfF#QC0R!!"%!'J!
+#!!!2389@48i!!!%)4ACPER4c,QJ!,J!&U%FNKUK(*)DS4b5'!")!(!!#!!!2380
+26P3!!!%+3fpZG(*[E(-ZD!!!!!5N-HP!T$(T3+3ak8!!%`!D!!)!!!p"68906`!
+!!3KYC@e[FRNZD!"S!!5S4b9#U%FP3UK(*8)!&!!F!!)!!!p"899*3`!!!3YaG@P
+MDf4bBAFZD!!!"+CNfF#QC0R!TQ6C`!!9!"S!!J!!$d&&9N91!!!"#'9fC@jdFbj
+S!#i!"+K(*)DS4b5'U%FNKJ!@!"`!!J!!$d&$6dj8!!!"#Q0[ER4bEfac,QJ!!!!
+%U%FN`+K(*-#S4b6!!"F!'J!#!!!2384*38`!!!%*C'PKE'pRFbjS!!!&U%FPM+K
+(*BbS4b@-!"J!(!!#!!!2394&@&3!!!%+9'9iG%9NDA3ZD!!!!!5S4b6fU%FNpUK
+(*2B!'3!B!!)!!!p"4Np19!!!!3GQEfjdFbjS!!!%T$(rN!#N-Iq3!+3arj!!!"S
+!'!!#!!!2lNC$6P3!!!%(CQ0ZG'`ZD!!!!DPX@MLTE&SiU@aD1!!E!"B!!3!!'C&
+23NSZ!!!!"@pLDLjS!!!"U@aD1DPX@MQTE&Sj!"`!(!!"!!!CN8p#5N-!!!!+Ef*
+UBfaKFh-ZD!!!!!'TE&SpU@aD2DPX@Md!(3!B!!%!!"Q48&*28!!!!!C`FQp`,QJ
+!F`!"U@aDikPX@Z1TE&VM!"i!'J!"!!!Cfdp#5N8!!!!*Ef*UC@0dFbjM!!!#U@a
+D&kPX@KHTE&SA!"m!'!!"!!!CN8026%m!!!!(BfpXEh)ZD!!)!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPX@mm!!!!B!!%!!"U!8%&153!!!!G`B@jTBbjM!!!"U@a
+D'+PX@KLTE&SB!!%!'J!"!!!CN8026NB!!!!)BfpZCQPR,QJ!!!!#U@aD4UPX@ND
+TE&T'!!)!(!!"!!!CN945383!!!!+G(*KC(0dC'-ZD!!!!!1N,E`5T#fm%U3Y[")
+!!`!D!!)!!!rZ8e4%33!!!3KcG'4KFQFZD!"S!!+TE&STU@aD+DPX@LN!"!!D!!%
+!!"Q44da23J!!!!KRE'pLB@`ZD!"S!!1Q`pMiTX2Bq+E$f2J!"3!B!!)!!!rZ8e4
+%53!!!3GcG'4TEbjS!!!%U'J6P+KS%j5SD"18!!B!'J!#!!!2lP0*@N8!!!!)FfP
+kC9pd,QJ!D!!$U@aD'DPX@KQTE&SC!!F!'!!"!!!CN8026e)!!!!(Bfp[FQ3ZD!!
+!!kPX@LZTE&SVU@aD+`!)!"S!!3!!'C&0380$!!!!#@eKBf0[EQBZD!!!"+PX@N5
+TE&T%U@aD4!!*!"S!!3!!'C&6@908!!!!#(0jFh4PE5jS!!!!"DKeJ-+SGB$#U(@
+!`J!+!"J!!J!!$d&8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E$f33!#`!B!!)
+!!!rZ9%P043!!!3CdD@eP,QJ!!!!%U%FPA+K(*9bS4b9F!!`!'J!#!!!2390&4d`
+!!!%*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!2lP084%`!!!%)Fh4
+NE'PL,QJ!!!!&T#h!)U3Y`#+N,F!L!!i!'J!#!!!2lPG$5%%!!!!*Gf0SBA*IG#j
+S!!!%U%FP`+K(*F#S4bA!!!m!'J!#!!!239G*6N3!!!%*GfPZC'phFbjS!!!&U%F
+P3UK(*8+S4b9#!"!!(!!#!!!239&958-!!!%,8A9TBfYNFQ&h,QJ!!!@QC0R!TQ6
+C`+CNfF!!%3!D!!)!!!p"49C&6J!!!3K&GQ9ZG(-ZD!!Z!!@S4b5'U%FNKUK(*)B
+!%J!F!!)!!!p"3dp19!!!!3T$EfjdFQpXFbjS!!!!"+3ak8#N-HP!T$(T3!!6!"S
+!!J!!$d&048e2!!!"#'ePE@pbH5jS!'J!"+K(*8+S4b9#U%FP3J!8!"`!!J!!$d&
+498P$!!!"#h&eD@0VC(*KGbjS!!!%TQ6C`+CNfF#QC0R!!"8!'J!#!!!2389@48i
+!!!%)CACPER4c,QJ!,J!%U%FNKUK(*)DS4b5'!"B!(!!#!!!238026P3!!!%+Bfp
+ZG(*[E(-ZD!!!!!5S4b6!U%FN`+K(*-!!&`!D!!)!!!p"4%P"6!!!!3PND@&XEfG
+c,QJ!!!@S4b@-U%FPM+K(*B`!'!!F!!)!!!p"9%9B9!!!!3T8CAKd4@4TG#jS!!!
+!"+K(*2DS4b6fU%FNpJ!C!"J!!J!!$d&'6dj8!!!""fC[ER4c,QJ!!!5N-Iq3!+3
+arj!!T$(rN!!!'J!B!!)!!!rZ4N019!!!!3GQBfjdE#jS!"!!!!!!!!!!!!!!!!!
+!!!!!!2rrrrrrrrrrU!L)V!!!!"B!!J!!$qG96NPB!!!!"(9ZDAJ!,JS!!!!!!!!
+!!!!!!!!!!!!!!2rrrrrrrrrrU@aDH3!!!"J!!3!!'GY%480-!!!!"Q4PBf`ZB`!
+!!!'TE))#U@b#!UPXJJ)!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!!!!"U@aD2UP
+X@MkTE&Sq!!%!'!!"!!!CN9&949-!!!!(FA9PFh3ZD!!!!!!!!!!!!!!!!!!!!!!
+!!!$rrrrrrrrrrkJpjc!!!!!D!!)!!!qb68&$9!!!!!K0B@08FQ&`F`!!!!!!!!!
+!!!!!!!!!!!!!!!!!rrrrrrrrrrqS2HG+!!!!'J!#!!!2XNe"3e3!!!!*6@&M9(*
+KF(-b!!!!!!#!`UKeJ-)!#J!B!!)!!!!!!!%!!!!)"'eKD@iJ)#"S!!!&TX2C"+E
+$f35Q`pN%!!X!'!!#!!!2lP4*688!!!%'G'PYC5jS!!!!"+K(*9bS4b9FU%FPA!!
+-!"S!!J!!$d&648G-!!!"#A0PCfa[B@3ZD!!!"+E$f*kQ`pLHTX2BRJ!0!"S!!J!
+!$qj69%4-!!!"#(0dC'aTBLjS!!!!"D3Y`#+N,F!LT#h!)J!1!"S!!J!!$qjA3dK
+"!!!!#AGMD'&bAh3ZD!!!"+K(*F#S4bA!U%FP`!!2!"S!!J!!$d&A58j%!!!"#AG
+TEQ4[Gh-ZD!!!"DK(*8+S4b9#U%FP3J!3!"`!!J!!$d&498P$!!!"#e&eD@0VC(*
+KGbjS!!!&TQ6C`+CNfF#QC0R!!"%!'J!#!!!2389@48i!!!%)4ACPER4c,QJ!,J!
+&U%FNKUK(*)DS4b5'!")!(!!#!!!238026P3!!!%+3fpZG(*[E(-ZD!!!!!5N-HP
+!T$(T3+3ak8!!%`!D!!)!!!p"68906`!!!3KYC@e[FRNZD!"S!!5S4b9#U%FP3UK
+(*8)!&!!F!!)!!!p"899*3`!!!3YaG@PMDf4bBAFZD!!!"+CNfF#QC0R!TQ6C`!!
+9!"S!!J!!$d&&9N91!!!"#'9fC@jdFbjS!#i!"+K(*)DS4b5'U%FNKJ!@!"`!!J!
+!$d&$6dj8!!!"#Q0[ER4bEfac,QJ!!!!%U%FN`+K(*-#S4b6!!"F!'J!#!!!2384
+*38`!!!%*C'PKE'pRFbjS!!!&U%FPM+K(*BbS4b@-!"J!(!!#!!!2394&@&3!!!%
++9'9iG%9NDA3ZD!!!!!5S4b6fU%FNpUK(*2B!'3!B!!)!!!p"4Np19!!!!3GQEfj
+dFbjS!!!%T$(rN!#N-Iq3!+3arj!!!"S!'!!#!!!2lNC$6P3!!!%(CQ0ZG'`ZD!!
+!!DPX@MbTE&SmU@aD2!!E!"`!!3!!'C&349*0!!!!#R"PFQe[ER0d,QJ!!!!#U@a
+D-UPX@M+TE&Sb!"`!'J!"!!!CN8e26N%!!!!*E@pZBA4dDbjS!!!#U@aD-kPX@M1
+TE&Sc!"d!'J!"!!!CN8e26NB!!!!*E@pZCQaKCbjS!!!#U@aD%kPX@K1TE&S6!"i
+!'!!"!!!CN8&-58F!!!!(B@aTCfiZD!!!!DPX@M@TE&SeU@aD03!I!"S!!3!!'C&
+06dj6!!!!#'e[ER0jE5jS!!!!!DPX@L'TE&SKU@aD)3!J!"J!!3!!'C&&8dK,!!!
+!"Q9cD'XZD!"S!!+TE&SHU@aD(UPX@Ki!)3!D!!%!!"Q44&914`!!!!PNG@jRC@p
+Z,QJ!!!1TE&S6U@aD%kPX@K-!)J!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!!"U@a
+D5UPX@NUTE&T+!#-!'!!"!!!CN9C"98`!!!!(GQ&eE(3ZD!!!!UPX@KkTE&SHU@a
+D(J!N!"S!!3!!'C&%98j(!!!!#@4eEQGPEfiZD!!!!DPX@L#TE&SJU@aD)!!P!"J
+!!3!!'C&&8&**!!!!"Q9`FQNZD!!Z!!+TE&SHU@aD(UPX@Ki!*J!D!!%!!"Q44&9
+14`!!!!PNG@jRC@pZ,QJ!!!+TE&S6U@aD%kPX@K-!*`!B!!%!!"Q438a*4`!!!!G
+KE'PRELjS!!!"U@aD&kPX@KHTE&SA!#J!'!!"!!!CN8026%m!!!!(BfpXEh)ZD!!
+)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Z-!!!!D!!%!!"RE6d*+43!!!!P
+[BQTPBh4c,Q-!!!'TE&SBU@aD'+PX@KJ!!3!D!!%!!"Q43dp14J!!!!KMEfjQD@F
+ZD!!!!!+TE&T'U@aD4UPX@NB!!J!F!!%!!"Q49&*"4!!!!!TdFQ&NFh4NBbjS!!!
+!!k3Y["+N,E`5T#fm%J!$!"S!!J!!$qj69%4"!!!"#(0dC'&bCbjS!'J!!UPX@LQ
+TE&STU@aD+3!%!"S!!3!!'C&(6%p#!!!!#'GXEf*KE#jS!'J!!kE$f2LQ`pMiTX2
+Bq!!&!"J!!J!!$qj69%4*!!!""h0dC'P[,QJ!!!5SD"18U'J6P+KS%j3!"J!D!!)
+!!!rZ8dPD43!!!!KcDATPAh3ZD!"S!!1TE&SCU@aD'DPX@KN!"`!B!!%!!"Q43dp
+28J!!!!GMEfpbC#jS!!!$U@aD+kPX@LZTE&SV!!J!'J!"!!!CN8e"3d-!!!!*E@&
+MBfpZCLjS!!!%U@aD4+PX@N5TE&T%!!N!'J!"!!!CN90C8e3!!!!)FhPcG'9Y,QJ
+!!!!&U(@!`UKeJ-+SGB$#!!S!'!!#!!!2394C8%8!!!%(G(P`CA-ZD!!!"DE$f35
+Q`pN%TX2C"!!,!"J!!J!!$qj858e&!!!""R4TE@8ZD!!!!!5S4b9FU%FPA+K(*9`
+!$!!D!!)!!!p"8d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pLHTX2BRUE$f*i!$3!D!!)
+!!!rZ8e4%6!!!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3Y`#)!$J!D!!)!!!rZ9d0
+)33!!!!PhBfKKFPpd,QJ!!!5S4bA!U%FP`+K(*F!!$`!D!!)!!!p"9dP14!!!!3P
+hD@jNEhGc,QJ!!!@S4b9#U%FP3UK(*8)!%!!F!!)!!!p"899*3`!!!3Y4G@PMDf4
+bBAFZD!!!"DCNfF#QC0R!TQ6C`!!4!"S!!J!!$d&&9N91!!!"#%9fC@jdFbjS!#i
+!"DK(*)DS4b5'U%FNKJ!5!"`!!J!!$d&$6dj8!!!"#N0[ER4bEfac,QJ!!!!%T$(
+T3+3ak8#N-HP!!"-!'J!#!!!238e&68m!!!%)E@9YEh*j,QJ!D!!%U%FP3UK(*8+
+S4b9#!"3!(!!#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!
+!&3!D!!)!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5'U%FNKUK(*)B!&J!F!!)
+!!!p"3dp19!!!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6!U%FN`!!A!"S!!J!!$d&
+%58&-!!!"#@4TB@a[Ch-ZD!!!"DK(*BbS4b@-U%FPM!!B!"`!!J!!$d&849K8!!!
+"#P4PH(4&C'Pd,QJ!!!!%U%FNpUK(*2DS4b6f!"N!'!!#!!!238C26P3!!!%(CQp
+ZG(-ZD!!!"+3arj!!T$(rN!#N-Iq3!!!D!"J!!J!!$qj'3dj8!!!""fCMER4X,QJ
+!!!'TE&SiU@aD1+PX@MJ!'`!@!!%!!"Q46d*+,J!!!!9[BQSZD!!!!DPX@MQTE&S
+jU@aD13!F!"`!!3!!'C&23NT$!!!!#QpLDQ0XBA0c,QJ!!!!"U@aD2DPX@MfTE&S
+p!"d!'!!"!!!CN9"56e!!!!!'F(*[F#jS!(-!!DPX@Z1TE&VMU@aDi`!H!"S!!3!
+!'GY23NT&!!!!#@pLDQ9MG(-ZB`!!!UPX@KHTE&SAU@aD&`!I!"J!!3!!'C&$6da
+2!!!!"f0[E'pb,QJ!@LB!-`!B!!%!!"Q44Na"4`!!!!CQE'&R,QJ!D!!#U@aD3+P
+X@N#TE&T!!$3!&J!"!!!CN9*0,NJ!!!!%FQdZD!"S!!+TE&T,U@aD5kPX@NX!03!
+D!!%!!"Q49NP653!!!!KfDA0TEfiZD!!!!!+TE&SGU@aD(DPX@Kd!0J!D!!%!!"Q
+44%P68!!!!!PNDA0`E'&j,QJ!!!+TE&SJU@aD)+PX@L!!0`!D!!%!!"Q448j(8J!
+!!!PPEQGbBACP,QJ!!!+TE&SrU@aD2kPX@Mm!1!!B!!%!!"Q48N9$9!!!!!CbC@0
+d,QJ!,J!#U@aD*DPX@L@TE&SP!$N!'J!"!!!CN89B9%8!!!!)CAKdCA*Z,QJ!!!!
+#U@aD8+PX@P#TE&T3!$S!(!!"!!!CN9G*6P!!!!!+GfPZF(*[Bh-ZD!!!!!'TE&T
+"U@aD3DPX@N%!1`!D!!%!!"Q48e"I6!!!!!KcF&pXCABZD!"S!!+TE&S6U@aD%kP
+X@K-!2!!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!!!!&`!!!(H!!!#GJ!!!RN!!!(
+U!!!!)!!!!RX!!!(V!!!"lJ!!!Rd!!!%b!!!"q`!!!fX!!!(r!!!#J`!!!58!!!+
+&!!!#KJ!!!Jd!!!+(!!!#L3!!!SX!!!+-!!!#M3!!!Sm!!!!!!!!#N!!!!!$&!!!
+!!!!!!LX!!!!!!!!!!!!!!Ld!!!+5!!!#P`!!!!!!!!!!!!!#Q!!!!Li!!!!!!!!
+#QJ!!!U%!!!!!!!!#S`!!!M%!!!)b!!!#-`!!!M3!!!!!!!!#TJ!!!MB!!!P@!!!
+!#J!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!3RJ+5Th16VS!D%kk!(J
+X2%P14&K1ZJG14rVraLD-4rVra#D%6VS!J%kk!lC1ZJJ'6VS!mNkk!,j1ZJ!Q3QG
+)H2rr5'm!"%KA5(J!!5)krkT1ZJ9H6V8B!#"Y!'a1N!#Tp#)krjTR#%kk"8K1Y4J
+!6R94q!THF!"1ZJ6'C`C+N!"R!U"*6R8J1!TiCJiX2&T26N91ZJE5)!aJ"LC!)#X
+!)%IkrdJQJ%je,$a%394"6VS'YL"-)RJ*##!%S#j1ZJGU4rVr-#D%,$a69&*66VS
+'Q%Ikra`QM#`m4&*&6%kk"SJJ6#!%C`a1ZJ+Z")!!!!!-C[41qJFd6PErfN(i#4!
+L6h!JS#j`!G!4@K(5`%(k!"*`"D!Z9Bp)E`!#UCG1ANje,R*cFQ-!4rS(pLDi#R`
+JH!TiXI`!!!!!C`K(qJIQ*UJ!&Lmi#S"Q!PL26R9BMdMRrrJq,`!i8IJ+AQ!+@Bm
+[#+QP)"qJ3$!(6VS$eQGX4rVqKLD))""Rj#*!5T&Q,U!TS%NX2%0548a1ZJAHCd`
+q,`!i)%`J"'F-6VS!fJ5!!!!!$'Ed6VS'JNkk!R`JH[j)S'N)!!!(CJ5JC+!T6VS
+#jL*[!$4GL5p*!$C-harr9)p+1!%YC`+TrdjeF!qTb9L2)'m!"!a36[PQ$M!J6VS
+$8QISS#T1ZJ+!,Tp1G8kk"bT1ZJ!16VS'Q%je6VS((%je)$S(%'B!!$)JH!+QF!c
+3N!#`Z!+UCL)JH!VXS#8J8#*))KKJ#N(S!!Kd!B3Bd-*4bIrdN!#)d)PQ!Nje)J#
+J,L"i#Z`J!D!N)P"2lrr!)%p#U!!5-@N!"!!@S"9#TdKT!!`J6kRb-KK1ZJ,Z*&M
+9`63B)KKZ2QFL8N&R%P*"CbC@3@F!!+j53@F!!*K1G6)Srr41ZJ,mde*1G6)Srr4
+1ZJ,-de*1G6)Srr41ZJ,5dkVrrNje6VS#NM)T!!a+D3!+CL"83QS38N*QH("MUFP
+53QEide*1G8kk!T65U3!1de*1G8kk!Uc5U3!1$%,rr'GLE@K53QB%de*1G82e'!+
+q8@E-$'%r2'E'8N*Q"JTU!"IrrM)K@%%LH[c3dT'55Y056R8b+2rd6VS#D0+0dkV
+rrNje-LMrp%kk!M65MG1Urrj1G8kk!LM5U3!1dSh6U[rq6RA5MG1Urrj1G82e'!+
+q8@E`$'%r2'EU#QS!!rrm-L&F35*kr(65NG+Urrk55M9"rrid[%ja6R8b'%kk!H"
+&p4J!eGJd''Fb)KKZ*'F18N&Q&$)Srr41ZJ(SB"Jb+2rd6VS"ZQ!1-LMrp%kk!F*
+J"Nkk!H,5MG156R8L'%kk!GE68Nje)(VlrL!kqrj+U!!!CbJb+!!SCb)N+!!B@8*
+$l3!3dqJ!"09C-[`r2%)C%ZJ!26,mUI"43@EX3HJ!3!5!!!!!3'E'6R8JH[Zk)$V
+lZR,rG!"+U!!!CaUq+!!pCK3f+!!S5-0R$05$XUJ!"'8%)LJ!"%(S!%!%J!!!!%"
+Qe#"kqjBJ8(!3NS$QL6$"jSS!3S!!--*1G5"3FJ!b'$!B!N"rrqH*3r8B)$34B")
+L+3!%NSJb`6,m2c`b`M,mUI"4b2rXB$BJ%+"9)%"b!$)B-"J#3(rrjiP$p4JJ$'P
+1q3!#CaJd+3!%B!ib%8K`%!!b`M,m6[NLhe()rr!J1J!+)%"Q!Q%'6Y!!!!!!-$b
+J[D0')JJ`2+LITdDbL'F'3IS!,'!J$$J!"!%[C3C"qJ!LB")-1!!#!5pP"N(k!"K
+J"%(k!"j$q[r#)SK1GD#p6RAdq%je6RS!!JM!!!01H`!#6R9CMbmm3dp%46m!UD!
+JAe$i#PiJ#%je+(VkNL*-Np6PJGR"dp41G5KkqRV#r!"!)M3B'#KkqS,5P%je+(V
+kCX,m!%!L0"J)NVVkDNje+(Vk9-,m!%!L0"J3dVVk9%je+(Vk3X,m!%!L0"J%"S%
+!!!!36R91Z[qL-LN!$%TT!!TQ"NkkrlKJ"%kkrpE5U3!16R8JAc)B0"L`@&I*rrT
++3QIq6[!Jr#"I-KJd',#B9mRrqNT#Crj1m#$k)&mb'$3BX%*Z#T!!3@d'd%""m!!
+#-""RrNl`!!!J,`!%,d%!"#)[!!J[A`!%51Fm!#3!*J&)3X6$+!!U!8K&b-A84%K
+#3N,!`G##60m!2#)I6R8J,`!%,d%!"#)[!!J[A`!%51Fa!%kk!*a-h`#-)Kp1G5!
+[!!3[33!%)Lm!##pI!!4)jc%!6VS!I#!"60m!M#)I6R8J,`!%,d%!"#)[!!J[A`!
+%51Fa!%kk!#a-h`#-)Kp1G5![!!3[33!%)Lm!##pI!!4)jc%!6VS!$#!"60m!M#)
+I6R9+J'SF5S&U$%5!4)&1ZJ!J4)&1G85!6VS!&N5!4)&1G8U"DJT%J8kk!!C%J%j
+e,M`!!2rrXS"M"L)!F!"1GE#(BJb!`8K!-J"#3%K!6R@bKf)D,J"#3%K!J-&)3%K
+(2J")4il"-!G)4c)(6R8N!#B"iSMLLE+(B[L!`F#(-J2#`#i$5%I1`%K(dSGP#*+
+#BJ4%J8je8d"Jj(i!8IJ+APQ2,`Br"kQJ)"pR!!#Z*N"CMbm,UD8Q(b!,+!054qp
+(8NFk"f!@@Bm["Mm(UD!J(fF!!)K54`D%!!"rrP@2,`#TTM!I#!!!"@EF82J+AXp
+&QNGQ(#!$S%![#kQL)"0R!!"D,`ZTNLK6)%ZJ+A!"6R8J"+%H)!KR!!"#+%J[#kQ
+L)"0R!!!f)%XJ!f!B@Bm["Mm(UD!J(fF!!#*54b"!)$`!!(rq,`JJ8#*-fF#J,UQ
+M8FhrfTR%*Na`!8je)%Y+4@B%S#01GD!I6R8b2+R`3rVj%%kk!,!b2+Rb3rVj[%k
+k!+3b2+Ra3rVjLNkk!*Jb2+Rc3rVjT#"i#RLar!!!!!"R%#!S!"CR#L!S!"aR&%l
+k!(41ZJ"`-MbTp%2kqA41qJ"N6VS!B$)mUI4$q[Pb6[S!9#m))'m!##pS!!)!##!
+k!(CQ!!!m)(J#TR!-d*!!X,J#UQBX6VS!CM)mUI"1ZJ"#-MbTm8kk!$Sb2+Rb6VS
+!-M)mUI01ZJ!U-MbTp%kk!#)JAdje-!'K4L4)F!bK(M!"S%F`r%kj)-N`r%lj)-T
+1G6!"S8BLD!!)S"m`!5"*S%G1G3!!!!!!!!!!6R8J1[rdC`3J3%+3!%je!!!!'a(
+-chK-!!!!!!!MC'9QD@jP)&03480I6%9@!!!!!!!!!!%!!!"H9J!!A9B!!!*[!-C
+ZJ!X'!!!!(!)k!"&)390)!!!!NPT26N8!!!#H5dP14!!!!+TA6%p$!!!!YNP14&J
+!!!$#8da69!!!!-j$6d4&!!8!fN4"9%%!!!%L8e458`!!!5j%8N9-!!!"1P0C69-
+!!!&'3dj'4`!%!9*659T&!!!"MN4#8e3!!!'D4%*A8`!!!DC$8N9-!!-"XN4#98F
+!!`(L4PG*6J!!!K)!!3!!!!!!!!$'E+!!!2rr!!!,e3$'E(J!!2rr!!!$p!$'EHJ
+!!2rr!!!&8J$'EH!!!2rr!!!'0!$'EJJ!!2rr!!!')!$'DpJ!!2rr!!!&LJ$'EH3
+!!rrr!!!&lJ$'E%J!"Irr!!!&pJ$'E&3!"[rr!!!&rJ$'E'!!"2rr!!!'"J$'E#3
+!!Irr&!"6f3$'E"3!!2rr!!!'$J$'E!J!!2rr!!!'%J$'DdJ!!2rr!!!'&J$'Dr`
+!!2rr!!!''J$'De3SS3!'!!!+PJ$'Dq3Kl3!8!!!+R!$'Dm`6e`!K!!"G-`$'DkK
+c-!!T!!!+`!$'Dj!!!![rr`!!#c3!aQbXrrm!-`!!"A`!aQbi!)$rr`!!#p%!aQZ
+F!)$rr`!!"9i!aQZ%!!2rr`!!#RJ!aQhi!!Arr`!!#R`!aQ`B!!Err`!!#S!!aQh
+`!!6rr`!!#S3!aQc!!!2rr`!!#SJ!aQbd!!Arr`!!#S`!aQi-!!Err`!!#T!!!-C
+Yd!!%rrm!!&e5!-CVA!#!rrm!!!9i!-CV8!9YDf&SE!dJ,QmJ3fpZGQ9bG'9b$&0
+jE@&ZG'9M)%-V+`G85%P15b"$#94)58j,)&*PHJ%lX#N:
diff -Pru nethack-3.4.1/sys/mac/old/MDproj.hqx nethack/sys/mac/old/MDproj.hqx
--- nethack-3.4.1/sys/mac/old/MDproj.hqx	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/MDproj.hqx	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,250 @@
+(This file must be converted with BinHex 4.0)
+
+:$8eKDf9%C@Cc,R"bEfS!8&*25NY"5%`!!!!!!!!!!#iFaU`!!!!!!3!!!#[e!!!
+Up3!!!LF!!"Qk&94)58j,)&"bEfTPBh3J6@&ZB@GPFJ)!!!""8!T0B@YP4'9QFbk
+j!!)!!!"38Np+5d&)6!%!rrrrr`!!!!"38Np+5d&)6!%!rrrrr`!!!!!!!!!!!!!
+!!!!!!!!!!+KM@5-!!!!!!!!Z(!!!FSS!fAd%!!)!!!!!!!!!!!X!!!!CZJ98Efp
+XF`%!!!!!!3!!'FQS3T!!TkK#Y$F!!!!!!,3!``%8!A8"!2re!-d"!2rp!!!!!!!
+!!!#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!$m!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!"`!!!!J!%Ip2!+J!2!!!!!!!!!!+!!!!"J!!!!B!!!!!!"B!!!#
+$!(d!!NN$!!!!!!#%!!!!!NNK!!!!$J!!!!!!1!!i!$J!1!!i!!!!"!!!!!!!!!!
+%!!!!!!!!!!!!!!!!!!!"@J!!X!8!!%459P)!!!!!!!!!!!!!!!!"D!"Lqc!!!!!
+!!!!!!J!!!!!!!!#8!',l-!!!!!!!m!"M!!!!DJ!!!!%!!!!#!3!!!!!!`!!!!!!
+!!!!!!!!!!!!!!!"MJE!!!!!!BfpbC@0bC@`!!*i)F(0Z)!!!!!J!!!!!!!!!!Q&
+PGR3!!3!"D@jdC@9ZG@d!!!!%Bf&ZFcXl1cYVEf0XG(P`C3!!!!434%p$C'&dB94
+68%)!!!!!!!!!!!!!!!!!D!"Lqc!!!!!!!!!!!!!!!&S!!!!!!!!!!!%!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'&PGR4KER0b!!#H#("cEL!!!!!)!!!!!!!
+!!!*KCACd!!%!!6Xl1cX!DJ!!!!!!!!"B!',l-!!!!3!!!!%!!!!-+J!!!%`!Bi(
+i#f6J!!!F!%B!!8K"39"36$mr2cm!!!!!!B!!!!)!!!!!!!!!!'!!!!!!!!!!!!!
+!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3)!!`!
+!!!)!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!%$!!%!!!!$!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"!`!#!!!!"!!!!'!!!!!!!!!!!!!
+!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3-!"`!
+!!!!!!!$J!!%+N!!!!$&F!!!!!!!!!63!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!#"!!'!!!!!!!!!'!!!!!!!!!!!!!!!!!!!!!!!!!!"!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3)!!!!!!!8!!!"J!!!!!!!!!!!
+!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)&!!8
+!!!!'!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!#"3!%!!!!)"(-chK-!!!!!!!MD@jME(9NC5!m6@&M5'9KC'9
+bFci!!!!!Q5%!!!!!!!!!)!!!!!!!!!!!!!!!!!!!!)!3!!J%,Q&cE3G85%P15b"
+$!LjM"e4)58j,)%-$,Q0`$&0jE@&ZG'9M)%-V+`3ZBh"`$&0jE@&ZG'9M)%-V+`8
+ZEQpdC3FJafj[EQA)!Lj[$5!ZEb"$EfjfCA*dCA)#,R)*9%K*6NXJ8Q9k"5jbFh*
+M$e*PFfpeFQ0P)%0[F'PPFJ!!!!)"!!!!!##K%(r`d!!!!#0TEQ0XG@4P)$a0B@0
+)C@&NCA*c+bXq!!!!!(!"!3!!!!!MC'9QD@jP)(4bG@8J)#!J)#!J-3dMC'9QD@j
+P)'CKE(0P)#!J)#!J-!dMC'9QD@jP)(*PHL!J)#!J)#!J-3dMC'9QD@jP)'4PFQ9
+k)#!J)#!J-!dMC'9QD@jP)&4)58j,Ae*PHL!J-3d!!!!!!!!!'!!!QiZ3!!#EMj!
+!!*Z2X!#EPHS!QjUb!*ZJ-!#ES'B!Qk#F!*ZJ[J#ESj!!!!!!!!%&!3B"5J&,Irm
+!9`%'!3J"5!&+Irm!@!%)!8Krrhrr!!!!!!!U"J!!!)6B!)!"5J#!!BS!J!'G!)!
+"h3#"!8J!J3&+!)%"LJ#"!B`!J3'E!)%"R3#"!Gd!J3(I!)-"4`#$!8J!J`'-!)-
+"M3#$!CS!J`'E!)-"h`#$!H!!N3&(!*%"5!#4!B`!N3'0!*%"QJ#4!CX!N3(I!*%
+"i!#6!8J!N`&+!*-"LJ#6!B`!N`'E!*-"R3#6!Gd!N`(I!*3"5J#8!BS!P!'G!*3
+"h3!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!+J6%!!"!JN#d!!8KNJ!!!!!!!!!!!!!!!!!!!%`!CjIm!'H@H!!!!!!
+!!!!!!!%!!!"`[[J!!!!!!!!!!!!#!!!!+J"-!!!!!!!!!!!!!!!U"C!!!!!ETeG
+$5%%!!!!*Gf0SBA*IG#jS!!!%T$(T3+3ak8#N-HP!!!m!'J!#!!!E%&G*6N3!!!%
+*GfPZC'phFbjS!!!%T$(T3+3ak8#N-HP!!"!!'J!#!!!E%%e&68m!!!%)E@9YEh*
+j,QJ!!!!%Tp)R`UI5*m+RdLI#!"%!(!!#!!!E%&&958-!!!%,FA9TBfYNFQ&h,QJ
+!!!5QC0R!TQ6C`+CNfF!!%J!D!!)!!"X349C&6J!!!3KPGQ9ZG(-ZD!!Z!!5N-HP
+!T$(T3+3ak8!!%`!F!!)!!"X33dp19!!!!3TMEfjdFQpXFbjS!!!!"+CNfF#QC0R
+!TQ6C`!!8!"S!!J!!'a"%58&-!!!"#@4TB@a[Ch-ZD!!!"+3ak8#N-HP!T$(T3!!
+9!"J!!J!!'a"'6dj8!!!""fC[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!&J!B!!)
+!!"ZR4N019!!!!3GQBfjdE#jS!!!"U'0A6UKM9dkSBeG1!"F!(!!"!!!XBe"&8Nd
+!!!!+F'9bE@pZFh3ZD!!!!!+SBeFjU'0A1DKM9cN!'!!D!!%!!#aM68p133!!!!P
+YEfjKG(4V,QJ!!!+SBeFlU'0A1kKM9cX!'3!D!!%!!#aM68p14J!!!!PYEfjQE'&
+R,QJ!!!+SBeEdU'0@p+KM9[3!'J!B!!%!!#aM38a*4`!!!!GKE'PRELjS!!!"U'0
+A2UKM9ckSBeFq!"X!'J!"!3!XBde26P-!!!!)E@pZFhPY,QJ!!!!"U'0A$UKM#J!
+!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqSBeK#!!!!'!!"!!!Xfde26P-!!!!(E@p
+ZFh3ZB`!!!DJ"eC!!U!(9N!#S!G@3!!!!!"`!!J!!'`p0380)!!!"#NeKBdKPB@4
+PFR-!C3!"U'0@qDKM9[QSBeEj!!%!'J!"!!!XBd026NB!!!!)BfpZCQPR,QJ!F`!
+#U'0AAkKM9eqSBeGI!!)!(!!"!!!XBe45383!!!!+G(*KC(0dC'-ZD!"P!!1N,E`
+5T#fm%U3Y[")!!`!D!!)!!"ZR8e4%33!!!3KcG'4KFQFZD!"S!!+SBeFIU'0A(kK
+M9am!"!!D!!%!!#aM4da23J!!!!KRE'pLB@`ZD!"S!!1Q`pMiTX2Bq+E$f2J!"3!
+B!!)!!"ZR8e4%53!!!3GcG'4TEbjS!!!%Tl%4$UHa%3kRX4%1!!B!'J!#!!!ETe0
+*@N8!!!!)FfPkC9pd,QJ!D!!$U'0@rDKM9[fSBeEp!!F!'!!"!!!XBd026e)!!!!
+(Bfp[FQ3ZD!!!!kKM9bHSBeFRU'0A*`!)!"S!!3!!,'00380$!!!!#@eKBf0[EQB
+ZD!!!"+KM9ebSBeGFU'0AA!!*!"S!!3!!,'06@908!!!!#(0jFh4PE5jS!!!!"DI
+pEF+Rr@h#TreY`J!+!"J!!J!!'a"8@9"&!!!""h4jF'9c,QJ!!!@Q`pN%TX2C"+E
+$f33!#`!B!!)!!"ZR9%P043!!!3CdD@eP,QJ!!!!%T$(T3+3ak8#N-HP!!!`!'J!
+#!!!E%&0&4d`!!!%*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pLH!!d!'J!#!!!ETe0
+84%`!!!%)Fh4NE'PL,QJ!!!!&T#h!)U3Y`#+N,F!L!!i!'J!#!!!ETeG$5%%!!!!
+*Gf0SBA*IG#jS!!!%T$(T3+3ak8#N-HP!!!m!'J!#!!!E%&G*6N3!!!%*GfPZC'p
+hFbjS!!!%T$(T3+3ak8#N-HP!!"!!'J!#!!!E%%e&68m!!!%)E@9YEh*j,QJ!!!!
+%Tp)R`UI5*m+RdLI#!"%!(!!#!!!E%&&958-!!!%,FA9TBfYNFQ&h,QJ!!!5QC0R
+!TQ6C`+CNfF!!%J!D!!)!!"X349C&6J!!!3KPGQ9ZG(-ZD!!Z!!5N-HP!T$(T3+3
+ak8!!%`!F!!)!!"X33dp19!!!!3TMEfjdFQpXFbjS!!!!"+CNfF#QC0R!TQ6C`!!
+8!"S!!J!!'a"%58&-!!!"#@4TB@a[Ch-ZD!!!"+3ak8#N-HP!T$(T3!!9!"J!!J!
+!'a"'6dj8!!!""fC[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!&J!B!!)!!"ZR4N0
+19!!!!3GQBfjdE#jS!!!"U'0A6UKM9dkSBeG1!"F!(!!"!!!XBe"&8Nd!!!!+F'9
+bE@pZFh3ZD!!!!!+SBeFjU'0A1DKM9cN!'!!D!!%!!#aM68p133!!!!PYEfjKG(4
+V,QJ!!!+SBeFlU'0A1kKM9cX!'3!D!!%!!#aM68p14J!!!!PYEfjQE'&R,QJ!!!+
+SBeEdU'0@p+KM9[3!'J!B!!%!!#aM38a*4`!!!!GKE'PRELjS!!!"U'0A2UKM9ck
+SBeFq!"X!'J!"!!!XBde26P-!!!!)E@pZFhPY,QJ!!!!"U'0A$UKM9`kSBeF1!"`
+!'!!"!!!XBd965%X!!!!'CA0SDbjS!'J!!UKM9`USBeF+U'0A#J!G!"S!!3!!,'0
+%98j(!!!!#@4eEQGPEfiZD!!!!kKM9[5SBeEdU'0@p!!H!"J!!3!!,'0"6%P(!!!
+!"f&XD@GZ,QJ!!!'SBeG[U'0AEkKM9fm!(`!B!!%!!#aM9N&96!!!!!GfBA9XG#j
+S!!!#U'0A#UKM9`USBeF+!#!!'J!"!!!XBd496NF!!!!*C(9ZCf9[ELjS!!!"U'0
+A$DKM9`fSBeF0!#%!'!!"!!!XBd938NN!!!!'CA"bD5jS!#i!!UKM9`USBeF+U'0
+A#J!L!"S!!3!!,'0%98j(!!!!#@4eEQGPEfiZD!!!!UKM9[5SBeEdU'0@p!!M!"J
+!!3!!,'0"6%P(!!!!"f&XD@GZ,QJ!!!'SBeEhU'0@pkKM9[F!*!!B!!%!!#aM3dp
+-6`!!!!GMEfa[FLjS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU'0B8`!!!"S
+!!3!!,0Y23NT&!!!!#@pLDQ9MG(-ZB`!!!DJ"eC!!U!(9N!#S!G@3!!!!!"`!!J!
+!'`p0380)!!!"#NeKBdKPB@4PFR-!!!!"U'0@qDKM9[QSBeEj!!%!'J!"!!!XBd0
+26NB!!!!)BfpZCQPR,QJ!F`!#U'0AAkKM9eqSBeGI!!)!(!!"!!!XBe45383!!!!
++G(*KC(0dC'-ZD!!!!!1N,E`5T#fm%U3Y[")!!`!D!!)!!"ZR8e4%33!!!3KcG'4
+KFQFZD!"S!!+SBeFIU'0A(kKM9am!"!!D!!%!!#aM4da23J!!!!KRE'pLB@`ZD!"
+S!!1Q`pMiTX2Bq+E$f2J!"3!B!!)!!"ZR8e4%53!!!3GcG'4TEbjS!!!%Tl%4$UH
+a%3kRX4%1!!B!'J!#!!!ETe0*@N8!!!!)FfPkC9pd,QJ!D!!$U'0@rDKM9[fSBeE
+p!!F!'!!"!!!XBd026e)!!!!(Bfp[FQ3ZD!!!!kKM9bHSBeFRU'0A*`!)!"S!!3!
+!,'00380$!!!!#@eKBf0[EQBZD!!!"+KM9ebSBeGFU'0AA!!*!"S!!3!!,'06@90
+8!!!!#(0jFh4PE5jS!!!!"DIpEF+Rr@h#TreY`J!+!"J!!J!!'a"8@9"&!!!""h4
+jF'9c,QJ!!!@Q`pN%TX2C"+E$f33!#`!B!!)!!"ZR9%P043!!!3CdD@eP,QJ!!!!
+%T$(T3+3ak8#N-HP!!!`!'J!#!!!E%&0&4d`!!!%*Ff9RE'pKC#jS!!!%TX2BRUE
+$f*kQ`pLH!!d!'J!#!!!ETe084%`!!!%)Fh4NE'PL,QJ!!!!&T#h!)U3Y`#+N,F!
+L!!i!'J!#!!!ETeG$5%%!!!!*Gf0SBA*IG#jS!!!%T$(T3+3ak8#N-HP!!!m!'J!
+#!!!E%&G*6N3!!!%*GfPZC'phFbjS!!!%T$(T3+3ak8#N-HP!!"!!'J!#!!!E%%e
+&68m!!!%)E@9YEh*j,QJ!!!!%Tp)R`UI5*m+RdLI#!"%!(!!#!!!E%&&958-!!!%
+,FA9TBfYNFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!!%J!D!!)!!"X349C&6J!!!3KPGQ9
+ZG(-ZD!!Z!!5N-HP!T$(T3+3ak8!!%`!F!!)!!"X33dp19!!!!3TMEfjdFQpXFbj
+S!!!!"+CNfF#QC0R!TQ6C`!!8!"S!!J!!'a"%58&-!!!"#@4TB@a[Ch-ZD!!!"+3
+ak8#N-HP!T$(T3!!9!"J!!J!!'a"'6dj8!!!""fC[ER4c,QJ!!!5N-Iq3!+3arj!
+!T$(rN!!!&J!B!!)!!"ZR4N019!!!!3GQBfjdE#jS!!!"U'0A3UKM9d+SBeG#!"F
+!&J!"!!!XBdp#5Li!!!!&Ef*U,QJ!!!'SBeG&U'0A4DKM9d8!'!!F!!%!!#aM6d*
++3`!!!!T[BQTME'&cFbjS!!!!!DKM9dqSBeG2U'0A6`!C!"J!!3!!,'038Np3!!!
+!"R"bEh!ZD!"c!!'SBeK6U'0B8kKM@&-!'J!D!!%!!#cE6d*+43!!!!P[BQTPBh4
+c,Q-!!!+SBeEhU'0@pkKM9[F!'`!B!!%!!#aM3dp-6`!!!!GMEfa[FLjS!!S!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU'1&fJ!!!"`!!3!!,4G038Y&!!!!#QeKDf9
+NC@Cc,Q-!C3!"U!(9N!#S!G@3!+J"eC!!!!!!(!!#!!!E$de"3dJ!!!%+6@&M5'9
+KC'9bF`"P!!'SBeEjU'0@qDKM9[N!!3!D!!%!!#aM3dp14J!!!!KMEfjQD@FZD!"
+c!!+SBeGIU'0AAkKM9em!!J!F!!%!!#aM9&*"4!!!!!TdFQ&NFh4NBbjS!'8!!k3
+Y["+N,E`5T#fm%J!$!"S!!J!!'kG69%4"!!!"#(0dC'&bCbjS!'J!!UKM9aqSBeF
+IU'0A(`!%!"S!!3!!,'0(6%p#!!!!#'GXEf*KE#jS!'J!!kE$f2LQ`pMiTX2Bq!!
+&!"J!!J!!'kG69%4*!!!""h0dC'P[,QJ!!!5RX4%1Tl%4$UHa%3i!"J!D!!)!!"Z
+R8dPD43!!!!KcDATPAh3ZD!"S!!1SBeEpU'0@rDKM9[d!"`!B!!%!!#aM3dp28J!
+!!!GMEfpbC#jS!!!$U'0A*kKM9bHSBeFR!!J!'J!"!!!XBde"3d-!!!!*E@&MBfp
+ZCLjS!!!%U'0AA+KM9ebSBeGF!!N!'J!"!!!XBe0C8e3!!!!)FhPcG'9Y,QJ!!!!
+&TreY`UIpEF+Rr@h#!!S!'!!#!!!E%&4C8%8!!!%(G(P`CA-ZD!!!"DE$f35Q`pN
+%TX2C"!!,!"J!!J!!'kG858e&!!!""R4TE@8ZD!!!!!5N-HP!T$(T3+3ak8!!$!!
+D!!)!!"X38d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pLHTX2BRUE$f*i!$3!D!!)!!"Z
+R8e4%6!!!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3Y`#)!$J!D!!)!!"ZR9d0)33!
+!!!PhBfKKFPpd,QJ!!!5N-HP!T$(T3+3ak8!!$`!D!!)!!"X39dP14!!!!3PhD@j
+NEhGc,QJ!!!5N-HP!T$(T3+3ak8!!%!!D!!)!!"X368906`!!!3KYC@e[FRNZD!!
+!!!5RdLI#Tp)R`UI5*m)!%3!F!!)!!"X3899*3`!!!3YaG@PMDf4bBAFZD!!!"+C
+NfF#QC0R!TQ6C`!!5!"S!!J!!'a"&9N91!!!"#'9fC@jdFbjS!#i!"+3ak8#N-HP
+!T$(T3!!6!"`!!J!!'a"$6dj8!!!"#Q0[ER4bEfac,QJ!!!!%TQ6C`+CNfF#QC0R
+!!"3!'J!#!!!E%%4*38`!!!%*C'PKE'pRFbjS!!!%T$(T3+3ak8#N-HP!!"8!'!!
+#!!!E%%C26P3!!!%(CQpZG(-ZD!!!"+3arj!!T$(rN!#N-Iq3!!!@!"J!!J!!'kG
+'3dj8!!!""fCMER4X,QJ!!!'SBeG1U'0A6UKM9di!&`!F!!%!!#aM8%9563!!!!T
+`CA*YEfjcG#jS!!!!!UKM9cQSBeFjU'0A13!B!"S!!3!!,'006dj"!!!!#@e[EQ&
+dG'XZD!!!!UKM9cZSBeFlU'0A1`!C!"S!!3!!,'006dj'!!!!#@e[EQCXB@FZD!!
+!!UKM9[5SBeEdU'0@p!!D!"J!!3!!,'0"6%P(!!!!"f&XD@GZ,QJ!!!'SBeG&U'0
+A4DKM9d8!'`!F!!%!!#aM6d*+3`!!!!T[BQTME'&cFbjS!!!!!DKM9ckSBeFqU'0
+A2J!F!"S!!3!!,'006dj6!!!!#'e[ER0jE5jS!'J!!DKM9[DSBeEfU'0@pJ!G!"`
+!!3!!,'0"8P4*!!!!#Q&bG'PXDA0d,QJ!!!!"U'0A4kKM9dHSBeG(!"i!(J!"!!!
+XBe""9%-!!!!-F'&dBfKXCACPE#jS!'i!!DKM9dqSBeG2U'0A6`!I!"J!!3!!,'0
+49%9B!!!!"h&dCAKd,QJ!%!!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqS3b*$!!!
+!&J!#!!!ES&9159J!!!!%G@jTH!"1-!!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrq
+S3b)6!!!!&J!#!!!ES%&18dN!!!!%38j653"d!!!!!&F+U'0A#UKM9`S!)J!D!!!
+!!3!!!!J%E@&TEL!J)'jRC@pZ,QJ!!!+SBeEdU'0@p+KM9[3!)`!B!!%!!#aM38a
+*4`!!!!GKE'PRELjS!!!"U'0@pkKM9[HSBeEh!#3!'!!"!!!XBd026%m!!!!(Bfp
+XEh)ZD!!+!!!!!!!!!!!!!!!!!!!!!!#SBeK6U'0B8kKM@&-!!!!D!!%!!#cE6d*
++43!!!!P[BQTPBh4c,Q-!!!'S!G@3!+J"eC!!U!(9N!!!!!!F!!)!!"X268&$5!!
+!!3T0B@0)C@&NCA*c!!!!!DKM9[QSBeEjU'0@q3!"!"S!!3!!,'0$6dj'!!!!#'0
+[EQCTCbjS!(-!!UKM9eqSBeGIU'0AA`!#!"`!!3!!,'088N&%!!!!#R4bB@4cG'4
+M,QJ!!!!$T#fm%U3Y["+N,E`5!!-!'J!#!!!ETe084%%!!!%)Fh4NBA*R,QJ!D!!
+#U'0A(kKM9aqSBeFI!!3!'J!"!!!XBdG-6d)!!!!)Cfa[BQ&X,QJ!D!!$TX2Bq+E
+$f2LQ`pMi!!8!'!!#!!!ETe084%N!!!%(Fh4ND@mZD!!!"+Ha%3kRX4%1Tl%4$J!
+'!"S!!J!!'kG659T&!!!!#(0THQ9IG#jS!'J!!kKM9[fSBeEpU'0@r3!(!"J!!3!
+!,'0$6dp5!!!!"f0[Eh*N,QJ!!!1SBeFRU'0A*kKM9bF!#!!D!!%!!#aM68&$3`!
+!!!PYB@0MEfjQ,QJ!!!5SBeGFU'0AA+KM9e`!#3!D!!%!!#aM8eP69!!!!!KcHA0
+dC@dZD!!!!!@Rr@h#TreY`UIpEF)!#J!B!!)!!"X39&P343!!!3GdHA"PFbjS!!!
+&TX2C"+E$f35Q`pN%!!X!'!!#!!!ETe4*688!!!%'G'PYC5jS!!!!"+3ak8#N-HP
+!T$(T3!!-!"S!!J!!'a"648G-!!!"#A0PCfa[B@3ZD!!!"+E$f*kQ`pLHTX2BRJ!
+0!"S!!J!!'kG69%4-!!!"#(0d!!!!B!!!!(!!!!!!!!!!8!!!!#!!)$mm!!'Tm!A
+Z2c`!!DR`"J)r2!!"UI!'&Mmm!!'Tm!Bb2c`!!DR`"QJr2!!"UI!'L$mm!!'Tm!D
+U2c`!!DR`"XSr2!!"UI!*4$mm!!'Tm!!!#9B!!!!+!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!"`!!!!"#H!T+RFj1ZJ"S6VS!H#`m58j%@%kk"dj(q[r'*Sa(q[r
+%*S41ZJ#!6VS$YNkk#!C1ZJ$b6VS![Nkk!#C#CdKirrp)E`!%5&G)H!!")MVrUNk
+k"9j1Y4J!)'d!E%k3!+Rd)MVrQQF)6VS&5%ke'!"1G9(i#Pj`!%kk"-CR"NU3!'F
+#S%P1G5!i#RKQ$L`m@Np148kk"Y)J$'!'*N!J+`!J4rVr5#D!6R8X2%4"9%&1ZJD
+f)%`LH!N))!5J,Nkk"fT(q[m`*S3X2&088P01ZJDB4rVr(#D-,$a%8N9-6VS'L#"
+-)!4R$%kk!Ui%J!!!!!aQp%lk"c419[rD3IJ*%#*2F##J,R!"d"&D%G,!3IS!%R!
+&S#j9MdK[!!+TPdjH6R8ZFR0bB`"(qJIf*VJ+I#"i#RLar!!!!!"R#%Ik"qBQU!!
+@,cJ+J'B#@)p1G9L251Irq$i[!$K4q!THB!TCMbm)UD8J(k"!-!G1ZJ2@Cfa(q[k
+'*SJJ%'IN)N"+N@BZS#QJ55`m3e*&6%kk"GjR6$i[!$JJ6#!%C`a1ZJ$D")!!!!!
+-C[41ZJD#6VS#I#"krNLJD3J!!!GQ"+"NS#P1ZJ,Q)Qm!0&f*,dN!0NcI(rp8MdS
+i!5eR!URr6R9`$kR*@)mJE`!%$&"1q@B1-#"1ZJ05CqLJ+Nkk!S!ZRdje6VS(+Nk
+k!!j1ZJDB6R91ZJFF6R8J1JF3CJ!!-L"i!UC`$0#3!,#i!UTQ)L"i#ZbJ*5"3)NJ
+L''!+3HJ!#(3"K"M3`P(*rr53!)M3L@B#6R8L!+!Z)(J+l#!"S#3L8%r[rm!J6d+
+S!")aD3!%!"DJ&8+R5'N!$#"2UI)b'%kk!ZiN@0A"0"JL''iqCb*53@F58N&R*PC
+"C`!!VP*"C`!!Q%je-LMrp%kk![c68Nje-LMrp%kk!Xc68Nje-LMrp%kk!Y,6U[r
+q6R91ZJ+5-LN!$%TT!!TQ)&4#DK"53QCiF'1Tb9*#C[M68Nje6VS#P0+T!!l68Nj
+e6VS#V0+T!!i-3[rmCf*YD&*#CJ668Nje3r8B!Vj4CX`-B6mmCXC53QB'#QS!&rr
+q-L&B35*kr0$5NC*+de*1G6)Srr41ZJ*SdSh6U[rq6R8b+2rd6VS#00+0dkVrrNj
+e6VS#+0+T!!l5MG1Urrj1GG+0dkVrrNje3r8B!Vj4C[!-B6mmCZS+DJ!$rr`b)9a
+")RVmG0+4dUVrrT*+08(rrM5m6R&1G6)B6VS"i%Ae'!$9f$3BCc)L''iNC`j53@B
+8-LMrp%kk!HKJ'$)Srr41ZJ'kB!ib+2rd6VS"`Q!'6VS"iY+0dj*1G5)B6VS"eY0
+56R8JH[[q)$VlrNUS!!"R+$)S!#KR)L3S!"KC3N2Y!"$6k!!%e9Nbr$mm3KN5k!!
+p-[bTm&&"CZa"k!"!")!!!!"!CXC1G5"kqlSJ1[ZkF[pd!%US!!"R'ViS!$eQ&$B
+S!#K)`fF-e)1bU!!%C33L+!!%3HJ!3!5!!!!!3'E8)(VlPL"3F"#5J1D*--(QLJ"
+#J!!``Nje)&"b!$)B-"J#3(rrjiP$p4JJ0"&J%L)T!!55L$,"-[`r2$,#-[bTm&(
+)rqaJ0L!3S&8J3()!-KJ`'!*!IrrRL82e'#!-D8lj!!*R'$3T!!4J$M)45(!3!$,
+#-[a1q5,I8FMrm#!k!!SJ3'B#B3C1d!!!!!!`2+#pSdBL#$!mU*qR4V+)C`C"qJ!
+XB#!-1!!%!5pP"N(k!#*J%J`i!!)",f8'3IS!''!%3IS!(N2krm)LL%jeS,e1GI6
+i6R91HJ!##-!!!djl!!*1G9Q2,ca$6d4&2`#TS#"I82J+AL!)6R8SH[U5)Nb6e1@
+"fF(6e%je+(VkHX,m!%!L0"JB+(VkJY+86R8SH[TQ`[`!3#)d'!L5Z[TU6R8SH[T
+8`[`!3#)d'"$5Z[T86R8SH[T#`[`!3#)d'!3'J3!!!""1G8kkrk)b+3!-5QN!#QB
+'6VVrZ'!%6VVreY+T!!j1G5"I-KJd',"B9mRrqNT#Crj1m#$m)&mb'$3BX*KAbIr
+k5N*RrNl`)2SJAc)B0"L`3Qi+N!""E3E33%(`!!)`%'Iq6[!!!#![!!3[33!%)Lm
+!##pI!!4)jc`!*!!Q!8K#a--S!#S"5%A)aG4%5%*#3X$"d)*-h`!m)Kp1G5![!!3
+[33!%)Lm!##pI!!4)jc%!6VS!R%cI!)`L(dje)#m!"#p"!!3L,`!),em!"%MR-3"
+1ZJ"m)!&-h`#-)Kp1G5![!!3[33!%)Lm!##pI!!4)jc%!6VS!,%cI!)`L(dje)#m
+!"#p"!!3L,`!),em!"%MR-3"1ZJ!-)!&-h`#-)Kp1G8U!DKa+J@S-4)"%J8kk!#"
+%J8je4)"1ZJ!@4)"%J8je5S&U#N5"6VS!"N5!6R8Z2!!!rrqbJ'-')J"`!%jeX)G
+L$)$"5%!b!%*!5%"1GE+(BKSZ!%*!5%#!`8K!5%Fq!%K(MX%`"dK(-JG1G53!*J(
+LL1+*XSGLq)$"`)Fb!m,!,J0)4ml!5%I5Kf8)NS*L"%5"6R963'$NIJ"4q!TH@Bm
+["Mm(UD!J(fF!!+iQ3&Q2,`ZTT5BI)!XS!e*(ldG54cS(B"CCMbm'2`HTS#!IC`!
+!L&*("S3!!(rq9Bm[!+QQ-"m)!!!&CYa3q!THcd@D4fBF)!1J3#m,UD)J%fF!!&S
+[#kQ5+&-J5k!TF!&1G5!%S4iJ#'F!!%)S5#m,UD)J%fF!!$BJ5b!$B"KCMbm'2`H
+TS#!IC`!!)P*()%!J2!!!Iri[##"3)NcC`+!ZUD04cIrDQF3Q6(!"6R8J5dT&CJ5
+J)djeS"p1G6)mUI"$q[N36VS!X$)mUI*$q[Qm6VS!T$)mUI&$q[Q+6VS!Q$)mUI0
+$q[QN)(J+H,(m!!!!!'F3)#J!&QF+)#J!('F86[S!G%kk!(!b2+Rd3rVjG%lk!'4
+1ZJ"J-MbTp%2kqA*1qJ"8,`JJE`!),fJ!!J!))$S!GQB!!$`JH!+QF!c3N!#`Z!+
+UCLa1ZJ"Q-MbTm%kk!%)b2+Ra6VS!1M)mUI*1ZJ!b-MbTmdkk!#Sb2+Rd6VS!)L"
+I6R8`!D&'*%K`$+%H-!'J4c$m6VNJb6$m6[NJbNje-!'K4L*S!!LJ(c!")%QJ4dj
+e!!!!!!!!!!"1G5!krr4R"#"!3T!!6R8!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!%!!!!Vp3!!+[8!!!)R!'HBG!T+!!!!(!(b!"&)390)!!!!NPT26N8!!!#H5dP
+14!!!!+TA6%p$!!!!YNP14&J!!!$#8da69!!!!-j$6d4&!!-!fN4"9%%!!!%+8e4
+58`!!!4C%8N9-!!!")P0C69-!!!%Z3dj'4`!%!6T659T&!!!"GN4#8e3!!!'#4%*
+A8`!!!Bj$8N9-!!%"QN4#98F!!3'b4PG*6J!!!FS!!3!!!!!!!!"RPq3!!2rr!!!
+*'`"RPY!!!2rr!!!%9J"RPbJ!!2rr!!!$p!"RPk3!!2rr!!!&Y!"RPXJ!!2rr!!!
+%,!"RPqJ!!2rr!!!K(`"RPX3!!rrr!!!%2J"RPi!!"Irr!!!%4J"RPe!!!Irr&!!
+KJ`"RPk`!!2rr!!!%6J"RPc!!!2rr!!!%8J"RPmJ!!2rr!!!Uh3"RPjJ!!2rr!!!
+Ui3"RPp`*A`!'!!!)H3"RP[3#U`!8!!!)I`"RPm"dP3!K!!!(Z!"RPa46lJ!T!!!
+)S`"RQ2`!#rrr!!!(h!"RQ#$rr`!c!!!%"!"RPVJ!J2rr!!!*&`"RPZ!!J2rr!!!
+%%J"RPl`!!rrr!!!Uj3"RPV3!"Irr!!!Uk3"RPX!!!rrr!!!Ul3"RPb!!"Irr!!!
+Um3"RPU3!J2rr!!!%!!"RPU`&E@YKD'`0)#j[)%0[ERCPFR4PFJa6H@eKER4PBb"
+$+bX(9%K*6NXJ3`P85%P15b"5CAS"1b4Z:
diff -Pru nethack-3.4.1/sys/mac/old/NHmake.hqx nethack/sys/mac/old/NHmake.hqx
--- nethack-3.4.1/sys/mac/old/NHmake.hqx	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/NHmake.hqx	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,549 @@
+(This file must be converted with BinHex 4.0)
+:$%jPG%KKBfXZE@&VC3"849K869"6)!%!!!"NkJ!!!DbMjb-J9'KTFb"TFb"K)'0
+[EA"XCA4P)%e39b"YB@YPCQPXC5"QEh)J6Q9dD'&MDb"KEQ3JB@aX)'PdFb"KFh0
+[BfPKG'9N)'CTE'9c$5-J8Q9aG@PbCA-J69"A)%-c,M+R-b"[FL"XBA4PFLiJ4@&
+bE'PPFL"fCA*cD@pZFb"hD@aX)'CKD@`JD'pbFQPLE(NJBQ9MBA9cC3dM)(4SCAN
+JBf&Z*h3JBfp`C5"hDA4S)#mU)#mU)#S[)'0[E@ePER4c$5-0)b"'Eh)J6Q9d5'&
+MDb!c,M%J6Qpf)$%j16%0)`dM)'*j)%eTBfKKC@bU)%KKE@9X)'&ZC#"5Eh0c)%*
+bEhGZ)$%j16%J1L"YD@0SB@9X3'pdB@G[,Q&M,Qjk$3dM,5dY,5dY,5dY,5dY,5d
+Y,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5d
+Y,5dY,5dY,5dY,5d0)`dM)%*&4Np545"C6e8J3P9*6%3J4Np5)&4)45"'59*69#"
+858e&$5-J)&0PG#"dD'Pc)'9aG@&dC5"dEb"dD'8JCQpXC'9b)'0[ER4KD@jTEQF
+JB@aX)(4SC5"1CA4)B@0V)(0[GA*MC5"QEfaNCA*c$3e8Eh!J)#!*)#!J25"l69"
+AI@jS-c%k$3dM)#"6CA3JG'KP)'4PCQ&eE(3JC'PbC@0dEh*j)(4[)(Y8Eh"p$5-
+J)%e[GQ8J6Q9d5'&MDbjYB@YP)'PZG'mJHe4[F(d0)b!J6@&VC5"dGfmJEQ9h)'9
+YF(4j)'C[E'4PFR-JD@iJG'p`1JdM)#!J)#dJ6f*U)'C[FL"dD'8JEf*UC@0d)'C
+TE'9c$5-J)#!J,5"%G@jRC@pZ)'C[FL"dD'8JBfpYF'aPG'9N)'GKE@80)b!J4@j
+cGA*P)(4SBA3JH@pe)'KKGQ8JBA3JE'9KFh3J0c!`-%XJB@aXEf0KG'9N)(4[)(4
+SC5"08&FJ8fKPE'`0)`dM,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5d
+Y,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5dY,5d0$5-J8f9
+d)(9`)(0jE@*[E(-JCQpb)'C[E'4PFR-JCR*[E5"dD'8JC'PcG(*TBR9dD@pZ$90
+bBb!J)!NJ)#!p)(Y8Eh"p8h*M1Je9G'PX)!NJ)#!p)(Y8Eh"p9A4TE$S04'&d#3N
+J)#!p)(Y8Eh"p4'&d1Je*EQ0XG@4P)#!J)$dJHe4[F(e*EQ0XG@4P1Je0B@0%DA)
+*)#!J25"l9'p`I90jFcT0B@-k$94dH84TFL!J)#!J25"l9'p`I9GTEMT8G(Nk$8e
+KBe4dH5!J)#!J25"l9'p`I90jFcT0B@-k$90SBA*P#5!J)$dJHe4[F(e6HA-k8fK
+KFQ8k$3dM)&4SCA0P)(4hEb"QEfaNCA*c)'&bC5"ZCAF06f*U4'Pb)#!J)#!p)(Y
+8Eh"p6f*U1JN*#3NM)#*8C@e`Eh*KFRNL)(0dG@CQ$9*PFh9XG(-*)#!J25"l9'p
+`I84eEQGPEfik#3N*)b"AD'9bC5"dD'8JCf&YC5"REf9c$3dM)%pfCA*bD@4P)(4
+SC5"cCA4dD@jRFb"TEL!LHdPZBfaeC'9p)Q0[EQCTCbjS$8j)3fpZCQPR)$dJ,@3
+J8d028N9I6djI3Np86#!YC#"@590*6djI9%&#6%96$3dM)&4jF'8JB@jN)'0bC@&
+dEh)J,5"ZEh4P)(4SBA3JGf8JGA0P)#*38N9')L"QEh)JB@aX)'j[ELecBACP)'C
+TE'9c$5-JBh9bFQ9ZG'aj,L"6D@jMC5"hC5"hD@aX)'PZG'9RFQ&dC5"dD'8JC'&
+dB5"QD@aPFb"TER4[)(4SC5"RB@eP$5-JFfp[EQ9b)'pb)'aKG'9b,#"dD'Pc)'4
+[CA0Z*h3JE@&dG'9b)'eeBfJZ$8CTE'98HA"P)#!J25"38N9'$8CTE'9$FQ9KG'p
+b25"ZD$-a$3dM)%jPG%KKBfXJDA-JB@iJB@*cG(*KBh3JG'&bCf9d)(GSD@0S)'P
+Z)'CKBh3JBfpZFfPcG(-JEfBk$3e6F'9MD@&X6'9fC@ac)$dJ)RY5CA0eE(4cI5*
+#D@G5EfpY,QaPGL!JYJd*#3N*)RY5CA0eE(4cI5*$BA0dE'8ZE'9f)#!JYJd*#3N
+*)RY5CA0eE(4cI5*KDA)ZE'9f#3Qf$3N*#3NLHe*PFh9XG(0p)NePC(9cB5da,Qa
+PGL#f$3N*#3NLHe*PFh9XG(0p)P&eCA0d,N4KG#!*YJd*#3N*)RY5CA0eE(4cI5*
+@B@aXCANZE'9f#EB0#3N*#5*l8Q9cG@adFhdL6h*KBfaP,QaPGL!J),B0#3N*#5*
+l8Q9cG@adFhdL9'phCA)a,QaPGL!J),B0#3N*#5*l8Q9cG@adFhdL35ecG'&bG#j
+XCABJ),B0#3N*#5*l8Q9cG@adFhdL3LecG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@a
+dFhdL3becG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@adFhdL45ecG'&bG#jXCABJ),B
+0#3N*#5*l8Q9cG@adFhdL5#ecG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@adFhdL5be
+cG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@adFhdL8#ecG'&bG#jXCABJ),B0#3N*#5*
+l8Q9cG@adFhdL8LecG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@adFhdL8becG'&bG#j
+XCABJ),B0#3N*#5*l8Q9cG@adFhdL9#ecG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@a
+dFhdL9LecG'&bG#jXCABJ),B0#3N*#5*l8Q9cG@adFhdL9becG'&bG#jXCABJ),B
+0#3N*#5*l8Q9cG@adFhdL6@PZC9p&EQ3ZE'9f),B0#3N*#5*l8Q9cG@adFhdLDfj
+[H#jXCAB*#EB0#3N*#5*l8Q9cG@adFhdLGfPkBA*N-5jXCAB0$84KG'&'D@aPFb!
+*23NLHe*PFh9XG(0p)N4eEQGPEfi*YJd*#3N*)RY5CA0eE(4cI5*5C@0[FQ3J)##
+f$3N*#3NLHe*PFh9XG(0p)NjPG%KKBfZf)%4PCQ&eE(4c)#!JYJd*#3N*)RY5CA0
+eE(4cI5*%BA4K)!Qf$3N*#3NLHe*PFh9XG(0p)P*eE@pbF`Qf$3N*#3NLHe*PFh9
+XG(0p)NpbB@0XCA-*YJd*#3N*)RY5CA0eE(4cI5*$E@4SC@a`$3N*#3N06Q9d5'&
+MDb$%)#!JHe0`C@0TB@a-CACPE(0p)(Y%BA4K4QPXCA0p)#*l8Q9cG@adFhdL6Q9
+d5'&MDb!0$5-J9'KPFf8JCQPXCA-JBA*P)(0PF'9bBA4P)'pZ)'pdD'9b)'eKBfK
+TEQ9c,#"LGA3JD'9bC5"dD'9j)'&bC5"LG@PXG!dM)'PZG'mJG'KP)'&`F'aTBf&
+dD@pZ)'*j)%jPG%KKBfXZFJd03R9TE(4*EN4KG'%J25!J)#*l4'&dI5*SD#!*#3Q
+f$3N*#3NLHd4KG(dL5'PcG'pbH5!*#EB0#3N*#5*l4'&dI5*-D@0PER0P)!N*YJd
+*#3N*)RY%BA4p)NKPE(!J#3Qf$3N*#3NLHd4KG(dL9fPkD'9XF#!*#EB0)`N*#3N
+LHd4KG(dL3feND'9XF#!*#EB0#3N*#5*l4'&dI5*2F(4SC@a`#3Qf$3N*#3NLHde
+KBd4TFRdL6@&MD'9XF!Qf$3N*#3NLHdeKBd4TFRdL6Q9hF`N*YJd*#3N*)RY2BQT
+%DA*p)Np`G'P[ER-0#3N*#3N*)#!J$3dM)%C[FL"NC@*eCfGTEQFk)'PQ)(P[G5"
+MD'&ZCf8JG'KTFb"jEh8JEQ9PC#"dEb"NDA0MBA*N)'9fCA*jG'KTEQFJD@iJHdp
+LDR0p$90"4%92F(4TEfjc)$dJ)b!YFhPY)'CeE'`0$5-J2$-b5b"QD@aP,@aPGQ9
+X)(0PCfePER4KG'P[EL"cBfKPE@806'PZDe4jF'8J25!YE@BJ,A0bG#!*#3N*#3N
+*#3N*#EB0#3NJ)#!YFfFJ6@&TEMeKE'aYB@PZ,'eKBfeKD@iXFQ&ZC'pY,(*ZC#a
+69%4$6%P#,&084%P2#EB0#3NJ)#!YFfFJ39*PFceKF("XH3N*#3N*#3N*#3Qf$3N
+*)#!J,A0R)%*5CA-pBQpdE#aNDA0`E'&j,(CTFfP[EJN*#3N*#3Qf$3N*)#!J,A0
+R)%05CA-pC'pIGf9KFLaME@3XG(*KBfX*#3N*#3N*YJd*#5!J)#ecCb"%8Q9c2@4
+[#3N*#3N*#3N*#3Qf$3N*)#!J,A0R)%95CA-pC'pR,'4[Cfe[GQ8*#3N*#3N*#3Q
+f$3N*)#!J,A0R)%C5CA-pC@&d,'edG(PYB@PZ,'eKBh4dH3N*#3N*#3Qf$3N*)#!
+J,A0R)%G5CA-pC@jRFQ&fC5aNG@jRC@pZ,'4LFQPNCf8*#3N*#3Qf$3N*)#!J,A0
+R)%K5CA-pD'&MDbaSB@0VE'PL#3N*#3N*#3Qf$3N*)#!J,A0R)%P5CA-pD@jfC@j
+d#3N*#3N*#3N*#EB0#3NJ)#!YFfFJ5P*PFceYEfjYEhCP,'e[EJN*#3N*#3N*#EB
+0#3NJ)#!YFfFJ5e*PFceYEfjNBA4K,'edD(*[Gh8XEA9cC5ahCA*P,(GTHQ&bC!N
+*#EB0#3NJ)#!YFfFJ6&*PFceYB@0hD@iXGfPZG(4j#3N*#3N*#3Qf$3N*)#!J,A0
+R)%e5CA-pE@&ME@9ZG3N*#3N*#3N*YJd*#5!J)#ecCb"18Q9c2A"TBfYeF#acEh9
+ZC(-XGQ&eE(3*#3N*#3N*YJd*#5!J)#ecCb"28Q9c2A&eCA0d,(4bBA!*#3N*#3N
+*#3Qf$3N*)#!J,A0R)&"5CA-pG'PYC@peG#aKG(4bD@)XE'pMD`e#G@PXC&4jF'8
+J25!YE5!YFb"l4'9QBA9XG(dJ#5-J6@&VC5"K)'jPGb"cC@GYC@jd)'C[FL"PB@0
+S)'CTE'8JBRNJC'9QBA9XG#!0$5-J3@adCA*ZBA4TGQ9XH5"jEh8JBf&Z)(9cC5!
+0)b"-D@jV9(P`C5!p)#eYEf4PE#"QBA)0)b"#G@PXC&4jF'8J25!YE@pNC@`JCQ&
+b)#eN)%e24%9-AdC"8Jd0)b"AC5"eFf8JG'KP)'4PCQ&eE(3JFR9XC5"dD'&d)#j
+M,QmJCQPXCA-JC'9`C@jN)'pZ)#jM)'CTE'9c1L"cCA3JGA!JG'KPFf80)b"NDA*
+PBh4[FRNJGQ&bD@&LE'9c)(0[)'Pd)'YZEhGc)(GSCA*P)(4[)'CTEQ3JG'KPE3d
+0)RY2BQT%DA*p)L$%)#*l8h*MI5)J)RY9G'PXI5)J)RY0B@0%DA*p)L!LHe0SBA*
+PI5)J)RY8G(P%DA*p)L!LHdeKBe4dHAdL$5!J$5-J3fpYF'PXCA)JEh"dD@pZFbi
+J9f8JFf9d)(9`)(4[)'a[EfXJD@iJG'KP)%eKBb"NDA)JCQPbFh3JCQpb)'PZBfa
+eC'8JCQPXCA-0)b"cEb"hC5"MB@iJG'&VC5"[GQ9b)'KKBfXZD#"KEQ3JGA0P)'%
+JC(9YF#"QD@aP$802F(4TEfjc)$dJ,A)J#3N*#3N*#5-J9f&bEL"KBQpeG#"eEQ4
+PCQPZC@3JCR9ZBh4TEfjc)!N*YJd*#5!J)#eT)#*l6@&M4'PbI5)X)RY*EQ0XG@4
+PI5)J#5-J9fKPFQ8JG'mJE'p[Db"QEh)JD@jME(9NC5"QD@aPFb!*#EB0#3NJ)#"
+l3R9TE'48HA"PI3N*#3N*YJd*#5!J)#eYBQFJCR9XE!N*#3N*YJd*#5!J)(Y15%0
+[EQCTChd*#3N*#EB0#3NJ)#"l8d&%48p`G'P[ER0p$3e1CA4)B@0V6'PZDb!p)(Y
+-D@jV9(P`CAdJ,@-J*fjS-c%R)#ed)%&38%`J,@eQ),B0#3N*)#"l8d&%48p`G'P
+[ER0p)#!J)b!J,@eKF#!qE'PZDbjYBA!J$3e08&G8EfpX6'PZD`Np)#eLFL"[EL!
+YFh*d)#eN)#eM)#G08&-J*b!YG#"08&08)#ecEL!P369*EQPd28PZDA30$5!0)b!
+Y,5dY,5dY,5dY,5dJ9'KP)'PZBfaeC'8JCQPXCA-JC'9`C@jN)'pZ)'pZC5"KEQp
+dD'9b)#dY,5dY,5dY,5dY,5dY,3dM)&*KG'KPFL"dD'&Z)(4[G@0SD@jR)(4SC@d
+JGfKTBfJJE@&VCA-JDA3JE'p[Db"KFb"dD'peCfJJG'KPH5"SBACP)'0SB@jRC@3
+0)b"hD'9Z)(4SCANJD'&fC@iRG#"KEQ3JCf9ZCA*KG'9c)(9ZEQ9MCA0cBA*j)'*
+KBfYeF(-X)(GP)'4PCQPZC5"cH@eLEfac1Jd0E@&MBfpZCLjS)$dJ)RY*EQ0XG@4
+PI5*YB@0MEfjQ,QJJ)RY*EQ0XG@4PI5*cHA0dC@dZD!d0F'0MEfjQ,QJJ25!LHdP
+ZBfaeC'9p)R"MBfpZCLjS)#*l5@jME(9NCAdLE@PMFQmZD#!LHdPZBfaeC'9p)R0
+jFh4PE5jS$3eRE'pLB@`ZD#!p)#*l5@jME(9NCAdLCfa[BQ&X,QJJ)RY*EQ0XG@4
+PI5*MEfpbC#jS)(Y`Bf0[EQBZD(dJHfeKBf0[EQBZD(d0$@0[EQCTCbjS)$dJ)RY
+*EQ0XG@4PI5*MEfjQD@FZD#!LHdPZBfaeC'9p)R4bB@4cG'4M,QJJHfGXEf*KE#j
+SI3d0H@peF(*[F#jS)$dJ)RY*EQ0XG@4PI5*jEh9`FQp`,QJJ)RY*EQ0XG@4PI5*
+`FQp`,QJJHh"PFQe[ER0d,QKp)#*l5@jME(9NCAdLE@pZC'&dB5jS),B0#3N*)RY
+*EQ0XG@4PI5*`E5jS$3ejEh8ZD#!p)#*l5@jME(9NCAdLH@pe,QJJ)RY*EQ0XG@4
+PI5*KG(4bD@)ZD#!LHdPZBfaeC'9p)Qe[ER0d,QJJHhP[GA"bEh!ZD(d0$@4PBf`
+ZD!Np)#*l5@jME(9NCAdLC'9ME#jS#5*l5@jME(9NCAdLFh"PE'`ZD#!LHdPZBfa
+eC'9p)Q0[E'pb,QJJ)RY*EQ0XG@4PI5*[BQSZD##f$3N*)#"lH@pe,QKp)#*l5@j
+ME(9NCAdLEfjKE@9c,QJ0$@4TFh"XBANZD#!p)#*l5@jME(9NCAdLC'PcF'aKH5j
+S)#*l5@jME(9NCAdLGQPcD@pZ,QJJ)RY*EQ0XG@4PI5*YEfjNBA4K,QJ0$@9YD@i
+ZD#!p)#*l5@jME(9NCAdLC@eTELjS)#*l5@jME(9NCAdLC(9ZCf9[ELjS$3ePF(*
+T,QJJ25!LHdPZBfaeC'9p)Q9`FQNZD#!LHdPZBfaeC'9p)Q4eEQGPEfiZD!d0CA0
+SDbjS)$dJ)RY*EQ0XG@4PI5*PFfKV,QJJ)RY*EQ0XG@4PI5*NG@jRC@pZ,QJ0$3e
+`CA*YEfjcG#jS)$dJ)RY*EQ0XG@4PI5*`CA*YEfjcG#jS)!NLHdPZBfaeC'9p)Qe
+[EQ&dG'XZD#!LHdPZBfaeC'9p)Qe[EQCXB@FZD!d0GQ&eE(3ZD#!p)#*l5@jME(9
+NCAdLGQ&eE(3ZD#!LHdPZBfaeC'9p)Q4eEQGPEfiZD!d*#3N0)bdY,5dY,5dY,5d
+Y,5dY,5dY,5dJ9A0P)'%JC(9YF#"QD@aP)'C[FL"SB@0V,QJJG'mJFh"PC@3JBfp
+YF'PXCA-J,5dY,5dY,5dY,5dY,5dY,5d0)b"AC5"NEb"dD'Pc)'*j)'KKGQPZCb"
+[GA)JEhGZ)'KKBfXZD#"TEL!kFhPc1QeKBb"hD'PMD#"UGA0d)'GbB@*c)(4SC5"
+NG@e`)'CTE'80)b"QFQpY)%pLDLiJ9'KP)'4PF'9ZC'9ZBfPPFb"KFQ8JFf9d)(9
+`)(4[)'*eD@aN)(4SC5"NG@e`)'CTE'8JD@BJDA4c)'eTFh0TEQF0$A*PB@aSB@0
+V,QJJ25!LHdPZBfaeC'9p)QKKBfXZD#"lBfpZCQPR,QKp)#*l5@jME(9NCAdLC(9
+ZCf9[ELjS)(YNC@0X,QKp),B0#3N*)#*l5@jME(9NCAdLE@pZFhPY,QJJ)RY*EQ0
+XG@4PI5*YDh*[EfdZD#!LHdPZBfaeC'9p)QpLDQ0XBA0c,QJJYJd*#3NJ)RY*EQ0
+XG@4PI5*dFQ&`,QJJ)RY*EQ0XG@4PI5*QE'&R,QJJ)RY*EQ0XG@4PI5*bE5jS),B
+0#3N*)(YNDA0`E'&j,QKp)#*l5@jME(9NCAdLGfPZG(P`C5jS)#*l5@jME(9NCAd
+LC@jRFQ&fC5jS),B0#3N*)#*l5@jME(9NCAdLFQ9MG#jS)#!LHdPZBfaeC'9p)R4
+bB@e`EfaT,QJJ)RY*EQ0XG@4PI5*PH(4PFQiZD#!0$@KKBfXZD#!p)#*l6f*U4'P
+bI5*SB@0V,QKNG@e`$3dM)&4SDA-JBfpYF'PXC5"TFb"NEfjP)(0[E'9XH5"QEh)
+JG'KP)(0TC'8JC@CQC@0d)'pQ)'GPEQ9bBA4TEQFJD'&MDbjSC(9YF!dLHdpLDN4
+TFRdLD'&MDbjSC(9YF#$%)(YbC@&XD'&MDbjSI5!LHdeKBd4TFRdLE@KNG@e`,Q-
+0#8-J,@NJ)RY*EQ0XG@4PI5)JHdj)3fpZCQPRI5"l8d&%48p`G'P[ER0p),B0#5!
+J)RY0B@0%DA*p)QeSC(9YF#jM)#e[)#*l6f*U4'PbI5*YD'4eEA!ZBbj[$3d0)RY
+*EQ0XG@4PI5*XCACIBfpYF#jS)-3J)RY6D'&bCAdLE'9fAf0[EA!ZD!d*C(9`E'P
+MBA4P)#ej)#*l8fKKFQ9p)QaPGPpMEfe`,QJJ)RY*EQ0XG@4PI5*XCACIBfpYF#j
+S$3dLHdPZBfaeC'9p)Q4REPpMEfe`,QJJa#!LHe0SBA*PI5*NCfjIBfpYF#jS$3P
+NGA"XD@0KG'8J,ANJ)RY6D'&bCAdLC'GZAf0[EA!ZD#!LHdPZBfaeC'9p)Q4REPp
+MEfe`,QJ0$5-Y,5dY,5dY,5dY,5dY,5dY,5dY)%jPG%KKBfXJEf*UC@0dFb!Y,5d
+Y,5dY,5dY,5dY,5dY,3d03dpLDR-J25!LHdpLDN4TFRdLB@aXE@&TELjM,QmJYJd
+J)#!J)#!J)#*l6f*U4'PbI5*KE'a[BbjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*
+KF("XH5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*KFR4TCQ&MG#jM,QmJYJdJ)#!
+J)#!J)#*l6f*U4'PbI5*KG(4bD@)ZBbj[),B0#3NLHdpLDN4TFRdLBQ&XE#jM,Qm
+JYJdJ)#!J)#!J)#*l6f*U4'PbI5*LEfjPFbjM,QmJYJdJ)#!J)#!J)#*l6f*U4'P
+bI5*LEh4X,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)Q0YC#jM,QmJYJdJ)#!J)#!
+J)#*l6f*U4'PbI5*NBR*TC'GP,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)Q4PBf`
+ZBbj[),B0#3NLHdpLDN4TFRdLC'9dC@0d,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*
+p)Q4TFh"XBANZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLC'mZBbj[),B0)#!J)#!
+J)#!LHdpLDN4TFRdLC'pIEQ&YC5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*NEep
+hC@&b,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)Q4[CbjM,QmJYJdJ)#!J)#!J)#*
+l6f*U4'PbI5*NEfGYEhCP,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)Q4[DfPMDbj
+M,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*NEh4SFQph,Q-ZEb#f$3N*)RY2BQT%DA*
+p)Q4bBAGTEQFZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLC(9ZCf9[ELjM,QmJYJd
+J)#!J)#!J)#*l6f*U4'PbI5*PBA3ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLC@j
+N,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)Q9ZCh*KGQ8ZBbj[),B0)#!J)#!J)#!
+LHdpLDN4TFRdLCAK`CA)ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLCAK`E'pNC5j
+M,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*PH(4bB@aPGLjM,QmJYJdJ)#!J)#!J)#*
+l6f*U4'PbI5*QD@aPFbjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*QEh9ZG'&TELj
+M,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*SB@0V,Q-ZEb#f$5!J)#!J)#!J)RY2BQT
+%DA*p)QKKBfYXD@)ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLD@jfC@jd,Q-ZEb#
+f$5!J)#!J)#!J)RY2BQT%DA*p)Qa[BfXZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRd
+LE@&MBh9bFbjM,QmJYJd*#5*l6f*U4'PbI5*YB@0PFR*c,Q-ZEb#f$5!J)#!J)#!
+J)RY2BQT%DA*p)QeKBfCTE'8ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLE@&ME@&
+TELjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*YB@0YC@je,Q-ZEb#f$3N*)RY2BQT
+%DA*p)QeKBh0ZC#jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*YB@0eEQPi,Q-ZEb#
+f$5!J)#!J)#!J)RY2BQT%DA*p)QeKBhGTELjM,QmJYJdJ)#!J)#!J)#*l6f*U4'P
+bI5*YB@YPE@pZ,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)QeMBA0dG5jM,QmJYJd
+J)#!J)#!J)#*l6f*U4'PbI5*YCf9dE'PZC5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'P
+bI5*YD'PdE5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*YD'PdG5jM,QmJYJdJ)#!
+J)#!J)#*l6f*U4'PbI5*YD@jTEfiZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLE@Y
+XCABZBbj[),B0#3NLHdpLDN4TFRdLE@YYBA!ZBbj[),B0)#!J)#!J)#!LHdpLDN4
+TFRdLE@YYBATP,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)QeVEf*U,Q-ZEb#f$5!
+J)#!J)#!J)RY2BQT%DA*p)QeVFQp[E5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*
+YE@pNB@`ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLE@pZ,Q-ZEb#f$5!J)#!J)#!
+J)RY2BQT%DA*p)Qe[EQ4KG'%ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLE@pZE@p
+fC5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*YEfjcG#jM,QmJYJd*#5*l6f*U4'P
+bI5*YEfjcG()ZBbj[),B0#3NLHdpLDN4TFRdLEA"XBAPPFLjM,QmJYJd*#5*l6f*
+U4'PbI5*YFh4bD@jR,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)QedD(*[Gh8ZBbj
+[),B0)#!J)#!J)#!LHdpLDN4TFRdLEA9cC5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'P
+bI5*YGA0TBbjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*[AfPZDA3ZBbj[),B0)#!
+J)#!J)#!LHdpLDN4TFRdLEf*UC@0dFbjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*
+[BQTZB@dZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLEh"dD@pZFbjM,QmJYJdJ)#!
+J)#!J)#*l6f*U4'PbI5*`B@GPFLjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*`D@0
+VGA!ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLF'aTEQ8ZBbj[),B0)#!J)#!J)#!
+LHdpLDN4TFRdLF'pXHA0PE'BZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLF'pdD@p
+Z,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)R"bBANZBbj[),B0)#!J)#!J)#!LHdp
+LDN4TFRdLF(*TCA0d,Q-ZEb#f$3N*)RY2BQT%DA*p)R&eCA0d,Q-ZEb#f$3N*)RY
+2BQT%DA*p)R&eCA0dF'Gb,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)R*KEQ4[E5j
+M,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*bC@&N,Q-ZEb#f$5!J)#!J)#!J)RY2BQT
+%DA*p)R*PBh3ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLFQ9cG'pbC5jM,QmJYJd
+J)#!J)#!J)#*l6f*U4'PbI5*bDA!ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLFQj
+N,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)R*eE@pbFbjM,QmJYJdJ)#!J)#!J)#*
+l6f*U4'PbI5*cBACP,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)R0SDbjM,QmJYJd
+J)#!J)#!J)#*l6f*U4'PbI5*cD'YZB@dZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRd
+LFfPd,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)R0[G@jNFbjM,QmJYJdJ)#!J)#!
+J)#*l6f*U4'PbI5*cF&pXCABZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLFh"PE'`
+ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLFh4PB@`ZBbj[),B0)#!J)#!J)#!LHdp
+LDN4TFRdLG'PYC@peG#jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*YB@0dEh"X,Q-
+ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)R4[F(4PELjM,QmJYJdJ)#!J)#!J)#*l6f*
+U4'PbI5*dFQ&MDbjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*dFQ&`,Q-ZEb#f$5!
+J)#!J)#!J)RY2BQT%DA*p)R9ID@jTG#jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*
+eD'PdE5jM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*fBA9XG#jM,QmJYJdJ)#!J)#!
+J)#*l6f*U4'PbI5*fCA*cD@pZ,Q-ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)RCTFfP
+[ELjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*fDA0IG'&L,Q-ZEb#f$5!J)#!J)#!
+J)RY2BQT%DA*p)RGPBA"[ELjM,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*hCA*P,Q-
+ZEb#f$5!J)#!J)#!J)RY2BQT%DA*p)RGTC@aN,Q-ZEb#f$3N*)RY2BQT%DA*p)RG
+TEQ4[Gh-ZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLGfPkBA*N,Q-ZEb#f$5!J)#!
+J)#!J)RY2BQT%DA*p)RG[FQdZBbj[),B0)#!J)#!J)#!LHdpLDN4TFRdLGfpbELj
+M,QmJYJdJ)#!J)#!J)#*l6f*U4'PbI5*hFQPdC5jM,QmJYJdJ)#!J)#!J)#*l6f*
+U4'PbI5*kBA!ZBbj[),B0#3Qf$3N*)RY2BQT%DA*p)QGPG'aTEQ8ZBbj[),B0#3N
+LHdpLDN4TFRdLG'p`E#jM,QmJYJd*#5*l6f*U4'PbI5*hD@jdG(NZBbj[),B0#3Q
+f$3N*)RY2BQT%DA*p)QeKBh4dH5jM,QmJYJd*#5*l6f*U4'PbI5*YG(4jE@&TELj
+M,QmJYJd*#EB0#3NLHd0-D@*bBA*TCA0p)P0dC%0XD@)ZEb#f$3N*)RY-D@*bBA*
+TCA0p)P*eER4TE@8ZEb#f$3N*)RY-D@*bBA*TCA0p)NPZG'9bCQ&MC5j[),B0#3Q
+f$3N*)RY2BQT%DA*p)Q4`FQPZG'BZBbj[$3dM,5dY,5dY,5dY,5dY,5"8D'8JEf*
+UC@0d)'CTE'9c)'4PF'9ZC#"eF'pZ)(4SC5"TEQ0XG@4P)'CTE'9c)'&c)'C[E'a
+[Gh-J,5dY,5d0$5*l6f*U4'PbI5*KE'aYB@PZ,Q-ZE`R%)#"lD'&MDbjSI3dLHdp
+LDN4TFRdLB@aXEf-ZBbj[)#!*a#!JHf0[EQCTCbjSI3dLHdpLDN4TFRdLBA"`E(N
+ZBbj[#3R%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)Q9NEfFZD!dLHdpLDN4TFRdLBA*
+dD@CKBh3ZBbj[#F3J)(YSB@0V,QKp)#*l5@jME(9NCAdLBA*dD@CKBh3ZD#!LHdP
+ZBfaeC'9p)Q&bG'PXDA0d,QJ0)RY2BQT%DA*p)Q&dG(*TBLjM,Qm*a#!JHfKKBfX
+ZD(dJ)RY*EQ0XG@4PI5*KFR4TCQ&MG#jS$5*l6f*U4'PbI5*LB@aX,Q-ZE`N*a#!
+JHfKKBfXZD(d0)RY2BQT%DA*p)Q*[EQ9c,Q-ZE`N*a#!JHfKKBfXZD(dJ)RY*EQ0
+XG@4PI5*XCABZD!dLHdpLDN4TFRdLBQpdE#jM,Qm*#F3J)(YSB@0V,QKp$5*l6f*
+U4'PbI5*ME@3ZBbj[#3R%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)QCeEQ0IG'&L,QJ
+0)RY2BQT%DA*p)Q4LFQPNCf8ZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*NC@0
+X,Q-ZE`N*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*aG@9cG#jS$5*l6f*U4'PbI5*
+NCA4PBh3ZBbj[#F3J)(YSB@0V,QKp)#*l5@jME(9NCAdLBA*dD@CKBh3ZD!dLHdp
+LDN4TFRdLC'PcF'aKH5jM,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)Q4[,Q-ZE`N
+*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*XCABZD!dLHdpLDN4TFRdLC'pIEQ&YC5j
+M,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)Q4[AhGPBA)ZBbj[#F3J)(YSB@0V,QK
+p$5*l6f*U4'PbI5*NEfFZBbj[#3R%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)Q9NEfF
+ZD!dLHdpLDN4TFRdLC'pRE@pfC5jM,Qm*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*
+YCQjNF'pc,QJJ)RY*EQ0XG@4PI5*PC'pR,QJ0)RY2BQT%DA*p)Q4[DfPMDbjM,Qm
+*a#!JHfKKBfXZD(dJHf9cD'XZD(d0)RY2BQT%DA*p)Q4[G'KbEhFZBbj[#F3J)(Y
+SB@0V,QKp$5*l6f*U4'PbI5*NFQ&hD@jR,Q-ZE`R%)#"lD'&MDbjSI5!LHdPZBfa
+eC'9p)R4PFQeMBA!ZD!dLHdpLDN4TFRdLC(9ZCf9[ELjM,Qm*a#!JHfKKBfXZD(d
+J)RY*EQ0XG@4PI5*NCfjICQPXC5jS$5*l6f*U4'PbI5*PBA3ZBbj[#3R%)#"lD'&
+MDbjSI3dLHdpLDN4TFRdLC@jN,Q-ZE`N*a#!JHfKKBfXZD(dJHf9cD'XZD(d0)RY
+2BQT%DA*p)Q9ZCh*KGQ8ZBbj[#F3J)(YSB@0V,QKp)#*l5@jME(9NCAdLE'9f,QJ
+0)RY2BQT%DA*p)Q9iF'9b,Q-ZE`N*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)Q9iF'a
+[C'8ZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*PH(4bB@aPGLjM,Qm*a#!JHfK
+KBfXZD(d0)RY2BQT%DA*p)QCTE'9c,Q-ZE`N*a#!JHfKKBfXZD(d0)RY2BQT%DA*
+p)QC[G@jdB@PZ,Q-ZE`R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLD'&MDbjM,Qm*#F3
+J)(YSB@0V,QKp$5*l6f*U4'PbI5*SB@0VE'PL,Q-ZE`R%)#"lBfpZCQPR,QKp$5*
+l6f*U4'PbI5*TERCPER3ZBbj[#F3J)(YSB@0V,QKp)#*l5@jME(9NCAdLBA*dD@C
+KBh3ZD!dLHdpLDN4TFRdLE'pMDbjM,Qm*#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*
+YB@0YB@PZ,Q-ZE`R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLE@&ME@9ZG5jM,Qm*a#!
+JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*`BA4MD'aPGQ9X,QJ0)RY2BQT%DA*p)QeYEf4
+KE#jM,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)QeKBh0ZC#jM,Qm*a#!JHfKKBfX
+ZD(d0)RY2BQT%DA*p)QeKBhGTELjM,Qm*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*
+YB@0dG(NZD#!LHdPZBfaeC'9p)RGTER4dH5jS)#*l5@jME(9NCAdLCR9ZBepdB@)
+ZD!dLHdpLDN4TFRdLE@&MBh9bFbjM,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)Qe
+KBfCTE'8ZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*YB@0PFR*c,Q-ZE`R%)#"
+lD'&MDbjSI3dLHdpLDN4TFRdLE@&MG'p`E#jM,Qm*a#!JHfKKBfXZD(d0)RY2BQT
+%DA*p)QeKBh9ZDAJZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*YB@PX,Q-ZE`N
+*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)QeKDf9YEfiZBbj[#F3J)(YSB@0V,QKp)(Y
+PF(*T,QKp)(YPE@PZ,QKp$5*l6f*U4'PbI5*YBf&cG(8ZBbj[#F3J)(YSB@0V,QK
+p$5*l6f*U4'PbI5*YCf9dE'PZC5jM,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)Qe
+SDA4Y,Q-ZE`N*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*KFR4TCQ&MG#jS)#*l5@j
+ME(9NCAdLC@4[CbjS$5*l6f*U4'PbI5*YD'PdG5jM,Qm*#F3J)(YSB@0V,QKp)#*
+l5@jME(9NCAdLBA*dD@CKBh3ZD#!LHdPZBfaeC'9p)Q9NEfFZD!dLHdpLDN4TFRd
+LE@PZD@pZ,Q-ZE`R%)#"lD'&MDbjSI5"lC@eTELjSI5"lCA"bD5jSI3dLHdpLDN4
+TFRdLE@YXCABZBbj[#3R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLE@YYBA!ZBbj[#3R
+%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)R0`AfaPGLjS$5*l6f*U4'PbI5*YDfeKHQ8
+ZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*YDfpLDLjM,Qm*#F3J)(YSB@0V,QK
+p)#*l5@jME(9NCAdLBA*dD@CKBh3ZD#!LHdPZBfaeC'9p)R"bEh!ZD!dLHdpLDN4
+TFRdLE@YbEfpY,Q-ZE`R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLE@pZ,Q-ZE`N*a#!
+JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*YCQjNF'pc,QJJ)RY*EQ0XG@4PI5*PC'pR,QJ
+0)RY2BQT%DA*p)Qe[EQ4KG'%ZBbj[#F3J)(YSB@0V,QKp)(YPFfKV,QKp)(YPF(*
+T,QKp$5*l6f*U4'PbI5*YEfjYEhCP,Q-ZE`R%)#"lD'&MDbjSI5!LHdPZBfaeC'9
+p)QeQEQ4`Eh-ZD#!LHdPZBfaeC'9p)Q&bG'PQB@0d,QJ0)RY2BQT%DA*p)Qe[ER0
+d,Q-ZE`N*a#!JHf0[EQCTCbjSI5"lF'9bE@pZFh3ZD(dJ)RY*EQ0XG@4PI5*YEfj
+cH@dZD##f$3N*#3N*#5!J)(YPFfKV,QKp)(YfBA9XG#jSI5"lCA"bD5jSIEB0#3N
+*#3N*)#!J)RY*EQ0XG@4PI5*MEfa[FLjS$5*l6f*U4'PbI5*YF'aKH@9b,Q-ZE`R
+%)#"lD'&MDbjSI3dLHdpLDN4TFRdLEA4SFQphG5jM,Qm*a#!JHfKKBfXZD(d0)RY
+2BQT%DA*p)QeeFf8ZBbj[#3R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLEA9cD@-ZBbj
+[#3R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLEepTEQPd,Q-ZE`R%)#"lD'&MDbjSI3d
+LHdpLDN4TFRdLEf*UC@0dFbjM,Qm*a#!JHf0[EQCTCbjSI5!LHdPZBfaeC'9p)Qp
+LDLjS)#*l5@jME(9NCAdLEf*UBfaKFh-ZD,B0#3N*#3N*)#!J)RY*EQ0XG@4PI5*
+`FQp`,QJJ)RY*EQ0XG@4PI5*MEfa[FLjS$5*l6f*U4'PbI5*[BQTZB@dZBbj[#F3
+J)(YSB@0V,QKp$5*l6f*U4'PbI5*[F(4TEfjc,Q-ZE`R%)#"lD'&MDbjSI5!LHdP
+ZBfaeC'9p)R4PFQeMBA!ZD!dLHdpLDN4TFRdLF'&RCA)ZBbj[#3R%)#"lE@&MBfp
+ZCLjSI3dLHdpLDN4TFRdLF'&ZD@-ZBbj[#3R%)#"lBfpZCQPR,QKp$5*l6f*U4'P
+bI5*`D@0VGA!ZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*`E'PZC5jM,Qm*#F3
+J)(YSB@0V,QKp)(YPF(*T,QKp$5*l6f*U4'PbI5*`EfajFf9XCLjM,Qm*a#!JHfK
+KBfXZD(d0)RY2BQT%DA*p)R"[G'P[ELjM,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*
+p)R"bBANZBbj[#3R%)#"lD'&MDbjSI5"lCA"bD5jSI3dLHdpLDN4TFRdLF(*TCA0
+d,Q-ZE`R%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)QeQEQ4`Eh-ZD#"lCA0SDbjSIEB
+0#3N*#3N*)#!JHf9`FQNZD(dJHf9YD@iZD(d0)RY2BQT%DA*p)R&eCA0d,Q-ZE`N
+*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*aG@9cG#jS)#*l5@jME(9NCAdLFA4PH(3
+ZD!dLHdpLDN4TFRdLFA9PFh4`Ch)ZBbj[#F3J)(YSB@0V,QKp)#*l5@jME(9NCAd
+LFA4PH(3ZD!dLHdpLDN4TFRdLFQ9KC#jM,Qm*#F3J)(YSB@0V,QKp$5*l6f*U4'P
+bI5*bC@0d,Q-ZE`N*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)R*PFh4[FQ8ZBbj[#F3
+J)(YSB@0V,QKp)#*l5@jME(9NCAdLE'9f,QJJ)RY*EQ0XG@4PI5*dCA*YBf&`,QJ
+J)RY*EQ0XG@4PI5*aG@9cG#jS$5*l6f*U4'PbI5*bDA!ZBbj[#3R%)#"lD'&MDbj
+SI3dLHdpLDN4TFRdLFQjN,Q-ZE`N*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)R*eE@p
+bFbjM,Qm*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)R0KGQ8ZBbj[#3R%)#"lD'&MDbj
+SI5!LHdPZBfaeC'9p)QaPGLjS)#*l5@jME(9NCAdLFA9PFh3ZD!dLHdpLDN4TFRd
+LFfKV,Q-ZE`N*a#!JHfKKBfXZD(dJHf9cD'XZD(d0)RY2BQT%DA*p)R0SDfjKE5j
+M,Qm*a#!JHfKKBfXZD(dJHf9cD'XZD(d0)RY2BQT%DA*p)R0TG#jM,Qm*#F3J)(Y
+SB@0V,QKp)#*l5@jME(9NCAdLBA*dD@CKBh3ZD!dLHdpLDN4TFRdLFfpeEQ4c,Q-
+ZE`R%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)Q9NEfFZD!dLHdpLDN4TFRdLFh"IE'9
+f,Q-ZE`R%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)R0`AfaPGLjS)#*l5@jME(9NCAd
+LFQ9MG#jS$5*l6f*U4'PbI5*cF'9XE#jM,Qm*#F3J)(YSB@0V,QKp$5*l6f*U4'P
+bI5*cG'9KE#jM,Qm*#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*dD@ePEh9d,Q-ZE`R
+%)#"lD'&MDbjSI3dLHdpLDN4TFRdLG'p`G'9Z,Q-ZE`R%)#"lD'&MDbjSI3dLHdp
+LDN4TFRdLG(*KBfXZBbj[#3R%)#"lD'&MDbjSI3dLHdpLDN4TFRdLG(*KF#jM,Qm
+*#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*eAfPZDA3ZBbj[#F3J)(YSB@0V,QKp$5*
+l6f*U4'PbI5*eD'PdE5jM,Qm*#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*fBA9XG#j
+M,Qm*#F3J)(YSB@0V,QKp)(YfBA9XG#jSI3dLHdpLDN4TFRdLGQ9bFfP[ELjM,Qm
+*a#!JHfKKBfXZD(dJ)RY*EQ0XG@4PI5*NBA4P,QJJ)#*l5@jME(9NCAdLF'&dBfK
+XCACPE#jS)#*l5@jME(9NCAdLG'9bE@0KF#jS$5*l6f*U4'PbI5*fDA0TEfiZBbj
+[#F3J)(YSB@0V,QKp)#*l5@jME(9NCAdLGQPcAh4KBLjS$5*l6f*U4'PbI5*hC@&
+`EfiZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*hCA*P,Q-ZE`N*a#!JHfKKBfX
+ZD(d0)RY2BQT%DA*p)RGTC@aN,Q-ZE`N*a#!JHfKKBfXZD(d0)RY2BQT%DA*p)RG
+TEQ4[Gh-ZBbj[#F3J)(YSB@0V,QKp$5*l6f*U4'PbI5*hDATKFQ3ZBbj[#F3J)(Y
+SB@0V,QKp)#*l5@jME(9NCAdLFA4PH(3ZD!dLHdpLDN4TFRdLGfpbE5jM,Qm*#F3
+J)(YSB@0V,QKp)#*l5@jME(9NCAdLE'9f,QJ0)RY2BQT%DA*p)RG[FQiZBbj[#3R
+%)#"lD'&MDbjSI3dLHdpLDN4TFRdLGh*TG'8ZBbj[#3R%)#"lD'&MDbjSI3dLHdp
+LDN4TFRdLHQ&`,Q-ZE`N*a#!JHfKKBfXZD(d0$5*l6f*U4'PbI5*RCA4XD@jP,Q-
+ZE`R%#AYSB@0V,QKp)#*l5@jME(9NCAdLGfPZG(4j,QJJ)RY*EQ0XG@4PI5*QG@j
+MAh4KBLjS$5*l6f*U4'PbI5*dEh"X,Q-ZE`N*a!PlD'&MDbjSI5!LHdPZBfaeC'9
+p)RGTER4dH5jS)#*l5@jME(9NCAdLG'9bE@0KF#jS$5*l6f*U4'PbI5*hD@jdG(N
+ZBbj[)!R%#AYSB@0V,QKp)#*l5@jME(9NCAdLGfPZG(4j,QJJ)RY*EQ0XG@4PI5*
+dCA*YBf&`,QJ0$5*l6f*U4'PbI5*YB@0dG(NZBbj[#F3*HfKKBfXZD(dJ)RY*EQ0
+XG@4PI5*YB@0dG(NZD#!LHdPZBfaeC'9p)QedG(P`FQPf,QJ0)RY2BQT%DA*p)Qe
+dG(PYB@PZ,Q-ZEb!*a!PlD'&MDbjSI5!LHdPZBfaeC'9p)QeKBh4dH5jS$3dLHdp
+LDN4TFRdL6@&VC84PCR-ZBbj[)#$%)#"lBfpZCQPR,QKp)(Y`CA*YEfjcG#jSI5!
+LHdPZBfaeC'9p)QpLDQ0XBA0c,QJJYJd*#3N*#3NJ)#!LHdPZBfaeC'9p)Qe[ER0
+jE5jS)#*l5@jME(9NCAdLBA*dD@aTFh3ZD##f$3N*#3N*#5!J)#*l5@jME(9NCAd
+LF'&dBfKXCACPE#jS)#*l5@jME(9NCAdLFA4PH(3ZD!d0)RY2BQT%DA*p)Q4REPp
+jB@0M,Q-ZE`R%)#"lBfpZCQPR,QKp)#*l5@jME(9NCAdLC'GZAfCTE'8ZD!dLHdp
+LDN4TFRdLC'GZAfaPH#jM,Qm*a#!JHf0[EQCTCbjSI5!LHdPZBfaeC'9p)Q4REPp
+MEfe`,QJJ)RY*EQ0XG@4PI5*NCfjICQPXC5jS$5*l6f*U4'PbI5*NCfjIE@&TELj
+M,Qm*a#!JHf0[EQCTCbjSI3d0)RY2BQT%DA*p)QaPGPpjB@0M,Q-ZE`R%)#"lD'&
+MDbjSI5!LHdPZBfaeC'9p)R0`AfaPGLjS$5*l6f*U4'PbI5*XCACIE'9i,Q-ZE`R
+%)#"lD'&MDbjSI5!LHdPZBfaeC'9p)QaPGPpMEfe`,QJJ)RY*EQ0XG@4PI5*cF&p
+XCABZD!dLHdpLDN4TFRdLE'9fAfeKD@iZBbj[#F3J)(YSB@0V,QKp)#*l5@jME(9
+NCAdLFh"IE'9f,QJ0$5*l6f*U4'PbI5*NF(*TER4Q,Q-ZE`R%#AYSB@0V,QKp$3d
+M)#dY,5dY,5dY)%*eD@aN)(4SC5"NG@jRC@pZ)'0[EA"TE'9b,#"KFb"KEL"08&F
+JG'p[E#!Y,5dY,5dY,5dY,5dY,5d0#3e%Cfj2BQTc25!LHdpLDN4TFRdLC'GZAfa
+PH#jM,Qm*#EB0#3NJ)RY2BQT%DA*p)Q4REPpYB@PZ,Q-ZE`N*YJd*#5!LHdpLDN4
+TFRdLC'GZAhPKBf-ZBbj[#3Qf$3N*)#*l6f*U4'PbI5*KE'a[BbjM,Qm*#EB0#3N
+J)RY2BQT%DA*p)R"KEQPM,Q-ZE`N*YJd*#5!LHdaTBR*KFQPPFhdL8h4eBR-ZE`N
+*YJd*#5!LHdaTBR*KFQPPFhdL8R9ZG'PYC5j[)!Qf$3N*)#*l6'PLFQ&bD@9cI5*
+8EfpX6'PLFbj[#EB0#3NJ)RY-D@*bBA*TCA0p)NPZG'9bCQ&MC5j[#EB0#3NJ)RY
+$6'PLFQ&bD@9cI5*6G'4$6'PL,Qm0$84REN0[EA!*a#"l4'GZ6f*UFhd0#8aTEQX
+JHde39e4[Efa-D@jVI5!JYJd*#5"l4'GZ6f*UFhdJ,@mJHe4KFQGp),B0)`N*)#!
+YFfFJ6@&TEMeKE'a[BbaNCfjIE'9i,'4REPpYB@PZ,'4REPpjB@0M,("KEQPM,&0
+84%P2,%P19%919La6384&9L#f$3N*$5-J,5dY,5dY,5dJ3R9TE'3JG'KP)(0`C@0
+TB@`YE'9fC@`JBfpYF'PXCA)X)'&c)'&Z)%e39b"dEfpX)#dY,5dY,5dY,5dY,5d
+Y,3d*$8aPGNpLDR-p)#*l6f*U4'PbI5*YEfjcG#jM,Qm*#EB0#3NJ)RY2BQT%DA*
+p)QpLDQ9MG(-ZBbj[#3Qf$3N*)#*l6f*U4'PbI5*NFQ&hD@jR,Q-ZE`N*YJd*#5!
+LHdpLDN4TFRdLB@aXEf-ZBbj[#3Qf$3N*)#*l6f*U4'PbI5*`B@jTBbjM,Qm*#EB
+0#3NJ)RY2BQT%DA*p)QaPGPpXCAJZBbj[#3Qf$3N*)#*l6f*U4'PbI5*XCACIH@&
+MBbjM,Qm*#EB0#3NJ)RY2BQT%DA*p)QeKBfCTE'8ZBbj[#3Qf$3N*)#*l6f*U4'P
+bI5*YB@0PFR*c,Q-ZE`N*YJd*#5!LHdpLDN4TFRdLCQPXCA-ZBbj[#3Qf$3N*)#*
+l6f*U4'PbI5*NC@0X,Q-ZE`N*#EB0#3NJ)RY-D@*bBA*TCA0p)P0dG@*c,Qm*#EB
+0#3NJ)RY2BQT%DA*p)QaPGPpYB@PZ,Q-ZE`N*YJd*#5!LHd0-D@*bBA*TCA0p)P0
+dC%0-D@)ZE`Qf$3N*)#!LHdaTBR*KFQPPFhdL9'p[E%aTBR-ZE`Qf$3N*)#*l6'P
+LFQ&bD@9cI5*5G@jdD@eP,QmJ#EB0#3NJ)RY-D@*bBA*TCA0p)NPZG'9bCQ&MC5j
+[)#!0$8aPGN0[EA!*a#"l6'9f6f*UFhd0#8aTEQXJHde39e4[Efa-D@jVI5#f$3N
+*)(Y-CAC2BQTcI5!YEb"l9'&bChdJYJdM#3NJ,A0R)%eKD@ipEf*UC@0dFbaYEfj
+cG#aYB@0QD@aP,'CTE'9c,'eKBf9bFR-XE'9fAfaPH#aXCACIE@&TELaXCACIH@&
+MBb#f$3N*$5-J,5dY,5dY,5dJ3R9TE'3J6@&VC84PCR-X)'&c)'&Z)%e39b"dEfp
+X)#dY,5dY,5dY,5dY,5dY,3d06@&VC84PCR02BQTc25!LHdpLDN4TFRdLEf*UC@0
+dFbjM,Qm*#EB0#3N*)#!LHdpLDN4TFRdLE@pZFh3ZBbj[#3Qf$3N*#5!J)RY2BQT
+%DA*p)NeKDf9%C@Cc,Q-ZE`Qf$3N*#5!J)RY-D@*bBA*TCA0p)P0dG@*c,Qm*#EB
+0)#!J)!N*)#!LHdaTBR*KFQPPFhdL8R9ZG'PYC5j[)!Qf$3N*#5!J)RY-D@*bBA*
+TCA0p)NPZG'9bCQ&MC5j[#EB0#3N*)#!LHdaTBR*KFQPPFhdL9'p[E%aTBR-ZE`Q
+f$3N*#5!J)RY$6'PLFQ&bD@9cI5*6G'4$6'PL,Qm0$8eKDf9%C@Cc#F6%)(Y0B@Y
+P4'9QFdpLDR0p$3P-D@jV)(Y08&G8EfpX6'PZDhdJYJd*#5"l6@&VC84PCR02BQT
+cI5!YEb"l9'&bChd0#3d*#3dM)#dY,5dY,5dY,5dY,5"*CL"0B@YP4'9QFb"MD'&
+ZCf9c)(GP)'jPC@3JG'mJFQ9LG@PXC#"cEfeP)'PZBfaeC'8JCQPXCA-J,5dY,5d
+Y,5dY,5d0$5*l5@jME(9NCAdLC'&dC5jS)!R%)!P0B@YP4'9QF`d*6@&VC84PCR-
+J,AB0#8e[GQ8J,ANJ)RY%BA4p)Np`G'P[ER-J)RY2BQT%DA*p)Jd0)RY2BQT%DA*
+p)Np`G'P[ER-*a!NLHdPZBfaeC'9p)Q4KG'8ZD!d0)RY*EQ0XG@4PI5*[EQ&YCA-
+ZD#$%#8eKDf9%C@Cc$3P0B@YP4'9QFb!YE`d0)RY*EQ0XG@4PI5*`E5jS)!R%#8e
+KDf9%C@Cc$3P0B@YP4'9QFb!YF!d0)RY6FQ0p)RCTFepdB@)ZB`R%#8eKDf9%C@C
+c)#*l5@jME(9NCAdLGQPcAh4KBLjS$3dLHdPZBfaeC'9p)RCTFepdB@)ZD#$%#8e
+KDf9%C@Cc$3P0B@YP4'9QFb!YHJd*$5*l6f*U4'PbI5*%G@jRC@pZ,R"NCL!Ja#!
+LHd4KG(dL4(9ZCf9[ELjNC@BJ6@&VC84PCR-0#8eKDf9%C@Cc)#eP$3P0EhCP)#e
+j)#*l4'&dI5*%G@jRC@pZ,R"NCL!LHdpLDN4TFRdL$3N0)RY6FQ0p)Qe[ER0dFLj
+M)-3J6@&VC@4PCR-JHf0[EQCTCbjSI3d*6@&VC84PCR-J,@d0$5-Y,5dY,5dY,5d
+Y,5dY,5dY)%eKD@iJC'9`C@jNC@jMD@9c)'&ZC#"dD'8JBA"`E'PMBA4TEfiX)'&
+d)'aKFh3J,5dY,5dY,5dY,5dY,5dY,5dY,3d0)RY5CA0eE(4cI5*%BA4K)#$%)#*
+l4'&dI5*%BA4K,Q*KFf8J6@&VC84PCR-0#3P0B@YP4'9QFb!YC!d*#8e[GQ8J,AN
+J)RY%BA4p)N4KG'%J)RY5CA0eE(4cI5)0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9
+p)L!YBb!LHdCTE'9$FQ9KG'pbI5)J)RY5CA0eE(4cI5*%BA4K$3dLHe*PFh9XG(0
+p)P*eE@pbFb!Ja#!LHd4KG(dL8R9YEh*c,R4bG5!LHd4KG(dL8R9YEh*c,QCKE#"
+0B@YP4'9QF`d*#8eKDf9%C@Cc)#eb$3N*6@pfC5!YH5!LHd4KG(dL8R9YEh*c)#*
+l8Q9cG@adFhdL$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*
+PBA4[FRdL)#*l8Q9cG@adFhdL8R9YEh*c$3dLHe*PFh9XG(0p)NpbB@0XCA-Ja#!
+LHd4KG(dL6h*KBfaPFbjdH(3J6@&VC84PCR-0#3P0B@YP4'9QFb!YD!d*#8e[GQ8
+J,ANJ)RY%BA4p)NpbB@0XCA-J)RY5CA0eE(4cI5)0#3P6CA4'D@aP)#ed)#*l4QP
+XC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'pbI5)J)RY5CA0eE(4cI5*2FQ&ME'9c$3d
+LHe*PFh9XG(0p)N0YC'KPE(!Ja#!LHd4KG(dL3feND'9XF!d*#@4eF'aTBf&dC5!
+YH5!LHd4KG(dL3feND'9XF#!LHe*PFh9XG(0p)Jd*#90PG%CTE'8J,A3J)RY'D@a
+P9(P`CAdL)#eM)#*l4QPXC80bC@&dEh*p)L!LHe*PFh9XG(0p)N0YC'KPE(!0$5*
+l8Q9cG@adFhdL8Q9MEh*N)#$%)!d*#8p`C@iJ,@iJ,A3J)RY5CA0eE(4cI5*5C@0
+[FQ30#3P5CA"XB@0P)#qP,b!L9'KTFb"TFb"dD'8JFQ9MEh*N)'CTE'8L$3N*3fa
+[Ff8J,ANJ)RY5CA0eE(4cI5*5C@0[FQ30$5*l8Q9cG@adFhdL6Q9d5'&MDlBJ4'9
+QBA9XG(-J)-3J$3N*C(9`E'PMBA4P)#ej)#*l6@&M4'PbI5*15%4PCQadFb!LHe*
+PFh9XG(0p)NjPG%KKBfZf)%4PCQ&eE(4c$3dLHe*PFh9XG(0p)N4eEQGPEfiJ)-3
+J)RY2BQT%DA*p)N4eEQGPEfiZF'4Q)%4REN0[EA!0#3P%Cfj$Efe`)#*l6f*U4'P
+bI5*NG@jRC@pZ,R"NCJd*#8e[GQ8J,ANJ)RY2BQT%DA*p)N4eEQGPEfiJ)RY5CA0
+eE(4cI5)0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'p
+bI5)J)RY5CA0eE(4cI5*%G@jRC@pZ$3dLHe*PFh9XG(0p)N*TCe*[EfdZE'9f)#$
+%)#*l4'&dI5*#D@G5EfpY,Q4PFb"-CAC$Efe`$3N*6'9f3fpYF#!LHd4KG(dL3QP
+R8Qp[E5jNCA-0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9
+KG'pbI5)Ja5jXCAB0#3P0EhCP)#ej)%*TCe*[EfdZE'9f)#*l8Q9cG@adFhdL$3d
+LHe*PFh9XG(0p)N0KFh4XC5jXCABJ)-3J)RY%BA4p)N0KFh4XC5jNCA-J6'9f3fp
+YF!d*#8aPGN0[EA!J)RY%BA4p)N0KFh4XC5jNCA-0#3P6CA4'D@aP)#ed)#*l4QP
+XC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'pbI5)Ja5jXCAB0#3P0EhCP)#ej)%0KFh4
+XC5jXCABJ)RY5CA0eE(4cI5)0$5*l8Q9cG@adFhdLB@Pb,QaPGJN*a#!LHf4KG(d
+LC@jNCf&YC5jNCA-JE'9fBfpYF!d*6'9f3fpYF#!LHf4KG(dLC@jNCf&YC5jNCA-
+0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'pbI5)Ja5j
+XCAB0#8e[GQ8J,ANJB@Pb,QaPGL!LHh*PFh9XG(0p)Jd*6@pfC5!YH5"KFh4bB@`
+ZE'9f)#*l8Q9cG@adFhdL$3P0EhCP)#ej)'9KFR4S,QaPGL!LHe*PFh9XG(0p)Jd
+*6@pfC5!YH5"QDA*P,QaPGL!LHe*PFh9XG(0p)Jd*6@pfC5!YH5"hBA4PFLjXCAB
+J)RY5CA0eE(4cI5)0$5*l8Q9cG@adFhdL6@9NGA0K,6%ZE'9f)-3J)RY%BA4p)Ne
+PC(9cB5jNCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)NePC(9cB5jNCA-0#3P
+6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'pbI5)Ja5jXCAB
+0#3P0EhCP)#ej)%ePC(9cB5da,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ6@9
+NGA0K,6)ZE'9f)#*l8Q9cG@adFhdL$3dLHe*PFh9XG(0p)NpbB@0XC5jXCABJ)-3
+J)RY%BA4p)NpbB@0XC5jNCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)NpbB@0
+XC5jNCA-0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'p
+bI5)Ja5jXCAB0#3P0EhCP)#ej)%pbB@0XC5jXCABJ)RY5CA0eE(4cI5)0$5*l8Q9
+cG@adFhdL6@PZC9p&EQ3ZE'9f)#$%)#*l4'&dI5*0D@jPFbjNCA-J6'9f3fpYF!d
+*#8aPGN0[EA!J)RY%BA4p)NeTEQ9c,Q4PF`d*#90PG%CTE'8J,A3J)RY'D@aP9(P
+`CAdL)#eM)#*l4QPXC80bC@&dEh*p)L$&,QaPGJd*#8e[GQ8J,ANJ6@PZC9p&EQ3
+ZE'9f)#*l8Q9cG@adFhdL)!d*#8e[GQ8J,ANJ6@PZC8CTE'`ZE'9f)#*l8Q9cG@a
+dFhdL$3N*6@pfC5!YH5"0D@jP9'phELjXCABJ)RY5CA0eE(4cI5)0$5*l8Q9cG@a
+dFhdL9'phCA)a,QaPGL!Ja#!LHd4KG(dL9'phCA)ZC'9c)%aPGN0[EA!0#3P-CAC
+$Efe`)#*l4'&dI5*8EhGPFLjNCA-0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!
+YBb!LHdCTE'9$FQ9KG'pbI5)Ja5jXCAB0#3P0EhCP)#ej)&4[Gf9b-5jXCABJ)RY
+5CA0eE(4cI5)0#3P0EhCP)#ej)&4[Gf9b-LjXCABJ)RY5CA0eE(4cI5)0#3P0EhC
+P)#ej)&4[Gf9b-bjXCABJ)RY5CA0eE(4cI5)0$5*l8Q9cG@adFhdLDfj[H#jXCAB
+Ja#!LHd4KG(dLDfj[H#jNCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)QYZEhJ
+ZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*PBA4[FRd
+L)-8ZE'9f$3N*6@pfC5!YH5"VEQpi,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4
+cI5*hDATKFQ3a,QaPGL$%)#*l4'&dI5*jC@jNEh)ZC'9c)%aPGN0[EA!0#3P-CAC
+$Efe`)#*l4'&dI5*jC@jNEh)ZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)
+J,@-J)RY'D@aP3h*PBA4[FRdL)-8ZE'9f$3N*6@pfC5!YH5"hDATKFQ3a,QaPGL!
+LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJGfPkBA*N-LjXCABJ)RY5CA0eE(4cI5)0#3P
+0EhCP)#ej)(GTHQ&bC$-ZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"QB@YPGfP
+k-5jXCABJ)RY5CA0eE(4cI5)0#3P0EhCP)#ej)'CKDf9hDASb,QaPGL!LHe*PFh9
+XG(0p)Jd0)RY5CA0eE(4cI5*",A0dBA*d,QaPGL!Ja#!LHd4KG(dL3A*MD#jNCA-
+J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)N&bBfJZC'9c$3N*8f9d4QPXC5!YG#!
+LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*PBA4[FRdL)-8ZE'9f$3N*6@pfC5!YH5"
+",@CTE'c&,QaPGJNLHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ35eREf&X,QaPGL!LHe*
+PFh9XG(0p)Jd*#8e[GQ8J,ANJ35eXEf0KG'8ZE'9f)#*l8Q9cG@adFhdL$3N*6@p
+fC5!YH5"",A0dBA*d,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4cI5*#,A0dBA*
+d,QaPGL!Ja#!LHd4KG(dL3Q&bBLjNCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4
+p)N*KFQ)ZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*
+PBA4[FRdL)-8ZE'9f$3N*6@pfC5!YH5"#,@CTE'c&,QaPGJNLHe*PFh9XG(0p)Jd
+*#8e[GQ8J,ANJ3LeREf&X,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ3LeXEf0
+KG'8ZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"#,A0dBA*d,QaPGL!LHe*PFh9
+XG(0p)Jd0)RY5CA0eE(4cI5*$,A0dBA*d,QaPGL!Ja#!LHd4KG(dL3f&fC@eKELj
+NCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)N0KGQ9YB@iZC'9c$3N*8f9d4QP
+XC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*PBA4[FRdL)-8ZE'9f$3N*6@p
+fC5!YH5"$,@CTE'c&,QaPGJNLHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ3beREf&X,Qa
+PGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ3beXEf0KG'8ZE'9f)#*l8Q9cG@adFhd
+L$3N*6@pfC5!YH5"$,A0dBA*d,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4cI5*
+&,A0dBA*d,QaPGL!Ja#!LHd4KG(dL4@aQ,Q4PFb"-CAC$Efe`$3N*6'9f3fpYF#!
+LHd4KG(dL4@aQ,Q4PF`d*#90PG%CTE'8J,A3J)RY'D@aP9(P`CAdL)#eM)#*l4QP
+XC80bC@&dEh*p)L$&,QaPGJd*#8e[GQ8J,ANJ45eQD@aXa5jXCAB*)RY5CA0eE(4
+cI5)0#3P0EhCP)#ej)%8YCfpKE#jXCABJ)RY5CA0eE(4cI5)0#3P0EhCP)#ej)%8
+YE'pMBA4P,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ45ecG'&bG#jXCABJ)RY
+5CA0eE(4cI5)0$5*l8Q9cG@adFhdL5#ecG'&bG#jXCABJ)-3J)RY%BA4p)NKPB@a
+PFLjNCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)NKPB@aPFLjNCA-0#3P6CA4
+'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'pbI5)Ja5jXCAB0#3P
+0EhCP)#ej)%JYCQPXE-8ZE'9f#5*l8Q9cG@adFhdL$3N*6@pfC5!YH5"),@G[B@`
+ZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"),@a[Bf&dC5jXCABJ)RY5CA0eE(4
+cI5)0#3P0EhCP)#ej)%JYFh4KFR3ZE'9f)#*l8Q9cG@adFhdL$3dLHe*PFh9XG(0
+p)NXYFh4KFR3ZE'9f)#$%)#*l4'&dI5*,EQPRD(3ZC'9c)%aPGN0[EA!0#3P-CAC
+$Efe`)#*l4'&dI5*,EQPRD(3ZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)
+J,@-J)RY'D@aP3h*PBA4[FRdL)-8ZE'9f$3N*6@pfC5!YH5",,@CTE'c&,QaPGJN
+LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ5beREf&X,QaPGL!LHe*PFh9XG(0p)Jd*#8e
+[GQ8J,ANJ5beXEf0KG'8ZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5",,A0dBA*
+d,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4cI5*3,A0dBA*d,QaPGL!Ja#!LHd4
+KG(dL8(*TCA0d,Q4PFb"-CAC$Efe`$3N*6'9f3fpYF#!LHd4KG(dL8(*TCA0d,Q4
+PF`d*#90PG%CTE'8J,A3J)RY'D@aP9(P`CAdL)#eM)#*l4QPXC80bC@&dEh*p)L$
+&,QaPGJd*#8e[GQ8J,ANJ8#eQD@aXa5jXCAB*)RY5CA0eE(4cI5)0#3P0EhCP)#e
+j)&!YCfpKE#jXCABJ)RY5CA0eE(4cI5)0#3P0EhCP)#ej)&!YE'pMBA4P,QaPGL!
+LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ8#ecG'&bG#jXCABJ)RY5CA0eE(4cI5)0$5*
+l8Q9cG@adFhdL8LecG'&bG#jXCABJ)-3J)RY%BA4p)P*[Ch9P,Q4PFb"-CAC$Efe
+`$3N*6'9f3fpYF#!LHd4KG(dL8QpRG@8ZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'9
+8HA"PI5)J,@-J)RY'D@aP3h*PBA4[FRdL)-8ZE'9f$3N*6@pfC5!YH5"5,@CTE'c
+&,QaPGJNLHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ8LeREf&X,QaPGL!LHe*PFh9XG(0
+p)Jd*#8e[GQ8J,ANJ8LeXEf0KG'8ZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"
+5,A0dBA*d,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4cI5*6,A0dBA*d,QaPGL!
+Ja#!LHd4KG(dL8f&YGA*KD5jNCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)P0
+KEA9bB@NZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*
+PBA4[FRdL)-8ZE'9f$3N*6@pfC5!YH5"6,@CTE'c&,QaPGJNLHe*PFh9XG(0p)Jd
+*#8e[GQ8J,ANJ8beREf&X,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ8beXEf0
+KG'8ZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"6,A0dBA*d,QaPGL!LHe*PFh9
+XG(0p)Jd0)RY5CA0eE(4cI5*8,A0dBA*d,QaPGL!Ja#!LHd4KG(dL9'peFQPcG#j
+NCA-J6'9f3fpYF!d*#8aPGN0[EA!J)RY%BA4p)P4[GA*TFh3ZC'9c$3N*8f9d4QP
+XC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*PBA4[FRdL)-8ZE'9f$3N*6@p
+fC5!YH5"8,@CTE'c&,QaPGJNLHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ9#eREf&X,Qa
+PGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ9#eXEf0KG'8ZE'9f)#*l8Q9cG@adFhd
+L$3N*6@pfC5!YH5"8,A0dBA*d,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4cI5*
+@,A0dBA*d,QaPGL!Ja#!LHd4KG(dL9Q&XDhPbD@8ZC'9c)%aPGN0[EA!0#3P-CAC
+$Efe`)#*l4'&dI5*@B@aVHA*TC5jNCA-0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9
+p)L!YBb!LHdCTE'9$FQ9KG'pbI5)Ja5jXCAB0#3P0EhCP)#ej)&BYCQPXE-8ZE'9
+f#5*l8Q9cG@adFhdL$3N*6@pfC5!YH5"@,@G[B@`ZE'9f)#*l8Q9cG@adFhdL$3N
+*6@pfC5!YH5"@,@a[Bf&dC5jXCABJ)RY5CA0eE(4cI5)0#3P0EhCP)#ej)&BYFh4
+KFR3ZE'9f)#*l8Q9cG@adFhdL$3dLHe*PFh9XG(0p)PFYFh4KFR3ZE'9f)#$%)#*
+l4'&dI5*ADATKFQ3ZC'9c)%aPGN0[EA!0#3P-CAC$Efe`)#*l4'&dI5*ADATKFQ3
+ZC'9c$3N*8f9d4QPXC5!YG#!LHdCTE'98HA"PI5)J,@-J)RY'D@aP3h*PBA4[FRd
+L)-8ZE'9f$3N*6@pfC5!YH5"A,@CTE'c&,QaPGJNLHe*PFh9XG(0p)Jd*#8e[GQ8
+J,ANJ9beREf&X,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ9beXEf0KG'8ZE'9
+f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"A,A0dBA*d,QaPGL!LHe*PFh9XG(0p)Jd
+0)RY5CA0eE(4cI5*4G@9cG#j%BA3*a#!LHd4KG(dL8A9PFh3ZG(Kd)%eKDf9%C@C
+c$3N*6@&VC84PCR-J,A%0#3P0EhCP)#ej)#*l4'&dI5*4G@9cG#j%BA3J)RY5CA0
+eE(4cI5)0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9$FQ9KG'p
+bI5)J)RY5CA0eE(4cI5*4G@9cG#jNBA30$5*l8Q9cG@adFhdL9Q&XE'9j,QaPGL!
+Ja#!LHd4KG(dL4f9SC@jZEfdZC'9c)%aPGN0[EA!0#3P-CAC$Efe`)#*l4'&dI5*
+(C@KPEQj[E5jNCA-0#3P6CA4'D@aP)#ed)#*l4QPXC94jF'9p)L!YBb!LHdCTE'9
+$FQ9KG'pbI5)Ja5jXCAB0#3P0EhCP)#ej)%&cE@pNCA9c,QaPGL!LHe*PFh9XG(0
+p)Jd*#8e[GQ8J,ANJ3Q&KE(SZE'9f)#*l8Q9cG@adFhdL$3N*6@pfC5!YH5"+G@P
+LE'9i,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,ANJ6h*MGA-ZE'9f)#*l8Q9cG@a
+dFhdL$3N*6@pfC5!YH5"6B@jMG(9Y,QaPGL!LHe*PFh9XG(0p)Jd*#8e[GQ8J,AN
+J9Q&XE'9j,QaPGL!LHe*PFh9XG(0p)Jd0)RY5CA0eE(4cI5*1CA4)B@0V)#$%a#!
+LHdeKBd4TFRdL6Q9d5'&MDbjb)#*l6@&M4'PbI5*1CA4)B@0V,R*cFQ-JHd*eD@a
+d5@j%BA4KI5!LHdeKBd4TFRdL8fpeEQ4c,R*cFQ-0#3P6CA3J4'&d)#*l4'&dI5)
+*#3NM)%eKDf8JG'KP)'PZG'9bEQ&X)%eKDf8JGQ&bD@&LE'8JB5"6D'9XE#"fBA*
+TB@*XC3d*#89iF'pbG#"%BA3*#3N*)b"KEQ3JCAK`Eh*d)'Pd)(0[)&*PHL"MB@i
+JGA0P)'Pd)(4[)'CTEQ3JG'KTEQGc$3N*8f9d)%pLDN4TFL!LHdpLDN4TFRdL$3N
+*4AK`Eh*d)%pLDN4TFJd*#9*PHL!LHdeKBd4TFRdL6Q9d5'&MDbjb)#!YFb!LHde
+KBd4TFRdL)#eKF("PEQ3J,@mJ)RY5CA0eE(4cI5*1CA4)B@0V$3dLHe*PFh9XG(0
+p)NjPG%KKBfX*a-3JHd02BQTcI3d*#8aTEQXJHdjPG%KKBfY-D@jVI5"l3dpLDR0
+p)#e[)#*l8Q9cG@adFhdL6Q9d5'&MD`dJ)#!*#90PG'CTE'8J,@%J3L!LHe*PFh9
+XG(0p)NjPG%KKBfX0#3P#C@9`)%-X-6)J35`a-L"$,$%b)%)X-6)J3b`a03dbUJ!
+!!3!!!!&Z!!!!EJ!!!$j+J'f1!J$@I!%V!8USDDX#3N4JB#X#F2k`U'N"CL)X8!a
+1CA4)B@0V,QeKDf8Y!J!!!&4&@&408&-J!3!!D!!!!!"849K869"6)!%!!'J!!!!
+!!!!!!!!!!!!!!!!!!!!!!+J1-Jd!!'6U!!!"V!'kER*Yl35i4f`'8SFR4hX""SC
+,JRm"[+KH!fh15-8J"G`(3N!b"&*"G!!d!B5!,`)V!8KSEf"-!IdfHPYS6lGEF`)
+Bm2rFC8jMH9`MM%eD6b3YHPYYJ!%!SPTE*#A-!5JVH`%Y4&m"2@jIFJ%k"&8"5N9
+Yf!&++qJ"E3*p""e!rrF!!!")!!T$Eh9bD@9b!!!!S5)!!!")!!!I!#9c$3!P+R0
+$3)$Gf!!'!!3!+J!N!Q%#)!!m!#3#E3,pU$(K@J!!!!!!!!!!!!!!!!%!!!!!(J!
+U!#3#B3)J!$`!*!*Y![d!!!!!!!!!!!!!!!!!!!!!!3!!!!&Z!!!!EJ!!!$i!XHf
+i#UJ!!!!F!$i!!%e38e)!!3!+!qhrr`!!!!!!!!!!!r$rr`!!!%`!Z$$S+'`:
diff -Pru nethack-3.4.1/sys/mac/old/NHproj.hqx nethack/sys/mac/old/NHproj.hqx
--- nethack-3.4.1/sys/mac/old/NHproj.hqx	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/NHproj.hqx	Thu Jan 10 16:43:27 2002
@@ -0,0 +1,953 @@
+(This file must be converted with BinHex 4.0)
+:$%jPG%KKBfXZF(*[DJ"38Np+5d&)6!%!!!!!!!!!XLGiY`!!!!!"!!!!Uk3!!+U
+N!!!'J`!!!-N!B!!!!!)(r`!!&ZB!D!!!!!%!!!!!!!!!!!!!$%jPG%KKBfXZF(*
+[DM!#!!!!8&*25NY"5%`"!!#F!!!!!&"56dT,38K-!3!!R!!!!!!!!!!!!!!!!!!
+!!!!!!!!!U@aE@J!!!!!!!,)R!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!r!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!(d!!!&D!!#i"3!!4&*@8J!!!!!"j!"bdiJ!!2m`!,B!!!!!!!!!!!!
+!!!!!&!"bdiJ!!!!!!!!!!J!!!!!!!!#8!(,6L!!!!!!!m!"c!!!!DJ!!!!%!!!!
+#!3!!!!!!`!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!BfpbC@0bC@`!!3kFF(0Z)!!
+!!!J!!!!!!!!!!Q&PGR3!!3!"D@jdC@9ZG@d!!!!%Bf&ZFcXl1cYVEf0XG(P`C3!
+!!!434%p$C'&dB9468%)!!!!!!!!!!!!!!!!!D!"bdiJ!!!!!!!!!!!!!!&S!!!!
+!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'&PGR4KEJe1CA4)B@0
+V)$-Z-5icC!!!!!!!!!*KCACd!!%!!6Xl1cX!DJ!!!!!!!!!8!(,6L!!!rc!!YJ!
+!!!!!!!!!!"4"8&"-2cmr2eL!!!!(d!!!!!J!1ImV!5B!1`!!!!!!!!!!!!!!"!!
+!!!!!!!!+@)!!(d!!!"p!!!!!!%S!!!!!!$J!!!!i!$J!!!!i!$J!1!!i!$J!1!!
+i!$J!1!!i!$J!1!!i!$J!1!!i!$J!1!!i!$J!1!!i!$J!1!!i!$J!1!!i!$J!1!!
+!!!3!!!!!!!!!"!!!!!!!!!!,%Fc6H%`!!!!!!!!!!!!@!0B!&!'%!@F!c3'B!B`
+#G*rB!!!!!!!!!*NK!!!!!!!!!#!!!!!!!!!!!!!!!!!!!!#!N!!!#!3ZBA0Y"e4
+)58j,)%-#,Q-(9%K*6NXJ3`-ZBh!-8hPYB@jdC@-J3bXV"#jMF(!-8hPYB@jdC@-
+J3bXV"5jZEh4P"b$(EQpZCFJ#,Qm0)#j[)%0[ERCPFR4PFJ)ZFJP85%P15b"5CAS
+&,R*cFQ-28Q9cEh9bBf8J3fp`D@9b!!!!B!!!!(!!!!!!!!!!8!!!!#!!)$mm!!'
+Tm!AZ2c`!!DR`"J)r2!!"UI!'&Mmm!!'Tm!Bb2c`!!DR`"QJr2!!"UI!'L$mm!!'
+Tm!DU2c`!!DR`"XSr2!!"UI!*4$mm!!'Tm!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!
+!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!
+!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!
+!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!
+!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!
+!!!!!!!3!!!!!!!!!"!!!!!!!!!!%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#!3!
+!!!!JS4"rm0!!!!!MD@jME(9NC5!m6@&M5'9KC'9bFbXV2J!!!!"`!3%!!!!!)f4
+PCQPZC5"dFR9P)#!J)#!J)$%0)f4PCQPZC5"QB@acC5!J)#!J)$!0)f4PCQPZC5"
+bCASJ)#!J)#!J)$%0)f4PCQPZC5"NCA*PHL!J)#!J)$!0)f4PCQPZC5"85%P15ep
+5CASJ)$%0!!!!H!!!qH!8!2RN&!$jj$3!qH6#!2RP6!$jjDi!qHSU!2RUXJ$jkfi
+!qHZN!2RX"!$jl)S!qHcU!2RY)!$jlB)!qHfm!2RYpJ$jlRi!qHm-!2R[EJ$jm"S
+!qI#J!2Ra9!$jmJJ!qI*U!2Rbc!$jmbi!qI1k!2RdF!$jp-i!qI9q!2Rf,J$jpSi
+!qIE`!2Rh9!$jq#i!qIL5!2RimJ$jq93!qIRL!2Rk3J$jqh!!qIc'!2Rp+!$jrG`
+!qIk3!!$jr[!!qIqL!2S!9J$k!3S!qJ&X!2S#4!$k!h)!qJ3U!2S+jJ$k$f3!qJr
+'!2S3+!$k%)J!qK$S!2S@-J$k&T3!qKG)!2SAUJ$k'!S!qKKX!2SC4J$k'DS!qKS
+-!2SDjJ$k(*!!!2SG3!$k(F`!qKiX!2SHM!$k(fB!qKr%!2SJ)J$k))3!qL%b!2S
+KiJ$k)TB!qL-J!2SMUJ$k*!S!qL6Q!2SP4J$k*DJ!qLB+!2SQDJ$k*XS!qLFU!2S
+RM!$k+$i!qLMf!2ST@!$k,GB!qLii!2SZQ!$k,[J!qLpq!2S`#!$k-'J!qM$)!2S
+a*J$k-GS!qM9S!2Si5J$k1LB!qMaD!2SpZJ$k3"J!qN,1!2T$eJ$k4BS!qNAX!2T
+'H!$k5&S!qNkf!2T2EJ$k8%S!qP$@!2T4M!$k8Hi!qP3-!2T85J$k9'`!qPJ8!!!
+!!!!#!!)!!J!B!-8!!"!i!!!!!!!!![J!!!!!!!%!!`!!!!-!!`!%!!-!!'HF!!!
+H,J!!!-!!!!!!!!!!!J!"!!3!"+DJ!!d!!!Zd!!!!N!!!!!!J!!!!!!!!!!-!!J!
+&!!8!!!!!!!!!3J!!!"3!!!!)!!!!!!!!!!3!!`!'!!DB%!!!!!"ESJ!!(BS!!!#
+B!!!!!!!"!!B!!!!(!!F!#!!&!!"Jb!!!)4B!!!'B!!!!!!!!!!8!!3!)!!J!!!!
+!!!!M8J!!$,i!!!#B!!!!!!!!!!B!!J!*!!N!!)d-!!!3$J!!"U3!!!#!!!!!!!!
+!!!F!!`!+!!S!4!$&!!!AK!!!!c)!!!"!!!!!!!!!!!J!"!!,!!X!#J&h!!!,'!!
+!!,`!!!!3!!!!!!!!!!N!"3!-!!`!!!!!!!!+b!!!#FB!!!!`!!!!!!!"!!J!!!!
+0!!d!$J!%!!"TdJ!!P$`!!!()!!!!!!!!!!S!!3!1!!lJ!#F4!!!M$!!!$e3!!!$
+`!!!!!!!!!!X!!J!2!!pPFLiZ!!!IQ!!!",S!!!"3!!!!!!!!!!`!!`!3!""PFbi
+Z!!!!!J!!HAB!!!!)!!!!!!!!!!d!"!!4!"%!!!!9!!!R+!!!"VJ!!!#!!!!!!!!
+"!!N!!!!5!")!%`!$!!"iS!!!-6B!!!()!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!
+!)4!!!!$3!!!!!!!!!!m+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Qi!!!!
+D!!%!!"RE39488J!!!!KKG(4bD@)ZB`"M!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q
+45%&$5`!!!!CSB@0V,QJ!B`!"U@aD&DPX@K@TE&S9!!%!(!!"!!!CN8&59%N!!!!
++BA*dD@CKBh3ZD!!!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Te!!!!&J!
+"!!!Cfd004#i!!!!&BfeN,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!
+!!!CSB@0V,QJ!!!!"U@aD*kPX@LHTE&SR!!%!(!!"!!!CN8C96N-!!!!+CR9ZBep
+dB@)ZD!!!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&TN!!!!'J!"!!!Cfd&
+-6%d!!!!*B@aXE@&TELjM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!
+'D'&MDbjS!#i)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Q8!!!!B!!%!!"R
+E38a-6`!!!!GKE'a[BbjM!!!"U@aD'+PX@KLTE&SB!!%!'J!"!!!CN8026NB!!!!
+)BfpZCQPR,QJ!!!!#U@aD4UPX@NDTE&T'!!)!(!!"!!!CN945383!!!!+G(*KC(0
+dC'-ZD!"M!!1N,E`5T#fm%U3Y[")!!`!D!!)!!!rZ8e4%33!!!3KcG'4KFQFZD!"
+S!!+TE&STU@aD+DPX@LN!"!!D!!%!!"Q44da23J!!!!KRE'pLB@`ZD!"S!!1Q`pM
+iTX2Bq+E$f2J!"3!B!!)!!!rZ8e4%53!!!3GcG'4TEbjS!!!%U'J6P+KS%j5SD"1
+8!!B!'J!#!!!2lP0*@N8!!!!)FfPkC9pd,QJ!D!!$U@aD'DPX@KQTE&SC!!F!'!!
+"!!!CN8026e)!!!!(Bfp[FQ3ZD!!!!kP`F!ZTF(!,UA"`#`!)!"S!!3!!'C&0380
+$!!!!#@eKBf0[EQBZD!!!"+PX@N5TE&T%U@aD4!!*!"S!!3!!'C&6@908!!!!#(0
+jFh4PE5jS!!!!"DKeJ-+SGB$#U(@!`J!+!"J!!J!!$d&8@9"&!!!""h4jF'9c,QJ
+!!!@Q`pN%TX2C"+E$f33!#`!B!!)!!!rZ9%P043!!!3CdD@eP,QJ!!!!%U%FPA+K
+(*9bS4b9F!!`!'J!#!!!2390&4d`!!!%*Ff9RE'pKC#jS!!!%TX2BRUE$f*kQ`pL
+H!!d!'J!#!!!2lP084%`!!!%)Fh4NE'PL,QJ!!!!&T#h!)U3Y`#+N,F!L!!i!'J!
+#!!!2lPG$5%%!!!!*Gf0SBA*IG#jS!!!%U%FP`+K(*F#S4bA!!!m!'J!#!!!239G
+*6N3!!!%*GfPZC'phFbjS!!!&U%FP3UK(*8+S4b9#!"!!(!!#!!!239&958-!!!%
+,8A9TBfYNFQ&h,QJ!!!@QC0R!TQ6C`+CNfF!!%3!D!!)!!!p"49C&6J!!!3K&GQ9
+ZG(-ZD!!Z!!@S4b5'U%FNKUK(*)B!%J!F!!)!!!p"3dp19!!!!3T$EfjdFQpXFbj
+S!!!!"+3ak8#N-HP!T$(T3!!6!"S!!J!!$d&048e2!!!"#'ePE@pbH5jS!'J!"+K
+(*8+S4b9#U%FP3J!8!"`!!J!!$d&498P$!!!"#h&eD@0VC(*KGbjS!!!%TQ6C`+C
+NfF#QC0R!!"8!'J!#!!!2389@48i!!!%)CACPER4c,QJ!,J!%U%FNKUK(*)DS4b5
+'!"B!(!!#!!!238026P3!!!%+BfpZG(*[E(-ZD!!!!!5S4b6!U%FN`+K(*-!!&`!
+D!!)!!!p"4%P"6!!!!3PND@&XEfGc,QJ!!!@S4b@-U%FPM+K(*B`!'!!F!!)!!!p
+"9%9B9!!!!3T8CAKd4@4TG#jS!!!!"+K(*2DS4b6fU%FNpJ!C!"J!!J!!$d&'6dj
+8!!!""fC[ER4c,QJ!!!5N-Iq3!+3arj!!T$(rN!!!'J!B!!)!!!rZ4N019!!!!3G
+QBfjdE#jS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDD3!!!"J!!3!!'GY
+"8&"-!!!!"f&`F'aj,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!C
+SB@0V,QJ!!!!"U@aD(UPX@KkTE&SH!!%!'!!"!!!CN89%6dF!!!!'C@4[CbjS!!!
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Qd!!!!F!!%!!"RE39*853!!!!T
+KFR4TCQ&MG#jM!!!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfX
+ZD!"d!!'TE&S9U@aD&DPX@K8!!3!F!!%!!"Q439*853!!!!TKFR4TCQ&MG#jS!!!
+!!DPX@KDTE&S@U@aD&J!#!"`!!3!!'C&"8P4*!!!!#Q&bG'PXDA0d,QJ!!0!!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU!L)V!!!!"B!!J!!$qG96NPB!!!!"(9ZDAJ
+!C3S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDF!!!!"J!!3!!'GY#38a-!!!
+!"Q*KE'`ZB`"M!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!B`S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDF3!!!"J!!3!!'GY#6dj&!!!
+!"f*[EQ9c,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!!!!"U@aD+kPX@LZTE&SV!!%!&J!"!!!CN8a&9Li!!!!&E'9f,QJ!#J!!!!!!!!!
+!!!!!!!!!!!!!rrrrrrrrrrqTE&Tc!!!!'!!"!!!Cfd*29%`!!!!'BQpdE#jM!!!
+!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!!m!!!!!!!!!!
+!!!!!!!!!!!!!rrrrrrrrrrqSJ``5!!!!&J!#!!!2jd&18dN!!!!%38j653"P#J!
+!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Ti!!!!'J!"!!!Cfd4#8NN!!!!*C'*
+bD@4RC5jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#k
+!!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkJpjc!!!!!D!!)!!!qb68&$9!!!!!K
+0B@08FQ&`F`!!J!!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqS2HG+!!!!'J!#!!!
+2XNe"3e3!!!!*6@&M9(*KF(-b!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@a
+DH3!!!"J!!3!!'GY%480-!!!!"Q4PBf`ZB`!Z!!'TF("YUA"`EDP`F'd!!!!B!!%
+!!"Q45%&$5`!!!!CSB@0V,QJ!,J!"U@aD2UPX@MkTE&Sq!!%!'!!"!!!CN9&949-
+!!!!(FA9PFh3ZD!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@RX!!!!D!!%
+!!"RE4%9843!!!!KNCA4PBh3ZB`!!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&
+$5`!!!!CSB@0V,QJ!B`!"U@aD&DPX@K@TE&S9!!%!(!!"!!!CN8&59%N!!!!+BA*
+dD@CKBh3ZD!!!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Tr!!!!'J!"!!!
+Cfd4*8e!!!!!*C'PcF'aKH5jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX
+!!!!'D'&MDbjS!#i+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@S%!!!!@!!%
+!!"RE4%mZ3`!!!!4NEbjM!'%!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!!Z!!'TE&SVU@aD+kPX@LX!!3!@!!%!!"Q46%9@,J!!!!9XCABZD!!
+!!D3VM+#N+ibJT#Z-S!!#!"J!!J!!$qj&8P*1!!!""f9bFQj[,QJ!#J!!!!!!!!!
+!!!!!!!!!!!!!rrrrrrrrrrqTE&U*!!!!&J!"!!!Cfd424bi!!!!&C'pR,Q-!!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!!!!"U@aD(UPX@Kk
+TE&SH!!%!'!!"!!!CN89%6dF!!!!'C@4[CbjS!!!+!!!!!!!!!!!!!!!!!!!!!!$
+rrrrrrrrrrkPX@SS!!!!D!!%!!"RE4%p(63!!!!PNEfGYEhCP,Q-!!!'TF("YUA"
+`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,J!"U@aD,kPX@LqTE&S[!!%
+!'J!"!!!CN8e'6N3!!!!*E@CZC("[FbjS!!!"U@aD(UPX@KkTE&SH!!)!'!!"!!!
+CN89%6dF!!!!'C@4[CbjS!#i+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Sd
+!!!!D!!%!!"RE4%p,53!!!!KNEfYTBfXZB`!!!!'TF("YUA"`EDP`F'd!!!!B!!%
+!!"Q45%&$5`!!!!CSB@0V,QJ!B`!"U@aD)DPX@L'TE&SK!!%!'!!"!!!CN8965%X
+!!!!'CA0SDbjS!'-!!UPX@KkTE&SHU@aD(J!#!"S!!3!!'C&%98j(!!!!#@4eEQG
+PEfiZD!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Sm!!!!D!!%!!"RE4%p
+85!!!!!PNEh4SFQph,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!C
+SB@0V,QJ!,JS!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDJ`!!!"S!!3!!'GY
+%6ep1!!!!#@4[AfjKE@8ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!!Z#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&U(!!!!'J!"!!!
+Cfd42AeF!!!!*C'pIGf9KFLjM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX
+!!!!'D'&MDbjS!#i+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@T%!!!!D!!%
+!!"RE4&*"9`!!!!PNFQ&hD@jR,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&
+$5`!!!!CSB@0V,QJ!,J!"U@aD4DPX@N@TE&T&!!%!'J!"!!!CN94&8Nd!!!!*G'9
+bE@0KF#jS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDP3!!!"S!!3!!'GY
+%98j(!!!!#@4eEQGPEfiZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!!Z!!'TE&SFU@aD(+PX@K`!!3!F!!%!!"Q44%G1A`!!!!TNCfjICQP
+XC5jS!!!!!UPX@K1TE&S6U@aD%`!#!"J!!3!!'C&"6%P(!!!!"f&XD@GZ,QJ!#J!
+!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&UB!!!!&J!"!!!Cfd9"9#i!!!!&C@&
+d,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,JS!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDQ`!!!"B!!3!!'GY&6N3Z!!!!"@9ZC#j
+M!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i!!DPX@L'
+TE&SKU@aD)3!"!"J!!3!!'C&&8dK,!!!!"Q9cD'XZD!!Z!!+TE&SHU@aD(UPX@Ki
+!!J!D!!%!!"Q44&914`!!!!PNG@jRC@pZ,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrr
+rrrrrrrqTE&UG!!!!'J!"!!!Cfd914e)!!!!*C@jRFQ&fC5jM!!!"UA"`EDP`F'f
+TF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i!!DPX@LZTE&SVU@aD+`!"!"B
+!!3!!'C&-49BZ!!!!"@aPGLjS!!!"TQbUZ+CXUVLQE+Ui!!)!'!!#!!!2lN08@9!
+!!!%(Bh4jF'8ZD!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Ti!!!!B!!%
+!!"RE49K343!!!!GPH("PFLjM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX
+!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Tm!!!!D!!%
+!!"RE49K36!!!!!PPH("XEf4P,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&
+$5`!!!!CSB@0V,QJ!,JS!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDS3!!!"`
+!!3!!'GY&@&45!!!!#Q9iG(*KE'9f,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!
+CN8K"3dX!!!!'D'&MDbjS!(B+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@U-
+!!!!B!!%!!"RE4NP-43!!!!GQD@aPFbjM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!
+CN8K"3dX!!!!'D'&MDbjS!!!!!DCXUVLQE+UiTQbUZ!!"!"J!!J!!$qj$9&P3!!!
+""f0dHA"P,QJ!!!'S4b6UU%FNkUK(*1S!!J!B!!)!!!p"4NP-43!!!3GQD@aPFbj
+S!!!#U%FP)UK(*5+S4b8L!!-!'J!#!!!238p6993!!!%*6e09G'PXFbjS!!S!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDT3!!!"`!!3!!'GY'6e91!!!!#QC[G@j
+dB@PZ,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'i
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@UJ!!!!B!!%!!"RE5%&$5`!!!!C
+SB@0V,Q-!EJ!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'i
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@US!!!!D!!%!!"RE5%&$5`!!!!P
+SB@0VE'PL,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!,JS!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDVJ!!!"S!!3!!'GY*6PC&!!!
+!#'PZGQ9ZG#jM!!!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfX
+ZD!"M!!'TE&S9U@aD&DPX@K8!!3!F!!%!!"Q439*853!!!!TKFR4TCQ&MG#jS!!!
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@V!!!!!B!!%!!"RE6%p$5`!!!!C
+XEf0V,Q-!B`!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'-
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Vi!!!!D!!%!!"RE68P153!!!!K
+YD@jTEfiZB`"S!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!B`!"U@aD(kPX@KqTE&SI!!%!'!!"!!!CN89058i!!!!'C@eTELjS!'-!!UPX@Kk
+TE&SHU@aD(J!#!"S!!3!!'C&%98j(!!!!#@4eEQGPEfiZD!!!!DPX@L#TE&SJU@a
+D)!!$!"J!!3!!'C&&8&**!!!!"Q9`FQNZD!!Z!!+TE&SHU@aD(UPX@Ki!"!!D!!%
+!!"Q44&914`!!!!PNG@jRC@pZ,QJ!!!+TE&S6U@aD%kPX@K-!"3!B!!%!!"Q438a
+*4`!!!!GKE'PRELjS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDY3!!!"S
+!!3!!'GY038Y&!!!!#@eKDf9YEfiZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&
+)380,!!!!"QKKBfXZD!!Z!!'TE&SJU@aD)+PX@L!!!3!B!!%!!"Q449"553!!!!C
+PF(*T,QJ!,J!#U@aD(UPX@KkTE&SH!!)!'J!"!!!CN8496NF!!!!*C(9ZCf9[ELj
+S!!!#U@aD%kPX@K1TE&S6!!-!'!!"!!!CN8&-58F!!!!(B@aTCfiZD!!!!DPX@Kq
+TE&SIU@aD(`!%!"J!!3!!'C&&68P1!!!!"Q9YD@iZD!!!!!+TE&SHU@aD(UPX@Ki
+!"3!D!!%!!"Q44&914`!!!!PNG@jRC@pZ,QJ!!!'QE+UiTQbUZ+CXUVJ!"J!B!!)
+!!!rZ3e4C8!!!!3GMG(P`C5jS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@a
+DYJ!!!"S!!3!!'GY03d&6!!!!#'eMBA0dG5jM!!!!!DP`F'fTF("YUA"`E3!!!"J
+!!3!!'C&)380,!!!!"QKKBfXZD!"M#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrq
+TE&Uj!!!!'!!"!!!Cfde)593!!!!(E@KTG'dZB`!!!DP`F'fTF("YUA"`E3!!!"J
+!!3!!'C&)380,!!!!"QKKBfXZD!!!!!'TE&S9U@aD&DPX@K8!!3!F!!%!!"Q439*
+853!!!!TKFR4TCQ&MG#jS!!!!!DPX@KkTE&SHU@aD(J!#!"J!!3!!'C&&4%p(!!!
+!"Q9NEfFZD!"d#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Up!!!!'!!"!!!
+Cfde)593!!!!(E@KTG(8ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!!!!!'TE&S9U@aD&DPX@K8!!3!F!!%!!"Q439*853!!!!TKFR4TCQ&
+MG#jS!!!!!DPX@KkTE&SHU@aD(J!#!"J!!3!!'C&&4%p(!!!!"Q9NEfFZD!"d#J!
+!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&V"!!!!'!!"!!!Cfde,6%8!!!!(E@Y
+XCABZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!!#J!
+!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&V$!!!!'!!"!!!Cfde,68%!!!!(E@Y
+YBA!ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!!!!'
+TE&T"U@aD3DPX@N%!!3!D!!%!!"Q48e"I6!!!!!KcF&pXCABZD!"S!!+TE&S6U@a
+D%kPX@K-!!J!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!S!!!!!!!!!!!!!!!!!!!!
+!!2rrrrrrrrrrU@aDa3!!!"S!!3!!'GY05de"!!!!#'eVE@&kC5jM!'J!!DP`F'f
+TF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!"M!!'TE&T"U@aD3DPX@N%
+!!3!D!!%!!"Q48e"I6!!!!!KcF&pXCABZD!"S!!+TE&S6U@aD%kPX@K-!!J!B!!%
+!!"Q438a*4`!!!!GKE'PRELjS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@a
+Da`!!!"J!!3!!'GY05dp#!!!!"feVEf*U,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%
+!!"Q45%&$5`!!!!CSB@0V,QJ!!!!"U@aD&DPX@K@TE&S9!!%!(!!"!!!CN8&59%N
+!!!!+BA*dD@CKBh3ZD!!!!!'TE&SpU@aD2DPX@Md!!J!B!!%!!"Q48&*28!!!!!C
+`FQp`,QJ!G!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDb3!!!"S!!3!!'GY
+05e*2!!!!#'eVFQp[E5jM!'J!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!"M#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&V0!!!!&J!"!!!
+Cfde26Li!!!!&E@pZ,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!C
+SB@0V,QJ!B`!"U@aD,kPX@LqTE&S[!!%!'J!"!!!CN8e'6N3!!!!*E@CZC("[Fbj
+S!!!"U@aD(UPX@KkTE&SH!!)!'!!"!!!CN89%6dF!!!!'C@4[CbjS!#i!!DCXUVL
+QE+UiTQbUZ!!$!"J!!J!!$qj$9&P3!!!""f0dHA"P,QJ!#J!!!!!!!!!!!!!!!!!
+!!!!!rrrrrrrrrrqTE&V2!!!!'J!"!!!Cfde26N3!!!!*E@pZC'&dB5jM!!!"UA"
+`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i!!DPX@L'TE&SKU@a
+D)3!"!"J!!3!!'C&&8dK,!!!!"Q9cD'XZD!!Z!!+TE&SHU@aD(UPX@Ki!!J!D!!%
+!!"Q44&914`!!!!PNG@jRC@pZ,QJ!!!'TE&SJU@aD)+PX@L!!!`!B!!%!!"Q449"
+553!!!!CPF(*T,QJ!,J!#U@aD(UPX@KkTE&SH!!3!'J!"!!!CN8496NF!!!!*C(9
+ZCf9[ELjS!!!#U@aD%kPX@K1TE&S6!!8!'!!"!!!CN8&-58F!!!!(B@aTCfiZD!!
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@Y%!!!!D!!%!!"RE68p163!!!!P
+YEfjYEhCP,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!,J!"U@aD,kPX@LqTE&S[!!%!'J!"!!!CN8e'6N3!!!!*E@CZC("[FbjS!!!"U@a
+D&DPX@K@TE&S9!!)!(!!"!!!CN8&59%N!!!!+BA*dD@CKBh3ZD!!!#!!!!!!!!!!
+!!!!!!!!!!!!!rrrrrrrrrrqTE&VA!!!!'!!"!!!Cfde26P-!!!!(E@pZFh3ZB`!
+!!DPX@KLTE&SBU@aD'!!"!"S!!3!!'C&$6dj'!!!!#'0[EQCTCbjS!!!!!UPX@ND
+TE&T'U@aD4J!#!"`!!3!!'C&88N&%!!!!#R4bB@4cG'4M,QJ!!!!$T#fm%U3Y["+
+N,E`5!!-!'J!#!!!2lP084%%!!!%)Fh4NBA*R,QJ!D!!#U@aD+DPX@LQTE&ST!!3
+!'J!"!!!CN8G-6d)!!!!)Cfa[BQ&X,QJ!D!!$TX2Bq+E$f2LQ`pMi!!8!'!!#!!!
+2lP084%N!!!%(Fh4ND@mZD!!!"+KS%j5SD"18U'J6P!!'!"S!!J!!$qj659T&!!!
+!#(0THQ9IG#jS!'J!!kPX@KQTE&SCU@aD'3!(!"J!!3!!'C&$6dp5!!!!"f0[Eh*
+N,QJ!!!1TF(!,UA"`#kP`F!X!#!!D!!%!!"Q468&$3`!!!!PYB@0MEfjQ,QJ!!!5
+TE&T%U@aD4+PX@N3!#3!D!!%!!"Q48eP69!!!!!KcHA0dC@dZD!!!!!@SGB$#U(@
+!`UKeJ-)!#J!B!!)!!!p"9&P343!!!3GdHA"PFbjS!!!&TX2C"+E$f35Q`pN%!!X
+!'!!#!!!2lP4*688!!!%'G'PYC5jS!!!!"+K(*9bS4b9FU%FPA!!-!"S!!J!!$d&
+648G-!!!"#A0PCfa[B@3ZD!!!"+E$f*kQ`pLHTX2BRJ!0!"S!!J!!$qj69%4-!!!
+"#(0dC'aTBLjS!!!!"D3Y`#+N,F!LT#h!)J!1!"S!!J!!$qjA3dK"!!!!#AGMD'&
+bAh3ZD!!!"+K(*F#S4bA!U%FP`!!2!"S!!J!!$d&A58j%!!!"#AGTEQ4[Gh-ZD!!
+!"DK(*8+S4b9#U%FP3J!3!"`!!J!!$d&498P$!!!"#e&eD@0VC(*KGbjS!!!&TQ6
+C`+CNfF#QC0R!!"%!'J!#!!!2389@48i!!!%)4ACPER4c,QJ!,J!&U%FNKUK(*)D
+S4b5'!")!(!!#!!!238026P3!!!%+3fpZG(*[E(-ZD!!!!!5N-HP!T$(T3+3ak8!
+!%`!D!!)!!!p"68906`!!!3KYC@e[FRNZD!"S!!5S4b9#U%FP3UK(*8)!&!!F!!)
+!!!p"899*3`!!!3YaG@PMDf4bBAFZD!!!"+CNfF#QC0R!TQ6C`!!9!"S!!J!!$d&
+&9N91!!!"#'9fC@jdFbjS!#i!"+K(*)DS4b5'U%FNKJ!@!"`!!J!!$d&$6dj8!!!
+"#Q0[ER4bEfac,QJ!!!!%U%FN`+K(*-#S4b6!!"F!'J!#!!!2384*38`!!!%*C'P
+KE'pRFbjS!!!&U%FPM+K(*BbS4b@-!"J!(!!#!!!2394&@&3!!!%+9'9iG%9NDA3
+ZD!!!!!5S4b6fU%FNpUK(*2B!'3!B!!)!!!p"4Np19!!!!3GQEfjdFbjS!!!%T$(
+rN!#N-Iq3!+3arj!!!"S!'!!#!!!2lNC$6P3!!!%(CQ0ZG'`ZD!!!!DPX@MbTE&S
+mU@aD2!!E!"`!!3!!'C&349*0!!!!#R"PFQe[ER0d,QJ!!!!#U@aD-UPX@M+TE&S
+b!"`!'J!"!!!CN8e26N%!!!!*E@pZBA4dDbjS!!!#U@aD-kPX@M1TE&Sc!"d!'J!
+"!!!CN8e26NB!!!!*E@pZCQaKCbjS!!!#U@aD%kPX@K1TE&S6!"i!'!!"!!!CN8&
+-58F!!!!(B@aTCfiZD!!!!DPX@M@TE&SeU@aD03!I!"S!!3!!'C&06dj6!!!!#'e
+[ER0jE5jS!!!!!DPX@L'TE&SKU@aD)3!J!"J!!3!!'C&&8dK,!!!!"Q9cD'XZD!"
+S!!+TE&SHU@aD(UPX@Ki!)3!D!!%!!"Q44&914`!!!!PNG@jRC@pZ,QJ!!!1TE&S
+6U@aD%kPX@K-!)J!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!!"U@aD5UPX@NUTE&T
++!#-!'!!"!!!CN9C"98`!!!!(GQ&eE(3ZD!!!!UPX@KkTE&SHU@aD(J!N!"S!!3!
+!'C&%98j(!!!!#@4eEQGPEfiZD!!!!DPX@L#TE&SJU@aD)!!P!"J!!3!!'C&&8&*
+*!!!!"Q9`FQNZD!!Z!!+TE&SHU@aD(UPX@Ki!*J!D!!%!!"Q44&914`!!!!PNG@j
+RC@pZ,QJ!!!+TE&S6U@aD%kPX@K-!*`!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!!
+"U@aD&kPX@KHTE&SA!#J!'!!"!!!CN8026%m!!!!(BfpXEh)ZD!!)!!!!!!!!!!!
+!!!!!!!!!!!$rrrrrrrrrrkPXJ8`!!!!D!!%!!"RE68p18`!!!!KYEfjcG()ZB`!
+!!!'TE&SBU@aD'+PX@KJ!!3!D!!%!!"Q43dp14J!!!!KMEfjQD@FZD!!!!!+TE&T
+'U@aD4UPX@NB!!J!F!!%!!"Q49&*"4!!!!!TdFQ&NFh4NBbjS!!!!!k3Y["+N,E`
+5T#fm%J!$!"S!!J!!$qj69%4"!!!"#(0dC'&bCbjS!'J!!UPX@LQTE&STU@aD+3!
+%!"S!!3!!'C&(6%p#!!!!#'GXEf*KE#jS!'J!!kE$f2LQ`pMiTX2Bq!!&!"J!!J!
+!$qj69%4*!!!""h0dC'P[,QJ!!!5SD"18U'J6P+KS%j3!"J!D!!)!!!rZ8dPD43!
+!!!KcDATPAh3ZD!"S!!1TE&SCU@aD'DPX@KN!"`!B!!%!!"Q43dp28J!!!!GMEfp
+bC#jS!!!$UA"`#kP`F!ZTF(!,!!J!'J!"!!!CN8e"3d-!!!!*E@&MBfpZCLjS!!!
+%U@aD4+PX@N5TE&T%!!N!'J!"!!!CN90C8e3!!!!)FhPcG'9Y,QJ!!!!&U(@!`UK
+eJ-+SGB$#!!S!'!!#!!!2394C8%8!!!%(G(P`CA-ZD!!!"DE$f35Q`pN%TX2C"!!
+,!"J!!J!!$qj858e&!!!""R4TE@8ZD!!!!!5S4b9FU%FPA+K(*9`!$!!D!!)!!!p
+"8d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pLHTX2BRUE$f*i!$3!D!!)!!!rZ8e4%6!!
+!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3Y`#)!$J!D!!)!!!rZ9d0)33!!!!PhBfK
+KFPpd,QJ!!!5S4bA!U%FP`+K(*F!!$`!D!!)!!!p"9dP14!!!!3PhD@jNEhGc,QJ
+!!!@S4b9#U%FP3UK(*8)!%!!F!!)!!!p"899*3`!!!3Y4G@PMDf4bBAFZD!!!"DC
+NfF#QC0R!TQ6C`!!4!"S!!J!!$d&&9N91!!!"#%9fC@jdFbjS!#i!"DK(*)DS4b5
+'U%FNKJ!5!"`!!J!!$d&$6dj8!!!"#N0[ER4bEfac,QJ!!!!%T$(T3+3ak8#N-HP
+!!"-!'J!#!!!238e&68m!!!%)E@9YEh*j,QJ!D!!%U%FP3UK(*8+S4b9#!"3!(!!
+#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ!!!5QC0R!TQ6C`+CNfF!!&3!D!!)!!!p
+"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5'U%FNKUK(*)B!&J!F!!)!!!p"3dp19!!
+!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6!U%FN`!!A!"S!!J!!$d&%58&-!!!"#@4
+TB@a[Ch-ZD!!!"DK(*BbS4b@-U%FPM!!B!"`!!J!!$d&849K8!!!"#P4PH(4&C'P
+d,QJ!!!!%U%FNpUK(*2DS4b6f!"N!'!!#!!!238C26P3!!!%(CQpZG(-ZD!!!"+3
+arj!!T$(rN!#N-Iq3!!!D!"J!!J!!$qj'3dj8!!!""fCMER4X,QJ!#J!!!!!!!!!
+!!!!!!!!!!!!!rrrrrrrrrrqTE&VD!!!!'J!"!!!Cfde36%%!!!!*EA"XBAPPFLj
+M!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i+!!!!!!!
+!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@YX!!!!D!!%!!"RE694)8J!!!!PYG'KbEhG
+e,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,JS!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDhJ!!!"J!!3!!'GY0990&!!!!"QeeFf8
+ZB`!Z!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,JS!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDi!!!!"J!!3!!'GY0990*!!!!"feeFfP
+M,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!!!J!!!!
+!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDi`!!!"S!!3!!'GY23NT&!!!!#@pLDQ9
+MG(-ZB`!!!DPX@KLTE&SBU@aD'!!"!"S!!3!!'C&$6dj'!!!!#'0[EQCTCbjS!!!
+!!UPX@NDTE&T'U@aD4J!#!"`!!3!!'C&88N&%!!!!#R4bB@4cG'4M,QJ!!!!$T#f
+m%U3Y["+N,E`5!!-!'J!#!!!2lP084%%!!!%)Fh4NBA*R,QJ!D!!#U@aD+DPX@LQ
+TE&ST!!3!'J!"!!!CN8G-6d)!!!!)Cfa[BQ&X,QJ!D!!$TX2Bq+E$f2LQ`pMi!!8
+!'!!#!!!2lP084%N!!!%(Fh4ND@mZD!!!"+KS%j5SD"18U'J6P!!'!"S!!J!!$qj
+659T&!!!!#(0THQ9IG#jS!'J!!kPX@KQTE&SCU@aD'3!(!"J!!3!!'C&$6dp5!!!
+!"f0[Eh*N,QJ!!!1TF(!,UA"`#kP`F!X!#!!D!!%!!"Q468&$3`!!!!PYB@0MEfj
+Q,QJ!!!5TE&T%U@aD4+PX@N3!#3!D!!%!!"Q48eP69!!!!!KcHA0dC@dZD!!!!!@
+SGB$#U(@!`UKeJ-)!#J!B!!)!!!p"9&P343!!!3GdHA"PFbjS!!!&TX2C"+E$f35
+Q`pN%!!X!'!!#!!!2lP4*688!!!%'G'PYC5jS!!!!"+K(*9bS4b9FU%FPA!!-!"S
+!!J!!$d&648G-!!!"#A0PCfa[B@3ZD!!!"+E$f*kQ`pLHTX2BRJ!0!"S!!J!!$qj
+69%4-!!!"#(0dC'aTBLjS!!!!"D3Y`#+N,F!LT#h!)J!1!"S!!J!!$qjA3dK"!!!
+!#AGMD'&bAh3ZD!!!"+K(*F#S4bA!U%FP`!!2!"S!!J!!$d&A58j%!!!"#AGTEQ4
+[Gh-ZD!!!"DK(*8+S4b9#U%FP3J!3!"`!!J!!$d&498P$!!!"#e&eD@0VC(*KGbj
+S!!!&TQ6C`+CNfF#QC0R!!"%!'J!#!!!2389@48i!!!%)4ACPER4c,QJ!,J!&U%F
+NKUK(*)DS4b5'!")!(!!#!!!238026P3!!!%+3fpZG(*[E(-ZD!!!!!5N-HP!T$(
+T3+3ak8!!%`!D!!)!!!p"68906`!!!3KYC@e[FRNZD!"S!!5S4b9#U%FP3UK(*8)
+!&!!F!!)!!!p"899*3`!!!3YaG@PMDf4bBAFZD!!!"+CNfF#QC0R!TQ6C`!!9!"S
+!!J!!$d&&9N91!!!"#'9fC@jdFbjS!#i!"+K(*)DS4b5'U%FNKJ!@!"`!!J!!$d&
+$6dj8!!!"#Q0[ER4bEfac,QJ!!!!%U%FN`+K(*-#S4b6!!"F!'J!#!!!2384*38`
+!!!%*C'PKE'pRFbjS!!!&U%FPM+K(*BbS4b@-!"J!(!!#!!!2394&@&3!!!%+9'9
+iG%9NDA3ZD!!!!!5S4b6fU%FNpUK(*2B!'3!B!!)!!!p"4Np19!!!!3GQEfjdFbj
+S!!!%T$(rN!#N-Iq3!+3arj!!!"S!'!!#!!!2lNC$6P3!!!%(CQ0ZG'`ZD!!!!DP
+X@MLTE&SiU@aD1!!E!"B!!3!!'C&23NSZ!!!!"@pLDLjS!!!"U@aD1DPX@MQTE&S
+j!"`!(!!"!!!CN8p#5N-!!!!+Ef*UBfaKFh-ZD!!!!!'TE&SpU@aD2DPX@Md!(3!
+B!!%!!"Q48&*28!!!!!C`FQp`,QJ!F`!"U@aDikPX@Z1TE&VM!"i!'J!"!!!Cfdp
+#5N8!!!!*Ef*UC@0dFbjM!!!#U@aD&kPX@KHTE&SA!"m!'!!"!!!CN8026%m!!!!
+(BfpXEh)ZD!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@ZJ!!!!D!!%!!"R
+E6d*+6J!!!!K[BQTZB@dZB`!!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!
+!!!CSB@0V,QJ!B`S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDk`!!!"S!!3!
+!'GY28&4*!!!!#@p`G'P[ER-ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380
+,!!!!"QKKBfXZD!!Z!!'TE&T&U@aD4DPX@N8!!3!D!!%!!"Q49%9563!!!!PdCA*
+YBf&`,QJ!!!'QE+UiTQbUZ+CXUVJ!!J!B!!)!!!rZ3e4C8!!!!3GMG(P`C5jS!!S
+!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aDi3!!!"S!!3!!'GY2AdP1!!!!#'p
+ID@jTG#jM!!!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!"
+M#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&VY!!!!'!!"!!!Cfe""4d8!!!!
+(F'&RCA)ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!
+!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&V[!!!!'J!"!!!Cfe"*3dX!!!!
+)F'PMDh9`,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbj
+S!'-+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@[%!!!!B!!%!!"RE8%a*6J!
+!!!G`E'PZC5jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbj
+S!!!!!DPX@L#TE&SJU@aD)!!"!"J!!3!!'C&&8&**!!!!"Q9`FQNZD!!!!!+TE&S
+HU@aD(UPX@Ki!!J!D!!%!!"Q44&914`!!!!PNG@jRC@pZ,QJ!!!+TE&S6U@aD%kP
+X@K-!!`!B!!%!!"Q438a*4`!!!!GKE'PRELjS!!S!!!!!!!!!!!!!!!!!!!!!!2r
+rrrrrrrrrU@aDm`!!!"`!!3!!'GY36daC!!!!#R"[E(PcC@aQ,Q-!!!!"UA"`EDP
+`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'B+!!!!!!!!!!!!!!!!!!!
+!!!$rrrrrrrrrrkPX@[8!!!!D!!%!!"RE8%p853!!!!K`Eh4TEfiZB`"M!!'TF("
+YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!B`S!!!!!!!!!!!!!!!!
+!!!!!!2rrrrrrrrrrU@aDq!!!!"J!!3!!'GY38N&C!!!!"R"bBANZB`"M!!'TF("
+YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!B`!"U@aD)+PX@L#TE&S
+J!!%!'!!"!!!CN8938NN!!!!'CA"bD5jS!'-!!UPX@KkTE&SHU@aD(J!#!"S!!3!
+!'C&%98j(!!!!#@4eEQGPEfiZD!!!!UPX@K1TE&S6U@aD%`!$!"J!!3!!'C&"6%P
+(!!!!"f&XD@GZ,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Vk!!!!'J!
+"!!!Cfe"5588!!!!)F(*TCA0d,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K
+"3dX!!!!'D'&MDbjS!'-!!DPX@LqTE&S[U@aD,`!"!"S!!3!!'C&04Nj%!!!!#@e
+QEQ4`Eh-ZD!!!!DPX@L'TE&SKU@aD)3!#!"J!!3!!'C&&8dK,!!!!"Q9cD'XZD!!
+Z!!+TE&SHU@aD(UPX@Ki!!`!D!!%!!"Q44&914`!!!!PNG@jRC@pZ,QJ!!!'TE&S
+JU@aD)+PX@L!!"!!B!!%!!"Q449"553!!!!CPF(*T,QJ!,J!#U@aD(UPX@KkTE&S
+H!!8!'J!"!!!CN8496NF!!!!*C(9ZCf9[ELjS!!!#U@aD%kPX@K1TE&S6!!B!'!!
+"!!!CN8&-58F!!!!(B@aTCfiZD!!!!DPX@KqTE&SIU@aD(`!(!"J!!3!!'C&&68P
+1!!!!"Q9YD@iZD!!!!!+TE&SHU@aD(UPX@Ki!#!!D!!%!!"Q44&914`!!!!PNG@j
+RC@pZ,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Vl!!!!'!!"!!!Cfe&
+949-!!!!(FA9PFh3ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QK
+KBfXZD!!!!!'TE&SqU@aD2UPX@Mi!!3!B!!%!!"Q4899&8`!!!!GaG@9cG#jS!!!
+"U@aD2UPX@MkTE&Sq!!)!'!!"!!!CN9&849J!!!!(FA4PH(3ZD!!+!!!!!!!!!!!
+!!!!!!!!!!!$rrrrrrrrrrkPX@[d!!!!F!!%!!"RE899&8`!!!!TaG@9cG("RFLj
+M!!!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!"b!!'TE&S
+qU@aD2UPX@Mi!!3!B!!%!!"Q4894&@!!!!!GaG'9iG#jS!!S!!!!!!!!!!!!!!!!
+!!!!!!2rrrrrrrrrrU@aDr`!!!"J!!3!!'GY548&%!!!!"R*PB@3ZB`"b!!'TF("
+YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!FJS!!!!!!!!!!!!!!!!
+!!!!!!2rrrrrrrrrrU@aE!3!!!"J!!3!!'GY54808!!!!"R*PBh3ZB`"b!!'TF("
+YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!FJS!!!!!!!!!!!!!!!!
+!!!!!!2rrrrrrrrrrU@aE!`!!!"S!!3!!'GY54908!!!!#A*PFh4[FQ8ZB`!!!DP
+`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!Z!!'TE&SVU@aD+kP
+X@LX!!3!@!!%!!"Q46%9@,J!!!!9XCABZD!!!!DPX@N@TE&T&U@aD43!#!"S!!3!
+!'C&849*0!!!!#A4PFQeMBA!ZD!!!!DPX@MkTE&SqU@aD2J!$!"J!!3!!'C&4989
+6!!!!"h&eCA0d,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&X%!!!!&J!
+"!!!Cfe**8#i!!!!&FQP`,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!
+!!!CSB@0V,QJ!,JS!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aE"!!!!"B!!3!
+!'GY56N3Z!!!!"A*ZC#jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!
+'D'&MDbjS!#i+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@`8!!!!D!!%!!"R
+E8P906`!!!!KbG@e[FR-ZB`!!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!
+!!!CSB@0V,QJ!B`S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aE#!!!!"J!!3!
+!'GY639C&!!!!"R0KGQ8ZB`"M!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!
+!!!CSB@0V,QJ!B`!"U@aD+kPX@LZTE&SV!!%!&J!"!!!CN8a&9Li!!!!&E'9f,QJ
+!!!'TE&SqU@aD2UPX@Mi!!J!B!!%!!"Q4899&8`!!!!GaG@9cG#jS!!S!!!!!!!!
+!!!!!!!!!!!!!!2rrrrrrrrrrU@aE$J!!!"B!!3!!'GY65%XZ!!!!"A0SDbjM!!!
+"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'-!!DPX@L'TE&S
+KU@aD)3!"!"J!!3!!'C&&8dK,!!!!"Q9cD'XZD!"M!!+TE&SHU@aD(UPX@Ki!!J!
+D!!%!!"Q44&914`!!!!PNG@jRC@pZ,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrr
+rrrqTE&X2!!!!'J!"!!!Cfe0)5di!!!!)FfKVEQ&Y,Q-!!!!"UA"`EDP`F'fTF("
+Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'-!!DPX@L'TE&SKU@aD)3!"!"J!!3!
+!'C&&8dK,!!!!"Q9cD'XZD!"M!!+TE&SHU@aD(UPX@Ki!!J!D!!%!!"Q44&914`!
+!!!PNG@jRC@pZ,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&X4!!!!&J!
+"!!!Cfe0*9#i!!!!&FfPd,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!
+!!!CSB@0V,QJ!B`!"U@aD&DPX@K@TE&S9!!%!(!!"!!!CN8&59%N!!!!+BA*dD@C
+KBh3ZD!!!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&X6!!!!'J!"!!!Cfe0
+298i!!!!)FfpeEQ4c,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!
+'D'&MDbjS!'-!!DPX@KkTE&SHU@aD(J!"!"J!!3!!'C&&4%p(!!!!"Q9NEfFZD!"
+M#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&XC!!!!'!!"!!!Cfe0348`!!!!
+(Fh"PE'`ZB`!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!
+!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&XA!!!!'J!"!!!Cfe03Ad`!!!!
+)Fh"IE'9f,Q-!D!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbj
+S!'-!!DPX@N'TE&T"U@aD33!"!"S!!3!!'C&68&p-!!!!#(0`AfaPGLjS!'J!!UP
+X@K1TE&S6U@aD%`!#!"J!!3!!'C&"6%P(!!!!"f&XD@GZ,QJ!!!'TE&SrU@aD2kP
+X@Mm!!`!B!!%!!"Q48N9$9!!!!!CbC@0d,QJ!!!S!!!!!!!!!!!!!!!!!!!!!!2r
+rrrrrrrrrU@aE'`!!!"J!!3!!'GY69%9"!!!!"h0dC@&X,Q-!!!'TF("YUA"`EDP
+`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!!!S!!!!!!!!!!!!!!!!!!!!!!2r
+rrrrrrrrrU@aE*`!!!"S!!3!!'GY858e&!!!!#A4TE@9[GA3ZB`!!!DP`F'fTF("
+YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!Z#J!!!!!!!!!!!!!!!!!!!!!
+!rrrrrrrrrrqTE&XT!!!!'J!"!!!Cfe428&3!!!!)G'p`G'9Z,Q-!!!!"UA"`EDP
+`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!'-+!!!!!!!!!!!!!!!!!!!
+!!!$rrrrrrrrrrkPX@bS!!!!B!!%!!"RE9&*"3`!!!!GdFQ&MDbjM!!!"UA"`EDP
+`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!!!!!
+!!!$rrrrrrrrrrkPX@bm!!!!B!!%!!"RE9&*"8!!!!!CdFQ&`,Q-!!!!"UA"`EDP
+`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!!!!!
+!!!$rrrrrrrrrrkPX@c8!!!!B!!%!!"RE98K*9!!!!!GeD'PdE5jM!!!"UA"`EDP
+`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!!!!!
+!!!$rrrrrrrrrrkPX@c%!!!!D!!%!!"RE99p*6J!!!!KeAfPZDA3ZB`"S!!'TF("
+YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!B`S!!!!!!!!!!!!!!!!
+!!!!!!2rrrrrrrrrrU@aE0`!!!"J!!3!!'GY@399-!!!!"hCKG@ad,Q-!!!'TF("
+YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!!!!"U@aD5UPX@NUTE&T
++!!%!'!!"!!!CN9C"98`!!!!(GQ&eE(3ZD!!!!UPX@KkTE&SHU@aD(J!#!"S!!3!
+!'C&%98j(!!!!#@4eEQGPEfiZD!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkP
+X@cF!!!!D!!%!!"RE9N958`!!!!PfCA*cD@pZ,Q-!!!'TF("YUA"`EDP`F'd!!!!
+B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,J!"U@b"6DPXJ8fTE)&0!!%!'!!"!!!CN84
+"9%8!!!!'C'&dC5jS!#i!!DPX@MZTE&SlU@aD1`!#!"i!!3!!'C&3394$!!!!$("
+KG'0SE'9fC@`ZD!"Z#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Xm!!!!'J!
+"!!!CfeC*8dN!!!!)GQPcD@pZ,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K
+"3dX!!!!'D'&MDbjS!'-)!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPXJ9N!!!!
+D!!%!!"RE9NP6A`!!!!PfDA0IG'&L,Q-!!!'TE&SBU@aD'+PX@KJ!!3!D!!%!!"Q
+43dp14J!!!!KMEfjQD@FZD!!!!!+TE&T'U@aD4UPX@NB!!J!F!!%!!"Q49&*"4!!
+!!!TdFQ&NFh4NBbjS!'J!!k3Y["+N,E`5T#fm%J!$!"S!!J!!$qj69%4"!!!"#(0
+dC'&bCbjS!'J!!UPX@LQTE&STU@aD+3!%!"S!!3!!'C&(6%p#!!!!#'GXEf*KE#j
+S!'J!!kE$f2LQ`pMiTX2Bq!!&!"J!!J!!$qj69%4*!!!""h0dC'P[,QJ!!!5SD"1
+8U'J6P+KS%j3!"J!D!!)!!!rZ8dPD43!!!!KcDATPAh3ZD!"S!!1TE&SCU@aD'DP
+X@KN!"`!B!!%!!"Q43dp28J!!!!GMEfpbC#jS!!!$UA"`#kP`F!ZTF(!,!!J!'J!
+"!!!CN8e"3d-!!!!*E@&MBfpZCLjS!!!%U@aD4+PX@N5TE&T%!!N!'J!"!!!CN90
+C8e3!!!!)FhPcG'9Y,QJ!!!!&U(@!`UKeJ-+SGB$#!!S!'!!#!!!2394C8%8!!!%
+(G(P`CA-ZD!!!"DE$f35Q`pN%TX2C"!!,!"J!!J!!$qj858e&!!!""R4TE@8ZD!!
+!!!5S4b9FU%FPA+K(*9`!$!!D!!)!!!p"8d9(6!!!!3PcC@GXEf&N,QJ!!!5Q`pL
+HTX2BRUE$f*i!$3!D!!)!!!rZ8e4%6!!!!3KcG'4XD@)ZD!!!!!@N,F!LT#h!)U3
+Y`#)!$J!D!!)!!!rZ9d0)33!!!!PhBfKKFPpd,QJ!!!5S4bA!U%FP`+K(*F!!$`!
+D!!)!!!p"9dP14!!!!3PhD@jNEhGc,QJ!!!@S4b9#U%FP3UK(*8)!%!!F!!)!!!p
+"899*3`!!!3Y4G@PMDf4bBAFZD!!!"DCNfF#QC0R!TQ6C`!!4!"S!!J!!$d&&9N9
+1!!!"#%9fC@jdFbjS!#i!"DK(*)DS4b5'U%FNKJ!5!"`!!J!!$d&$6dj8!!!"#N0
+[ER4bEfac,QJ!!!!%T$(T3+3ak8#N-HP!!"-!'J!#!!!238e&68m!!!%)E@9YEh*
+j,QJ!D!!%U%FP3UK(*8+S4b9#!"3!(!!#!!!239&958-!!!%,FA9TBfYNFQ&h,QJ
+!!!5QC0R!TQ6C`+CNfF!!&3!D!!)!!!p"49C&6J!!!3KPGQ9ZG(-ZD!!Z!!5S4b5
+'U%FNKUK(*)B!&J!F!!)!!!p"3dp19!!!!3TMEfjdFQpXFbjS!!!!"+K(*-#S4b6
+!U%FN`!!A!"S!!J!!$d&%58&-!!!"#@4TB@a[Ch-ZD!!!"DK(*BbS4b@-U%FPM!!
+B!"`!!J!!$d&849K8!!!"#P4PH(4&C'Pd,QJ!!!!%U%FNpUK(*2DS4b6f!"N!'!!
+#!!!238C26P3!!!%(CQpZG(-ZD!!!"+3arj!!T$(rN!#N-Iq3!!!D!"J!!J!!$qj
+'3dj8!!!""fCMER4X,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Xq!!!
+!'J!"!!!CfeG&39!!!!!)Gf9KF'pZ,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!
+CN8K"3dX!!!!'D'&MDbjS!'-+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@cm
+!!!!B!!%!!"RE9d9543!!!!ChCA*P,Q-!B`!"UA"`EDP`F'fTF("Y!!!!'!!"!!!
+CN8K"3dX!!!!'D'&MDbjS!'-+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@d%
+!!!!B!!%!!"RE9dP&6!!!!!GhD@9XC#jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!
+CN8K"3dX!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@d8
+!!!!B!!%!!"RE9dp563!!!!ChEh*Y,Q-!D!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!
+CN8K"3dX!!!!'D'&MDbjS!'J!!DPX@LZTE&SVU@aD+`!"!"B!!3!!'C&-49BZ!!!
+!"@aPGLjS!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aE3`!!!"S!!3!!'GY
+A59T"!!!!#(GTHQ&bC#jM!!!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!"M!!'TE&SqU@aD2UPX@Mi!!3!B!!%!!"Q4894&@!!!!!GaG'9iG#j
+S!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aE4J!!!"J!!3!!'GYA6e*1!!!
+!"RG[FQiZB`"S!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!D!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aE4`!!!"J!!3!!'GYA8NP8!!!
+!"hGbDA4P,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!!!S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aE6!!!!"B!!3!!'GYD39!Z!!!
+!"ATKF#jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkP`EZS!!!!D!!%!!"T!4&"553!!!!P
+NF(*TER4Q,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!,J!"UA"2KkP`6iHTF%q(!!%!'J!"!!!CN8e"3eF!!!!)E@&MGfPZ,QJ!!!!"U(@
+!`UKeJ-+SGB$#!!)!'!!#!!!2394C8%8!!!%(9(P`CA-ZD!!)!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPXMYS!!!!D!!%!!"T!68&$9!!!!!KYB@0dG(NZB`!!!!'
+TE&SfU@aD0UPX@MB!!3!F!!%!!"Q46948@3!!!!TYG(4jF(*TGLjS!'8!!UPX@Lf
+TE&SYU@aD,3!#!"S!!3!!'C&03808!!!!#'eKBh4dH5jS!'J!!kK(*F#S4bA!U%F
+P`!!$!"S!!J!!$d&A58j%!!!"#9GTEQ4[Gh-ZD!!!"+K(*8+S4b9#U%FP3J!%!"`
+!!J!!$d&498P$!!!"#e&eD@0VC(*KGbjS!!!&U(@!`UKeJ-+SGB$#!!8!'!!#!!!
+2394C8%8!!!%(9(P`CA-ZD!!!"+CNfF#QC0R!TQ6C`!!'!"S!!J!!$d&&9N91!!!
+"#%9fC@jdFbjS!#i!"+K(*)DS4b5'U%FNKJ!(!"`!!J!!$d&$6dj8!!!"#N0[ER4
+bEfac,QJ!!!!$U%FI"UK((`DS4am'!!J!(J!#!!!239&%6dB!!!%08842CQCcBh*
+PC@iZD!!!!kK(*2DS4b6fU%FNpJ!*!"J!!J!!$d&'6dj8!!!""dC[ER4c,QJ!!!1
+N-HP!T$(T3+3ak8!!#J!D!!)!!!p"68906`!!!3K0C@e[FRNZD!"P!!1S4b8LU%F
+P)UK(*5)!#`!D!!)!!!p"6e099!!!!3P28e9dD@ac,QJ!!!1N-HP!T$(T3+3ak8!
+!$!!D!!)!!!p"49*56`!!!3K&FR*[FR-ZD!!!!!1QC0R!TQ6C`+CNfF!!$3!H!!)
+!!!p"4d969!!!!3a(CA0dB@ad4A&e,QJ!!!!$TQ6C`+CNfF#QC0R!!!i!(!!#!!!
+239""6%8!!!%+8'&XCA4dCA-ZD!"S!!1S4b5ZU%FNVUK(*+i!$`!B!!)!!!p"4%9
+65`!!!3C%CA0V,QJ!F`!$U%FNdUK(*0+S4b65!"!!(!!#!!!2384*8dX!!!%+4'P
+cDdPZDA3ZD!"S!!1N-HP!T$(T3+3ak8!!%3!F!!)!!!p"6e0&9J!!!3T28d9fC@j
+dFbjS!'J!!DE$f2LQ`pMiTX2Bq!!5!"J!!J!!$qj69%4*!!!""h0dC'P[,QJ!!!+
+SD"18U'J6P+KS%j3!%`!D!!)!!!rZ8dPD43!!!!KcDATPAh3ZD!"S!!'N,E`5T#f
+m%U3Y[")!&!!D!!)!!!rZ8e4%33!!!3KcG'4KFQFZD!"S#J!!!!!!!!!!!!!!!!!
+!!!!!rrrrrrrrrrqTE&Z+!!!!(!!"!!!D3%e89&N!!!!+EA4dH@eKD@iZB`!!!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!EJ!"UA"2KkP`6iH
+TF%q(!!%!'J!"!!!CN8e"3eF!!!!)E@&MGfPZ,QJ!B`!"U@aD8DPX@P'TE&T4!!)
+!'J!"!!!CN9G*6P3!!!!)GfPZG(4j,QJ!B`!"U@aD,DPX@LfTE&SY!!-!'J!"!!!
+CN8e"3e3!!!!)E@&MG(4j,QJ!B`!#U%FP`+K(*F#S4bA!!!3!'J!#!!!239G*6N3
+!!!%*9fPZC'phFbjS!!!#U%FI"UK((`DS4am'!!8!(J!#!!!239&%6dB!!!%0884
+2CQCcBh*PC@iZD!!!!UK(*2DS4b6fU%FNpJ!'!"J!!J!!$d&'6dj8!!!""dC[ER4
+c,QJ!!!+N-HP!T$(T3+3ak8!!"`!D!!)!!!p"68906`!!!3K0C@e[FRNZD!"P!!+
+S4b8LU%FP)UK(*5)!#!!D!!)!!!p"6e099!!!!3P28e9dD@ac,QJ!!!+N-HP!T$(
+T3+3ak8!!#3!D!!)!!!p"49*56`!!!3K&FR*[FR-ZD!!!!!+QC0R!TQ6C`+CNfF!
+!#J!H!!)!!!p"4d969!!!!3a(CA0dB@ad4A&e,QJ!!!!#TQ6C`+CNfF#QC0R!!!X
+!(!!#!!!239""6%8!!!%+8'&XCA4dCA-ZD!"S!!+S4b5ZU%FNVUK(*+i!$!!B!!)
+!!!p"4%965`!!!3C%CA0V,QJ!F`!#U%FNdUK(*0+S4b65!!d!(!!#!!!2384*8dX
+!!!%+4'PcDdPZDA3ZD!"S!!+N-HP!T$(T3+3ak8!!$J!F!!)!!!p"6e0&9J!!!3T
+28d9fC@jdFbjS!'J!!DK(*4US4b8DU%FP'J!2!"J!!J!!$d&048j9!!!""dePER9
+c,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&YX!!!!'J!"!!!D3%e"3d-
+!!!!*E@&MBh9bFbjM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&
+MDbjS!#i!!DP`6iHTF%q(UA"2K`!"!"S!!3!!'C&0380A!!!!#'eKBhGTELjS!!!
+!!D3ak8#N-HP!T$(T3!!#!"S!!J!!$d&'6da%!!!"#8C[E'4PFR-ZD!!!!UK(*1U
+S4b6UU%FNkJ!$!"J!!J!!$d&'58a&!!!""dCTE'9c,QJ!!!1S4b8LU%FP)UK(*5)
+!"!!D!!)!!!p"6e099!!!!3P28e9dD@ac,QJ!!!'S4bA!U%FP`+K(*F!!"3!D!!)
+!!!p"9dP14!!!!3PAD@jNEhGc,QJ!!!'S4b@@U%FPPUK(*CB!"J!F!!)!!!p"9%p
+26!!!!3Y8EfpX9A4TE(-ZD!!!!DK(*8bS4b9-U%FP6!!(!"`!!J!!$d&54902!!!
+"#e*PFfpeFQ0PFbjS!!!"T$(T3+3ak8#N-HP!!!J!'J!#!!!238e&68m!!!%)6@9
+YEh*j,QJ!,J!"U%FNkUK(*1US4b6U!!N!'!!#!!!238C*6%8!!!%(4QPXCA-ZD!!
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@fd!!!!D!!%!!"T!68&$43!!!!P
+YB@0PFR*c,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!,J!"U%FP)UK(*5+S4b8L!!%!'J!#!!!238p6993!!!%*6e09G'PXFbjS!!!"U%F
+NkUK(*1US4b6U!!)!'!!#!!!238C*6%8!!!%(CQPXCA-ZD!!!!DKeJ-+SGB$#U(@
+!`J!$!"J!!J!!$d&8@9"&!!!""e4jF'9c,QJ!!!'Rk`3NTqX%*+IV"#3!"!!D!!)
+!!!qU8%&63`!!!3K`BA0MB@`ZD!!!!!'S4b6!U%FN`+K(*-!!"3!D!!)!!!p"4%P
+"6!!!!3P%D@&XEfGc,QJ!!!'S4b8bU%FP-UK(*6)!"J!F!!)!!!p"8%&$5`!!!3T
+3B@0VB@GPFbjS!!!!!UK(*@DS4b9QU%FPCJ!(!#!!!J!!$d&69%&1!!!"$P0dB@j
+NBA*N4QPXC5jS!#i!!UCNfF#QC0R!TQ6C`!!)!"S!!J!!$d&63e**!!!"#&0MFQP
+`G#jS!'N!!UKaFJkSFA)1U(&b$J!*!"B!!J!!$kT#4%-Z!!!""8*%3bjS!!!"U%F
+PPUK(*CDS4b@@!!S!(!!#!!!239426d`!!!%,9'p[E&9dD@ac,QJ!!!'S4b9-U%F
+P6+K(*8`!#`!F!!)!!!p"8N966`!!!3Y5CA0[GA*MCA-ZD!!+!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPX@fi!!!!D!!%!!"T!68&$4J!!!!PYB@0QD@aP,Q-!!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,J!"U%FNkUK(*1U
+S4b6U!!%!'!!#!!!238C*6%8!!!%(CQPXCA-ZD!!!!UK(*5+S4b8LU%FP)J!#!"S
+!!J!!$d&28e98!!!"#8p69A4TE(-ZD!!!!D3ak8#N-HP!T$(T3!!$!"S!!J!!$d&
+&8P*2!!!"#'9bFQpbFbjS!!!!!DK(*8bS4b9-U%FP6!!%!"`!!J!!$d&54902!!!
+"#h*PFfpeFQ0PFbjS!!!"T$(T3+3ak8#N-HP!!!8!'J!#!!!238e&68m!!!%)E@9
+YEh*j,QJ!,J!"U%FPPUK(*CDS4b@@!!B!(!!#!!!239426d`!!!%,9'p[E&9dD@a
+c,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Ya!!!!'J!"!!!D3%e"3dd
+!!!!*E@&ME@&TELjM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&
+MDbjS!#i!!DP`6iHTF%q(UA"2K`!"!"S!!3!!'C&0380A!!!!#'eKBhGTELjS!!!
+!!DK(*5+S4b8LU%FP)J!#!"S!!J!!$d&28e98!!!"#8p69A4TE(-ZD!!!!DK(*1U
+S4b6UU%FNkJ!$!"J!!J!!$d&'58a&!!!""fCTE'9c,QJ!!!'SGB$#U(@!`UKeJ-)
+!"!!B!!)!!!p"9&P343!!!3G8HA"PFbjS!!!"U%FN`+K(*-#S4b6!!!8!'J!#!!!
+2384*38`!!!%*4'PKE'pRFbjS!!!"U%FP-UK(*6+S4b8b!!B!(!!#!!!239""3dX
+!!!%+8'&MDf&RCA-ZD!!!!!+S4b9QU%FPCUK(*@B!"`!J!!)!!!p"8e4"6J!!!3j
+6G'&ZC'&bC%CTE'8ZD!!Z!!+QC0R!TQ6C`+CNfF!!#!!D!!)!!!p"8d0553!!!3K
+6Bh*TF(3ZD!"T!!+SFA)1U(&b$UKaFJi!#3!@!!)!!!qU3N4$,J!!!39#4%-ZD!!
+!!DK(*CDS4b@@U%FPPJ!+!"`!!J!!$d&86dp-!!!"#e4[Efa9G'PXFbjS!!!"U%F
+P6+K(*8bS4b9-!!X!(!!#!!!239*&8dm!!!%,8Q9cEh9bBf9c,QJ!!!'N-HP!T$(
+T3+3ak8!!$!!D!!)!!!p"49*56`!!!3K&FR*[FR-ZD!!Z#J!!!!!!!!!!!!!!!!!
+!!!!!rrrrrrrrrrqTE&Yc!!!!'J!"!!!D3%e"3dd!!!!*E@&ME@9ZG5jM!!!"UA"
+`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i!!DP`6iHTF%q(UA"
+2K`!"!"S!!3!!'C&0380A!!!!#'eKBhGTELjS!!!!!DPX@MZTE&SlU@aD1`!#!"i
+!!3!!'C&3394$!!!!$("KG'0SE'9fC@`ZD!"S!!'S4b5ZU%FNVUK(*+i!!`!B!!)
+!!!p"4%965`!!!3C%CA0V,QJ!GJ!"U%FP'UK(*4US4b8D!!3!'!!#!!!238e&6P8
+!!!%(6@9ZGA-ZD!!!!DK(*8bS4b9-U%FP6!!&!"`!!J!!$d&54902!!!"#e*PFfp
+eFQ0PFbjS!!!#U%FNkUK(*1US4b6U!!B!'!!#!!!238C*6%8!!!%(4QPXCA-ZD!!
+!!kK(*5+S4b8LU%FP)J!(!"S!!J!!$d&28e98!!!"#8p69A4TE(-ZD!!!!DK(*Bb
+S4b@-U%FPM!!)!"`!!J!!$d&849K8!!!"#P4PH(4&C'Pd,QJ!!!!"U%FPPUK(*CD
+S4b@@!!N!(!!#!!!239426d`!!!%,9'p[E&9dD@ac,QJ!!!'S4b8bU%FP-UK(*6)
+!#J!F!!)!!!p"8%&$5`!!!3T3B@0VB@GPFbjS!!!!!UK(*@DS4b9QU%FPCJ!,!#!
+!!J!!$d&69%&1!!!"$P0dB@jNBA*N4QPXC5jS!#i!!UCNfF#QC0R!TQ6C`!!-!"S
+!!J!!$d&63e**!!!"#&0MFQP`G#jS!'N!!UKaFJkSFA)1U(&b$J!0!"B!!J!!$kT
+#4%-Z!!!""8*%3bjS!!!"TqX%*+IV"#5Rk`3N!!i!'J!#!!!2UP""8d-!!!%)F'&
+cBf&X,QJ!D3S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@aEG!!!!"S!!3!!'N"
+03806!!!!#'eKBh0ZC#jM!!!!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!
+!"QKKBfXZD!"M!!'Ra*`mTm5F2+I%R$`!!3!B!!)!!!p"8dp96J!!!3G6Eh9ZC#j
+S!!!#U%FNkUK(*1US4b6U!!)!'!!#!!!238C*6%8!!!%(4QPXCA-ZD!!!!kK(*5+
+S4b8LU%FP)J!$!"S!!J!!$d&28e98!!!"#8p69A4TE(-ZD!!!!DK(*8bS4b9-U%F
+P6!!%!"`!!J!!$d&54902!!!"#e*PFfpeFQ0PFbjS!!S!!!!!!!!!!!!!!!!!!!!
+!!2rrrrrrrrrrUA"4i3!!!"S!!3!!'N"03808!!!!#@eKBh4[F'`ZB`!!!DP`F'f
+TF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!Z!!'TF%q(UA"2KkP`6iF
+!!3!D!!%!!"Q468&$9`!!!!KYB@0hD@iZD!!!!!'S4b6!U%FN`+K(*-!!!J!D!!)
+!!!p"4%P"6!!!!3P%D@&XEfGc,QJ!!!'S4b8LU%FP)UK(*5)!!`!D!!)!!!p"6e0
+99!!!!3P28e9dD@ac,QJ!!!'S4b8bU%FP-UK(*6)!"!!F!!)!!!p"8%&$5`!!!3T
+3B@0VB@GPFbjS!!!!!UK(*@DS4b9QU%FPCJ!&!#!!!J!!$d&69%&1!!!"$P0dB@j
+NBA*N4QPXC5jS!#i!!kK(*1US4b6UU%FNkJ!'!"J!!J!!$d&'58a&!!!""dCTE'9
+c,QJ!!!+QC0R!TQ6C`+CNfF!!"`!D!!)!!!p"8d0553!!!3K6Bh*TF(3ZD!"T!!+
+SFA)1U(&b$UKaFJi!#!!@!!)!!!qU3N4$,J!!!39#4%-ZD!!+!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPX@hN!!!!D!!%!!"T!68&$93!!!!PYB@0eEQPi,Q-!!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!,JS!!!!!!!!!!!!
+!!!!!!!!!!2rrrrrrrrrrU@aE33!!!"S!!3!!'GYA58j%!!!!#AGTEQ4[Gh-ZB`!
+!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!Z!!'TE&T4U@a
+D8DPX@P%!!3!D!!%!!"Q49dP19!!!!!KhD@jdG(NZD!!!#J!!!!!!!!!!!!!!!!!
+!!!!!rrrrrrrrrrqTE&Z#!!!!(!!"!!!D3%e(493!!!!+E@GPG'aTEQ8ZB`!!!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!C3!"UA"2KkP`6iH
+TF%q(!!%!'J!"!!!CN8e"3eF!!!!)E@&MGfPZ,QJ!B`!"U@aD*kPX@LHTE&SR!!)
+!(!!"!!!CN8C96N-!!!!+CR9ZBepdB@)ZD!!!!!'S4b6!U%FN`+K(*-!!!`!D!!)
+!!!p"4%P"6!!!!!P%D@&XEfGc,QJ!!!'S4b8bU%FP-UK(*6)!"!!F!!)!!!p"8%&
+$5`!!!3T3B@0VB@GPFbjS!!!!!UK(*@DS4b9QU%FPCJ!&!#!!!J!!$d&69%&1!!!
+"$P0dB@jNBA*N4QPXC5jS!#i!!kK(*1US4b6UU%FNkJ!'!"J!!J!!$d&'58a&!!!
+""dCTE'9c,QJ!!!5S4b8LU%FP)UK(*5)!"`!D!!)!!!p"6e099!!!!3P28e9dD@a
+c,QJ!!!+QC0R!TQ6C`+CNfF!!#!!D!!)!!!p"8d0553!!!3K6Bh*TF(3ZD!!!!!+
+SFA)1U(&b$UKaFJi!#3!@!!)!!!qU3N4$,J!!!39#4%-ZD!!+!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPaDGJ!!!!D!!%!!"T!68&$9`!!!!KYB@0hD@iZB`!!!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!B`!"U@aD*kPX@LH
+TE&SR!!%!(!!"!!!CN8C96N-!!!!+CR9ZBepdB@)ZD!"P!!'TF%q(UA"2KkP`6iF
+!!J!D!!%!!"Q468&$9`!!!!KYB@0hD@iZD!"S!!'TE&SYU@aD,DPX@Ld!!`!D!!%
+!!"Q468&$9!!!!!KYB@0dG(NZD!"S!!+S4bA!U%FP`+K(*F!!"!!D!!)!!!p"9dP
+14!!!!3PAD@jNEhGc,QJ!!!+S4am'U%FI"UK((`B!"3!H!!)!!!p"88424J!!!3e
+44%pQCR0MFQ9PELjS!!!#U%FNpUK(*2DS4b6f!!B!'!!#!!!238C26P3!!!%(4Qp
+ZG(-ZD!!!!U3ak8#N-HP!T$(T3!!(!"S!!J!!$d&048e2!!!"#%ePE@pbH5jS!'8
+!!UK(*5+S4b8LU%FP)J!)!"S!!J!!$d&28e98!!!"#8p69A4TE(-ZD!!!!U3ak8#
+N-HP!T$(T3!!*!"S!!J!!$d&&8P*2!!!"#%9bFQpbFbjS!!!!!UCNfF#QC0R!TQ6
+C`!!+!"i!!J!!$d&(4908!!!"$%GPFh4KE(4&FA8ZD!!!!!+QC0R!TQ6C`+CNfF!
+!#`!F!!)!!!p"8%&-43!!!3T3B@aPG(4PFbjS!'J!!UK(*+kS4b5ZU%FNVJ!-!"J
+!!J!!$d&%490,!!!""N4PFfXZD!"c!!+S4b65U%FNdUK(*0)!$3!F!!)!!!p"4%P
+65`!!!3T%DA0V5@jTG#jS!'J!!U3ak8#N-HP!T$(T3!!1!"`!!J!!$d&28d9@!!!
+"#Np64ACPER4c,QJ!D!!"U@aD8DPX@P'TE&T4!!m!'J!"!!!CN9G*6P3!!!!)GfP
+ZG(4j,QJ!D!!"U%FP)UK(*5+S4b8L!"!!'J!#!!!238p6993!!!%*Eh0eG'PXFbj
+S!!!"U%FN`+K(*-#S4b6!!"%!'J!#!!!2384*38`!!!%*C'PKE'pRFbjS!!!"U%F
+PM+K(*BbS4b@-!")!(!!#!!!2394&@&3!!!%+G'9iG'9NDA3ZD!"S!!'S4b8DU%F
+P'UK(*4S!%`!B!!)!!!p"689193!!!3GYC@jeFbjS!!!"U!(8j+J"e15S!G6N!"3
+!'!!#!!!2UNa2688!!!%(6'p0C@dZD!!!!U3ak8#N-HP!T$(T3!!9!"S!!J!!$d&
+%49C*!!!"#84PGQPMCA-ZD!!!!kK(*1US4b6UU%FNkJ!@!"J!!J!!$d&'58a&!!!
+""dCTE'9c,QJ!!!+N-HP!T$(T3+3ak8!!&`!B!!)!!!p"8d0533!!!3G6Bh*KF#j
+S!!!"U%FP6+K(*8bS4b9-!"J!(!!#!!!239*&8dm!!!%,FQ9cEh9bBf9c,QJ!!!'
+S4b5ZU%FNVUK(*+i!'3!B!!)!!!p"4%965`!!!3CNCA0V,QJ!C3!"TQ6C`+CNfF#
+QC0R!!"S!(J!#!!!238G&8e3!!!%-Cf9cG'&XG'9aG5jS!!!!!DCNfF#QC0R!TQ6
+C`!!E!"`!!J!!$d&#38a-!!!"#Q*KE'a[Efjc,QJ!D!!#Tp0hpUI6GrDRdhIf!"`
+!'!!#!!!2394539!!!!%(9(*KF(-ZD!!!!DK(*CDS4b@@U%FPPJ!G!"`!!J!!$d&
+86dp-!!!"#h4[EfaeG'PXFbjS!!!"TQ6C`+CNfF#QC0R!!"i!'J!#!!!2390$8NN
+!!!%)Ff0bDA"d,QJ!,J!"T$(T3+3ak8#N-HP!!"m!(!!#!!!238p649B!!!%+6e0
+&GQ9ZG(-ZD!!!!!'S4b8bU%FP-UK(*6)!)!!F!!)!!!p"8%&$5`!!!3T3B@0VB@G
+PFbjS!!!!!UK(*@DS4b9QU%FPCJ!K!#!!!J!!$d&69%&1!!!"$P0dB@jNBA*N4QP
+XC5jS!(-!!UKaFJkSFA)1U(&b$J!L!"B!!J!!$kT#4%-Z!!!""8*%3bjS!!!"Tm5
+F2+I%R$bRa*`m!#-!'!!#!!!2390298i!!!%(8fpeEQ3ZD!!!!DK(*0+S4b65U%F
+NdJ!N!"`!!J!!$d&%590,!!!"#N4TFfY*EQPd,QJ!C3S!!!!!!!!!!!!!!!!!!!!
+!!2rrrrrrrrrrU@aEi`!!!"S!!3!!'TC(494-!!!!#@GPG'aTEQ8ZB`!!!DP`F'f
+TF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!!Z!!'TE&T4U@aD8DPX@P%
+!!3!D!!%!!"Q49dP19!!!!!KhD@jdG(NZD!!!!!'TE&SRU@aD*kPX@LF!!J!F!!%
+!!"Q44P913`!!!!TQG@jMAh4KBLjS!!!+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrr
+rrkPX@qB!!!!B!!%!!"U@9%p36!!!!!CdEh"X,Q-!,J!"UA"`EDP`F'fTF("Y!!!
+!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!#i!!DPX@N@TE&T&U@aD43!"!"S!!3!!'C&
+849*0!!!!#A4PFQeMBA!ZD!!!!DPX@P'TE&T4U@aD83!#!"S!!3!!'C&A58j8!!!
+!#(GTER4dH5jS!!!!!DCXUVLQE+UiTQbUZ!!$!"J!!J!!$qj$9&P3!!!""f0dHA"
+P,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&[U!!!!'J!"!!!DPPG*6P3
+!!!!)GfPZG(4j,Q-!!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&
+MDbjS!'-!!DPX@P'TE&T4U@aD83!"!"S!!3!!'C&A58j8!!!!#(GTER4dH5jS!!!
++!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@i3!!!!D!!%!!"T!68e24!!!!!K
+YE@pNB@`ZB`!!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ
+!B`!"UA"2KkP`6iHTF%q(!!%!'J!"!!!CN8e"3eF!!!!)E@&MGfPZ,QJ!!!!"U%F
+P)UK(*5+S4b8L!!)!'J!#!!!238p6993!!!%*6e09G'PXFbjS!!S!!!!!!!!!!!!
+!!!!!!!!!!2rrrrrrrrrrU@aEUJ!!!"S!!3!!'Q0538j%!!!!#(*KEQ4[E5jM!!!
+!!DP`F'fTF("YUA"`E3!!!"J!!3!!'C&)380,!!!!"QKKBfXZD!"M!!!!!!!!!!!
+!!!!!!!!!!!!!rrrrrrrrrrqTE&Z,!!!!'J!"!!!D3%j&9%J!!!!*6Q9d5'&MDbj
+b!!!"TQ6C`+CNfF#QC0R!!!%!'!!#!!!2S94C8%8!!!!(9(P`CA-ZFJ!!!DCNfF#
+QC0R!TQ6C`!!#!"`!!J!!$k&6@908!!!!#P0jFe4jF'9c,R)!C3!"TQ6C`+CNfF#
+QC0R!!!-!)!!#!!!2S8*"6%`!!!!13Q&XE'p[EP4jF'9c,R)!,J!!U@aCe+PX@G5
+TE&R8!!!!&J!"!!!CAdK&6&!!!!!%D'9XF!"[!!#TE&RbU@aCmUPX@I)!!!!B!!%
+!!"PI9dPD5!!!!!GhDATSC@a`!!!!U@aChDPX@GfTE&RG!!!!'!!"!!!CAdp39%J
+!!!!(Eh"dD'9XF!!!!+PX@fqTE&Y[U@aEE`!!!"J!!3!!'9j0380)!!!!"deKBdK
+PE(!!!!#TE&R9U@aCeDPX@G8!!!!8!!%!!"PI5%JJ)!!!!!*SD!")!!#TE&R@U@a
+CeUPX@GB!!!!B!!%!!"PI5%P69!!!!!GSDA0dEh*j!!!!U@aCfUPX@GUTE&RD!!!
+!'!!"!!!CAda*3d8!!!!(E'PMC@jcC3!!!+PX@ibTE&Z-U@aEM!!!!"B!!3!!'N"
+149G6!!!!"%jPGh-!F`!!U@b"6DPXJ8fTE)&0!!!!'!!"!!!CAdp39%N!!!!(Eh"
+dD@pZF`!!!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@j)!!!!H!!%!!"T!6N9
+85!!!!!a1CA4)B@0V,R*cFQ-!EJ!!!!!CN8e"3eF!!!!)E@&MG`!!!!%!!!!)"'e
+KD@iJ)##S4b6!!!)!'J!#!!!2384*38`!!!%*4'PKE'pRFbjS!!!"U%FP)UK(*5+
+S4b8L!!-!'J!#!!!238p6993!!!%*6e09G'PXFbjS!!!"U%FP-UK(*6+S4b8b!!3
+!(!!#!!!239""3dX!!!%+8'&MDf&RCA-ZD!!!!!+S4b9QU%FPCUK(*@B!"3!J!!)
+!!!p"8e4"6J!!!3j6G'&ZC'&bC%CTE'8ZD!!Z!!1S4b6UU%FNkUK(*1S!"J!B!!)
+!!!p"4NP-43!!!3G'D@aPFbjS!!!#TQ6C`+CNfF#QC0R!!!F!'J!#!!!2390$8NN
+!!!%)8f0bDA"d,QJ!D3!#U(&b$UKaFJkSFA)1!!J!&J!#!!!2UN*%3bi!!!%&3N4
+$,QJ!#J!!!!!!!!!!!!!!!!!!!!!!rrrrrrrrrrqTE&Yj!!!!'J!"!!!D3%e"3e8
+!!!!*E@&MG@jTH#jM!!!"UA"`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&
+MDbjS!#i+!!!!!!!!!!!!!!!!!!!!!!$rrrrrrrrrrkPX@d%!!!!D!!%!!"RE9dP
+14!!!!!PhD@jNEhGc,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!C
+SB@0V,QJ!,J!"U@aD8DPX@P'TE&T4!!%!'J!"!!!CN9G*6P3!!!!)GfPZG(4j,QJ
+!!!!!!!$rrrrrrrrrrkPX@bm!!!!B!!%!!"RE9&*"8!!!!!CdFQ&`,Q-!!!!"UA"
+`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPX@c8!!!!B!!%!!"RE98K*9!!!!!GeD'PdE5jM!!!"UA"
+`EDP`F'fTF("Y!!!!'!!"!!!CN8K"3dX!!!!'D'&MDbjS!!!+!!!!!!!!!!!!!!!
+!!!!!!!$rrrrrrrrrrkPX@c%!!!!D!!%!!"RE99p*6J!!!!KeAfPZDA3ZB`"S!!'
+TF("YUA"`EDP`F'd!!!!B!!%!!"Q45%&$5`!!!!CSB@0V,QJ!BkP`F'd!!!!B!!%
+!!"Q45%&$5`!!!!CSB@0V,QJ!B`S!!!!!!!!!!!!!!!!!!!!!!2rrrrrrrrrrU@a
+Dl3!!!"J!!3!!'GY338G&!!!!"h"KCf9b,Q-!!!'TF("YUA"`EDP`F'd!!!!B!!%
+!!"Q45%&$5`!!!!CSB@0V,QJ!!!!!!!!!!!!S!!)!!"q!!!!!!!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3)
+!$`!!!!!!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!#)(!"!!!!!!!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!L!J!&!!!!!J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!`B
+!"J!!!!-!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!3)!!F!!!!%!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#!`!)!!!!"3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!J-
+!!`!!!!B!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!)$!!S!!!!(!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$"J!,!!!!#!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)33
+!$!!!!!N!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!-'!!3!!!!+!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$"J!1!!!!#`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!`B
+!%3!!!!`!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!#%%!")!!!!0!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%#!!6!!!!$J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!38
+!&!!!!!m!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!%&!"8!!!!3!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%#!!@!!!!%3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"!J
+!&`!!!")!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!8*!"J!!!!6!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&#3!C!!!!&!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"3N
+!'J!!!"8!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!B+!"X!!!!@!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'#J!F!!!!&`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"JS
+!(3!!!"J!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!F,!"i!!!!C!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(#`!I!!!!'J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"`X
+!)!!!!"X!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!F,!#%!!!!F!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)$!!L!!!!(3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#!`
+!)`!!!"i!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!J-!#3!!!!I!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)$!!P!!!!)!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#!`
+!*J!!!#%!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!N0!#F!!!!L!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*$3!S!!!!)`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#3d
+!+J!!!#3!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!S1!#X!!!!P!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!+$J!X!!!!*J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#`m
+!,3!!!#F!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!X2!#N!!!!S!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!0%3!Z!!!!+3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$"!
+!,`!!!#S!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!`3!$!!!!!V!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-%!!a!!!!,!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$4%
+!-J!!!#d!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!i5!$-!!!!Z!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1%J!d!!!!,`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$K)
+!03!!!$!!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!m6!$B!!!!a!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!2%`!h!!!!-J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$a-
+!1!!!!$-!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!!m6!$N!!!!d!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3&!!k!!!!03!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%"3
+!1`!!!$B!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"!8!$`!!!!h!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!3&!!p!!!!1!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%"3
+!2J!!!$N!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"%9!$m!!!!k!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!4&3"!!!!!1`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%48
+!33!!!$`!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!")@!%)!!!!p!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!5&J"$!!!!2J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%KB
+!4!!!!$m!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"-A!%8!!!"!!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!6&`"'!!!!33!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!%aF
+!4`!!!%)!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"-A!%J!!!"$!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!8'!"*!!!!4!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&"J
+!5J!!!%8!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"8C!%X!!!"'!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!9'3"-!!!!4`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&4N
+!63!!!%J!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"8C!%i!!!"*!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!9'3"3!!!!5J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&4N
+!6`!!!%X!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"BD!&%!!!"-!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!@'J"5!!!!63!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&KS
+!8`!!!%i!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"FE!&3!!!"2!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!@'J"9!!!!8!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&aX
+!9J!!!&%!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"FE!&F!!!"5!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!A'`"B!!!!8`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&aX
+!@3!!!&3!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"JF!&S!!!"9!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!B(!"E!!!!9J!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'"`
+!A!!!!&F!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"NG!&d!!!"B!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!C(3"H!!!!@3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'4d
+!A`!!!&S!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"SH!'!!!!"E!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!D(J"K!!!!A!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'Ki
+!BJ!!!&d!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"SH!'-!!!"H!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!E(`"P!!!!A`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'am
+!C!!!!'!!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"XI!'B!!!"K!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!E(`"T!!!!BJ!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'am
+!E!!!!'-!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"XI!'d!!!"N!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!E(`"Z!!!!C3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'am
+!E`!!!'B!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"dK!(!!!!"R!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!G)3"a!!!!D!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(#!
+!FJ!!!'N!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"`J!'S!!!"U!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!F)!"c!!!!D`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(#!
+!G3!!!'`!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"`J!'X!!!"Y!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!F)!"d!!!!EJ!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(#!
+!C`!!!'m!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"`J!'J!!!"`!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!F)!"h!!!!F3!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(#!
+!H!!!!()!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"`J!(N!!!"c!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!G)3"f!!!!G!!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(#!
+!HJ!!!(8!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"mM!(X!!!"f!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!H)J"m!!!!G`!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(L)
+!I3!!!(J!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!"iL!!d!!!"j!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!I)`!*!!!!HJ!!!'!!!!!!!!!
+!!!!!!!!!!!!!!!!!"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(b-
+!!!!!!(X!!!"J!!!!!!!!!!!!!!!!!!!!!!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!
+!!!!!!!!!!!!!!!!!!#!N!!%!!!"m!!!!B!!!!!!!!!!!!!!!!!!!!!!!!!!%!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!J*!!#!!!*9J!!!!S!!!!!!!!
+!!!!!!!!!!!!!!!!!!!!!!!!!!!"p!!!!!%*i#NUGcNkk!'K1ZJ"i,$a*6N4B6VS
+(6NIkrmBQM%Ikrm3QK%kk!)"1ZJ1f6VS)"Nkk!2*1ZJ#q6VS!*N*R5(MrrdK[!!4
+)9dKi!!%L1[qU6VS&ANke'!!JE3"X6T!!UI3L1[qDC`K1ZJ9)6V8B!%je8IJ+AR!
+!6VS%aQF'5T!!C`+J58je)$J+H'B1,$aD6dj&6VS'dL!-B!BQ3#!V!#"(q[p)*S"
+1G5`m4%&838kk"VBJ6#*i#3JJ"+!Z6VS(DNIkrc!QK#`m8e458dkk"TK(q[mF*S`
+X2%4548a1ZJD))%`J"'F-6VS#VJ5!!!!!$'Ed6[S(0%j@rpT"q!N3)Np`)+!ZF!(
+3%9S4dX""qJ!5F!@J,P@25'm!!UQA6Pj1G5jbFh*M!%Ik"rBQZ!Tm)(J+H,(m!!!
+!!'F)4rS(jLDS!"B[1!U!CJ*BMdje@)p)jrri2Lm!1&(i#PjJ#PQ2,`LTT5!IS%!
+`"dkk!pCRE%IkrSBQL#!3Cq3L3%U4CLkJ+D"*,$a$8N9-6VS&hQG-2Lm!1#"-)!4
+R$%kk!0S%J!!!!!aQp%kk"S*1ZJ*m)(Vq5+"T#!!!"fB%S'5J+8kk!ZBLE`!dABN
+[53!f60mIre525MJ",@F#UIp1GA!2UFPBMb"[!!3-8%ljCJi`)%kk!e*Rk+!U6VS
+#J#kI6R91ZJFU6VS!$Nkk"TK1G8kk"aa1G5!k"a"Q!!!b)(J#TR!-d*!!X,J#UQB
+L)(J+l+!P)&!L5#)BB!T"k!!)G!'%'0$#8FRrp*!!L0#*CJ*1G5)!S#iJH!VX)!'
+J*#*36qrr`#"23UJ!%M&T!!3!&U!93UG)D3!-)%qTmM)B6VS#lL4BeF%d'#)BEMj
+R)P*"Ca*53@FQ9N&R!!#Z8N&R!!#B6R8b+2rd6VS#r0056R8b+2rd6VS#c0056R8
+b+2rd6VS#dY1Urrj1G8kk!T)b+3!-5QN!#QBJ9%*U%&*#CRK`BkR*8N*Qq0056R9
+1ZJ+8dUN!$Y056R91ZJ+XdUN!$Ja#rraRBQeS8N*Q"0056R9$p4J#[P&Qc!aK2ca
+QaP*#CJB+DJ!Arrib)9K")RVmd0+4NNV68Nje-LMrp%kk!QM5MG1Urrj1G6)Srr4
+1ZJ)ddSh6U[rq6R91ZJ)SdUN!$Y+0dkVrrNjedSh6U[rq6R9$p4J#[P&Qm!aK2ca
+QkJTU!!2rr$)KA%%LH[addT(5U[rqNNSe3Irq0,a1F8je-KK1ZJ(J4I8B!0AB0"K
+R-L)BEL4R$P*"CK3b+2rd6VS"k'!B-LMrp%kk!ETJ$M)Srr41ZJ(#B!C1ZJ(LdSh
+6NNje)KK1ZJ(@de*1G5"kqriJ1[[q5UJ!!'FS-LJ!+'FL*#J!'&P#3qd!%02S!!6
+9@6,m2ca#'4,S!$dbr+R`88&Ql%(S!%!%J!!!!%"QaNje)(VlZL!kqlTbrh3!5UJ
+!!'FD[LJ!2@B80LJ!+%M$C`c8Jl+S!!4P"#)S!!4"k!"!")!!!!"!CY3JH[Z@)&"
+`%*+!jSN``HD+!%+!!$$#6R8J8()!-KJ`'!*!IrrRL82e'#!d%@!5)LN!"*+)-X%
+br$mm-X)br+R`8FMrl'!f)"#J95"!FJ!b'$!B!N"rrqH*3r8B)!aT6[N!!QFB0#N
+!"'!1-K&)F"!!-X)br%lj)Yp4b2r`)$S!#L"!CJ*K"Nl3!!!!!$!mS,fM4L))-$b
+SRkG'XSKR"N(k!#aJ)!`i!!3",f8'3IS!)Q!5$$J!!J%[C3C"qJ!BB!4"qJ!H3rV
+r`L+)6R@J[8jep2K1G8jk!!))`!!$6RX!!Nje@Bm[2%024%8r!+QJ)&p3q!TH)!K
+1G5KkqT)L6*28jB(C`G286R8SH[Tk`[`!3#)d'"JSH[U#dT41G5KkqQE#r!"!)M3
+B#*+kqQT1G5KkqP6#r!"!)M3B%0+kqP41G5KkqN,#r!"!)M3B"!D"!!!!%%je6VV
+rSM)T!!a+D3!+CJC1Z[qiB!41Z[r@dUN!$Nje)&mb'$3BX&KAbIrk5N*RrNl`)2`
+JAc)B0"L`Q&I*rrT+3QIq6[!JqL"I-KJd',"#EJU3!%&Y"Y"!3I!!!M!3Crj1m!!
+!)#m!"#p"!!3L,`!),em!"%MR2!!N!#B"5%,%`bJ!+J&)4FM&e%4)3N*#`-(3JNc
+I!$`L(dje)#m!"#p"!!3L,`!),em!"%MR-3"1ZJ#F60m!M#)I6R8J,`!%,d%!"#)
+[!!J[A`!%51Fa!%kk!(`J!8cI!)`L(dje)#m!"#p"!!3L,`!),em!"%MR-3"1ZJ!
+X60m!M#)I6R8J,`!%,d%!"#)[!!J[A`!%51Fa!%kk!!`J!8cI!)`L(dje5S"U(%U
+"DJa%J%5"6VS!)%5"6R9%J%kk!"C%J%5"6R9+J@S+4)&1ZJ!'4)"1G5im!!$rrl+
+!B`BL!(!!6R@`Kf)-J-&)3$)!3N")3%jeXSGL'Li!3N")3)$"5%")4ci!5%H1`6!
+(5%Fb"dje*!!Q!H+)iSQbKf,iJ-(!Kc)$`X!Z!dK(cX")4p+(C3L5JQ)%4)&1G90
+!B14q!&(i#PjCMbm'2`HTS#!IC`!!VLC!@Bm[#kQP*KmJ#bJ$8NI[4e*(1JGJ&PQ
+2,`Br"kQJ)"pR!!#)8NF'K!!!Irj9Mbm!UDB`(`J!!!9Qh&$i#Pl24CT(CK`J!k"
+!,`ZTSL!6C`!!@Lm,UC)S8b",S#P`!8je)!5K(L!)C`!!3LK),`ZTSL!6C`!!0L"
+,)!0J'&Q2,`Br"kQJ)"pR!!!L8NFJ3#!m!!"rrLm))&!L60R!S#kTSe(0rpUCa#C
+-F!&1G5",5N9Q"+!M6R@J(dje-MbTm%2kq4"1ZJ#`-MbTmN2kqEa1ZJ#N-MbTm82
+kqBT1ZJ#B-MbTmd2kqD3JH!TiXI`!!!!!Ca!J+!!@C`SJ+!!FCa41qJ"d6VS!F$)
+mUI4$q[Pd6[S!C%kk!'!b2+Rd3rVjFNlk!&3[##"[!!J[D!!#!!JJ1J"fCJ!!2#"
+i!UC`$0#3!,#i!UTQ,%kk!'Bb2+R`6VS!3M)mUI&1ZJ!k-MbTmNkk!$)b2+Rc6VS
+!+M)mUI41ZJ!L)&p1G6!"S8BN5(!-S4i`!D"(-2a1Z5$*-2a1q5$+6R8`!D&')QJ
+!#+!I-!%J5D"(6R8!!!!!!!!!!%je)$Vrp'F%)%"#N!"1G3!!!3!!!+ZN!!#UT!!
+!"S-!aQk!#`B!!!!F"Ni!%8K"8dJ!!!#5@Np143!!!*j,58j%!!!!UPG-6d-!!!#
+f58j%@!!!!-*66&08!!!!cN024%8!)J$D4%&833!!!Rj69&*6!!!#LN4548`!!!+
+@8eP08`!!!U*$6NC(!!3#VP0*@N8!!!,U4%*69!!!![C%3PG6!!!$!N0548`!)!-
+14%*94`!J"*T'9dP1!!!'*J!"!!!!!!!!!-CZ%!!!rrm!!!R#!-CZ!!!!rrm!!!2
+d!-CZ'!!!rrm!!!95!-CZ&!!!rrm!!)('!-CZ"!!!rrm!!!9m!-CYf!!!rrm!!!D
+J!-CYr!!&rrm!!!9Q!-CXl!!$rrm!!!A+!-CXj!!'rrm!!!A5!-CXi!!)rrm!!!F
+%!-CXk!!*rrm!!!F-!-CXf!!+rrm!!!F8!-CXQ!!,rrm!!!FF!-CXb!!-rrm!!!F
+N!-CXc!!0rrm!!!FX!-CXF!!1rrm!!!Fd!-CXC!!2rrm!!!Fm!-CX@!!3rrm!!!G
+%!-CX6!!4rrm!!!G-!-CX3!!5rrm!!!G8!-CX0!!6rrm!!!GF!-CX(!!8rrm!!!G
+N!-CX%!!9rrm!!!GX!-CX"!!@rrm!!!Gd!-CVq!!Arrm!!!Gm!-CVl!!Brrm!!!H
+%!-CVi!!Crrm!!!H-!-CVe!!Drrm!!!H8!-CVb!!Errm!!!HF!-CV[!!Frrm!!!H
+N!-CVX!!Grrm!!!HX!-CVT!!Hrrm!!!Hd!-CVQ!!Irrm!!!Hm!-CVM!!Jrrm!!!I
+%!-CVJ!!Krrm!!!I-!-CVG!!Lrrm!!!I8!-CVD!!Mrrm!!!IF!-CVA!!Nrrm!!!I
+N!-CV8!!%rrm!!!IX!-CV4!!"rrm8!+&+!-CYb!!!rrm!!!Id!-CYq!!!rrm!!!I
+i!-CYm!!!rrm!!!Im!-CYp!!!rrm!!!J!!-CYl#LK!!B!!!NN!-CYh#(Y!"3!!!N
+U!-CYi"2A!#%!!!AD!-CYj(-`!#N!!!P1!-CYe!!,rrm!!!B$!-CZ#2rr!$-!!!9
+Z!-CZ$!#!rrm!!!9L!-CYd!#!rrm!!!AT!-CYc!!&rrm!!!J%!-CXS!!$rrm!!!J
+)!-CX`!!'rrm!!!J-!-CXZ!!)rrm!!!J3!-CXT!!*rrm!!!J8!-CXV!!+rrm!!!J
+B!-CXH!!,rrm!!!JF!-CXK!!-rrm!!!JJ!-CXI!!0rrm!!!JN!-CXE!!1rrm!!!J
+S!-CXB!!2rrm!!!JX!-CX9!!3rrm!!!J`!-CX5!!4rrm!!!Jd!-CX2!!5rrm!!!J
+i!-CX*!!6rrm!!!Jm!-CX'!!8rrm!!!K!!-CX$!!9rrm!!!K%!-CX!!!@rrm!!!K
+)!-CVp!!Arrm!!!K-!-CVk!!Brrm!!!K3!-CVh!!Crrm!!!K8!-CVd!!Drrm!!!K
+B!-CVa!!Errm!!!KF!-CVZ!!Frrm!!!KJ!-CVV!!Grrm!!!KN!-CVS!!Hrrm!!!K
+S!-CVP!!Irrm!!!KX!-CVL!!Jrrm!!!K`!-CVI!!Krrm!!!Kd!-CVF!!Lrrm!!!K
+i!-CVC!!Mrrm!!!Km!-CV@!!Nrrm!!!L!!-CV6!!%rrm!!!L%!-CSl!!&rrm!!!L
+)!-CXd!!$rrm!!!L-!-CXU!!'rrm!!!L3!!$'E*!!!!Mrr`!!#*3!aQb-!!Rrr`!
+!#*J!aQb8!!Vrr`!!#*`!aQb)!![rr`!!#+!!aQb!!!crr`!!#+3!aQad!!hrr`!
+!#+J!aQaS!!lrr`!!#+`!aQaF!!rrr`!!#,!!aQa3!"$rr`!!#,3!aQa%!"(rr`!
+!#,J!aQ`i!",rr`!!#,`!aQ`J!"2rr`!!#-!!aQ`8!"6rr`!!#-3!aQ`)!"Arr`!
+!#-J!aQ[m!"Err`!!#-`!aQ[`!"Irr`!!#0!!aQ[N!"Mrr`!!#03!aQ[B!"Rrr`!
+!#0J!aQ[-!"Vrr`!!#0`!aQ[!!"[rr`!!#1!!aQZd!"crr`!!#13!aQZS!"hrr`!
+!#1J!aQZF!"lrr`!!#1`!aQZ3!!!Irrm!!!M`!-CVK!!Jrrm!!!Md!-CVH!!Krrm
+!!!Mi!-CVE!!Lrrm!!!Mm!-CVB!!Mrrm!!!N!!-CV9!!Nrrm!!!N%!-CV5!!%rrm
+!!!N)!-CSk!#!rrm!!!9H!-CXR!9YDf&SE!dJ,QmJ3fpZGQ9bG'9b$&0jE@&ZG'9
+M)%-V+`G85%P15b"$#94)58j,)&*PHJ%l+HX:
diff -Pru nethack-3.4.1/sys/mac/old/NetHack.r nethack/sys/mac/old/NetHack.r
--- nethack-3.4.1/sys/mac/old/NetHack.r	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/NetHack.r	Thu Jan 10 16:43:28 2002
@@ -0,0 +1,89 @@
+#ifndef THINK_Rez
+INCLUDE "NetHack.rsrc";			/* MENU, ALRT, WIND, ICN#, etc */
+INCLUDE "Sounds.rsrc";			/* Instruments as snd resources */
+#endif
+
+#include "Types.r"
+#include "SysTypes.r"
+#include "BalloonTypes.r"	    /* Mac resource type definitions */
+
+#ifdef THINK_Rez
+read 'TEXT' (1000,"Help") 	 "help";
+read 'TEXT' (1001,"WizHelp") "wizhelp";
+read 'TEXT' (1002,"OptHelp") "opthelp";
+read 'TEXT' (1004,"MacHelp") "MacHelp";
+read 'TEXT' (1005,"HH") 	 "hh";
+read 'TEXT' (1006,"History") "history";
+read 'TEXT' (1007,"License") "license";
+read 'TEXT' (1008,"News")	 "News";
+read 'TEXT' (1009,"Options") "options";
+#else	/* MPW rez */
+read 'TEXT' (1000,"Help") 	 $$Shell("Dat") "Help";
+read 'TEXT' (1001,"WizHelp") $$Shell("Dat") "WizHelp";
+read 'TEXT' (1002,"OptHelp") $$Shell("Dat") "OptHelp";
+/*
+read 'TEXT' (1003,"CmdHelp") $$Shell("Dat") "CmdHelp";
+*/
+read 'TEXT' (1004,"MacHelp") $$Shell("MacDir") "MacHelp";
+
+read 'TEXT' (1005,"HH") 	 $$Shell("Dat") "HH";
+read 'TEXT' (1006,"History") $$Shell("Dat") "History";
+read 'TEXT' (1007,"License") $$Shell("Dat") "License";
+
+read 'TEXT' (1008,"News")	 $$Shell("MacDir") "News";
+read 'TEXT' (1009,"Options") $$Shell("ObjDir") "Options";
+
+/*
+read 'TEXT' (1010,"Rumors")  $$Shell("ObjDir") "Rumors";
+read 'TEXT' (1011,"Data")    $$Shell("ObjDir") "Data";
+*/
+
+/* Think C generates a SIZE resource into NetHack.rsrc, MPW needs this */
+resource 'SIZE' (-1) {
+	reserved,
+	acceptSuspendResumeEvents,
+	reserved,
+	canBackground,
+	doesActivateOnFGSwitch,
+	backgroundAndForeground,
+	dontGetFrontClicks,
+	ignoreAppDiedEvents,
+	is32BitCompatible,
+	notHighLevelEventAware,
+	onlyLocalHLEvents,
+	notStationeryAware,
+	dontUseTextEditServices,
+	reserved,
+	reserved,
+	reserved,
+	1500 * 1024,		/* recommended */
+	1000 * 1024		/* absolute minimum, to be determined */
+};
+#endif
+
+/* System 7 help balloon information */
+resource 'hfdr' (-5696, purgeable) { 
+     HelpMgrVersion, hmDefaultOptions, 0, 0, /* header information */ 
+	    { HMSTRResItem { /* use 'STR ' resource 2000 */ 2000 } 
+	} 
+};
+
+resource 'STR ' (2000, purgeable) { /* Help message for app icon */
+   "NetHack 3.1\nThis is the famous Dungeons and Dragons*-like game ported to the Macintosh." 
+};
+
+resource 'STR '(-16396, purgeable) {	/* Will be copied to the saved file. */
+	"NetHack"							/* See Inside Mac VI, page 9-21.	 */
+};
+
+
+/* Mac error decodes : 2000 - err# for common errors. Add your favorites below */
+
+resource 'STR ' (2034) { "the disk is full"  };
+resource 'STR ' (2036) { "there was an I/O error"  };
+resource 'STR ' (2043) { "a file is missing"  };
+resource 'STR ' (2044) { "the disk is write-protected"  };
+resource 'STR ' (2047) { "the file is busy"  };
+resource 'STR ' (2049) { "the file is already open"  };
+resource 'STR ' (2108) { "there is not enough memory"  };
+resource 'STR ' (2192) { "a resource is missing"  };
diff -Pru nethack-3.4.1/sys/mac/old/macsegs nethack/sys/mac/old/macsegs
--- nethack-3.4.1/sys/mac/old/macsegs	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/macsegs	Thu Jan 10 16:43:28 2002
@@ -0,0 +1,333 @@
+This patch removes some obsolete code that provides code segment management
+on older 68k Macintoshes.  Specifically, one would need the segment management
+only if:
+1.  You are compiling the code yourself.  Most Macintosh
+    players use the precompiled official binaries, which are
+    built with Metrowerks Codewarrior using the large memory
+    model.
+2.  You are compiling for an 68k Macintosh using a small
+    memory model.  If your Mac has enough memory to load in
+    the entire game, you might as well build using the large
+    memory model.  Newer PowerPC Macintoshes do not have segments,
+    nor a segment model.
+
+This patch should be archived as the file sys/mac/old/macsegs.
+
+
+diff -c -r old/include/extern.h new/include/extern.h
+*** old/include/extern.h	Mon Jun  7 21:46:55 1999
+--- new/include/extern.h	Mon Jun 21 12:52:04 1999
+***************
+*** 820,831 ****
+  E int FDECL(macwrite, (int,void *,unsigned));
+  E long FDECL(macseek, (int,long,short));
+  
+- /* ### macmain.c ### */
+- 
+- #ifdef MAC68K
+- E void NDECL(UnloadAllSegments);
+- #endif
+- 
+  /* ### macsnd.c ### */
+  
+  E void FDECL(mac_speaker, (struct obj *,char *));
+--- 820,825 ----
+diff -c -r old/src/allmain.c new/src/allmain.c
+*** old/src/allmain.c	Mon Jun  7 21:45:57 1999
+--- new/src/allmain.c	Mon Jun 21 12:51:36 1999
+***************
+*** 62,70 ****
+  #ifdef CLIPPING
+  		cliparound(u.ux, u.uy);
+  #endif
+- #if defined(MAC68K) && defined(MAC_MPW32) && !defined(MODEL_FAR)
+- 		UnloadAllSegments();  /* Marks non-resident segments as purgeable */
+- #endif
+  		get_nh_event();
+  #ifdef POSITIONBAR
+  		do_positionbar();
+--- 62,67 ----
+diff -c -r old/include/macwin.h new/include/macwin.h
+*** old/include/macwin.h	Tue Apr 27 12:29:27 1999
+--- new/include/macwin.h	Mon Jun 21 12:57:46 1999
+***************
+*** 180,189 ****
+  
+  /* ### macmain.c ### */
+  
+- #ifdef MAC68K
+- /* extern void UnloadAllSegments( void );	declared in extern.h */
+- extern void InitSegMgmt( void * );		/* called from macwin.c */
+- #endif
+  extern void NDECL ( finder_file_request ) ;
+  
+  /* ### mactty.c ### */
+--- 180,185 ----
+diff -c -r old/sys/mac/macmain.c new/sys/mac/macmain.c
+*** old/sys/mac/macmain.c	Thu Apr 29 12:43:46 1999
+--- new/sys/mac/macmain.c	Mon Jun 21 12:56:40 1999
+***************
+*** 31,39 ****
+  
+  int NDECL(main);
+  
+- #ifdef MAC68K
+- static void FDECL(IsResident,(void *));
+- #endif
+  static void NDECL(process_options);
+  static void NDECL(whoami);
+  
+--- 31,36 ----
+***************
+*** 147,171 ****
+  
+  	UndimMenuBar ( ) ; /* Yes, this is the place for it (!) */
+  	
+- 	attemptingto("proceed");
+- #if defined(MAC68K) && defined(MAC_MPW32) && !defined(MODEL_FAR)
+- 	UnloadAllSegments();						/* Do this before naming residents */
+- 	IsResident( (Ptr) um_dist );				/* Sample resident segments */
+- 	IsResident( (Ptr) flush_screen );
+- 	IsResident( (Ptr) rhack );
+- 	IsResident( (Ptr) remove_cadavers );
+- 	IsResident( (Ptr) dog_move );
+- 	IsResident( (Ptr) gethungry );
+- 	IsResident( (Ptr) engr_at );
+- 	IsResident( (Ptr) domove );
+- 	IsResident( (Ptr) carried );
+- 	IsResident( (Ptr) movemon );
+- 	IsResident( (Ptr) attacktype ) ;
+- 	IsResident( (Ptr) mac_get_nh_event ) ;
+- 	IsResident( (Ptr) dosounds ) ;
+- 	IsResident( (Ptr) t_at ) ;
+- 	IsResident( (Ptr) nh_timeout ) ;
+- #endif
+  	moveloop();
+  	exit(EXIT_SUCCESS);
+  	/*NOTREACHED*/
+--- 144,149 ----
+***************
+*** 452,639 ****
+  	}
+  #endif /* MAC68K */
+  }
+- 
+- 
+- 
+- /*------------------- UnloadAllSegments and support stuff --------------------------*/
+- /* Derived from MacApp source */
+- 
+- /*
+-  * Don't unload segments unless you are exactly controlling the file
+-  * placement in each of the segments you plan to unload.
+-  *
+-  * The 68K MetroWerks compile is done with automatic segment placement, so
+-  * don't mess with this stuff...
+-  */
+- #if defined(MAC68K) && !defined(__MWERKS__)	/* segments only make sense on 68K macs */
+- 
+- typedef Handle **HandleListHandle;
+- typedef Boolean **BoolListHandle;
+- typedef short *ShortPtr, **ShortHandle;
+- 
+- #if defined(MAC_MPW32) || defined(THINK_C)
+- pascal long GetA5(void) = { 0x2E8D };					/* MOVE.L A5,(A7) */
+- pascal short GetCurJTOffset(void) = { 0x3EB8, 0x934 };	/* MOVE.W CurJTOffset,(SP) */
+- #endif
+- 
+- static void NDECL(ListGUnloads);
+- static short FDECL(GetSegNumber, (ShortPtr));
+- static void FDECL(NotResident, (void *));
+- 
+- short 			 pMaxSegNum = 0,		/* Highest segment number */
+- 	  			 gCodeRefNum;			/* rsrc refnum of the application */
+- HandleListHandle gCodeSegs;				/* List of code seg handles */
+- BoolListHandle   gIsResidentSeg;		/* Resident flags */
+- 
+- #define kLoaded   0x4EF9				/* if loaded then a JMP instruction */
+- #define	kUnLoaded 0x3F3C				/* if unloaded then a LoadSeg trap */
+- 										/* Note: probably incorrect for -model far! */
+- 
+- /* #define TRACKSEGS /* Utility to print a trace of segment load frequencies. */
+- 
+- #ifdef TRACKSEGS
+- 
+- long	  gUnloads[120];
+- char	  gSegNames[120][16];
+- 
+- void ListGUnloads(void)
+- {
+-   int i;
+-   FILE *f;
+-   
+-   f = fopen("unloads","w");
+-   fprintf(f,"%d calls to UnloadAllSegments\n\n",gUnloads[0]);
+-   for (i=1; i<=pMaxSegNum; i++) {
+- 	 fprintf(f,"Unloaded %10s, segment %2d, %6d times\n",gSegNames[i],i,gUnloads[i]);
+-   }
+-   fclose(f);
+- }
+- 
+- #endif
+- 
+- short GetSegNumber(ShortPtr aProc)
+- /* Derives seg number from a procedure ptr */
+- 
+- {
+- 	if (*aProc == kLoaded) 				/* loaded segment */
+- 		return(*--aProc);
+- 	else if (*aProc == kUnLoaded)  		/* unloaded segment */
+- 		return(*++aProc);
+- 	else {
+- 		progerror("GetSegNumber was not passed an jump table address");
+- 		return(1);
+- 	}
+- }
+- 
+- void InitSegMgmt(void * mainSeg)
+- /* Initialise a list of handles to all the CODE segments and mark the mainseg as resident */
+- {
+- 	short 	i,
+- 			lastRsrc,
+- 			rsrcID,
+- 			oldResFile;
+- 	Handle  seg;
+- 	ResType rsrcType;
+- 	Str255  rsrcName;
+- 	 
+- 	gCodeRefNum = HomeResFile(GetResource('CODE', 1));	
+- 	oldResFile = CurResFile();
+- 	UseResFile(gCodeRefNum);
+- 	
+- 	/* Discover the highest CODE rsrc ID: be ready for noncontiguous IDs */
+- 	lastRsrc = Count1Resources('CODE');	
+- 	SetResLoad(false);
+- 	for (i=1; i<=lastRsrc; i++) 
+- 		if (seg = Get1IndResource('CODE', i)) {
+- 			GetResInfo(seg, &rsrcID, &rsrcType, rsrcName);
+- 			if (rsrcID > pMaxSegNum) pMaxSegNum = rsrcID;
+- 		}
+- 		
+- 	/* Make handles of appropriate size to keep flags/segment handles */
+- 	SetResLoad(true);  /* In case we fail */
+- 	gCodeSegs = (HandleListHandle) NewHandle((pMaxSegNum+1) * sizeof(Handle));	
+- 	mustwork(MemError());
+- 	gIsResidentSeg = (BoolListHandle) NewHandle((pMaxSegNum+1) * sizeof(Boolean));
+- 	mustwork(MemError());
+- 	SetResLoad(false);	
+- 
+- 	#ifdef TRACKSEGS
+- 	atexit(&ListGUnloads);
+- 	gUnloads[0]=0;
+- 	#endif
+- 	for (i=1; i<=pMaxSegNum; i++) {
+- 	   (*gIsResidentSeg)[i] = false;
+- 	   (*gCodeSegs)[i] = Get1Resource('CODE',i);   /* Will be NIL if it doesn't exist */
+- 	   #ifdef TRACKSEGS
+- 	   {  /* Go get the segment name and save it */
+- 	      short id;
+- 		  ResType rType;
+- 		  Str255 name;
+- 		  char *cptr;
+- 		  
+- 		  GetResInfo((*gCodeSegs)[i],&id,&rType,&name);
+- 		  if (name[0]>15) name[0]=15;
+- 		  cptr = p2cstr(&name);
+- 		  cptr = strcpy(&gSegNames[i], &name);
+- 		  gUnloads[i] = 0;
+- 	   }
+- 	   #endif
+- 	}
+- 	SetResLoad(true);	
+- 	(*gIsResidentSeg)[GetSegNumber((ShortPtr)mainSeg)] = true;	
+- 	UseResFile(oldResFile);
+- }
+- 
+- 
+- void UnloadAllSegments(void)
+- {
+-   short	 i,
+- 		 oldResFile;
+-   Handle seg;
+-   long	 jumpTablePtr;
+- 
+-   jumpTablePtr = GetA5() + GetCurJTOffset();
+-   oldResFile = CurResFile();
+-   UseResFile(gCodeRefNum);
+- #ifdef TRACKSEGS
+-   gUnloads[0]++;
+- #endif
+-   for (i=1; i<=pMaxSegNum; i++)
+- 	  if (!(*gIsResidentSeg)[i]) {
+- 		  seg = (*gCodeSegs)[i];
+- 		  if ((seg != (Handle) nil) && (*seg != (Ptr) nil))  /* Check it exists and hasn't been purged */
+- 			  if (HGetState(seg) & 0x80)  {   /* Is it locked? => loaded */
+- #ifdef TRACKSEGS
+- 				 gUnloads[i]++;
+- #endif
+- 				 UnloadSeg( (void *) (jumpTablePtr + **(ShortHandle)seg + 2) );
+- 			  }
+- 	  }
+- 
+-   UseResFile(oldResFile);
+- }
+- 
+- static void IsResident( void * routineaddr )
+- /* We want to move this high up in the heap as it won't be shifted again, so... */
+- {
+- 	int    segnum;
+- 	Handle theseg;
+- 	
+- 	segnum = GetSegNumber((ShortPtr)routineaddr);
+- 	theseg = (*gCodeSegs)[segnum];
+- 	UnloadSeg( routineaddr );
+- 	if (*theseg != nil) {
+- 	   MoveHHi( theseg );  /* If it has been purged we can't do this */
+- 	   HLock( theseg );
+- 	}
+- 	(*gIsResidentSeg)[segnum] = true;	
+- }
+- 
+- static void NotResident( void * routineaddr )
+- {
+- 	(*gIsResidentSeg)[GetSegNumber((ShortPtr)routineaddr)] = false;	
+- }
+- 
+- #endif /* MAC68K */
+  
+  /*macmain.c*/
+--- 430,434 ----
+diff -c -r old/sys/mac/macwin.c new/sys/mac/macwin.c
+*** old/sys/mac/macwin.c	Mon Jun  7 21:46:52 1999
+--- new/sys/mac/macwin.c	Mon Jun 21 12:57:30 1999
+***************
+*** 307,317 ****
+  	long l ;
+  	long applLimit;
+  
+- #ifdef MAC68K
+-  #ifdef applec
+- 	UnloadSeg((Ptr) _DataInit);
+-  #endif
+- #endif
+  
+  	if ( LMGetDefltStack() < 50 * 1024L ) {
+  		applLimit = (long) LMGetCurStackBase() - (50 * 1024L);
+--- 307,312 ----
+***************
+*** 327,338 ****
+  	InitMenus ( ) ;
+  	InitDialogs ( ( ResumeProcPtr ) 0L ) ;
+  	TEInit ( ) ;
+- 
+- #if defined(MAC68K) && !defined(__MWERKS__)
+- 	InitSegMgmt( itworked );	/* itworked is always in the main segment */
+- #endif
+- 
+- 	attemptingto("start up");
+  
+  	if ( Gestalt ( gestaltOSAttr , & l ) ) {
+  		macFlags . processes = 0 ;
+--- 322,327 ----
+
+
diff -Pru nethack-3.4.1/sys/mac/old/mhdump.c nethack/sys/mac/old/mhdump.c
--- nethack-3.4.1/sys/mac/old/mhdump.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/mhdump.c	Thu Jan 10 16:43:28 2002
@@ -0,0 +1,10 @@
+/* Dump file creator for MPW */
+
+#define NEED_VARARGS
+
+#include ":Include:hack.h"
+
+#pragma dump ":Obj:hack.hdump"
+
+
+dummy() {}
diff -Pru nethack-3.4.1/sys/mac/old/mpwhack.h nethack/sys/mac/old/mpwhack.h
--- nethack-3.4.1/sys/mac/old/mpwhack.h	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/mpwhack.h	Thu Jan 10 16:43:28 2002
@@ -0,0 +1,2 @@
+/* For use with MPW */
+#pragma load ":Obj:hack.hdump"
diff -Pru nethack-3.4.1/sys/mac/old/mstring.c nethack/sys/mac/old/mstring.c
--- nethack-3.4.1/sys/mac/old/mstring.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/mac/old/mstring.c	Thu Jan 10 16:43:28 2002
@@ -0,0 +1,43 @@
+/*	SCCS Id: @(#)mstring.c	3.1	93/01/24		  */
+/* Copyright (c) Jon W{tte */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#if defined(applec)
+
+extern int strlen ( char * ) ;
+
+char *
+PtoCstr ( unsigned char * p )
+{
+	int len = * p ;
+	char * ret = ( char * ) p ;
+
+	while ( len -- ) {
+
+		* p = p [ 1 ] ;
+		p ++ ;
+	}
+	* p = 0 ;
+
+	return ret ;
+}
+
+
+unsigned char *
+CtoPstr ( char * p )
+{
+	int len = strlen ( p ) ;
+	unsigned char * ret = ( unsigned char * ) p ;
+
+	p += len ;
+	while ( (unsigned char *)p > ret ) {
+
+		* p = p [ -1 ] ;
+		p -- ;
+	}
+	* ret = len ;
+
+	return ret ;
+}
+
+#endif
diff -Pru nethack-3.4.1/sys/msdos/Install.dos nethack/sys/msdos/Install.dos
--- nethack-3.4.1/sys/msdos/Install.dos	Sun Feb 23 06:43:35 2003
+++ nethack/sys/msdos/Install.dos	Sun Mar  9 13:39:51 2003
@@ -7,7 +7,7 @@
 		     NetHack 3.4 on a DOS system
          ======================================================
                    (or, How to make PC NetHack 3.4)
-                 Last revision: $Date: 2003/02/22 01:20:02 $
+                 Last revision: $Date: 2003/03/09 21:39:51 $
 
 Credit for a runnable full PC NetHack 3.4 goes to the PC Development team
 of Paul Winner, Kevin Smolkowski, Michael Allison, Yitzhak Sapir, Bill Dyer, 
diff -Pru nethack-3.4.1/sys/msdos/Makefile.GCC nethack/sys/msdos/Makefile.GCC
--- nethack-3.4.1/sys/msdos/Makefile.GCC	Sun Feb 23 06:43:36 2003
+++ nethack/sys/msdos/Makefile.GCC	Sun Mar  9 13:39:52 2003
@@ -1,4 +1,4 @@
-#	SCCS Id: @(#)Makefile.GCC	      3.4     $Date: 2003/02/17 23:56:35 $
+#	SCCS Id: @(#)Makefile.GCC	      3.4     $Date: 2003/03/09 21:39:52 $
 #	Copyright (c) NetHack PC Development Team 1996-2003.
 #	PC NetHack 3.4 Makefile for djgpp V2
 #
diff -Pru nethack-3.4.1/sys/msdos/Makefile.SC nethack/sys/msdos/Makefile.SC
--- nethack-3.4.1/sys/msdos/Makefile.SC	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/Makefile.SC	Tue Apr 23 12:12:11 2002
@@ -0,0 +1,931 @@
+#	SCCS Id :  @(#)Makefile.SC	      3.4     1996/10/14
+#	Copyright (c) NetHack Development Team 1996.
+#
+#	Symantec C compiler V7.2
+#	Written for Symantec SMAKE utility
+#
+#	NOTE: This Makefile has not been tested for NetHack 3.4.0
+#
+#	For questions or comments :  nethack-bugs@linc.cis.upenn.edu
+#
+#	In addition to your C compiler,
+#
+#  if you want to change   you will need a
+#  files with suffix   workalike for
+#	  .y	     yacc
+#	  .l	     lex
+#
+
+# Game Installation Variables
+# NOTE :  Make sure GAMEDIR exists before make is started.
+
+GAME = nethack
+GAMEDIR = c:\games\nethacks
+
+#
+# Directories, gnu utilities like unix style directory specs
+#
+
+DUTIL = ../util
+
+# But we must use dos directory specs to find src files, so....
+
+DAT  = ..\dat
+DOC  = ..\doc
+INCL = ..\include
+MSYS = ..\sys\msdos
+SRC  = ..\src
+SSHR = ..\sys\share
+UTIL = ..\util
+WIN  = ..\win\tty
+WSHR = ..\win\share
+
+#
+#  Executables.
+
+CC    = sc
+LINK  = link
+MAKEBIN  = smake
+
+# if you have a uudecode program, add its name here
+# otherwise leave blank
+UUDECODE =
+
+
+#
+# Special libraries and how to link them in.
+
+LIBS = 
+
+# To build a DOS-extended executable uncomment the top line.
+# To build a WIN32 console executable uncomment the second line.
+
+TARGENV=DOS_EXTENDED
+#TARGENV=WIN32_CONSOLE
+
+#
+#  Yacc/Lex ... if you got 'em.
+#
+# If you have yacc/lex or a work-alike set YACC_LEX to Y
+#
+YACC_LEX = N
+
+# If YACC_LEX is Y above, set the following to values appropriate for
+# your tools.
+#
+YACC   = bison -y
+LEX    = flex
+YTABC  = y_tab.c
+YTABH  = y_tab.h
+LEXYYC = lexyy.c
+
+#
+# Uncomment the line below if you want to store all the level files,
+# help files, etc. in a single library file.
+
+USE_DLB = N
+
+#############################################################################
+#
+# nothing below this line should have to be changed
+#
+
+GAMEFILE = $(GAMEDIR)\$(GAME).exe
+
+LIBRARIES = $(LIBS) $(TERMLIB)
+
+# Changing this conditional block is not recommended
+!IF "$(USE_DLB)"=="Y"
+DLBFLG = -DDLB
+!ELSE
+DLBFLG =
+!ENDIF
+
+#######################################
+!IF "$(TARGENV)"=="DOS_EXTENDED"
+
+# DOS Extended Executable
+#  Flags.
+#
+#   Debugging
+CFLAGS = -c -Nc -w- -w2 -w3 -mx -g -I../include $(DLBFLG)
+LFLAGS = /NOI /XREF /DETAILED /DEBUG cx
+#   Normal
+#CFLAGS = -c -Nc -w- -w2 -w3 -mx -I../include $(DLBFLG)
+#LFLAGS = /NOI /MAP cx
+
+!ELSE
+
+# WIN32 Console Executable
+#  Flags.
+#
+#   Debugging
+#CFLAGS = -c -o -Nc -w- -w2 -w3 -mx -g -gt -I../include $(DLBFLG)
+#LFLAGS = /NOI /XREF /DETAILED /DEBUG cx
+
+#   Normal
+CFLAGS = -c -o -Nc -w- -w2 -w3 -mx -gt -I../include $(DLBFLG)
+LFLAGS = /NOI /MAP cx
+!ENDIF
+
+#
+#  Utility Objects.
+#
+
+MAKEOBJS    = makedefs.o  monst.o	 objects.o
+
+SPLEVOBJS   = lev_yacc.o  lev_$(LEX).o	lev_main.o  alloc.o	\
+		monst.o	    objects.o	    panic.o  \
+		drawing.o	decl.o
+
+DGNCOMPOBJS = dgn_yacc.o  dgn_$(LEX).o	dgn_main.o  alloc.o	 \
+		panic.o
+
+RECOVOBJS   = recover.o
+
+#  Tile related object files.
+
+TILOBJ      = tile.o pctiles.o vidvga.o
+
+TEXTIO      = tiletext.o tiletxt.o drawing.o decl.o monst.o objects.o
+
+TEXTIO2     = tiletex2.o tiletxt2.o drawing.o decl.o monst.o objects.o
+
+PLANAR_TIB  = NetHack1.tib
+
+OVERVIEW_TIB = NetHacko.tib
+
+#TILEUTIL    = $(TILOBJ) $(UTIL)\tile2bin.exe $(UTIL)\til2bin2.exe \
+#		$(PLANAR_TIB) $(OVERVIEW_TIB)
+
+TILEUTIL =
+
+TILEFILES   = $(WSHR)\monsters.txt $(WSHR)\objects.txt $(WSHR)\other.txt
+
+TILEFILES2  = $(WSHR)\monthin.txt $(WSHR)\objthin.txt $(WSHR)\oththin.txt
+
+GIFREADERS  = gifread.o alloc.o panic.o
+
+GIFREAD2    = gifread2.o alloc.o panic.o
+
+GIFWRITERS  = gifwrite.o alloc.o panic.o
+
+GIFWRIT2    = gifwrit2.o alloc.o panic.o
+
+DLBOBJ = dlb.o
+
+#  Object files for the game itself.
+
+VOBJ01 = allmain.o  alloc.o    apply.o	  artifact.o attrib.o
+VOBJ02 = ball.o	    bones.o    botl.o	  cmd.o	     dbridge.o
+VOBJ03 = decl.o	    detect.o   display.o  do.o	     do_name.o
+VOBJ04 = do_wear.o  dog.o      dogmove.o  dokick.o   dothrow.o
+VOBJ05 = drawing.o  dungeon.o  eat.o	  end.o	     engrave.o
+VOBJ06 = exper.o    explode.o  extralev.o files.o    fountain.o
+VOBJ07 = getline.o  hack.o     hacklib.o  invent.o   lock.o
+VOBJ08 = mail.o	    main.o     makemon.o  mcastu.o   mhitm.o
+VOBJ09 = mhitu.o    minion.o   mkmap.o	  mklev.o    mkmaze.o
+VOBJ10 = mkobj.o    mkroom.o   mon.o	  mondata.o  monmove.o
+VOBJ11 = monst.o    monstr.o   mplayer.o  mthrowu.o  muse.o
+VOBJ12 = music.o    o_init.o   objects.o  objnam.o   options.o
+VOBJ13 = pickup.o   pline.o    polyself.o potion.o   quest.o
+VOBJ14 = questpgr.o pager.o    pray.o	  priest.o   read.o
+VOBJ15 = rect.o	    restore.o  rip.o	  rnd.o	     role.o
+VOBJ16 = rumors.o   save.o	   shk.o      shknam.o	 sit.o
+VOBJ17 = sounds.o   sp_lev.o   spell.o    steal.o	 steed.o
+VOBJ18 = termcap.o  timeout.o  topl.o	  topten.o   track.o
+VOBJ19 = trap.o     u_init.o   uhitm.o    vault.o    vision.o
+VOBJ20 = vis_tab.o  weapon.o   were.o	  wield.o    windows.o
+VOBJ21 = wintty.o   wizard.o   worm.o	  worn.o     write.o
+VOBJ22 = zap.o	    light.o    dlb.o      dig.o      teleport.o
+VOBJ23 = random.o
+
+SOBJ   = msdos.o    sound.o    sys.o	  tty.o	     unix.o    video.o \
+	vidtxt.o    pckeys.o
+
+VVOBJ  = version.o
+
+VOBJ   = $(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) \
+	$(VOBJ06) $(VOBJ07) $(VOBJ08) $(VOBJ09) $(VOBJ10) \
+	$(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) $(VOBJ15) \
+	$(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ19) $(VOBJ20) \
+	$(VOBJ21) $(VOBJ22) $(VOBJ23)
+
+#ALLOBJ = $(VOBJ) $(SOBJ) $(TILOBJ) $(VVOBJ)
+ALLOBJ = $(VOBJ) $(SOBJ) $(VVOBJ)
+
+#
+#  Header Objects.
+#
+
+DGN_FILE_H = $(INCL)\align.h	$(INCL)\dgn_file.h
+DUNGEON_H  = $(INCL)\align.h	$(INCL)\dungeon.h
+EMIN_H	   = $(DUNGEON_H)	$(INCL)\emin.h
+EPRI_H	   = $(DUNGEON_H)	$(INCL)\align.h	    $(INCL)\epri.h
+ESHK_H	   = $(DUNGEON_H)	$(INCL)\eshk.h
+MONDATA_H  = $(INCL)\align.h	$(INCL)\mondata.h
+MONST_H	   = $(INCL)\align.h	$(INCL)\monst.h
+PERMONST_H = $(INCL)\monattk.h	$(INCL)\monflag.h   $(INCL)\align.h   \
+	    $(INCL)\permonst.h
+RM_H	   = $(INCL)\align.h	$(INCL)\rm.h
+SP_LEV_H   = $(INCL)\align.h	$(INCL)\sp_lev.h
+VAULT_H	   = $(DUNGEON_H)	$(INCL)\vault.h
+YOUPROP_H  = $(PERMONST_H)	$(MONDATA_H)	    $(INCL)\prop.h    \
+	    $(INCL)\pm.h       $(INCL)\youprop.h
+YOU_H	   = $(MONST_H)		$(YOUPROP_H)	    $(INCL)\align.h   \
+	     $(INCL)\attrib.h	$(INCL)\you.h
+DISPLAY_H  = $(MONDATA_H)	$(INCL)\vision.h    $(INCL)\display.h
+PCCONF_H   = $(INCL)\micro.h	$(INCL)\system.h    $(INCL)\pcconf.h
+CONFIG_H   = $(GLOBAL_H)	$(INCL)\tradstdc.h  $(INCL)\config1.h \
+	    $(INCL)\config.h
+DECL_H	   = $(YOU_H)		$(INCL)\spell.h	    $(INCL)\color.h   \
+	     $(INCL)\obj.h	$(INCL)\onames.h    $(INCL)\pm.h      \
+	      $(INCL)\decl.h
+GLOBAL_H   = $(PCCONF_H)	$(INCL)\coord.h	    $(INCL)\global.h
+HACK_H	   = $(CONFIG_H)	$(DUNGEON_H)	    $(DECL_H)	      \
+	       $(DISPLAY_H)	  $(INCL)\monsym.h    $(INCL)\mkroom.h	\
+	      $(INCL)\objclass.h $(INCL)\trap.h	     $(INCL)\flag.h    \
+	      $(RM_H)		 $(INCL)\vision.h    $(INCL)\wintype.h \
+	      $(INCL)\engrave.h	 $(INCL)\rect.h	     \
+	       $(INCL)\trampoli.h $(INCL)\hack.h
+DLB_H      = $(INCL)\dlb.h
+TILE_H	   = $(INCL)\tile.h $(INCL)\pctiles.h
+
+!IF "$(USE_DLB)"=="Y"
+DLB = dlb
+DLBOBJS = dlb_main.o dlb.o alloc.o panic.o
+!ELSE
+DLB =
+DLBOBJS =
+!ENDIF
+
+#
+#  Make Rules.
+#
+
+.SUFFIXES :   .exe .o .c .y .l
+
+.c.o : 
+	$(CC) $(CFLAGS) -o$@ $<
+
+#
+#  Primary Targets.
+#
+
+#  The default target.
+
+default :  $(GAMEFILE)
+
+all :  install.tag
+
+util :  utility.tag
+
+install :  install.tag
+
+utility.tag :  $(INCL)\date.h $(INCL)\trap.h    $(INCL)\onames.h	       \
+	$(INCL)\pm.h	  monstr.c   vis_tab.c	\
+	$(UTIL)\lev_comp.exe	 $(UTIL)\dgn_comp.exe	 \
+	$(UTIL)\recover.exe $(TILEUTIL)
+	echo utilities made > utility.tag
+
+gifutil :  $(UTIL)\gif2txt.exe $(UTIL)\txt2gif.exe
+	echo Optional GIF development utilities are up to date.
+
+install.tag :  dat.tag $(GAMEFILE)
+!IF "$(USE_DLB)"=="Y"
+	copy $(DAT)\nhdat         $(GAMEDIR)
+	copy $(DAT)\license       $(GAMEDIR)
+!ELSE
+	copy $(DAT)\*.            $(GAMEDIR)
+	copy $(DAT)\*.dat         $(GAMEDIR)
+	copy $(DAT)\*.lev         $(GAMEDIR)
+	copy $(MSYS)\msdoshlp.txt $(GAMEDIR)
+	if exist $(GAMEDIR)\makefile. del $(GAMEDIR)\makefile.
+!ENDIF
+	copy $(SSHR)\termcap	  $(GAMEDIR)
+	copy *.tib                $(GAMEDIR)
+	copy $(SSHR)\NetHack.cnf  $(GAMEDIR)\defaults.nh
+	copy $(UTIL)\recover.exe  $(GAMEDIR)
+	copy $(DOC)\guideb*.txt   $(GAMEDIR)
+	echo install done > install.tag
+
+#  The main target.
+
+$(GAMEFILE) :  utility.tag $(ALLOBJ)
+	$(LINK) /STACK:100000 $(LFLAGS) @<<$(GAME).lnk
+		$(ALLOBJ:^	=+^
+		)
+		$(GAMEFILE)
+		$(GAME);
+<<KEEP
+
+#
+#  Housekeeping.
+#
+
+clean : 
+	del *.o
+	del *.map
+	del $(UTIL)\dlb_main.exe
+	if exist utility.tag	del utility.tag
+	if exist install.tag	del install.tag
+	if exist dat.tag	del dat.tag
+spotless :  clean
+	if exist $(GAME).lnk	   del $(GAME).lnk
+	if exist $(UTIL)\makedefs.exe	   del $(UTIL)\makedefs.exe
+	if exist $(UTIL)\lev_comp.exe	   del $(UTIL)\lev_comp.exe
+	if exist $(UTIL)\dgn_comp.exe	   del $(UTIL)\dgn_comp.exe
+	if exist $(UTIL)\recover.exe	   del $(UTIL)\recover.exe
+	if exist $(INCL)\onames.h  del $(INCL)\onames.h
+	if exist $(INCL)\pm.h	   del $(INCL)\pm.h
+	if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
+	if exist $(INCL)\pcvideo.h del $(INCL)\pcvideo.h
+	if exist $(INCL)\pctiles.h del $(INCL)\pctiles.h
+	if exist $(INCL)\portio.h  del $(INCL)\portio.h
+	if exist $(INCL)\tile.h	   del $(INCL)\tile.h
+	if exist $(SRC)\monstr.c   del $(SRC)\monstr.c
+	if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
+	if exist $(SRC)\tile.c	   del $(SRC)\tile.c
+	if exist $(INCL)\date.h	   del $(INCL)\date.h
+	if exist $(INCL)\onames.h  del $(INCL)\onames.h
+	if exist $(INCL)\pm.h	   del $(INCL)\pm.h
+	if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
+	if exist *.lnk		   del *.lnk
+	if exist *.map		   del *.map
+	if exist $(UTIL)\tilemap.exe       del $(UTIL)\tilemap.exe
+	if exist $(UTIL)\tile2bin.exe      del $(UTIL)\tile2bin.exe
+	if exist $(UTIL)\til2bin2.exe      del $(UTIL)\til2bin2.exe
+	if exist $(UTIL)\viewtib.exe       del $(UTIL)\viewtib.exe
+	if exist $(DAT)\data	   del $(DAT)\data
+	if exist $(DAT)\*.lev      del $(DAT)\*.lev
+	if exist $(DAT)\data	   del $(DAT)\data
+	if exist $(DAT)\dungeon	   del $(DAT)\dungeon
+	if exist $(DAT)\options	   del $(DAT)\options
+	if exist $(DAT)\oracles	   del $(DAT)\oracles
+	if exist $(DAT)\rumors	   del $(DAT)\rumors
+	if exist $(DAT)\quest.dat  del $(DAT)\quest.dat
+	if exist $(DAT)\nhdat      del $(DAT)\nhdat
+	if exist $(DAT)\dlb.lst    del $(DAT)\dlb.lst
+	if exist sp_lev.tag	   del sp_lev.tag
+	if exist $(PLANAR_TIB)	   del $(PLANAR_TIB)
+	if exist $(OVERVIEW_TIB)   del $(OVERVIEW_TIB)
+
+#
+#  Secondary Targets.
+#
+#  The following include files depend on makedefs to be created.
+#
+#  date.h should be remade every time any of the source or include
+#  files is modified.
+
+
+$(INCL)\date.h :  $(UTIL)\makedefs.exe
+	$(UTIL)\makedefs -v
+
+$(INCL)\onames.h :  $(UTIL)\makedefs.exe
+	$(UTIL)\makedefs -o
+
+$(INCL)\pm.h :  $(UTIL)\makedefs.exe
+	$(UTIL)\makedefs -p
+
+monstr.c :  $(UTIL)\makedefs.exe
+	$(UTIL)\makedefs -m
+
+$(INCL)\vis_tab.h :  $(UTIL)\makedefs.exe
+	$(UTIL)\makedefs -z
+
+vis_tab.c :  $(UTIL)\makedefs.exe
+	$(UTIL)\makedefs -z
+
+#
+#  Makedefs Stuff
+#
+
+$(UTIL)\makedefs.exe :   $(MAKEOBJS)
+	$(LINK) $(LFLAGS) $(MAKEOBJS),$@
+
+makedefs.o :   $(CONFIG_H)	$(PERMONST_H)	   $(INCL)\objclass.h \
+		$(INCL)\monsym.h   $(INCL)\qtext.h $(UTIL)\makedefs.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\makedefs.c
+
+#
+#  Level Compiler Dependencies
+#
+
+$(UTIL)\lev_comp.exe :   $(SPLEVOBJS)
+	$(LINK) $(LFLAGS) $(SPLEVOBJS),$@
+
+!IF "$(YACC_LEX)"=="Y"
+
+lev_yacc.o :   $(HACK_H)	 $(SP_LEV_H) $(UTIL)\lev_yacc.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\lev_yacc.c
+
+lev_$(LEX).o :   $(HACK_H)   $(SP_LEV_H)	  $(INCL)\lev_comp.h \
+	lev_$(LEX).c
+	$(CC) $(CFLAGS) -o$@ lev_$(LEX).c
+
+$(INCL)\lev_comp.h :  $(UTIL)\lev_yacc.c
+
+$(UTIL)\lev_yacc.c :   $(UTIL)\lev_comp.y
+	$(YACC) -d $(DUTIL)/lev_comp.y
+	copy $(YTABC) $@
+	copy $(YTABH) $(INCL)\lev_comp.h
+	del $(YTABC)
+	del $(YTABH)
+
+$(UTIL)\lev_$(LEX).c :   $(UTIL)\lev_comp.l
+	$(LEX) $(DUTIL)/lev_comp.l
+	copy $(LEXYYC) $@
+	del $(LEXYYC)
+
+!ELSE
+
+lev_yacc.o :   $(HACK_H)	 $(SP_LEV_H) $(INCL)\lev_comp.h $(SSHR)\lev_yacc.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\lev_yacc.c
+
+lev_$(LEX).o :   $(HACK_H)   $(SP_LEV_H) $(INCL)\lev_comp.h $(SSHR)\lev_lex.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\lev_lex.c
+
+$(INCL)\lev_comp.h :  $(SSHR)\lev_comp.h
+	copy $(SSHR)\lev_comp.h $@
+
+$(UTIL)\lev_$(LEX).c :  $(SSHR)\lev_lex.c
+	copy $(SSHR)\lev_lex.c $@
+
+$(UTIL)\lev_yacc.c : $(SSHR)\lev_yacc.c
+	copy $(SSHR)\lev_yacc.c $@
+
+!ENDIF
+
+lev_main.o :   $(HACK_H) $(UTIL)\lev_main.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\lev_main.c
+
+#
+#  Dungeon Dependencies
+#
+
+$(UTIL)\dgn_comp.exe :   $(DGNCOMPOBJS)
+	$(LINK) $(LFLAGS) $(DGNCOMPOBJS),$@
+
+!IF "$(YACC_LEX)"=="Y"
+
+dgn_yacc.o :   $(HACK_H)	 $(DGN_FILE_H)	$(UTIL)\dgn_yacc.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\dgn_yacc.c
+
+$(UTIL)\dgn_yacc.c :  $(UTIL)\dgn_comp.y
+	$(YACC) -d $(DUTIL)/dgn_comp.y
+	copy $(YTABC) $@
+	copy $(YTABH) $(INCL)\dgn_comp.h
+	del $(YTABC)
+	del $(YTABH)
+
+$(UTIL)\dgn_$(LEX).c :   $(UTIL)\dgn_comp.l
+	$(LEX) $(DUTIL)/dgn_comp.l
+	copy $(LEXYYC) $@
+	del $(LEXYYC)
+
+dgn_$(LEX).o : $(HACK_H) $(DGN_FILE_H) $(INCL)\dgn_comp.h $(UTIL)\dgn_$(LEX).c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\dgn_$(LEX).c
+
+$(INCL)\dgn_comp.h :   $(UTIL)\dgn_yacc.c
+
+!ELSE
+
+dgn_yacc.o : $(HACK_H)	 $(DGN_FILE_H)	$(INCL)\dgn_comp.h $(SSHR)\dgn_yacc.c
+	$(CC) $(CFLAGS) -I$(SSHR) -o$@ $(SSHR)\dgn_yacc.c
+
+dgn_$(LEX).o : $(HACK_H) $(DGN_FILE_H) $(SSHR)\dgn_comp.h $(SSHR)\dgn_lex.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\dgn_lex.c
+
+$(INCL)\dgn_comp.h :   $(SSHR)\dgn_comp.h
+	copy $(SSHR)\dgn_comp.h $@
+
+!ENDIF
+
+dgn_main.o :   $(HACK_H) $(UTIL)\dgn_main.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\dgn_main.c
+
+#
+#  Recover Utility
+#
+
+$(UTIL)\recover.exe :    $(RECOVOBJS)
+	$(LINK) $(LFLAGS) recover.o,$@
+
+recover.o :    $(CONFIG_H) $(UTIL)\recover.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\recover.c
+
+
+#
+#  Header file moves required for tile support
+#
+
+$(INCL)\tile.h :  $(WSHR)\tile.h
+	copy $(WSHR)\tile.h $@
+
+$(INCL)\pctiles.h :  $(MSYS)\pctiles.h
+	copy $(MSYS)\pctiles.h $@
+
+$(INCL)\pcvideo.h :  $(MSYS)\pcvideo.h
+	copy $(MSYS)\pcvideo.h $@
+
+$(INCL)\portio.h :  $(MSYS)\portio.h
+	copy $(MSYS)\portio.h $@
+
+#
+#  Tile Mapping
+#
+tile.o :  $(HACK_H) $(TILE_H) tile.c
+	$(CC) $(CFLAGS) -o$@ tile.c
+
+tile.c :  $(UTIL)\tilemap.exe
+	$(UTIL)\tilemap
+	@echo A new $@ has been created
+
+$(UTIL)\tilemap.exe :  tilemap.o
+	$(LINK) $(LFLAGS) tilemap.o,$@
+
+tilemap.o :  $(WSHR)\tilemap.c $(HACK_H) $(TILE_H)
+	$(CC) $(CFLAGS) -o$@ $(WSHR)\tilemap.c
+
+#
+#   Tile Utilities
+#
+#
+#  Required for tile support
+#
+
+NetHack1.tib :  $(TILEFILES) $(UTIL)\tile2bin.exe
+	@echo Creating binary tile files (this may take some time)
+	$(UTIL)\tile2bin
+
+NetHacko.tib :  thintile.tag $(TILEFILES2) $(UTIL)\til2bin2.exe
+	@echo Creating overview binary tile files (this may take some time)
+	$(UTIL)\til2bin2
+
+$(UTIL)\tile2bin.exe :  tile2bin.o $(TEXTIO)
+	$(LINK) $(LFLAGS) tile2bin.o $(TEXTIO),$@
+
+$(UTIL)\til2bin2.exe :  til2bin2.o $(TEXTIO2)
+	$(LINK) $(LFLAGS) til2bin2.o $(TEXTIO2),$@
+
+$(UTIL)\thintile.exe :  thintile.o 
+	$(LINK) $(LFLAGS) thintile.o,$@
+
+thintile.o :   $(HACK_H) $(INCL)\tile.h $(WSHR)\thintile.c
+	$(CC) $(CFLAGS) -o$@ $(WSHR)\thintile.c
+
+thintile.tag :  $(UTIL)\thintile.exe $(TILEFILES)
+	$(UTIL)\thintile
+	@echo thintiles created >thintile.tag
+
+tile2bin.o :   $(HACK_H) $(INCL)\tile.h $(INCL)\pctiles.h $(INCL)\pcvideo.h \
+	$(MSYS)\tile2bin.c
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\tile2bin.c
+
+til2bin2.o :   $(HACK_H) $(INCL)\tile.h $(INCL)\pctiles.h $(INCL)\pcvideo.h \
+	$(MSYS)\tile2bin.c
+	$(CC) $(CFLAGS) -DTILE_X=8 -DOVERVIEW_FILE -o$@ $(MSYS)\tile2bin.c
+
+tiletext.o :   $(CONFIG_H) $(INCL)\tile.h $(WSHR)\tiletext.c
+	$(CC) $(CFLAGS) -o$@ $(WSHR)\tiletext.c
+
+tiletex2.o :   $(CONFIG_H) $(INCL)\tile.h $(WSHR)\tiletext.c
+	$(CC) $(CFLAGS) -DTILE_X=8 -o$@ $(WSHR)\tiletext.c
+
+tiletxt.o :  $(CONFIG_H)	$(INCL)\tile.h $(WSHR)\tilemap.c
+	$(CC) $(CFLAGS) -DTILETEXT -o$@ $(WSHR)\tilemap.c
+  
+tiletxt2.o :  $(CONFIG_H)	$(INCL)\tile.h $(WSHR)\tilemap.c
+	$(CC) $(CFLAGS) -DTILETEXT -DTILE_X=8 -o$@ $(WSHR)\tilemap.c
+#
+# Optional GIF Utilities (for development)
+#
+
+$(UTIL)\gif2txt.exe :  $(GIFREADERS) $(TEXTIO)
+	$(LINK) $(LFLAGS) $(GIFREADERS) $(TEXTIO)
+
+$(UTIL)\gif2txt2.exe :  $(GIFREAD2) $(TEXTIO2)
+	$(LINK) $(LFLAGS) $(GIFREAD2) $(TEXTIO2)
+
+$(UTIL)\txt2gif.exe :  $(GIFWRITERS) $(TEXTIO)
+	$(LINK) $(LFLAGS) $(GIFWRITERS) $(TEXTIO)
+
+$(UTIL)\txt2gif2.exe :  $(GIFWRIT2) $(TEXTIO2)
+	$(LINK) $(LFLAGS) $(GIFWRIT2) $(TEXTIO2)
+
+gifread.o :  $(CONFIG_H) $(INCL)\tile.h $(WSHR)\gifread.c
+	$(CC) $(CFLAGS) -o$@ $(WSHR)\gifread.c
+
+gifread2.o :  $(CONFIG_H) $(INCL)\tile.h gifread.c
+	$(CC) $(CFLAGS) -DTILE_X=8 -o$@ $(WSHR)\gifread.c
+
+gifwrite.o :  $(CONFIG_H)	$(INCL)\tile.h $(WSHR)\gifwrite.c
+	$(CC) $(CFLAGS) -o$@ $(WSHR)\gifwrite.c
+
+gifwrit2.o :   $(CONFIG_H) $(INCL)\tile.h $(WSHR)\gifwrite.c
+	$(CC) $(CFLAGS) -DTILE_X=8 -o$@ $(WSHR)\gifwrite.c
+
+#
+#  Optional tile viewer (development sources only)
+#
+
+$(UTIL)\viewtib.exe :  viewtib.o
+	$(LINK) $(LFLAGS) viewtib.o,$@
+
+viewtib.o :  $(MSYS)\viewtib.c
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\viewtib.c
+
+#
+#  Other Util Dependencies.
+#
+
+alloc.o :  $(CONFIG_H)	 alloc.c
+	$(CC) $(CFLAGS) -o$@ alloc.c
+
+drawing.o :  $(CONFIG_H) drawing.c
+	$(CC) $(CFLAGS) -o$@ drawing.c
+
+decl.o :  $(CONFIG_H) decl.c
+	$(CC) $(CFLAGS) -o$@ decl.c
+
+monst.o :  $(CONFIG_H)	     $(PERMONST_H)	$(ESHK_H)	   \
+	$(EPRI_H)	      $(VAULT_H)	 $(INCL)\monsym.h   \
+	$(INCL)\color.h	 monst.c
+	$(CC) $(CFLAGS) -o$@ monst.c
+
+objects.o :  $(CONFIG_H)	      $(INCL)\obj.h	 $(INCL)\objclass.h \
+	$(INCL)\prop.h	    $(INCL)\color.h    objects.c
+	$(CC) $(CFLAGS) -o$@ objects.c
+
+panic.o :    $(CONFIG_H)	  $(UTIL)\panic.c
+	$(CC) $(CFLAGS) -o$@ $(UTIL)\panic.c
+
+
+
+
+#
+# make data.base an 8.3 filename to prevent an nmake warning
+#
+
+DATABASE = $(DAT)\data.bas
+
+
+dat.tag :  $(DAT)\data	     $(DAT)\rumors	 $(DAT)\dungeon \
+	$(DAT)\oracles	    $(DAT)\quest.dat	sp_lev.tag $(DLB)
+	@echo dat done >dat.tag
+
+$(DAT)\data : 	 utility.tag	$(DATABASE)
+	$(UTIL)\makedefs -d
+
+$(DAT)\rumors : 	     utility.tag    $(DAT)\rumors.tru	$(DAT)\rumors.fal
+	$(UTIL)\makedefs -r
+
+$(DAT)\quest.dat :  utility.tag  $(DAT)\quest.txt
+	$(UTIL)\makedefs -q
+
+$(DAT)\oracles : 	     utility.tag    $(DAT)\oracles.txt
+	$(UTIL)\makedefs -h
+
+sp_lev.tag :  utility.tag $(DAT)\bigroom.des  $(DAT)\castle.des \
+	$(DAT)\endgame.des $(DAT)\gehennom.des $(DAT)\knox.des	 \
+	$(DAT)\medusa.des	 $(DAT)\oracle.des   $(DAT)\tower.des  \
+	$(DAT)\yendor.des	 $(DAT)\arch.des     $(DAT)\barb.des   \
+	$(DAT)\caveman.des   $(DAT)\healer.des   $(DAT)\knight.des \
+	$(DAT)\monk.des      $(DAT)\priest.des   $(DAT)\ranger.des \
+	$(DAT)\rogue.des     $(DAT)\samurai.des  $(DAT)\tourist.des \
+	$(DAT)\valkyrie.des  $(DAT)\wizard.des
+	cd $(DAT)
+	$(UTIL)\lev_comp bigroom.des
+	$(UTIL)\lev_comp castle.des
+	$(UTIL)\lev_comp endgame.des
+	$(UTIL)\lev_comp gehennom.des
+	$(UTIL)\lev_comp knox.des
+	$(UTIL)\lev_comp mines.des
+	$(UTIL)\lev_comp medusa.des
+	$(UTIL)\lev_comp oracle.des
+	$(UTIL)\lev_comp sokoban.des
+	$(UTIL)\lev_comp tower.des
+	$(UTIL)\lev_comp yendor.des
+	$(UTIL)\lev_comp arch.des
+	$(UTIL)\lev_comp barb.des
+	$(UTIL)\lev_comp caveman.des
+	$(UTIL)\lev_comp healer.des
+	$(UTIL)\lev_comp knight.des
+	$(UTIL)\lev_comp monk.des
+	$(UTIL)\lev_comp priest.des
+	$(UTIL)\lev_comp ranger.des
+	$(UTIL)\lev_comp rogue.des
+	$(UTIL)\lev_comp samurai.des
+	$(UTIL)\lev_comp tourist.des
+	$(UTIL)\lev_comp valkyrie.des
+	$(UTIL)\lev_comp wizard.des
+	cd $(SRC)
+	echo sp_levs done > sp_lev.tag
+	
+$(DAT)\dungeon : 	  utility.tag  $(DAT)\dungeon.def
+	$(UTIL)\makedefs -e
+	cd $(DAT)
+	$(UTIL)\dgn_comp dungeon.pdf
+	cd $(SRC)
+#
+# DLB stuff
+#
+dlb : 	$(UTIL)\dlb_main.exe
+	cd $(DAT)
+	copy $(MSYS)\msdoshlp.txt .
+	@echo data >dlb.lst
+	@echo dungeon >>dlb.lst
+	@echo oracles >>dlb.lst
+	@echo options >>dlb.lst
+	@echo quest.dat >>dlb.lst
+	@echo rumors >>dlb.lst
+	@echo help >>dlb.lst
+	@echo hh >>dlb.lst
+	@echo cmdhelp >>dlb.lst
+	@echo history >>dlb.lst
+	@echo opthelp >>dlb.lst
+	@echo wizhelp >>dlb.lst
+	@echo license >>dlb.lst
+	@echo msdoshlp.txt >>dlb.lst
+	for %%N in (*.lev) do echo %%N >>dlb.lst
+	$(UTIL)\dlb_main cvIf dlb.lst nhdat
+	cd $(SRC)
+
+$(UTIL)\dlb_main.exe :  $(DLBOBJS)
+	$(LINK) /STACK:65000 $(LFLAGS) $(DLBOBJS),$@
+
+dlb_main.o :  $(UTIL)\dlb_main.c $(INCL)\config.h $(DLB_H)
+	$(CC) $(CFLAGS) -odlb_main.o $(UTIL)\dlb_main.c
+
+# Game Dependencies
+# Some files require movement as Gnu make doesn't like unix style '/'
+# directory specs and djgcc doesn't like dos style directory specs.
+# So we get to copy stuff where we might need it.   Fun eh?
+
+# sys/share
+main.o : 	 $(HACK_H) $(DLB_H) $(SSHR)\pcmain.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\pcmain.c
+
+tty.o : 	 $(HACK_H) $(INCL)\wintty.h $(SSHR)\pctty.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\pctty.c
+
+unix.o : 	 $(HACK_H) $(SSHR)\pcunix.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\pcunix.c
+
+sys.o :  $(HACK_H) $(SSHR)\pcsys.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\pcsys.c
+
+random.o : $(HACK_H) $(SSHR)\random.c
+	$(CC) $(CFLAGS) -o$@ $(SSHR)\random.c
+
+# sys/msdos
+msdos.o :  $(HACK_H)  $(MSYS)\msdos.c
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\msdos.c
+
+pckeys.o :  $(HACK_H)  $(MSYS)\pckeys.c
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\pckeys.c
+
+pctiles.o :  $(HACK_H)  $(MSYS)\pctiles.c $(INCL)\portio.h
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\pctiles.c
+
+sound.o :  $(HACK_H)  $(MSYS)\sound.c $(INCL)\portio.h
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\sound.c
+
+video.o :  $(HACK_H)  $(INCL)\pcvideo.h $(INCL)\portio.h $(MSYS)\video.c
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\video.c
+
+vidvga.o :  $(HACK_H)  $(INCL)\pcvideo.h $(INCL)\portio.h $(TILE_H) \
+	$(MSYS)\vidvga.c
+	$(CC) $(CFLAGS) -e -o$@ $(MSYS)\vidvga.c
+
+vidtxt.o :  $(HACK_H)  $(INCL)\pcvideo.h $(INCL)\portio.h $(TILE_H) \
+	$(MSYS)\vidtxt.c
+	$(CC) $(CFLAGS) -o$@ $(MSYS)\vidtxt.c
+
+
+
+# win/tty
+getline.o :  $(HACK_H) $(INCL)\wintty.h $(WIN)\getline.c
+	$(CC) $(CFLAGS) -o$@ $(WIN)\getline.c
+
+termcap.o :  $(CONFIG_H) $(WIN)\termcap.c
+	$(CC) $(CFLAGS) -o$@ $(WIN)\termcap.c
+
+topl.o :  $(CONFIG_H) $(WIN)\topl.c
+	$(CC) $(CFLAGS) -o$@ $(WIN)\topl.c
+
+wintty.o :  $(CONFIG_H) $(WIN)\wintty.c
+	$(CC) $(CFLAGS) -o$@ $(WIN)\wintty.c
+
+# src dependencies
+allmain.o :   $(HACK_H)
+alloc.o :     $(CONFIG_H)
+apply.o :     $(HACK_H) $(INCL)\edog.h
+artifact.o :  $(HACK_H) $(INCL)\artifact.h $(INCL)\artilist.h
+attrib.o :    $(HACK_H) $(INCL)\artifact.h
+ball.o : 	    $(HACK_H)
+bones.o :     $(HACK_H) $(INCL)\lev.h
+botl.o : 	    $(HACK_H)
+cmd.o : 	    $(HACK_H) $(INCL)\func_tab.h
+dbridge.o :   $(HACK_H)
+decl.o : 	    $(HACK_H) $(INCL)\quest.h
+detect.o :    $(HACK_H) $(INCL)\artifact.h
+dig.o :       $(HACK_H)
+display.o :   $(HACK_H)
+dlb.o :       $(HACK_H) $(DLB_H)
+do.o : 	    $(HACK_H) $(INCL)\lev.h
+do_name.o :   $(HACK_H)
+do_wear.o :   $(HACK_H)
+dog.o : 	    $(HACK_H) $(INCL)\edog.h
+dogmove.o :   $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
+dokick.o :    $(HACK_H) $(ESHK_H)
+dothrow.o :   $(HACK_H)
+drawing.o :   $(HACK_H) $(INCL)\tcap.h
+dungeon.o :   $(HACK_H) $(INCL)\dgn_file.h
+eat.o : 	    $(HACK_H)
+end.o : 	    $(HACK_H) $(ESHK_H)
+engrave.o :   $(HACK_H) $(INCL)\lev.h
+exper.o :     $(HACK_H)
+explode.o :   $(HACK_H)
+extralev.o :   $(HACK_H)
+files.o :      $(HACK_H)
+fountain.o :   $(HACK_H)
+hack.o : 	     $(HACK_H)
+hacklib.o :    $(HACK_H)
+invent.o :     $(HACK_H) $(INCL)\artifact.h
+light.o :      $(HACK_H) $(INCL)\lev.h
+lock.o : 	     $(HACK_H)
+mail.o : 	     $(HACK_H) $(INCL)\mail.h
+makemon.o :    $(HACK_H) $(EPRI_H) $(EMIN_H)
+mcastu.o :     $(HACK_H)
+mhitm.o :      $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
+mhitu.o :      $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
+minion.o :     $(HACK_H) $(EMIN_H) $(EPRI_H)
+mklev.o :      $(HACK_H)
+mkmap.o :      $(HACK_H) $(INCL)\sp_lev.h
+mkmaze.o :     $(HACK_H) $(INCL)\sp_lev.h
+mkobj.o :      $(HACK_H) $(INCL)\artifact.h $(INCL)\prop.h
+mkroom.o :     $(HACK_H)
+mon.o : 	     $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
+mondata.o :    $(HACK_H) $(ESHK_H) $(EPRI_H)
+monmove.o :    $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
+monst.o :      $(CONFIG_H) $(PERM_H) $(ESHK_H) $(EPRI_H) \
+	  $(INCL)\color.h $(INCL)\monsym.h $(INCL)\vault.h
+mplayer.o :    $(HACK_H)
+mthrowu.o :    $(HACK_H)
+muse.o : 	     $(HACK_H)
+music.o :      $(HACK_H)
+o_init.o :     $(HACK_H)
+objects.o :    $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h \
+	       $(INCL)\prop.h $(INCL)\color.h
+objnam.o :     $(HACK_H)
+options.o :    $(CONFIG_H) $(HACK_H) $(INCL)\objclass.h $(INCL)\flag.h \
+	      $(INCL)\tcap.h
+pager.o :      $(HACK_H)
+pickup.o :     $(HACK_H)
+pline.o :      $(HACK_H) $(EPRI_H)
+polyself.o :   $(HACK_H)
+potion.o :     $(HACK_H)
+pray.o : 	     $(HACK_H) $(EPRI_H)
+priest.o :     $(HACK_H) $(INCL)\mfndpos.h $(ESHK_H) $(EPRI_H) $(EMIN_H)
+quest.o :      $(HACK_H) $(INCL)\quest.h $(INCL)\qtext.h
+questpgr.o :   $(HACK_H) $(INCL)\qtext.h
+read.o : 	     $(HACK_H)
+region.o :     $(HACK_H)
+rect.o : 	     $(HACK_H)
+restore.o :    $(HACK_H) $(INCL)\lev.h $(INCL)\tcap.h $(INCL)\quest.h
+rip.o : 	     $(HACK_H)
+rnd.o : 	     $(HACK_H)
+role.o :       $(HACK_H)
+rumors.o :     $(HACK_H)
+save.o : 	     $(HACK_H) $(INCL)\lev.h $(INCL)\quest.h
+shk.o : 	     $(HACK_H) $(ESHK_H)
+shknam.o :     $(HACK_H) $(ESHK_H)
+sit.o : 	     $(HACK_H) $(INCL)\artifact.h
+sounds.o :     $(HACK_H) $(INCL)\edog.h
+sp_lev.o :     $(HACK_H) $(INCL)\sp_lev.h $(INCL)\align.h $(INCL)\rect.h
+spell.o :      $(HACK_H)
+steal.o :      $(HACK_H)
+steed.o :      $(HACK_H)
+teleport.o :   $(HACK_H)
+timeout.o :    $(HACK_H)
+topten.o :     $(HACK_H)
+track.o :      $(HACK_H)
+trap.o : 	     $(HACK_H)
+u_init.o :     $(HACK_H)
+uhitm.o :      $(HACK_H)
+vault.o :      $(HACK_H) $(INCL)\vault.h
+version.o :    $(HACK_H) $(INCL)\patchlev.h
+vision.o :     $(HACK_H) $(INCL)\vis_tab.h
+weapon.o :     $(HACK_H)
+were.o : 	     $(HACK_H)
+wield.o :      $(HACK_H)
+windows.o :    $(HACK_H) $(INCL)\wintty.h
+wizard.o :     $(HACK_H) $(INCL)\qtext.h
+worm.o : 	     $(HACK_H) $(INCL)\lev.h
+worn.o : 	     $(HACK_H)
+write.o :      $(HACK_H)
+zap.o : 	     $(HACK_H)
+
+# end of file
diff -Pru nethack-3.4.1/sys/msdos/compwarn.lst nethack/sys/msdos/compwarn.lst
--- nethack-3.4.1/sys/msdos/compwarn.lst	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/compwarn.lst	Tue Apr 23 12:11:50 2002
@@ -0,0 +1,16 @@
+/*	SCSS Id:    @(#)compwarn.lst	3.4	1992/10/08	    */
+/* Copyright (c) Paul Winner, 1992				    */
+/* NetHack may be freely redistributed.  See license for details.   */
+
+This file contains a list of compiler warnings generated by Microsoft
+C version 7.0, compiled with the /W4 switch, and any known reasons for
+the warning.  You can safely ignore any warning your compile gives if
+it appears on this list.
+
+C4127 (4):  Conditional expression is constant
+	    The While(1) statements used in the code cause this warning.
+	    For the sake of making more easily readable code, this is the
+	    preferred construct for NetHack.
+C4131 (4):  function: uses old-style declarator
+	    In order to make the code as portable as possible, all func-
+	    tions in NetHack use the old-style declarator.
diff -Pru nethack-3.4.1/sys/msdos/def2mak.c nethack/sys/msdos/def2mak.c
--- nethack-3.4.1/sys/msdos/def2mak.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/def2mak.c	Tue Apr 23 12:11:52 2002
@@ -0,0 +1,383 @@
+/*	SCCS Id: @(#)def2mak.c	3.4	1995/03/19	*/
+/* Copyright (c) NetHack PC Development Team, 1994. */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#include "config.h"
+#include <malloc.h>
+#include <ctype.h>
+#ifndef _MSC_VER
+#include <stdlib.h>
+#else
+int __cdecl _strcmpi(const char *, const char *);
+int __cdecl _stricmp(const char *, const char *);
+int __cdecl _strnicmp(const char *, const char *,size_t);
+#endif
+
+#define	MALLOC(type)	(type *)malloc(sizeof(type))
+
+#define MACROID_SIZ	50
+#define MACROVAL_SIZ	300
+
+typedef unsigned char bool;
+
+struct MacroNode * FDECL(AddMacro, (struct MacroNode *, char *, char *));
+char * FDECL(ApplyMacros, (char *, struct MacroNode *));
+struct MacroNode * FDECL(DelMacro, (struct MacroNode *));
+struct MacroNode * FDECL(DelMacroList, (struct MacroNode *));
+void FDECL(COMPILER, (bool, char *, char *, FILE *));
+void FDECL(SaveNewLine, (char *, char *));
+struct ListItem * FDECL(AddItem, (struct ListItem *, char *));
+struct ListItem * FDECL(ReadList, (FILE *, int));
+void FDECL(LINKLIST, (bool, struct ListItem *, char *, char *));
+struct ListTable * FDECL(AddList, (struct ListTable *, struct ListItem *,
+    char *));
+struct ListItem * FDECL(DelTableList, (struct ListItem *));
+struct ListTable * FDECL(DelTable, (struct ListTable *));
+struct ListItem * FDECL(FindList, (struct ListTable *, char *));
+
+#ifdef strcmpi
+# undef strcmpi		/* don't want to drag in hacklib.c */
+#endif
+
+#ifdef _MSC_VER
+#define stricmp _strcmpi
+#define strnicmp _strnicmp
+#endif
+
+int
+strcmpi(s1, s2)
+char *s1, *s2;
+{
+	char t1, t2;
+
+	while (*s1 || *s2) {
+		if (!*s2) return 1;		/* s1 > s2 */
+		else if (!*s1) return -1;	/* s1 < s2 */
+		if (isupper(*s1)) t1 = tolower(*s1); else t1 = *s1;
+		if (isupper(*s2)) t2 = tolower(*s2); else t2 = *s2;
+		if (t1 != t2) return (t1 > t2) ? 1 : -1;
+		s1++; s2++;
+	}
+	return 0;				/* s1 == s2 */
+}
+
+struct MacroNode {
+	char Name[MACROID_SIZ];
+	char Val[MACROVAL_SIZ];
+	struct MacroNode *Next;
+};
+
+struct MacroNode *
+AddMacro (List, MID, MVal)
+struct MacroNode *List;
+char *MID;
+char *MVal;
+{
+	struct MacroNode *Tmp;
+	Tmp = MALLOC (struct MacroNode);
+	strncpy (Tmp->Name, MID, MACROID_SIZ);
+	strncpy (Tmp->Val, MVal, MACROVAL_SIZ);
+	Tmp->Next = List;
+        return Tmp;
+}
+
+char *
+ApplyMacros (Line, List)
+char *Line;
+struct MacroNode *List;
+{
+	static char TotalLine[MACROVAL_SIZ + 100];
+	char TmpLine[MACROVAL_SIZ + 100];
+	int AfterLine;
+        char MacroName[MACROID_SIZ];
+	struct MacroNode *TmpList;
+
+	strcpy (TotalLine, "");
+	strcpy (TmpLine, Line);
+        if (sscanf (TmpLine, "%[^?]?[%[^]]]%n", TotalLine, MacroName,
+		&AfterLine) <= 1) return Line;
+        for (TmpList = List; TmpList; TmpList = TmpList->Next)
+	    if (!strcmp(TmpList->Name, MacroName)) {
+		strcat (TotalLine, TmpList->Val);
+		break;
+	    }
+	strcat (TotalLine, TmpLine + AfterLine);
+	return TotalLine;
+}
+
+struct MacroNode *
+DelMacro (List)
+struct MacroNode *List;
+{
+	struct MacroNode *tmp;
+
+        tmp = List->Next;
+        free (List);
+        return tmp;
+}
+
+struct MacroNode *
+DelMacroList (List)
+struct MacroNode *List;
+{
+	while (List != NULL)
+            List = DelMacro (List);
+	return List;
+}
+
+void
+COMPILER (display, SavedNewLine, EndString, input)
+bool display;
+char *SavedNewLine;
+char *EndString;
+FILE *input;
+{
+        char buffer[100];
+
+        fgets (buffer, 100, input);
+        while (strnicmp(buffer, EndString, strlen(EndString))) {
+            if (display)
+                SaveNewLine(buffer, SavedNewLine);
+            fgets (buffer, 100, input);
+        };
+}
+
+void
+SaveNewLine (Line, NewLine)
+char *Line;
+char *NewLine;
+{
+	char tempNewLine[2];
+
+	strcpy (tempNewLine, "");
+	if (Line[strlen(Line)-1] == '\n') {
+        	Line[strlen(Line)-1] = '\0';
+                strcpy (tempNewLine, "\n");
+	};
+        printf ("%s%s", NewLine, Line);
+        strcpy (NewLine, tempNewLine);
+}
+
+struct ListItem {
+	char Item[40];
+	struct ListItem *next;
+};
+
+struct ListTable {
+	char name[40];
+	struct ListItem *List;
+	struct ListTable *next;
+};
+
+struct ListItem *
+AddItem (List, Item)
+struct ListItem *List;
+char Item[40];
+{
+	struct ListItem *temp;
+
+	temp = MALLOC(struct ListItem);
+	temp->next = List;
+	strncpy (temp->Item, Item, 39);
+	return temp;
+}
+
+struct ListItem *
+ReadList (input, LinePos)
+FILE *input;
+int LinePos;
+{
+	char Item[40];
+	char buffer[100];
+	struct ListItem *List;
+
+	List = NULL;
+	fscanf (input, "%39s", Item);
+	while (strncmp(Item, "?ENDLIST?", 9)) {
+	    if (LinePos > 60) {
+		LinePos = 18;
+		printf ("\\\n\t\t");
+	    }
+	    List = AddItem(List, Item);
+	    printf ("%s ", Item);
+	    LinePos += 1 + strlen(Item);
+	    fscanf (input, "%39s", Item);
+	}
+	printf ("\n");
+	fgets (buffer, 100, input);
+	return List;
+}
+
+void
+LINKLIST (BC, List, Listname, SavedNewLine)
+bool BC;
+struct ListItem *List;
+char *Listname;
+char *SavedNewLine;
+{
+	int LinePos;
+
+	printf ("%s\t\t", SavedNewLine);
+	strcpy (SavedNewLine, "");
+
+        if (!BC) {
+            printf ("$(%s:^\t=+^\n\t\t)\n", Listname);
+	    return;
+        };
+
+	if (List == NULL) return;
+
+	LinePos = 18;
+	while (List != NULL) {
+	    if (LinePos > 60) {
+		LinePos = 18;
+		printf ("+\n\t\t");
+	    }
+	    printf ("%s ", List->Item);
+	    LinePos += 1 + strlen(List->Item);
+	    List = List->next;
+	}
+	printf ("\n");
+}
+
+struct ListTable *
+AddList (Table, List, Name)
+struct ListTable *Table;
+struct ListItem *List;
+char *Name;
+{
+	struct ListTable *temp;
+	temp = MALLOC (struct ListTable);
+	temp->next = Table;
+	temp->List = List;
+	strncpy (temp->name, Name, 39);
+	return temp;
+}
+
+struct ListItem *
+DelTableList (List)
+struct ListItem *List;
+{
+	struct ListItem *temp;
+
+	while (List != NULL) {
+	    temp = List->next;
+	    free (List);
+	    List = temp;
+	};
+	return List;
+}
+
+struct ListTable *
+DelTable (Table)
+struct ListTable *Table;
+{
+	struct ListTable *temp;
+
+	while (Table != NULL) {
+	    temp = Table->next;
+	    Table->List = DelTableList(Table->List);
+	    free(Table);
+	    Table=temp;
+	};
+	return Table;
+}
+
+struct ListItem *
+FindList (Table, Item)
+struct ListTable *Table;
+char *Item;
+{
+	while (Table != NULL) {
+	    if (!stricmp(Table->name, Item)) return Table->List;
+	    Table = Table->next;
+	}
+	return NULL;
+}
+
+int
+main (argc, argv)
+int argc;
+char *argv[];
+{
+        FILE *makfile;
+        char buffer[100];
+        char SavedNewLine[2];
+	char Listname[40];
+	struct ListTable *Table;
+        time_t timer;
+        bool MSC, BC;
+	struct MacroNode *MacroList = NULL;
+	char MacroName[MACROID_SIZ];
+	char MacroVal[MACROVAL_SIZ];
+
+        if (argc < 3) {
+		printf ("Too few arguments.  Correct usage is:\n");
+		printf ("\t%s {/MSC || /BC} template\n\n", "def2mak");
+		printf ("\t{/MSC || /BC} indicate the compiler to use.\n");
+		printf ("\ttemplate is the template file to process.\n\n");
+		printf ("The output makefile goes to standard output.\n");
+        	return 1;
+	};
+	Table = NULL;
+	if (!strcmpi(argv[1], "/MSC") || !strcmpi(argv[1], "-MSC")) {
+            MSC = TRUE;
+            BC = FALSE;
+	} else if (!strcmpi(argv[1], "/BC") || !strcmpi(argv[1], "-BC")) {
+            MSC = FALSE;
+            BC = TRUE;
+	} else {
+            fprintf (stderr, "Unknown compiler format: %s\n", argv[1]);
+            return 1;
+	};
+
+        strcpy (SavedNewLine, "");
+        if ((makfile = fopen (argv[2], "r")) == NULL)
+        	return 2;
+	COMPILER (0, SavedNewLine, "?BEGIN?", makfile);
+	while (!feof(makfile)) {
+            if (fgets(buffer, 100, makfile) == NULL)
+		break;
+	    if (!strnicmp(buffer, "?SCCS?", 6)) {
+		time (&timer);
+	      printf ("%s#\tSCCS Id: @(#)Makefile.%s\t3.4\t%02d/%02d/%02d\n",
+                    SavedNewLine,
+		    MSC ? "MSC" : BC ? "BC" : "???",
+		    localtime(&timer)->tm_year,
+		    localtime(&timer)->tm_mon + 1,
+		    localtime(&timer)->tm_mday);
+		printf ("# Copyright (c) %s, %d.\n",
+		    BC ? "Yitzhak Sapir" : "NetHack PC Development Team",
+		    localtime(&timer)->tm_year + 1900);
+		printf ("# NetHack may be freely distributed.  ");
+		printf ("See license for details.\n#\n\n");
+		strcpy (SavedNewLine, "");
+            } else if (MSC ? sscanf (buffer, "?MSCMACRO:%[^=]=%[^?]?",
+			MacroName, MacroVal) :
+			BC ? sscanf (buffer, "?BCMACRO:%[^=]=%[^?]?",
+			MacroName, MacroVal) : 0)
+		MacroList = AddMacro(MacroList, MacroName, MacroVal);
+	    else if (!strnicmp(buffer, "?BC?", 4))
+                COMPILER(BC, SavedNewLine, "?ENDBC?", makfile);
+            else if (!strnicmp(buffer, "?MSC?", 5))
+                COMPILER(MSC, SavedNewLine, "?ENDMSC?", makfile);
+            else if (!strnicmp(buffer, "?COMMENT?", 9))
+                COMPILER(FALSE, SavedNewLine, "?ENDCOMMENT?", makfile);
+	    else if (sscanf(buffer, "?LIST:%[^?]?", Listname)
+		    == 1) {
+		printf ("%s%s\t=", SavedNewLine, Listname);
+		Table = AddList (Table, ReadList (makfile, 18), Listname);
+		strcpy (SavedNewLine, "");
+	    } else if (sscanf(buffer, "?LINKLIST:%[^?]?", Listname)
+		    == 1)
+		LINKLIST (BC, FindList(Table, Listname), Listname,
+		    SavedNewLine);
+            else if (buffer[0] != '?')
+                SaveNewLine(ApplyMacros(buffer, MacroList), SavedNewLine);
+        };
+	printf ("%s", SavedNewLine);
+        fclose (makfile);
+	Table = DelTable(Table);
+	MacroList = DelMacroList (MacroList);
+	return 0;
+}
diff -Pru nethack-3.4.1/sys/msdos/genschem.l nethack/sys/msdos/genschem.l
--- nethack-3.4.1/sys/msdos/genschem.l	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/genschem.l	Tue Apr 23 12:11:52 2002
@@ -0,0 +1,326 @@
+%{
+
+#include "config.h"
+#include <stdlib.h>
+#include <ctype.h>
+
+#define	MALLOC(type)	(type *)malloc(sizeof(type))
+
+typedef unsigned char bool;
+
+struct OvlNode {
+	char FileName[13];
+	char Comment[80];
+	int  OvlNumber;
+        struct OvlNode *Next;
+};
+
+int linenumber = 1;
+int OvlNum = -1;
+FILE *outf = NULL;
+char *ovldesc = NULL;
+struct OvlNode *List = NULL;
+char *CommentTemplate;
+
+struct OvlNode * FDECL(AddNode, (struct OvlNode *, struct OvlNode *));
+struct OvlNode * FDECL(DelNode, (struct OvlNode *));
+struct OvlNode * FDECL(ReverseList, (struct OvlNode *));
+struct OvlNode * FDECL(SortList, (struct OvlNode *));
+int NDECL (yylex);
+
+#ifndef	yywrap
+int NDECL (yywrap);
+#endif
+
+#ifdef exit
+#undef exit
+#endif
+
+%}
+
+FILECH	[A-Za-z0-9_]
+FILE	{FILECH}{1,8}("."{FILECH}{0,3})?
+SCCS	[Ss][Cc][Cc][Ss].*\n
+COPYR	[Cc][Oo][Pp][Yy][Rr][Ii][Gg][Hh][Tt].*\n
+
+%%
+
+{SCCS}	{ linenumber ++; }
+{COPYR}	{ linenumber ++; }
+^#.*\n	{
+	    if (OvlNum < 0) {
+		yytext[yyleng - 1] = 0;
+		fprintf (outf, CommentTemplate, yytext+1);
+	    }
+	    linenumber ++;
+	}
+\n	{ linenumber ++; }
+[ \t]+	;	/* skip trailing tabs & spaces */
+\[.*\]	{
+	    yytext[yyleng-1] = 0; /* Discard the trailing \] */
+	    if (ovldesc) free (ovldesc);
+	    ovldesc = (char *) malloc(strlen(yytext+1)+1);
+	    strcpy(ovldesc, yytext+1); /* Discard the first \[ */
+	    OvlNum++;
+	}
+{FILE}	{
+	    struct OvlNode *Tmp;
+
+	    Tmp = MALLOC (struct OvlNode);
+	    strcpy (Tmp->FileName, yytext);
+	    Tmp->OvlNumber = OvlNum;
+	    strncpy (Tmp->Comment, ovldesc, 80);
+	    List = AddNode (List, Tmp);
+	}
+.	{
+	    printf ("Line %d: Received character '%c' (%02x)\n",
+			linenumber, *yytext, *yytext);
+	}
+
+
+%%
+
+#ifndef yywrap
+int
+yywrap()
+{
+	return 1;
+}
+#endif
+
+#if defined(UNIX) || defined(_MSC_VER)
+char *
+strlwr(s)
+char *s;
+{
+	char *p;
+	for (p = s; *p; p++)
+		if (isupper(*p)) *p = tolower(*p);
+	return s;
+}
+
+char *
+strupr(s)
+char *s;
+{
+	char *p;
+	for (p = s; *p; p++)
+		if (islower(*p)) *p = toupper(*p);
+	return s;
+}
+#endif
+
+struct OvlNode *
+SortList (List)
+struct OvlNode *List;
+{
+	struct OvlNode *List1 = NULL;
+	struct OvlNode *List2 = NULL;
+	struct OvlNode *Tmp;
+
+	if (List == NULL) return NULL;
+	if (List->Next == NULL) return List;
+
+	while (List != NULL) {
+	    if (List != NULL) {
+		Tmp = List->Next;
+		List1 = AddNode (List1, List);
+		List = Tmp;
+	    }
+	    if (List != NULL) {
+		Tmp = List->Next;
+		List2 = AddNode (List2, List);
+		List = Tmp;
+	    }
+	}
+
+	List1 = SortList (List1);
+	List2 = SortList (List2);
+
+	while (List1 != NULL || List2 != NULL) {
+	    while (List1 != NULL && List2 == NULL) {
+		Tmp = List1->Next;
+		List = AddNode (List, List1);
+		List1 = Tmp;
+	    }
+	    while (List1 != NULL &&
+		    strcmp(List1->FileName, List2->FileName) <= 0) {
+		Tmp = List1->Next;
+		List = AddNode (List, List1);
+		List1 = Tmp;
+	    }
+	    while (List2 != NULL && List1 == NULL) {
+		Tmp = List2->Next;
+		List = AddNode (List, List2);
+		List2 = Tmp;
+	    }
+	    while (List2 != NULL &&
+		    strcmp(List1->FileName, List2->FileName) >= 0) {
+		Tmp = List2->Next;
+		List = AddNode (List, List2);
+		List2 = Tmp;
+	    }
+	}
+
+	return ReverseList (List);
+}
+
+struct OvlNode *
+AddNode (List, ToAdd)
+struct OvlNode *List;
+struct OvlNode *ToAdd;
+{
+	ToAdd->Next = List;
+        return ToAdd;
+}
+
+struct OvlNode *
+DelNode (List)
+struct OvlNode *List;
+{
+	struct OvlNode *tmp;
+
+        tmp = List->Next;
+        free (List);
+        return tmp;
+}
+
+struct OvlNode *
+DelOvlList (List)
+struct OvlNode *List;
+{
+	while (List != NULL)
+            List = DelNode (List);
+	return List;
+}
+
+struct OvlNode *
+ReverseList (List)
+struct OvlNode *List;
+{
+	struct OvlNode *Temp, *Last;
+
+	Last = NULL; Temp = List;
+	while (Temp) {
+	    Temp = List->Next;
+	    List->Next = Last;
+	    Last = List;
+	    List = Temp;
+	}
+	return Last;
+}
+
+/*
+ * Deletes all nodes with filename equal to that of the first node, except
+ * for the first node, itself, which it keeps.
+ */
+
+void
+DelFile (List)
+struct OvlNode *List;
+{
+	struct OvlNode *tmp;
+
+        tmp = List;
+        while (tmp->Next != NULL) {
+	    if (!stricmp(List->FileName, tmp->Next->FileName))
+                tmp->Next = DelNode (tmp->Next);
+            else
+                tmp = tmp->Next;
+        };
+}
+
+int
+InList (List, ToFind)
+struct OvlNode *List;
+struct OvlNode *ToFind;
+{
+        while (List != NULL) {
+            if (!stricmp(List->FileName, ToFind->FileName))
+                return 1;
+            List = List->Next;
+        };
+        return 0;
+}
+
+int
+main (argc, argv)
+int argc;
+char *argv[];
+{
+        bool MSC, BC;
+	char *Header, *Header2, *Header3, *RootLine, *OvlLine;
+	char *c;
+	char FileName[9];
+	time_t timer;
+	struct tm *curtim;
+
+        if (argc < 3) {
+
+	printf ("Too few arguments.  Correct usage is:\n");
+	printf ("\t%s {/MSC || /BC} schemafile deffile\n\n", "genschem");
+	printf ("\t{/MSC || /BC} indicate the compiler to use.\n");
+	printf ("\tschemafile is the schema file to process.\n");
+	printf ("\tdeffile is the definition file to produce.\n");
+	printf ("\t\tif deffile is missing, stdout is assumed.\n\n");
+        	return 1;
+	};
+	if (!stricmp(argv[1], "/MSC") || !stricmp(argv[1], "-MSC")) {
+            MSC = TRUE;
+            BC = FALSE;
+	} else if (!stricmp(argv[1], "/BC") || !stricmp(argv[1], "-BC")) {
+            MSC = FALSE;
+            BC = TRUE;
+	} else {
+            fprintf (stderr, "Unknown compiler format: %s\n", argv[1]);
+            return 1;
+	};
+
+	Header = BC ? "/* SCCS Id: @(#)%s\t3.4\t %02d/%02d/%02d */\n" :
+	    "; SCCS Id: @(#)%s\t3.4\t %02d/%02d/%02d\n";
+	Header2 = BC ? "/* Copyright (c) Yitzhak Sapir, %d */\n" :
+	    "; Copyright (c) NetHack PC Development Team, %d\n";
+	Header3 = BC ? "\n\n" : ";\n\nSEGMENTS\n\n";
+	RootLine = BC ? "-zC%s\n" :
+	    "\"%s\" OVL:0\n";
+	OvlLine = BC ?
+	    "-zC%s -zAOVLY -zCOVL%d\n" :
+	    "\"%s\" OVL:%d\n";
+	CommentTemplate = BC ? "/* %s */\n" : ";%s\n";
+
+	yyin = fopen (argv[2], "r");
+
+	if (yyin == NULL) {
+	    fprintf (stderr, "Error: Input file incorrect\n");
+	    exit (1);
+	}
+
+	outf = fopen (argv[3], "w");
+
+	if (outf == NULL)
+	    if (argc == 4) {
+		fprintf (stderr, "Error: Output file incorrect\n");
+		exit (1);
+	    } else outf = stdout;
+
+	time (&timer);
+	curtim = localtime(&timer);
+	fprintf (outf, Header, argv[3], curtim->tm_year, curtim->tm_mon + 1,
+		curtim->tm_mday);
+	fprintf (outf, Header2, curtim->tm_year +1900);
+	yylex();
+
+	fprintf (outf, Header3);
+
+	for (List = SortList (List); List != NULL; List = DelNode (List)) {
+	    if (BC) {
+		for (c = strlwr(List->FileName); *c; c++)
+		    if (*c == '.') *c = '_';
+	    } else strupr(List->FileName);
+	    if (List->OvlNumber)
+		fprintf (outf, OvlLine, List->FileName, List->OvlNumber);
+	    else fprintf (outf, RootLine, List->FileName, List->FileName);
+	}
+	fclose (outf);
+
+}
diff -Pru nethack-3.4.1/sys/msdos/old/MakeMSC.src nethack/sys/msdos/old/MakeMSC.src
--- nethack-3.4.1/sys/msdos/old/MakeMSC.src	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/MakeMSC.src	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,740 @@
+# SCCS Id: @(#)MakeMSC.src	3.1	93/07/11
+# Copyright (c) NetHack PC Development Team 1992, 1993
+# PC NetHack 3.1 Makefile for Microsoft(tm) "C" >= 6.0ax and MSVC >= 1.0
+#
+# Nota Bene:	Before you get to here you should have already read
+# 		the Install.dos file located in the sys/msdos directory.
+
+# This Makefile supports two different overlay management schemes.
+# You must select either the one that supports Microsoft C
+# version 6, or the one that supports Microsoft C version 7 and 
+# Microsoft Visual C++ Professional version 1 (MSVC).  By default this 
+# Makefile is set up for version 7 or greater (including MSVC).  Certain 
+# sections particular to each compiler are marked either MSC7/MSVC or MSC6.
+# If you are using Microsoft C version 7 or MSVC, make sure that all the MSC6
+# sections are commented out and pay particular attention
+# to all sections marked MSC7/MSVC, uncommenting all the variables.
+# Do the same thing for MSC6 if you are using that version of
+# the compiler.
+#
+# MSC6 Notes:
+#	As it is set up, this makefile requires that exesmurf (the
+#	NetHack overlay-aware .exe header editor) be on your path or in the
+#	$(SRC) directory. If you wish to change the path or use Microsoft
+#	EXEMOD instead, see the symbols EXEPATCH and EXEFLAGS.
+#
+
+#
+# Game Installation Variables.
+# NOTE: Make sure GAMEDIR exists before make is started.
+#
+
+GAME	= NetHack
+GAMEDIR = c:\games\nethack
+default: $(GAME)
+
+#
+#	Source code and data file directories.
+#
+
+DAT	= ..\dat
+INCL	= ..\include
+SRC	= .
+OBJ	= $(SRC)\o
+SYS	= ..\sys\msdos
+SSYS	= ..\sys\share
+UTL	= ..\util
+WIN	= ..\win\tty
+
+#
+#	Exe File Info.
+#	($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.)
+#
+
+ASM	= masm		# Assembler
+CC	= cl		# Compiler
+LINK	= link		# Linker
+MAKEBIN = make45l	# Make Utility
+
+#
+# Make the necessary changes in *one* of the two sections below.
+#
+
+
+#### MSC7/MSVC Section Only #####
+# MSC7 and MSVC Compiler Flags are set up in the setup.bat file using
+# the CL environment variable as the total lenth of the compiler
+# command line exceeds the MSDOS 128 character limit.
+#
+CFLAGS	= /c
+LFLAGS	= /noi /seg:512 /map /st:5120 /DYNAMIC:1052 /INFO
+OVLMUCKING =	# None required
+MSC6MUCK =	# None required
+OVERLAY =	# None required
+OVERLAY_H =	# None required
+############################
+
+
+#### MSC6 Section Only #####
+#
+# First comment out the MSC7/MSVC section.  And uncomment much of what is below.
+#
+
+#
+# CC	There was a register bug, to be safe remove stack probes.
+# /Gt18 is currently about the largest value that keeps the initialised
+#	data segment below 64K (and keeps the linker happy).
+# /G2	286 or higher machines can use the /G2 CFLAG option for better
+#	performance.
+#
+#CFLAGS	= /AL /c /Os /Gs /Gt18 /Zp1 /W0 /I$(INCL)
+#LFLAGS	= /noi /seg:512 /map /st:4096
+#EXEPATCH = exesmurf	# Executable Massager
+#EXEFLAGS = /max4500 /min4500
+#OVLMUCKING = $(EXEPATCH) $(OBJ)\ovlmgr.obj
+#MSC6MUCK = msc6muck
+
+#
+# For Microsoft C version <= 6.00ax, we use a custom overlay
+# manager.
+#
+# Switch the following $(OBJ)\$(OVLMGR): lines if you don't have a
+# MASM compatible assembler.
+#$(OBJ)\ovlmgr.obj: $(SYS)\ovlmgr.asm
+#	$(ASM) $(AFLAGS) $(SYS)\ovlmgr.asm, $@ ;
+$(OBJ)\ovlmgr.obj: ; copy $(SYS)\ovlmgr.obj $(OBJ)\ovlmgr.obj
+
+#
+# Object files and a header file required for trampoli overlay system.
+#
+#OVERLAY = $(OBJ)\ovlmgr.obj $(OBJ)\trampoli.o
+#OVERLAY_H = $(INCL)\trampoli.h
+
+#
+# If you need to recompile ovlmgr.asm you may want to change
+# some of the flags.
+AFLAGS = /MX
+# /Di386	= Use 386 specific enhancements
+# /DNOEMS	= Do not use EMS memory
+# /DDEBUG	= Report memory usage on startup
+# /DNOSPLIT	= EXE file is not split out to OVL files
+
+#
+# Uncomment these sections.
+#
+#$(EXEPATCH): $(EXEPATCH).exe
+#$(EXEPATCH).exe: $(OBJ)\$(EXEPATCH).o
+#	$(LINK) $(OBJ)\$*.o, $*.exe;
+
+############################
+
+#
+#	Optional high-quality BSD random number generation routines
+#	(see pcconf.h).	Set to nothing if not used.
+#
+
+RANDOM	= $(OBJ)\random.o
+# RANDOM	=
+
+#
+# If TERMLIB is #defined in the source (in include\pcconf.h), 
+# comment out the upper line and uncomment the lower.  Make sure 
+# that TERMLIB contains the full pathname to the termcap library. 
+
+TERMLIB =
+#TERMLIB = $(SSYS)\termcap.lib
+
+#
+#	Nothing below this line should have to be changed.
+#
+
+#
+#	Make Roolz dude.
+#	Due to an NDMake inadequacy these must accord with a topological
+#	sort of the generated-from relation... output on the left, input
+#	on the right. Trust me.
+#
+
+.SUFFIXES: .exe .0 .0-1 .0-2 .0-3 .1 .1-2 .1-3 .1-b .2 .2-3 .2-b .3 .3-b .b \
+	   .o .c .y .l .obj .asm
+
+.c.o:
+	$(CC) $(CFLAGS) /Fo$@ $<
+.c.0:
+	$(CC) $(CFLAGS) /DOVL0 /NT$(@F) /Fo$@ $<
+.c.0-1:
+	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /NT$(@F) /Fo$@ $<
+.c.0-2:
+	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /NT$(@F) /Fo$@ $<
+.c.0-3:
+	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /DOVL3 /NT$(@F) /Fo$@ $<
+.c.1:
+	$(CC) $(CFLAGS) /DOVL1 /NT$(@F) /Fo$@ $<
+.c.1-2:
+	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /NT$(@F) /Fo$@ $<
+.c.1-3:
+	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVL3 /NT$(@F) /Fo$@ $<
+.c.1-b:
+	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVL3 /DOVLB /NT$(@F) /Fo$@ $<
+.c.2:
+	$(CC) $(CFLAGS) /DOVL2 /NT$(@F) /Fo$@ $<
+.c.2-3:
+	$(CC) $(CFLAGS) /DOVL2 /DOVL3 /NT$(@F) /Fo$@ $<
+.c.2-b:
+	$(CC) $(CFLAGS) /DOVL2 /DOVL3 /DOVLB /NT$(@F) /Fo$@ $<
+.c.3:
+	$(CC) $(CFLAGS) /DOVL3 /NT$(@F) /Fo$@ $<
+.c.3-b:
+	$(CC) $(CFLAGS) /DOVL3 /DOVLB /NT$(@F) /Fo$@ $<
+.c.b:
+	$(CC) $(CFLAGS) /DOVLB /NT$(@F) /Fo$@ $<
+.asm.obj:
+	$(ASM) $(AFLAGS) $<, $@ ;
+
+#
+#	Header Objects.
+#
+
+CONFIG_H   = $(GLOBAL_H)	$(INCL)\tradstdc.h	$(INCL)\config.h
+DECL_H	   = $(YOU_H)		$(INCL)\spell.h		$(INCL)\color.h	\
+	     $(INCL)\obj.h	$(INCL)\onames.h	$(INCL)\pm.h \
+	     $(INCL)\decl.h
+DGN_FILE_H = $(INCL)\align.h	$(INCL)\dgn_file.h
+DISPLAY_H  = $(MONDATA_H)	$(INCL)\vision.h	$(INCL)\display.h
+DUNGEON_H  = $(INCL)\align.h	$(INCL)\dungeon.h
+EMIN_H	   = $(DUNGEON_H)	$(INCL)\emin.h
+EPRI_H	   = $(DUNGEON_H)	$(INCL)\align.h		$(INCL)\epri.h
+ESHK_H	   = $(DUNGEON_H)	$(INCL)\eshk.h
+GLOBAL_H   = $(PCCONF_H)	$(INCL)\coord.h		$(INCL)\global.h
+HACK_H	   = $(CONFIG_H)	$(DUNGEON_H)		$(DECL_H) \
+	     $(DISPLAY_H)	$(INCL)\monsym.h	$(INCL)\mkroom.h \
+	     $(INCL)\objclass.h	$(INCL)\trap.h		$(INCL)\flag.h	\
+	     $(RM_H)		$(INCL)\vision.h	$(INCL)\wintype.h \
+	     $(INCL)\engrave.h	$(INCL)\rect.h \
+	     $(INCL)\trampoli.h	$(INCL)\hack.h
+MONDATA_H  = $(INCL)\align.h	$(INCL)\mondata.h
+MONST_H	   = $(INCL)\align.h	$(INCL)\monst.h
+PCCONF_H   = $(INCL)\micro.h	$(INCL)\system.h	$(INCL)\pcconf.h
+PERMONST_H = $(INCL)\monattk.h	$(INCL)\monflag.h	$(INCL)\align.h	\
+	     $(INCL)\permonst.h
+RM_H	   = $(INCL)\align.h	$(INCL)\rm.h
+SP_LEV_H   = $(INCL)\align.h	$(INCL)\sp_lev.h
+VAULT_H	   = $(DUNGEON_H)	$(INCL)\vault.h
+YOU_H	   = $(MONST_H)		$(YOUPROP_H)		$(INCL)\align.h	\
+	     $(INCL)\attrib.h	$(INCL)\you.h
+YOUPROP_H  = $(PERMONST_H)	$(MONDATA_H)		$(INCL)\prop.h	\
+	     $(INCL)\pm.h	$(INCL)\youprop.h
+
+#
+#	Overlay Objects.
+#
+
+ROOT =	$(OVERLAY) $(OBJ)\main.o $(OBJ)\msdos.0 $(OBJ)\dungeon.0 \
+	$(OBJ)\alloc.o $(OBJ)\random.o $(OBJ)\decl.o $(OBJ)\dbridge.0 \
+	$(OBJ)\objects.o $(OBJ)\invent.0 $(OBJ)\mkobj.0 $(OBJ)\mkroom.0 \
+	$(OBJ)\rnd.0 $(OBJ)\video.0 $(OBJ)\mondata.0 $(OBJ)\muse.o \
+	$(OBJ)\engrave.0 $(OBJ)\explode.o $(OBJ)\display.o $(OBJ)\vision.o \
+	$(OBJ)\attrib.0 $(OBJ)\rect.o $(OBJ)\vis_tab.o $(OBJ)\hacklib.0 \
+	$(OBJ)\monst.o $(OBJ)\hack.3 $(OBJ)\topl.0 $(OBJ)\trap.0 \
+	$(OBJ)\termcap.0 $(OBJ)\wintty.o $(OBJ)\monmove.0 $(OBJ)\dogmove.0
+
+# These could use to go in root, but are in OLV1 to make
+# the game loadable in under 512 free ram.
+# rhack and friends
+OVL01 = $(OBJ)\allmain.0 $(OBJ)\artifact.0 $(OBJ)\attrib.1 $(OBJ)\cmd.1 \
+	$(OBJ)\do.1 $(OBJ)\do.3 $(OBJ)\eat.0 $(OBJ)\engrave.2 \
+	$(OBJ)\getline.0-1 $(OBJ)\hack.1-2 \
+	$(OBJ)\botl.1 $(OBJ)\sounds.0 $(OBJ)\timeout.0 \
+	$(OBJ)\track.1 $(OBJ)\vault.0 $(OBJ)\wizard.0 $(OBJ)\hacklib.1
+# startup
+OVL02 = $(OBJ)\dungeon.1 $(OBJ)\files.o $(OBJ)\pcsys.o \
+	$(OBJ)\monstr.o $(OBJ)\msdos.b
+# main monster code
+OVL03 = $(OBJ)\cmd.0 $(OBJ)\engrave.1 $(OBJ)\mondata.1 \
+	$(OBJ)\mthrowu.0 $(OBJ)\priest.0 $(OBJ)\track.0 \
+	$(OBJ)\trap.1 $(OBJ)\were.0
+# monster movement
+OVL04 = $(OBJ)\mon.0-1 $(OBJ)\monmove.1
+# pet monster movement
+OVL05 = $(OBJ)\dog.1 $(OBJ)\dogmove.1-b
+# advanced monsters
+OVL06 = $(OBJ)\minion.o $(OBJ)\mcastu.o
+OVL07 = $(OBJ)\priest.1-b $(OBJ)\shk.1-b
+OVL08 = $(OBJ)\were.1-b
+OVL09 = $(OBJ)\wizard.1-b
+OVL10 = $(OBJ)\worm.o
+# 11-15 around the movement loop
+# domove and friends
+OVL11 = $(OBJ)\hack.0 $(OBJ)\apply.0 $(OBJ)\do_wear.1 $(OBJ)\lock.0 \
+	$(OBJ)\cmd.2
+OVL12 = $(OBJ)\detect.o
+OVL13 = $(OBJ)\attrib.2-b $(OBJ)\exper.o
+OVL14 = $(OBJ)\eat.1 $(OBJ)\invent.1
+OVL15 = $(OBJ)\makemon.0-2 $(OBJ)\mkobj.1
+OVL16 = $(OBJ)\makemon.b $(OBJ)\mplayer.o $(OBJ)\mkobj.2-b
+OVL17 = $(OBJ)\mhitm.1-b
+OVL18 = $(OBJ)\mthrowu.1
+OVL19 = $(OBJ)\mthrowu.2-b
+OVL20 = $(OBJ)\allmain.1 $(OBJ)\mhitm.0 $(OBJ)\mhitu.0-1 $(OBJ)\rnd.1 \
+	$(OBJ)\weapon.0-1
+OVL21 = $(OBJ)\mon.2-b
+OVL22 = $(OBJ)\artifact.1 $(OBJ)\uhitm.o $(OBJ)\weapon.2-b
+OVL23 = $(OBJ)\do_wear.0 $(OBJ)\mhitu.2-b
+OVL24 = $(OBJ)\steal.0-1
+OVL25 = $(OBJ)\monmove.2-b $(OBJ)\steal.2-b
+OVL26 = $(OBJ)\rnd.2-b
+OVL27 = $(OBJ)\do_wear.2 $(OBJ)\mondata.2 $(OBJ)\objnam.0-1 \
+	$(OBJ)\polyself.0-1
+OVL28 = $(OBJ)\do_name.0
+OVL29 = $(OBJ)\objnam.2-b $(OBJ)\hacklib.2-b
+OVL30 = $(OBJ)\pager.o
+OVL31 = $(OBJ)\botl.0
+OVL32 = $(OBJ)\botl.b $(OBJ)\topl.b $(OBJ)\termcap.1 $(OBJ)\windows.o \
+	$(OBJ)\video.1
+OVL33 = $(OBJ)\topl.1-2
+OVL34 = $(OBJ)\pline.o
+OVL35 = $(OBJ)\termcap.2-b $(OBJ)\video.2-b
+OVL36 = $(OBJ)\quest.o $(OBJ)\questpgr.o
+OVL37 = $(OBJ)\invent.b
+OVL38 = $(OBJ)\hack.b
+OVL39 = $(OBJ)\mondata.b $(OBJ)\timeout.1-b $(OBJ)\dog.b $(OBJ)\sounds.1-b
+OVL40 = $(OBJ)\do.0 $(OBJ)\invent.3
+OVL41 = $(OBJ)\cmd.b $(OBJ)\getline.2 $(OBJ)\write.o
+OVL42 = $(OBJ)\apply.2-b
+OVL43 = $(OBJ)\do.b $(OBJ)\drawing.o
+OVL44 = $(OBJ)\dokick.o
+OVL45 = $(OBJ)\dothrow.o
+OVL46 = $(OBJ)\eat.2-b
+OVL47 = $(OBJ)\invent.2 $(OBJ)\pickup.o
+OVL48 = $(OBJ)\lock.1-b
+OVL49 = $(OBJ)\polyself.2-b
+OVL50 = $(OBJ)\potion.o
+OVL51 = $(OBJ)\pray.o
+OVL52 = $(OBJ)\read.1-b $(OBJ)\spell.o
+OVL53 = $(OBJ)\ball.o
+# clothing stuff
+OVL54 = $(OBJ)\do_wear.b $(OBJ)\wield.o $(OBJ)\worn.o
+# Zappage
+OVL55 = $(OBJ)\zap.o
+OVL56 = $(OBJ)\dbridge.1-b
+OVL57 = $(OBJ)\trap.b
+# Unusual circumstances
+OVL58 = $(OBJ)\artifact.b $(OBJ)\do_name.1-b $(OBJ)\fountain.o $(OBJ)\music.o \
+	$(OBJ)\rumors.o $(OBJ)\sit.o $(OBJ)\vault.1-b
+# Uppers and Downers
+OVL59 = $(OBJ)\apply.1 $(OBJ)\bones.o $(OBJ)\mklev.o
+OVL60 = $(OBJ)\save.o $(OBJ)\restore.o
+OVL61 = $(OBJ)\mkmaze.o $(OBJ)\mkroom.1-b $(OBJ)\mkmap.o
+# Note: version.o is in OVL62, but in a special way.  See below.
+OVL62 = $(OBJ)\allmain.2-b $(OBJ)\end.o $(OBJ)\engrave.b \
+	$(OBJ)\o_init.o $(OBJ)\options.o $(OBJ)\rip.o \
+	$(OBJ)\shknam.o $(OBJ)\topten.o $(OBJ)\tty.o \
+	$(OBJ)\u_init.o $(OBJ)\unix.1-b
+# Levelling
+OVL63 = $(OBJ)\do.2 $(OBJ)\dog.2 $(OBJ)\extralev.o \
+	$(OBJ)\sp_lev.o $(OBJ)\track.2-b
+
+#
+#	Make Objects.
+#
+
+MOBJ = $(OVL01) $(OVL02) $(OVL03) $(OVL04) $(OVL05) $(OVL06) $(OVL07) $(OVL08)\
+       $(OVL09) $(OVL10) $(OVL11) $(OVL12) $(OVL13) $(OVL14) $(OVL15) $(OVL16)\
+       $(OVL17) $(OVL18) $(OVL19) $(OVL20) $(OVL21) $(OVL22) $(OVL23) $(OVL24)\
+       $(OVL25) $(OVL26) $(OVL27) $(OVL28) $(OVL29) $(OVL30) $(OVL31) $(OVL32)\
+       $(OVL33) $(OVL34) $(OVL35) $(OVL36) $(OVL37) $(OVL38) $(OVL39) $(OVL40)\
+       $(OVL41) $(OVL42) $(OVL43) $(OVL44) $(OVL45) $(OVL46) $(OVL47) $(OVL48)\
+       $(OVL49) $(OVL50) $(OVL51) $(OVL52) $(OVL53) $(OVL54) $(OVL55) $(OVL56)\
+       $(OVL57) $(OVL58) $(OVL59) $(OVL60) $(OVL61) $(OVL62) $(OVL63)
+
+VOBJ = $(ROOT)	$(MOBJ)
+
+HOBJ = $(VOBJ)	$(OBJ)\version.o
+
+OVERLAYS = ($(OVL01)) ($(OVL02)) ($(OVL03)) ($(OVL04)) ($(OVL05)) ($(OVL06)) \
+	   ($(OVL07)) ($(OVL08)) ($(OVL09)) ($(OVL10)) ($(OVL11)) ($(OVL12)) \
+	   ($(OVL13)) ($(OVL14)) ($(OVL15)) ($(OVL16)) ($(OVL17)) ($(OVL18)) \
+	   ($(OVL19)) ($(OVL20)) ($(OVL21)) ($(OVL22)) ($(OVL23)) ($(OVL24)) \
+	   ($(OVL25)) ($(OVL26)) ($(OVL27)) ($(OVL28)) ($(OVL29)) ($(OVL30)) \
+	   ($(OVL31)) ($(OVL32)) ($(OVL33)) ($(OVL34)) ($(OVL35)) ($(OVL36)) \
+	   ($(OVL37)) ($(OVL38)) ($(OVL39)) ($(OVL40)) ($(OVL41)) ($(OVL42)) \
+	   ($(OVL43)) ($(OVL44)) ($(OVL45)) ($(OVL46)) ($(OVL47)) ($(OVL48)) \
+	   ($(OVL49)) ($(OVL50)) ($(OVL51)) ($(OVL52)) ($(OVL53)) ($(OVL54)) \
+	   ($(OVL55)) ($(OVL56)) ($(OVL57)) ($(OVL58)) ($(OVL59)) ($(OVL60)) \
+	   ($(OVL61)) ($(OVL62)	$(OBJ)\version.o) ($(OVL63))
+
+#
+#	Primary make targets.
+#
+
+GAMEFILE = $(GAMEDIR)\$(GAME).exe
+
+all: install
+
+install: $(DAT)\sp_lev.tag	$(GAMEFILE)	$(MSC6MUCK)	install.tag
+	@echo Don't forget to check HACKDIR in $(GAMEDIR)\NetHack.cnf.
+	@echo Done.
+
+install.tag: $(GAMEFILE) $(MSC6MUCK)
+	copy $(SSYS)\termcap		$(GAMEDIR)
+	copy $(DAT)\*.?			$(GAMEDIR)
+	copy $(DAT)\*.dat		$(GAMEDIR)
+	copy $(DAT)\*.lev		$(GAMEDIR)
+	copy $(SSYS)\NetHack.cnf	$(GAMEDIR)
+	copy $(UTL)\recover.exe		$(GAMEDIR)
+	copy $(SYS)\msdos.hlp		$(GAMEDIR)
+	del  $(GAMEDIR)\makefile
+	echo install done > install.tag
+
+$(GAME): $(GAMEFILE) $(MSC6MUCK)
+
+$(GAME).exe: $(GAMEFILE) $(MSC6MUCK)
+
+$(GAMEFILE): $(UTL)\utility.tag $(OBJ) $(OVLMUCKING) $(HOBJ)
+	@echo Loading....
+	$(LINK) $(LFLAGS) $(ROOT) $(OVERLAYS),$(GAMEFILE),$(GAME),$(TERMLIB);
+	@del $(GAMEDIR)\$(GAME).bak > NUL
+	@echo $(GAME) is up to date.
+
+msc6muck:
+	$(EXEPATCH) $(GAMEFILE) $(EXEFLAGS)
+	$(EXEPATCH) $(GAMEFILE) 1 40
+
+#
+#	Secondary Targets.
+#
+
+clean:
+	del $(OBJ)\*.o
+	del $(OBJ)\*.0
+	del $(OBJ)\*.0-1
+	del $(OBJ)\*.0-2
+	del $(OBJ)\*.0-3
+	del $(OBJ)\*.1
+	del $(OBJ)\*.1-2
+	del $(OBJ)\*.1-3
+	del $(OBJ)\*.1-b
+	del $(OBJ)\*.2
+	del $(OBJ)\*.2-3
+	del $(OBJ)\*.2-b
+	del $(OBJ)\*.3
+	del $(OBJ)\*.3-b
+	del $(OBJ)\*.b
+	del $(OBJ)\*.obj
+	rmdir $(OBJ)
+
+spotless: clean
+	del *.exe
+	del *.bak
+	del *.tag
+	del *.map
+	del *.obj
+	del *.lib
+	del *.txt
+
+$(OBJ):
+	if not exist $(OBJ)\*.* mkdir $(OBJ)
+
+#
+# I'm not too fond of using this `attrib .foo` command to stop make,
+# but I can't think of any better generic way to do it.
+# It works for DOS 3.3, 4.00, & 5.0.
+# If you find a better one please feel free to implement it.
+#
+$(UTL)\utility.tag: monst.c	alloc.c			objects.c \
+	$(UTL)\makedefs.c	$(UTL)\panic.c		$(UTL)\recover.c \
+	$(UTL)\dgn_main.c	$(UTL)\dgn_comp.l	$(UTL)\dgn_comp.y \
+	$(UTL)\lev_main.c	$(UTL)\lev_comp.l	$(UTL)\lev_comp.y \
+	$(HACK_H)		$(INCL)\patchlevel.h	$(INCL)\qtext.h
+	@echo You must first "$(MAKEBIN) all" in the $(UTL) directory.
+	@attrib .foo
+
+$(DAT)\sp_lev.tag: $(UTL)\utility.tag
+	@echo You must first "$(MAKEBIN) all" in the $(DAT) directory.
+	@attrib .foo
+
+#
+# Other dependencies
+#
+
+$(INCL)\date.h: $(VOBJ)
+	$(UTL)\makedefs -v
+
+#
+#	Overlay/PC source code dependencies.
+#
+
+#
+#	$(SYS) files.
+#
+
+$(OBJ)\msdos.0: $(HACK_H) $(INCL)\termcap.h $(SYS)\msdos.c
+	$(CC) $(CFLAGS) /DOVL0 /NT$(@F) /Fo$@ $(SYS)\msdos.c
+
+$(OBJ)\msdos.b: $(HACK_H) $(INCL)\termcap.h $(SYS)\msdos.c
+	$(CC) $(CFLAGS) /DOVLB /NT$(@F) /Fo$@ $(SYS)\msdos.c
+
+$(OBJ)\trampoli.o: $(HACK_H) $(SYS)\trampoli.c
+	$(CC) $(CFLAGS) /Fo$@ $(SYS)\trampoli.c
+
+$(OBJ)\video.0:	$(HACK_H) $(INCL)\wintty.h $(SYS)\video.c
+	$(CC) $(CFLAGS) /DOVL0 /NT$(@F) /Fo$@ $(SYS)\video.c
+
+$(OBJ)\video.1: $(HACK_H) $(INCL)\wintty.h $(SYS)\video.c
+	$(CC) $(CFLAGS) /DOVL1 /NT$(@F) /Fo$@ $(SYS)\video.c
+
+$(OBJ)\video.2-b: $(HACK_H) $(INCL)\wintty.h $(SYS)\video.c
+	$(CC) $(CFLAGS) /DOVL2 /DOVLB /NT$(@F) /Fo$@ $(SYS)\video.c
+
+$(OBJ)\exesmurf.o: $(SYS)\exesmurf.c
+	$(CC) $(CFLAGS) /Fo$@ $(SYS)\exesmurf.c
+
+#
+#	$(SSYS) files.
+#
+
+$(OBJ)\main.o: $(HACK_H)	$(SSYS)\pcmain.c
+	$(CC) $(CFLAGS) /Fo$@ $(SSYS)\pcmain.c
+
+$(OBJ)\pcsys.o:	$(HACK_H)	$(INCL)\wintty.h	$(SSYS)\pcsys.c
+	$(CC) $(CFLAGS) /Fo$@ $(SSYS)\pcsys.c
+
+$(OBJ)\random.o: $(SSYS)\random.c
+	$(CC) $(CFLAGS) /Fo$@ $(SSYS)\random.c
+
+$(OBJ)\tty.o: $(HACK_H)		$(INCL)\wintty.h	$(SSYS)\pctty.c
+	$(CC) $(CFLAGS) /Fo$@	$(SSYS)\pctty.c
+
+$(OBJ)\unix.0: $(HACK_H)	$(SSYS)\pcunix.c
+	$(CC) $(CFLAGS) /DOVL0 /Fo$@ $(SSYS)\pcunix.c
+
+$(OBJ)\unix.1-b: $(HACK_H)	$(SSYS)\pcunix.c
+	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /DOVL3 /DOVLB /Fo$@ $(SSYS)\pcunix.c
+
+#
+#	$(WIN) files.
+#
+
+$(OBJ)\getline.0-1: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\func_tab.h \
+	$(WIN)\getline.c
+	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /NT$(@F) /Fo$@ $(WIN)\getline.c
+
+$(OBJ)\getline.2: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\func_tab.h \
+	$(WIN)\getline.c
+	$(CC) $(CFLAGS) /DOVL2 /NT$(@F) /Fo$@ $(WIN)\getline.c
+
+$(OBJ)\getline.b: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\func_tab.h \
+	$(WIN)\getline.c
+	$(CC) $(CFLAGS) /DOVLB /NT$(@F) /Fo$@ $(WIN)\getline.c
+
+$(OBJ)\termcap.0: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
+	$(WIN)\termcap.c
+	$(CC) $(CFLAGS) /DOVL0 /NT$(@F) /Fo$@ $(WIN)\termcap.c
+
+$(OBJ)\termcap.1: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
+	$(WIN)\termcap.c
+	$(CC) $(CFLAGS) /DOVL1 /NT$(@F) /Fo$@ $(WIN)\termcap.c
+
+$(OBJ)\termcap.2-b: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
+	$(WIN)\termcap.c
+	$(CC) $(CFLAGS) /DOVL2 /DOVLB /NT$(@F) /Fo$@ $(WIN)\termcap.c
+
+$(OBJ)\topl.0: $(HACK_H)	$(INCL)\termcap.h	$(INCL)\wintty.h \
+	$(WIN)\topl.c
+	$(CC) $(CFLAGS) /DOVL0 /NT$(@F) /Fo$@ $(WIN)\topl.c
+
+$(OBJ)\topl.1-2: $(HACK_H)	$(INCL)\termcap.h	$(INCL)\wintty.h \
+	$(WIN)\topl.c
+	$(CC) $(CFLAGS) /DOVL1 /DOVL2 /NT$(@F) /Fo$@ $(WIN)\topl.c
+
+$(OBJ)\topl.b: $(HACK_H)	$(INCL)\termcap.h	$(INCL)\wintty.h \
+	$(WIN)\topl.c
+	$(CC) $(CFLAGS) /DOVLB /NT$(@F) /Fo$@ $(WIN)\topl.c
+
+$(OBJ)\wintty.o: $(HACK_H)	$(INCL)\wintty.h	$(INCL)\termcap.h \
+	$(WIN)\wintty.c
+	$(CC) $(CFLAGS) /DOVL0 /DOVL1 /DOVL2 /DOVLB /Fo$@ $(WIN)\wintty.c
+
+#
+#	$(SRC) files.
+#
+# DO NOT DELETE THIS LINE
+#
+
+$(OBJ)\allmain.0:	$(HACK_H)
+$(OBJ)\allmain.1:	$(HACK_H)
+$(OBJ)\allmain.2-b:	$(HACK_H)
+$(OBJ)\alloc.o:		$(CONFIG_H)
+$(OBJ)\apply.0:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\apply.1:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\apply.2-b:	$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\artifact.0:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
+$(OBJ)\artifact.1:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
+$(OBJ)\artifact.2:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
+$(OBJ)\artifact.b:	$(HACK_H)	$(INCL)\artifact.h  $(INCL)\artilist.h
+$(OBJ)\attrib.0:	$(HACK_H)
+$(OBJ)\attrib.1:	$(HACK_H)
+$(OBJ)\attrib.2-b:	$(HACK_H)
+$(OBJ)\ball.o:		$(HACK_H)
+$(OBJ)\bones.o:		$(HACK_H)
+$(OBJ)\botl.0:		$(HACK_H)
+$(OBJ)\botl.1:		$(HACK_H)
+$(OBJ)\botl.2:		$(HACK_H)
+$(OBJ)\botl.b:		$(HACK_H)
+$(OBJ)\cmd.0:		$(HACK_H)	$(INCL)\func_tab.h
+$(OBJ)\cmd.1:		$(HACK_H)	$(INCL)\func_tab.h
+$(OBJ)\cmd.b:		$(HACK_H)	$(INCL)\func_tab.h
+$(OBJ)\dbridge.0:	$(HACK_H)
+$(OBJ)\dbridge.1-b:	$(HACK_H)
+$(OBJ)\decl.o:		$(HACK_H)	$(INCL)\quest.h
+$(OBJ)\detect.o:	$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\display.o:	$(HACK_H)
+$(OBJ)\do.0:		$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\do.1:		$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\do.2:		$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\do.3:		$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\do.b:		$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\do_name.0:	$(HACK_H)
+$(OBJ)\do_name.1-b:	$(HACK_H)
+$(OBJ)\do_wear.0-1:	$(HACK_H)
+$(OBJ)\do_wear.2:	$(HACK_H)
+$(OBJ)\do_wear.b:	$(HACK_H)
+$(OBJ)\dog.0:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\dog.1:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\dog.2:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\dog.b:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\dogmove.0:	$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
+$(OBJ)\dogmove.1-b:	$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
+$(OBJ)\dokick.o:	$(HACK_H)	$(ESHK_H)
+$(OBJ)\dothrow.o:	$(HACK_H)
+$(OBJ)\drawing.o:	$(HACK_H)	$(INCL)\termcap.h
+$(OBJ)\dungeon.o:	$(HACK_H)	$(DGN_FILE_H)
+$(OBJ)\eat.0:		$(HACK_H)
+$(OBJ)\eat.1:		$(HACK_H)
+$(OBJ)\eat.2-b:		$(HACK_H)
+$(OBJ)\end.o:		$(HACK_H)	$(ESHK_H)
+$(OBJ)\engrave.0-1:	$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\engrave.2:	$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\engrave.b:	$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\exper.o:		$(HACK_H)
+$(OBJ)\explode.o:	$(HACK_H)
+$(OBJ)\extralev.o:	$(HACK_H)
+$(OBJ)\files.o:		$(HACK_H)
+$(OBJ)\fountain.o:	$(HACK_H)
+$(OBJ)\hack.0:		$(HACK_H)
+$(OBJ)\hack.1:		$(HACK_H)
+$(OBJ)\hack.2:		$(HACK_H)
+$(OBJ)\hack.b:		$(HACK_H)
+$(OBJ)\hacklib.0:	$(HACK_H)
+$(OBJ)\hacklib.1:	$(HACK_H)
+$(OBJ)\hacklib.2-b:	$(HACK_H)
+$(OBJ)\invent.0:	$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\invent.1:	$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\invent.2:	$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\invent.3:	$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\invent.b:	$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\lock.0:		$(HACK_H)
+$(OBJ)\lock.1-b:	$(HACK_H)
+$(OBJ)\mail.0:		$(HACK_H)	$(INCL)\mail.h
+$(OBJ)\mail.1-b:	$(HACK_H)	$(INCL)\mail.h
+$(OBJ)\makemon.0-2:	$(HACK_H)	$(EPRI_H)	$(EMIN_H)
+$(OBJ)\makemon.b:	$(HACK_H)	$(EPRI_H)	$(EMIN_H)
+$(OBJ)\mcastu.o:	$(HACK_H)
+$(OBJ)\mhitm.0:		$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
+$(OBJ)\mhitm.1-b:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
+$(OBJ)\mhitu.0-1:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
+$(OBJ)\mhitu.2-b:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\edog.h
+$(OBJ)\minion.o:	$(HACK_H)	$(EMIN_H)
+$(OBJ)\mklev.o:		$(HACK_H)
+$(OBJ)\mkmaze.o:	$(HACK_H)	$(SP_LEV_H)
+$(OBJ)\mkobj.0:		$(HACK_H)	$(INCL)\artifact.h	$(INCL)\prop.h
+$(OBJ)\mkobj.1:		$(HACK_H)	$(INCL)\artifact.h	$(INCL)\prop.h
+$(OBJ)\mkobj.2-b:	$(HACK_H)	$(INCL)\artifact.h	$(INCL)\prop.h
+$(OBJ)\mkroom.0:	$(HACK_H)
+$(OBJ)\mkroom.1-b:	$(HACK_H)
+$(OBJ)\mon.0-1:		$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
+$(OBJ)\mon.2-b:		$(HACK_H)	$(INCL)\mfndpos.h	$(INCL)\edog.h
+$(OBJ)\mondata.0-1:	$(HACK_H)	$(ESHK_H)	$(EPRI_H)
+$(OBJ)\mondata.2:	$(HACK_H)	$(ESHK_H)	$(EPRI_H)
+$(OBJ)\mondata.b:	$(HACK_H)	$(ESHK_H)	$(EPRI_H)
+$(OBJ)\monmove.0-1:	$(HACK_H)	$(INCL)\mfndpos.h $(INCL)\artifact.h
+$(OBJ)\monmove.2-b:	$(HACK_H)	$(INCL)\mfndpos.h $(INCL)\artifact.h
+$(OBJ)\monst.o:		$(CONFIG_H)	$(PERMONST_H)	$(INCL)\monsym.h \
+			$(ESHK_H)	$(VAULT_H)	$(EPRI_H) \
+			$(INCL)\color.h
+$(OBJ)\monstr.o:	$(CONFIG_H)
+$(OBJ)\mplayer.o:	$(HACK_H)
+$(OBJ)\mthrowu.0:	$(HACK_H)
+$(OBJ)\mthrowu.1:	$(HACK_H)
+$(OBJ)\mthrowu.2-b:	$(HACK_H)
+$(OBJ)\muse.o:		$(HACK_H)
+$(OBJ)\music.o:		$(HACK_H)
+$(OBJ)\o_init.o:	$(HACK_H)
+$(OBJ)\objects.o:	$(CONFIG_H)	$(INCL)\obj.h	$(INCL)\objclass.h \
+			$(INCL)\prop.h	$(INCL)\color.h
+$(OBJ)\objnam.0-1:	$(HACK_H)
+$(OBJ)\objnam.2-b:	$(HACK_H)
+$(OBJ)\options.o:	$(HACK_H)	$(INCL)\termcap.h
+$(OBJ)\pager.o:		$(HACK_H)
+	$(CC) $(CFLAGS) /Od /Fo$(OBJ)\$*.o $*.c
+$(OBJ)\pickup.o:	$(HACK_H)
+$(OBJ)\pline.o:		$(HACK_H)	$(EPRI_H)
+$(OBJ)\polyself.0-1:	$(HACK_H)
+$(OBJ)\polyself.2-b:	$(HACK_H)
+$(OBJ)\potion.o:	$(HACK_H)
+$(OBJ)\pray.o:		$(HACK_H)	$(EPRI_H)
+$(OBJ)\priest.0:	$(HACK_H)	$(INCL)\mfndpos.h	$(ESHK_H) \
+			$(EPRI_H)	$(EMIN_H)
+$(OBJ)\priest.1-b:	$(HACK_H)	$(INCL)\mfndpos.h	$(ESHK_H) \
+			$(EPRI_H)	$(EMIN_H)
+$(OBJ)\quest.o:		$(HACK_H)	$(INCL)\quest.h	$(INCL)\qtext.h
+$(OBJ)\questpgr.o:	$(HACK_H)	$(INCL)\qtext.h
+$(OBJ)\read.0:		$(HACK_H)
+$(OBJ)\read.1-b:	$(HACK_H)
+$(OBJ)\rect.o:		$(HACK_H)
+$(OBJ)\restore.o:	$(HACK_H)	$(INCL)\lev.h	$(INCL)\termcap.h \
+			$(INCL)\quest.h
+$(OBJ)\rip.o:		$(HACK_H)
+$(OBJ)\rnd.0:		$(HACK_H)
+$(OBJ)\rnd.1:		$(HACK_H)
+$(OBJ)\rnd.2-b:		$(HACK_H)
+$(OBJ)\rumors.o:	$(HACK_H)
+$(OBJ)\save.o:		$(HACK_H)	$(INCL)\lev.h	$(INCL)\quest.h
+$(OBJ)\shk.0:		$(HACK_H)	$(ESHK_H)
+$(OBJ)\shk.1-b:		$(HACK_H)	$(ESHK_H)
+$(OBJ)\shknam.0:	$(HACK_H)	$(ESHK_H)
+$(OBJ)\shknam.1-b:	$(HACK_H)	$(ESHK_H)
+$(OBJ)\sit.o:		$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\sounds.0:	$(HACK_H)	$(INCL)\edog.h	$(ESHK_H)
+$(OBJ)\sounds.1-b:	$(HACK_H)	$(INCL)\edog.h	$(ESHK_H)
+$(OBJ)\sp_lev.o:	$(HACK_H)	$(SP_LEV_H)	$(INCL)\rect.h
+$(OBJ)\spell.o:		$(HACK_H)
+$(OBJ)\steal.0-1:	$(HACK_H)
+$(OBJ)\steal.2-b:	$(HACK_H)
+$(OBJ)\timeout.0:	$(HACK_H)
+$(OBJ)\timeout.1-b:	$(HACK_H)
+$(OBJ)\topten.o:	$(HACK_H)
+$(OBJ)\track.0:		$(HACK_H)
+$(OBJ)\track.1:		$(HACK_H)
+$(OBJ)\track.2-b:	$(HACK_H)
+$(OBJ)\trap.0-1:	$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\trap.2:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\trap.b:		$(HACK_H)	$(INCL)\edog.h
+$(OBJ)\u_init.o:	$(HACK_H)
+$(OBJ)\uhitm.o:		$(HACK_H)	$(INCL)\artifact.h
+$(OBJ)\vault.0:		$(HACK_H)	$(VAULT_H)
+$(OBJ)\vault.1-b:	$(HACK_H)	$(VAULT_H)
+$(OBJ)\version.o:	$(HACK_H)	$(INCL)\date.h	$(INCL)\patchlev.h
+$(OBJ)\vision.o:	$(HACK_H)	$(INCL)\vis_tab.h
+$(OBJ)\vis_tab.o:	$(HACK_H)	$(INCL)\vis_tab.h
+$(OBJ)\weapon.0-1:	$(HACK_H)
+$(OBJ)\weapon.2-b:	$(HACK_H)
+$(OBJ)\were.0:		$(HACK_H)
+$(OBJ)\were.1-b:	$(HACK_H)
+$(OBJ)\wield.o:		$(HACK_H)
+$(OBJ)\wizard.0:	$(HACK_H)	$(INCL)\qtext.h
+$(OBJ)\wizard.1-b:	$(HACK_H)	$(INCL)\qtext.h
+$(OBJ)\worm.o:		$(HACK_H)	$(INCL)\lev.h
+$(OBJ)\worn.o:		$(HACK_H)
+$(OBJ)\write.o:		$(HACK_H)
+$(OBJ)\zap.o:		$(HACK_H)
diff -Pru nethack-3.4.1/sys/msdos/old/MakeMSC.utl nethack/sys/msdos/old/MakeMSC.utl
--- nethack-3.4.1/sys/msdos/old/MakeMSC.utl	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/MakeMSC.utl	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,322 @@
+#	SCCS Id: @(#)MakeMSC.utl	 3.1	 93/05/23
+# Copyright (c) NetHack PC Development Team 1992, 1993.
+# NetHack may be freely redistributed.  See license for details.
+#
+# PC NetHack 3.1 Utilities Source Code Makefile for Microsoft(tm) "C" >= 6.0ax
+# and Microsoft Visual C++ Professional version >= 1.0.
+#
+#	In addition to your C compiler,
+#
+#	if you want to change		you will need a
+#	files with suffix		workalike for
+#	       .y			    yacc
+#	       .l			    lex
+
+#
+#	Executables.
+#
+
+CC	= cl
+LINK	= link
+MAKEBIN	= make45l
+
+#
+#	Yacc/Lex ... if you got 'em.
+#	(Note: if you don't, leave the top pair uncommented.)
+#
+
+YACC	= yacc
+LEX	= lex
+# YACC	= bison -y
+# LEX	= flex
+
+YTABC	= y_tab.c
+YTABH	= y_tab.h
+LEXYYC	= lexyy.c
+
+#
+#	Flags.
+#
+
+#
+#	+ prepare for CodeView symbolic debugger.
+#
+
+CDFLAGS	=
+#CDFLAGS = /Zi
+
+LDFLAGS =
+#LDFLAGS = /CO
+
+#
+#	CC
+#
+
+CPPFLAGS = /E /AL /c /Os /Gs /Gt20 /Zp1 /W0 /I$(INCL) $(CDFLAGS)
+CFLAGS	 = /AL /c /Os /Gs /Gt20 /Zp1 /W0 /I$(INCL) $(CDFLAGS)
+
+#
+#	Link
+#
+
+LFLAGS	= /noi /seg:512 /map /st:5120 $(LDFLAGS)
+
+#
+#	Directories
+#
+
+INCL	= ..\include
+DAT	= ..\dat
+SRC	= ..\src
+OBJ	= $(SRC)\o
+
+default: all
+#
+#	If you have yacc and lex programs and make any changes, comment
+#	out the upper two targets and uncomment the lower two.
+#
+
+do_yacc: yacc_msg
+do_lex:  lex_msg
+# do_yacc: yacc_act
+# do_lex:  lex_act
+
+#
+#	Optional C library specifier for those with non-standard
+#	libraries or a multiple-target library setup.
+#
+
+# CLIB	   = llibcer /nod
+CLIB	 =
+
+#############################################################################
+#
+# nothing below this line should have to be changed
+#
+
+#
+#	Utility Objects.
+#
+
+MAKESRC     =	makedefs.c
+
+SPLEVSRC    =   lev_yacc.c  lev_$(LEX).c  lev_main.c  panic.c
+
+DGNCOMPSRC  =   dgn_yacc.c  dgn_$(LEX).c  dgn_main.c
+
+MAKEOBJS    =	makedefs.o	  $(OBJ)\monst.o    $(OBJ)\objects.o
+
+SPLEVOBJS   =	lev_yacc.o	  lev_$(LEX).o	    lev_main.o \
+		$(OBJ)\alloc.o	  $(OBJ)\decl.o     $(OBJ)\drawing.o \
+		$(OBJ)\monst.o    $(OBJ)\objects.o  panic.o
+
+DGNCOMPOBJS =	dgn_yacc.o	  dgn_$(LEX).o	    dgn_main.o \
+		$(OBJ)\alloc.o	  panic.o
+
+RECOVOBJS   =	recover.o
+
+#
+#	Header Objects.
+#
+
+CONFIG_H   = $(GLOBAL_H)           $(INCL)\tradstdc.h $(INCL)\config.h
+DECL_H     = $(YOU_H)              $(INCL)\quest.h    $(INCL)\spell.h  \
+             $(INCL)\color.h       $(INCL)\obj.h      $(INCL)\onames.h \
+             $(INCL)\pm.h          $(INCL)\decl.h
+DGN_FILE_H = $(INCL)\align.h       $(INCL)\dgn_file.h
+DISPLAY_H  = $(MONDATA_H)          $(INCL)\vision.h   $(INCL)\display.h
+DUNGEON_H  = $(INCL)\align.h       $(INCL)\dungeon.h
+EMIN_H     = $(DUNGEON_H)          $(INCL)\emin.h
+EPRI_H     = $(DUNGEON_H)          $(INCL)\align.h    $(INCL)\epri.h
+ESHK_H     = $(DUNGEON_H)          $(INCL)\eshk.h
+GLOBAL_H   = $(PCCONF_H)           $(INCL)\coord.h    $(INCL)\global.h
+HACK_H     = $(CONFIG_H)           $(DUNGEON_H)       $(DECL_H)          \
+             $(DISPLAY_H)          $(RM_H)            $(INCL)\monsym.h   \
+             $(INCL)\mkroom.h      $(INCL)\objclass.h $(INCL)\trap.h     \
+             $(INCL)\flag.h        $(INCL)\vision.h   $(INCL)\wintype.h  \
+             $(INCL)\engrave.h     $(INCL)\rect.h     $(INCL)\winprocs.h \
+             $(INCL)\trampoli.h    $(INCL)\hack.h
+MONDATA_H  = $(INCL)\align.h       $(INCL)\mondata.h
+MONST_H    = $(INCL)\align.h       $(INCL)\monst.h
+PCCONF_H   = $(INCL)\micro.h       $(INCL)\system.h   $(INCL)\pcconf.h
+PERMONST_H = $(INCL)\monattk.h     $(INCL)\monflag.h  $(INCL)\align.h \
+             $(INCL)\permonst.h
+RM_H       = $(INCL)\align.h       $(INCL)\rm.h
+SP_LEV_H   = $(INCL)\align.h       $(INCL)\sp_lev.h
+VAULT_H    = $(DUNGEON_H)          $(INCL)\vault.h
+YOU_H      = $(MONST_H)            $(YOUPROP_H)       $(INCL)\align.h \
+             $(INCL)\attrib.h      $(INCL)\you.h
+YOUPROP_H  = $(PERMONST_H)         $(MONDATA_H)       $(INCL)\prop.h \
+             $(INCL)\pm.h          $(INCL)\youprop.h
+
+#
+#	Make Rules.
+#
+
+.SUFFIXES:  .exe .o .c .y .l
+
+.c.o:
+	$(CC) $(CFLAGS) /Fo$*.o $*.c
+
+#
+#	Primary Targets.
+#
+all:	utility.tag
+
+utility.tag: $(OBJ)             $(INCL)\onames.h     $(INCL)\pm.h \
+             $(SRC)\monstr.c    $(SRC)\vis_tab.c     lev_comp.exe \
+             dgn_comp.exe       recover.exe
+             echo utilities made > utility.tag
+
+$(OBJ):
+	if not exist $(OBJ)\*.* mkdir $(OBJ)
+
+clean:
+	del *.o
+	del *.map
+
+spotless: clean
+	if exist utility.tag	   del utility.tag
+	if exist makedefs.exe	   del makedefs.exe
+	if exist lev_comp.exe	   del lev_comp.exe
+	if exist dgn_comp.exe	   del dgn_comp.exe
+	if exist recover.exe	   del recover.exe
+	if exist $(INCL)\date.h	   del $(INCL)\date.h
+	if exist $(INCL)\onames.h  del $(INCL)\onames.h
+	if exist $(INCL)\pm.h	   del $(INCL)\pm.h
+	if exist $(INCL)\vis_tab.h del $(INCL)\vis_tab.h
+	if exist $(SRC)\monstr.c   del $(SRC)\monstr.c
+	if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
+
+#
+#	Secondary Targets.
+#
+
+$(INCL)\onames.h: makedefs.exe
+	.\makedefs -o
+
+$(INCL)\pm.h: makedefs.exe
+	.\makedefs -p
+
+$(SRC)\monstr.c: makedefs.exe
+	.\makedefs -m
+
+$(SRC)\vis_tab.h: makedefs.exe
+	.\makedefs -z
+
+$(SRC)\vis_tab.c: makedefs.exe
+	.\makedefs -z
+
+#
+#	Makedefs Stuff
+#
+
+makedefs.exe:	$(MAKEOBJS)
+	$(LINK) $(LFLAGS) $(MAKEOBJS), $*.exe,, $(CLIB);
+
+makedefs.o:	$(CONFIG_H)	    $(PERMONST_H)      $(INCL)\objclass.h \
+		$(INCL)\monsym.h    $(INCL)\qtext.h	$(INCL)\patchlevel.h
+
+#
+#	Level Compiler Dependencies
+#
+
+lev_comp.exe:	$(SPLEVOBJS)
+	$(LINK) $(LFLAGS) $(SPLEVOBJS),lev_comp.exe,, $(CLIB);
+
+lev_yacc.o:	$(HACK_H)   $(SP_LEV_H)    lev_yacc.c
+	$(CC) $(CFLAGS) /Fo$*.o $*.c
+
+lev_$(LEX).o:	$(HACK_H)   $(SP_LEV_H)    $(INCL)\lev_comp.h \
+		lev_$(LEX).c
+	$(CC) $(CFLAGS) /Fo$*.o $*.c
+
+lev_main.o:	$(HACK_H)   $(SP_LEV_H)
+
+$(INCL)\lev_comp.h: lev_yacc.c
+
+lev_yacc.c:	lev_comp.y
+	$(MAKEBIN) YY=lev do_yacc
+
+lev_$(LEX).c:	lev_comp.l
+	$(MAKEBIN) YY=lev do_lex
+
+#
+#	Dungeon Dependencies
+#
+
+dgn_comp.exe:	$(DGNCOMPOBJS)
+	$(LINK) $(LFLAGS) $(DGNCOMPOBJS),$*.exe,, $(CLIB);
+
+dgn_yacc.o:	$(HACK_H)   $(DGN_FILE_H)  dgn_yacc.c
+	$(CC) $(CFLAGS) /Fo$*.o $*.c
+
+dgn_$(LEX).o:	$(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h \
+		dgn_$(LEX).c
+	$(CC) $(CFLAGS) /Fo$*.o $*.c
+
+dgn_main.o:	$(HACK_H)
+
+$(INCL)\dgn_comp.h:	dgn_yacc.c
+
+dgn_yacc.c: dgn_comp.y
+	$(MAKEBIN) YY=dgn do_yacc
+
+dgn_$(LEX).c:  dgn_comp.l
+	$(MAKEBIN) YY=dgn do_lex
+
+#
+#	Yacc & Lex Magic.
+#
+
+yacc_msg:
+	@echo $(YY)_comp.y has changed. To update $(YY)_yacc.c and $(YY)_comp.h run $(YACC).
+
+yacc_act:
+	$(YACC) -d $(YY)_comp.y
+	copy $(YTABC) $(YY)_yacc.c
+	copy $(YTABH) $(INCL)\$(YY)_comp.h
+	del $(YTABC)
+	del $(YTABH)
+
+lex_msg:
+	@echo $(YY)_comp.l has changed. To update $(YY)_$(LEX).c run $(LEX).
+
+lex_act:
+	$(LEX) $(YY)_comp.l
+	copy $(LEXYYC) $(YY)_$(LEX).c
+	del $(LEXYYC)
+
+#
+#	Recover Utility
+#
+
+recover.exe:	$(RECOVOBJS)
+	$(LINK) $(LFLAGS) $*.o,$*.exe,, $(CLIB);
+
+recover.o:	$(CONFIG_H)	recover.c
+	$(CC) $(CFLAGS) /Fo$*.o $*.c
+
+#
+#	Other Dependencies.
+#
+
+$(OBJ)\alloc.o:	$(CONFIG_H)	$(SRC)\alloc.c
+	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
+
+$(OBJ)\decl.o:  $(HACK_H)       $(INCL)\quest.h   $(SRC)\decl.c
+	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
+
+$(OBJ)\drawing.o: $(HACK_H)     $(INCL)\termcap.h $(SRC)\drawing.c
+	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
+
+$(OBJ)\monst.o: $(CONFIG_H)	     $(PERMONST_H)	$(ESHK_H)	 \
+		$(EPRI_H)	     $(VAULT_H)		$(INCL)\monsym.h \
+		$(INCL)\color.h    $(SRC)\monst.c
+	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
+
+$(OBJ)\objects.o: $(CONFIG_H)	     $(INCL)\obj.h	$(INCL)\objclass.h \
+		  $(INCL)\prop.h     $(INCL)\color.h	$(SRC)\objects.c
+	$(CC) $(CFLAGS) /Fo$(OBJ)\$*.o $(SRC)\$*.c
+
+panic.o:	$(CONFIG_H)
diff -Pru nethack-3.4.1/sys/msdos/old/Makefile.dat nethack/sys/msdos/old/Makefile.dat
--- nethack-3.4.1/sys/msdos/old/Makefile.dat	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/Makefile.dat	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,108 @@
+#	SCCS Id: @(#)Makefile.dat  3.1   93/04/25
+#	Copyright (c) NetHack PC Development Team 1992, 1993.
+#	NetHack may be freely redistributed.  See license for details.
+#
+# PC NetHack 3.1 Data Files Makefile for NDMAKE and MSC >= 6.0ax, or
+# MSVC >= 1.0, or DGJPP 1.9.
+
+DAT	= ..\dat
+INCL	= ..\include
+UTL	= ..\util
+
+default: all
+
+all:	$(DAT)\data	    $(DAT)\rumors	$(DAT)\dungeon \
+	$(DAT)\oracles	    $(DAT)\quest.dat	$(DAT)\sp_lev.tag
+
+$(UTL)\utility.tag: $(UTL)\*.c $(UTL)\*.l $(UTL)\*.y $(INCL)\*.h
+	@echo You must "make all" in $(UTL) first.
+	@attrib .foo
+
+$(DAT)\data: 	$(UTL)\utility.tag    $(DAT)\data.base
+	$(UTL)\makedefs -d
+
+$(DAT)\rumors:	$(UTL)\utility.tag    $(DAT)\rumors.tru   $(DAT)\rumors.fal
+	$(UTL)\makedefs -r
+
+$(DAT)\quest.dat: $(UTL)\utility.tag  $(DAT)\quest.txt
+	$(UTL)\makedefs -q
+
+$(DAT)\oracles:	$(UTL)\utility.tag    $(DAT)\oracles.txt
+	$(UTL)\makedefs -h
+
+#
+# Note: `options` should be created via date.h target in ..\src\makefile
+#
+$(DAT)\options: $(UTL)\utility.tag    $(INCL)\config.h    $(INCL)\pcconf.h
+	$(UTL)\makedefs -v
+
+$(DAT)\sp_lev.tag: $(UTL)\utility.tag $(DAT)\bigroom.des  $(DAT)\castle.des \
+	$(DAT)\endgame.des $(DAT)\gehennom.des $(DAT)\knox.des   \
+	$(DAT)\medusa.des  $(DAT)\oracle.des   $(DAT)\tower.des  \
+	$(DAT)\yendor.des  $(DAT)\arch.des     $(DAT)\barb.des   \
+	$(DAT)\caveman.des $(DAT)\elf.des      $(DAT)\healer.des \
+	$(DAT)\knight.des  $(DAT)\priest.des   $(DAT)\rogue.des  \
+	$(DAT)\samurai.des $(DAT)\tourist.des  $(DAT)\valkyrie.des \
+	$(DAT)\wizard.des
+	$(UTL)\lev_comp $(DAT)\bigroom.des
+	$(UTL)\lev_comp $(DAT)\castle.des
+	$(UTL)\lev_comp $(DAT)\endgame.des
+	$(UTL)\lev_comp $(DAT)\gehennom.des
+	$(UTL)\lev_comp $(DAT)\knox.des
+	$(UTL)\lev_comp $(DAT)\mines.des
+	$(UTL)\lev_comp $(DAT)\medusa.des
+	$(UTL)\lev_comp $(DAT)\oracle.des
+	$(UTL)\lev_comp $(DAT)\tower.des
+	$(UTL)\lev_comp $(DAT)\yendor.des
+	$(UTL)\lev_comp $(DAT)\arch.des
+	$(UTL)\lev_comp $(DAT)\barb.des
+	$(UTL)\lev_comp $(DAT)\caveman.des
+	$(UTL)\lev_comp $(DAT)\elf.des
+	$(UTL)\lev_comp $(DAT)\healer.des
+	$(UTL)\lev_comp $(DAT)\knight.des
+	$(UTL)\lev_comp $(DAT)\priest.des
+	$(UTL)\lev_comp $(DAT)\rogue.des
+	$(UTL)\lev_comp $(DAT)\samurai.des
+	$(UTL)\lev_comp $(DAT)\tourist.des
+	$(UTL)\lev_comp $(DAT)\valkyrie.des
+	$(UTL)\lev_comp $(DAT)\wizard.des
+	echo sp_levs done > $(DAT)\sp_lev.tag
+
+$(DAT)\dungeon:	$(UTL)\utility.tag  $(DAT)\dungeon.def
+	$(UTL)\makedefs -e
+	$(UTL)\dgn_comp $(DAT)\dungeon.pdf
+
+clean: spotless
+
+spotless:
+	if exist $(DAT)\?-fill?.lev	del $(DAT)\?-fill?.lev
+	if exist $(DAT)\?-goal.lev	del $(DAT)\?-goal.lev
+	if exist $(DAT)\?-locate.lev	del $(DAT)\?-locate
+	if exist $(DAT)\?-start.lev	del $(DAT)\?-start.lev
+	if exist $(DAT)\air.lev		del $(DAT)\air.lev
+	if exist $(DAT)\asmodeus.lev	del $(DAT)\asmodeus.lev
+	if exist $(DAT)\astral.lev	del $(DAT)\astral.lev
+	if exist $(DAT)\baalz.lev	del $(DAT)\baalz.lev
+	if exist $(DAT)\bigroom.lev	del $(DAT)\bigroom.lev
+	if exist $(DAT)\castle.lev	del $(DAT)\castle.lev
+	if exist $(DAT)\data		del $(DAT)\data
+	if exist $(DAT)\dungeon		del $(DAT)\dungeon
+	if exist $(DAT)\dungeon.pdf	del $(DAT)\dungeon.pdf
+	if exist $(DAT)\earth.lev	del $(DAT)\earth.lev
+	if exist $(DAT)\fakewiz?.lev	del $(DAT)\fakewiz?.lev
+	if exist $(DAT)\fire.lev	del $(DAT)\fire.lev
+	if exist $(DAT)\juiblex.lev	del $(DAT)\juiblex.lev
+	if exist $(DAT)\medusa-?.lev	del $(DAT)\medusa-?.lev
+	if exist $(DAT)\mine*.lev	del $(DAT)\mine*.lev
+	if exist $(DAT)\options		del $(DAT)\options
+	if exist $(DAT)\oracle.lev	del $(DAT)\oracle.lev
+	if exist $(DAT)\oracles		del $(DAT)\oracles
+	if exist $(DAT)\orcus.lev	del $(DAT)\orcus.lev
+	if exist $(DAT)\rumors		del $(DAT)\rumors
+	if exist $(DAT)\quest.dat	del $(DAT)\quest.dat
+	if exist $(DAT)\sanctum.lev	del $(DAT)\sanctum.lev
+	if exist $(DAT)\tower?.lev	del $(DAT)\tower?.lev
+	if exist $(DAT)\valley.lev	del $(DAT)\valley.lev
+	if exist $(DAT)\water.lev	del $(DAT)\water.lev
+	if exist $(DAT)\wizard?.lev	del $(DAT)\wizard?.lev
+	if exist $(DAT)\sp_lev.tag	del $(DAT)\sp_lev.tag
diff -Pru nethack-3.4.1/sys/msdos/old/exesmurf.c nethack/sys/msdos/old/exesmurf.c
--- nethack-3.4.1/sys/msdos/old/exesmurf.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/exesmurf.c	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,384 @@
+/*	SCCS Id: @(#)exesmurf.c	 3.1	 91/01/29			  */
+/* Copyright (c) Pierre Martineau and Stephen Spackman 1991, 1992, 1993.  */
+/* NetHack may be freely redistributed.  See license for details.	  */
+
+/******************************************************************************
+*                                                                             *
+*                         EXE header list and modify                          *
+*                                                                             *
+*                        by Pierre Martineau, 91/01/29                        *
+*                                                                             *
+*                                Version 1.2                                  *
+*                                                                             *
+>*****************************************************************************<
+* Modified (stephen@estragon.uchicago.edu):                                   *
+* 1990oct23 sps Overlay splitter-outer first cut                              *
+*        31     Error handling; some #defines                                 *
+*     nov01     /l                                                            *
+*   91jan29     Changed default overlay file names to conform to ovlmgr 30a0  *
+******************************************************************************/
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+
+/** parameters ***************************************************************/
+#define MAXFILENAME 128   /* Probably overkill - theoretical limit is 80     */
+#define NPARTS	    36	  /* Maximum # of overlay files (excluding root .EXE)*/
+#define COPYBUFSIZE 32768 /* Fair sized buffer for file copy                 */
+#define BAKEXT      ".BAK"/* Extension for .exe backups                      */
+#define OVLEXT      ".OVL"/* Default extension for overlay files             */
+/* #define MANYZEROES */  /* Old style default: foo00001.ovl, not foo0.ovl   */
+/*****************************************************************************/
+
+#define BOOLEAN int
+#define TRUE    1
+#define FALSE   0
+
+int sstrccnt(register char const *s, register char c)
+  { int n = 0;
+
+    while (*s) if (*s++ == c) n++;
+    return n;
+  }
+
+FILE *wrkfile, *outfile;
+long min, max, stk;
+BOOLEAN listflg = FALSE;
+BOOLEAN verbose = FALSE;
+BOOLEAN minflg = FALSE;
+BOOLEAN maxflg = FALSE;
+BOOLEAN stkflg = FALSE;
+
+int column = 0;
+
+struct exehdr {
+unsigned signature;
+unsigned mod512;
+unsigned pages;
+unsigned relocitems;
+unsigned headerparas;
+unsigned minalloc;
+unsigned maxalloc;
+unsigned ss;
+unsigned sp;
+unsigned checksum;
+unsigned ip;
+unsigned cs;
+unsigned relocptr;
+unsigned ovlnum;
+} exehdr_area;
+
+main(argc, argv)
+int argc;
+char *argv[];
+{
+char *dot, *slash;
+char fname[MAXFILENAME], oname[MAXFILENAME], zname[MAXFILENAME];
+char *jname = NULL;
+char *args;
+int i;
+long offset, oldstk;
+unsigned nparts = 0, part = 0, partstart[NPARTS + 2];
+
+    printf("EXE list and modify V1.1s, by Pierre Martineau, 90/05/20.\n");
+    printf("This program may be freely distributed.\n");
+
+	if ((argc < 2) || (argc > NPARTS + 2)) {
+        usage();
+        return;
+    }
+
+/*  Process any remaining arguments  */
+
+    if (argc == 2) {
+        listflg = TRUE;
+        verbose = TRUE; /* ??? */
+    }
+    else {
+        i = 2;
+        while (argc-- > 2) {
+            args = argv[i];
+	    if ('0' <= args[0] && args[0] <= '9') { /* File split request */
+			if (nparts >= NPARTS) {
+			printf("\nToo many .OVL files requested (max. %d)\n", NPARTS);
+		    usage();
+		    return;
+		}
+		else if (!atoi(args)) {
+		    printf("\nCan't relocate the root overlay (#0)\n");
+		    usage();
+		    return;
+		}
+		else if (nparts && partstart[nparts - 1] >= atoi(args)) {
+		    printf("\nOverlay starts must be in ascending order\n");
+		    usage();
+		    return;
+		}
+		partstart[nparts++] = atoi(args);
+	    } else {
+		if ((args[0] != '-') && (args[0] != '/')) {
+		    printf("\nInvalid switch in paramater %s!\n", argv[i]);
+			usage();
+			return;
+		}
+		args++;
+		if (strnicmp(args, "min", 3) == 0) {
+		    args += 3;
+		    min = atol(args);
+		    minflg = TRUE;
+		}
+		else if (strnicmp(args, "max", 3) == 0) {
+		    args += 3;
+		    max = atol(args);
+		    maxflg = TRUE;
+		}
+		else if (strnicmp(args, "stk", 3) == 0) {
+		    args += 3;
+		    stk = atol(args);
+		    stkflg = TRUE;
+		}
+		else if (strnicmp(args, "v", 1) == 0) {
+		    listflg = TRUE;
+                    verbose = TRUE;
+                }
+                else if (strnicmp(args, "l", 1) == 0)
+                    listflg = TRUE;
+                else if (strnicmp(args, "p", 1) == 0) {
+                    args++;
+                    jname = args;
+                }
+		else {
+		    printf("\nInvalid paramater %s!\n", argv[i]);
+		    usage();
+		    return;
+		}
+            }
+            i++;
+        }
+    }
+
+/*  Extract filename from first argumemt  */
+
+    strcpy(fname, argv[1]);
+    dot = strrchr(fname, '.');
+    slash = strrchr(fname, '\\');
+    if ((dot == NULL) || (slash > dot))
+        strcat(fname, ".exe");
+
+    if (nparts) {
+	strcpy(oname,fname);
+	*strrchr(fname, '.') = '\0';
+	strcat(fname,BAKEXT);
+	if (!stricmp(oname,fname)) {
+	    printf(
+                "\nI refuse to split a file with extension "BAKEXT": %s\n",
+                oname
+            );
+	    return;
+	}
+        if (!jname || nparts > 1 && !sstrccnt(jname, '?')) {
+            char ext[5];
+            char *t;
+
+            if (!jname) {
+                strcpy(zname, oname);
+                *strrchr(zname, '.') = '\0';
+                strcpy(ext, OVLEXT);
+            } else {
+                if (strrchr(jname, '.') &&
+                     (!strrchr(jname, '\\') ||
+                         strrchr(jname, '.') > strrchr(jname, '\\')
+                     )
+                ) {
+                    strncpy(ext, strrchr(jname, '.'), sizeof(ext));
+                    ext[sizeof(ext) - 1] = '\0';
+                    strncpy(zname, jname, strrchr(jname, '.') - jname);
+                    zname[strrchr(jname, '.') - jname] = '\0';
+                } else {
+                    strcpy(zname, jname);
+                    strcpy(ext, OVLEXT);
+                }
+            }
+            t = strrchr(zname, '\\') ? strrchr(zname, '\\') + 1:
+                strrchr(zname, ':') ? strrchr(zname, ':') + 1:
+                zname;
+            if (strlen(t) >= 8)
+                t[7] = '\0';
+#if defined(MANYZEROES)
+	    while (strlen(t) < 8)
+#endif
+	      strcat(t, "?");
+            strcat(zname, ext);
+            jname = zname;
+        }
+	if (rename(oname,fname)) { /* This assumes oldname, newname.
+				      There's some confusion. OK for TC2.0 */
+	    printf("\nCouldn't rename (original) %s to %s\n", oname, fname);
+	    return;
+	}
+	if ((outfile = fopen(oname, "wb")) == NULL) {
+            printf("\nCouldn't create file %s\n",oname);
+            return;
+        }
+    }
+
+    if ((wrkfile = fopen(fname, "r+b")) == NULL) {
+        printf("\nCouldn't open file %s\n", fname);
+        return;
+    }
+
+    fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
+    if (exehdr_area.signature != 0x5a4d) {
+        printf("\nNot an EXE file!\n");
+        return;
+    }
+
+    while(!feof(wrkfile)) {
+        if (nparts) {
+	    if (exehdr_area.ovlnum == partstart[part]) {
+	         fclose(outfile);
+                 {
+                     int p = part + 1;
+                     strcpy(oname, jname);
+                     while (sstrccnt(oname, '?') > 1) {
+                         *strrchr(oname, '?') = '0' + p % 10;
+                         p /= 10;
+                     }
+                     *strchr(oname, '?') = (p > 9 ? 'a' - 10 : '0') + p;
+                 }
+                 part++;
+		 if ((outfile = fopen(oname, "wb")) == NULL) {
+                     printf("\nCan't open file %s\n", oname);
+                     return;
+                 }
+	    }
+            fwrite(&exehdr_area, sizeof (struct exehdr), 1, outfile);
+            if (ferror(outfile)) {
+                printf("\nWrite error while moving overlay header in %s\n", oname);
+                return;
+            }
+	}
+        if (listflg)
+            show_hdr();
+        else if (nparts)
+            printf("[overlay %d]\r", exehdr_area.ovlnum); /* Keep talking... */
+        if ((minflg || maxflg || stkflg) && (exehdr_area.ovlnum == 0) && (exehdr_area.signature == 0x5a4d)) {
+            if (minflg)
+                exehdr_area.minalloc = min;
+            if (maxflg)
+                exehdr_area.maxalloc = max;
+            if (stkflg) {
+                oldstk = exehdr_area.sp;
+                exehdr_area.sp = stk;
+                if (!minflg) {
+                    exehdr_area.minalloc += ((stk - oldstk) / 16);
+                    printf("\nAdjusting size of minalloc!\n");
+                }
+            }
+            fseek(nparts ? outfile : wrkfile, ftell(wrkfile) - sizeof (struct exehdr), SEEK_SET);
+            fwrite(&exehdr_area, sizeof (struct exehdr), 1, nparts ? outfile : wrkfile);
+            if (ferror(nparts ? outfile : wrkfile)) {
+                printf("Write error while trying to update header!\n");
+                fclose(nparts ? outfile : wrkfile);
+                return;
+            }
+        }
+        offset = exehdr_area.pages;
+        offset *= 512L;
+        offset -= sizeof(struct exehdr);
+        if (nparts) { /* Copy the stuff across */
+	    static char buffer[COPYBUFSIZE];
+	    while (offset > sizeof(buffer)) {
+	         fread(buffer, sizeof(buffer), 1, wrkfile);
+                 if (ferror(wrkfile)) {
+                     printf("\nRead error in overlay body\n");
+                     return;
+                 }
+		 fwrite(buffer, sizeof(buffer), 1, outfile);
+                 if (ferror(outfile)) {
+                     printf("\nWrite error moving overlay body, file %s\n", oname);
+                     return;
+                 }
+		 offset -= sizeof(buffer);
+	    }
+	    fread(buffer, (unsigned)offset, 1, wrkfile);
+            if (ferror(wrkfile)) {
+                printf("\nRead error in overlay body\n");
+                return;
+            }
+            fwrite(buffer, (unsigned)offset, 1, outfile);
+            if (ferror(outfile)) {
+                printf("\nWrite error moving overlay body, file %s\n", oname);
+                return;
+            }
+        } else fseek(wrkfile, offset, SEEK_CUR);
+        fread(&exehdr_area, sizeof (struct exehdr), 1, wrkfile);
+        if (ferror(wrkfile)) {
+            printf("Read error while trying to get a header!\n");
+            fclose(wrkfile);
+            return;
+        }
+    }
+    if (nparts) {
+        fclose(outfile);
+        if (!listflg) printf("                    \r");
+    }
+    fclose(wrkfile);
+    if (listflg && !verbose && column % 4) printf("\n");
+}
+
+show_hdr()
+{
+long lsize;
+
+    lsize = exehdr_area.pages;
+    if (exehdr_area.mod512 != 0)
+        lsize--;
+    lsize *= 512L;
+    lsize += exehdr_area.minalloc * 16;
+    lsize += exehdr_area.mod512;
+    lsize -= exehdr_area.headerparas * 16;
+
+    if (verbose) {
+        printf("\nOverlay: %d\n", exehdr_area.ovlnum);
+        printf("Size (512 byte pages)\t-%6x\t\t%6u\n", exehdr_area.pages, exehdr_area.pages);
+        printf("Remainder (last page)\t-%6x\t\t%6u\n", exehdr_area.mod512, exehdr_area.mod512);
+        printf("Header size (in paras)\t-%6x\t\t%6u\n", exehdr_area.headerparas, exehdr_area.headerparas);
+        printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
+        printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
+        printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
+        printf("Relocation items\t-%6x\t\t%6u\n", exehdr_area.relocitems, exehdr_area.relocitems);
+        printf("Relocation table offset\t-%6x\t\t%6u\n", exehdr_area.relocptr, exehdr_area.relocptr);
+        printf("Checksum\t\t-%6x\t\t%6u\n", exehdr_area.checksum, exehdr_area.checksum);
+        printf("Initial CS:IP\t\t-  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip);
+        printf("Initial SS:SP\t\t-  %04x:%04x\n", exehdr_area.ss, exehdr_area.sp);
+    } else {
+        if (!exehdr_area.ovlnum) {
+            printf("\nOverlay: %d\n", exehdr_area.ovlnum);
+            printf("Minalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.minalloc, exehdr_area.minalloc);
+            printf("Maxalloc (in paras)\t-%6x\t\t%6u\n", exehdr_area.maxalloc, exehdr_area.maxalloc);
+            printf("Stored size (in bytes)\t-%6lx\t\t%6lu\n", exehdr_area.pages * 512L, exehdr_area.pages * 512L);
+            printf("Load size (in bytes)\t-%6lx\t\t%6lu\n", lsize, lsize);
+            printf("Initial CS:IP, SS:SP\t-  %04x:%04x\t  %04x:%04x\n", exehdr_area.cs, exehdr_area.ip, exehdr_area.ss, exehdr_area.sp);
+	} else {
+	    static bis = 0;
+	    if (!bis++)
+                printf("\nOvl StrdSz LoadSz | Ovl StrdSz LoadSz | Ovl StrdSz LoadSz | Ovl StrdSz LoadSz\n");
+            printf("%3d:%6lu %6lu%s", exehdr_area.ovlnum, exehdr_area.pages * 512L, lsize, ++column % 4 ? " | " : "\n");
+        }
+    }
+}
+
+usage()
+{
+    printf("\nUsage: exesmurf exe_file [/l] [/v] [/min#####] [/max#####] [/stk#####]\n");
+    printf("                [n1 n2...nn] [/p????????.???]\n");
+    printf("       where: min   = minalloc\n");
+    printf("              max   = maxalloc\n");
+    printf("              stk   = stack size\n");
+    printf("              ##### = decimal number of paragraphs\n");
+    printf("              ni    = overlay starting each new .OVL file, n1 < n2 <...< nn\n");
+    printf("              p     = DOS filename, maybe with ?s, for overlay files.\n");
+}
diff -Pru nethack-3.4.1/sys/msdos/old/exesmurf.doc nethack/sys/msdos/old/exesmurf.doc
--- nethack-3.4.1/sys/msdos/old/exesmurf.doc	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/exesmurf.doc	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,97 @@
+	SCCS Id: @(#)exesmurf.doc	 3.1		91/01/29
+        Copyright (c) Pierre Martineau and Stephen Spackman 1991, 1992, 1993.
+        NetHack may be freely redistributed.  See license for details.
+		     ============================
+		     PC NetHack Support Utilities
+		     ============================
+		     Last revision: 1991January29
+
+This file contains documentation for the NetHack MS-DOS support
+utility EXESMURF.EXE.  This utility examines and modifies the load
+parameters of an .EXE file and can be used to split .OVL files off a
+monolithic overlaid executable using ovlmgr.
+
+EXESMURF
+--------
+exesmurf FILENAME[.EXT] /v
+exesmurf FILENAME[.EXT] /minN
+exesmurf FILENAME[.EXT] /maxN
+exesmurf FILENAME[.EXT] /l
+exesmurf FILENAME[.EXT] N... [/pPATTERN]
+
+The programme exesmurf is basically a reimplementation of Microsoft's
+EXEMOD utility.  However, this incarnation is one that is
+"overlay-aware" (as they say).  It will provide the user with
+information about the executable and its overlays, and allow you to
+modify the executable's parameters and overlay locations.
+
+This program is made available for all users who were not graced with a
+release of EXEMOD in their Microsoft product, or who need the
+additional functionality it provides.
+
+/v.
+If exesmurf is invoked with a filename as argument, optionally
+followed by a /v, the filename's exeheader is listed for your viewing
+pleasure, along with the headers of any Microsoft-format overlays the
+file may contain.  The listing is verbose; if there are many overlays
+you will want to redirect the output.  Note that the redundancy in the
+output listing largely reflects redundancy in the file structure.
+
+/minN, /maxN, /stackN.
+Exesmurf may also be used to modify the "minalloc", "maxalloc" and
+"stack" allocation parameters of the executable file.  This can be
+accomplished with the /min, /max, and /stack flags respectively.  Any
+arguments to these flags should be *immediately* followed by a decimal
+number N.  Note that this is inconsistent with the arguments to EXEMOD
+which takes hex numbers, and *needs* a space between the flag and the
+number.
+
+/l.
+The /l option requests a version of the /v listing (see above) in
+which the information about overlays is very much compressed; only
+their decimal file and load sizes are given, in a multi-column format.
+The resulting display will generally fit on a single screen.  This
+turns out to be very useful when contemplating appropriate parameters
+for the overlay splitting operation described next.
+
+N... [/pPATTERN].
+The overlay-unpacking function of exesmurf is invoked by following the
+filename argument by a sequence of decimal numbers.  Each of these
+numbers is an overlay number at which a new external overlay file is
+to be started.  The main executable file will keep its old name after
+the overlays have been unloaded; the original input file will be
+retained, with its extension changed to .BAK.  By default, the output
+files will be derived from the input file name by appending a
+discriminating character (in sequence, 0, 1, ..., 9, a, b, ..., z) to
+the basename and changing the extension to .OVL; but if the basename
+is a full 8 characters long, the discriminating character will replace
+the last character instead.  This default is chosen for compatibility
+with ovlmgr.  The default may be overridden with the /p option, which
+specifies a file PATTERN - a file name, possibly complete with
+extension, containing one or more ? characters (* is not allowed),
+which will be replaced by discriminating characters.  If there is
+exactly one questionmark, it will be replaced by a digit or letter in
+the sequence described above, but if more than one questionmark
+appears a decimal numbering scheme is used instead.
+	Note that the numeric arguments are overlay numbers, not
+indices, and they indicate the starting overlays of files.  This
+permits us to manipulate files in which (for some reason) the overlays
+are not stored in ascending order, but it does mean that if a
+mentioned overlay does not exist in the original file, no new overlay
+file will be started.  This is a realistic risk, since the Microsoft
+linker does not seem to generate overlays at all if there is no actual
+code generated into the segments in question.
+	Note further that this operation can be reversed with the DOS
+copy/b operation, always supposing that it works as documented in your
+release of the operating system: the overlays are simply moved
+page-by-page to the external files.
+	No guarantees are made as to how this programme will behave if
+there is debug information or other strangeness stored after the last
+overlay in the file.
+
+Whenever exesmurf is invoked, the extension .EXE is assumed for the
+file if no extension is given.  Other extensions are probably only
+meaningful for examining overlay files.
+----------------------------------------------------------------------
+Stephen P Spackman                       stephen@estragon.uchicago.edu
+----------------------------------------------------------------------
diff -Pru nethack-3.4.1/sys/msdos/old/maintovl.doc nethack/sys/msdos/old/maintovl.doc
--- nethack-3.4.1/sys/msdos/old/maintovl.doc	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/maintovl.doc	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,340 @@
+	SCCS Id: @(#)maintovl.doc	 3.1		92/11/23
+        Copyright (c) NetHack PC Development Team 1990, 1991, 1992, 1993.
+        NetHack may be freely redistributed.  See license for details.
+		     ===========================
+			Maintaining PC NetHack
+		     ===========================
+		     Last revision: 1992november23
+
+The installation of the system of overlay management that currently
+brings full-featured NetHack to the IBM PC and compatibles has
+introduced a number of arcanities into the source code of the
+programme, and unfortunately running afoul of these intricacies can
+result (as we ourselves have discovered) in the most bizarre and
+strangely inexplicable dysfunctional manifestations, aka sick bugs.
+
+This document is required reading for anyone making substantive
+changes to NetHack for the PC or embarking upon a revision of its
+overlay structure.
+
+
+1. The overlay manager
+----------------------
+NetHack is by now a fairly large programme (in excess of 800
+kilobytes), and in order to compile it for the PC (which typically
+has little more than 500k of available memory) it was necessary to
+rely on the technique of _overlaying_, whereby not all the
+programme is resident in memory at the same time, segments of the
+programme being loaded and discarded as they are needed. Unlike
+traditional candidates for the overlaying strategy, however, NetHack
+does not exhibit strongly phased behaviour; although much of the code
+is not being used at any one moment, there is comparatively little
+code that can confidently be said not to be related to or potentially
+necessary for the immediate progress of the game.
+	Furthermore we wished to develop an overlaying strategy that
+did _not_ involve intimate knowledge of the operation of the
+programme (since NetHack is an international team effort, and few
+people have a good feeling for the totality of the code structure),
+and which would not require substantive changes to the source code,
+impacting on its maintainability and portability.
+	It turned out to be impossible to satisfy these goals with
+tools that are widely available at the time of writing, and so we
+undertook to write our own overlay manager (compatible with
+Microsoft's, but more in concert with NetHack's particular needs).
+The result is called ovlmgr.asm and is documented in the file
+ovlmgr.doc. You would probably be well advised to read at least the
+less technical parts of that file now.
+
+
+2. The trampoli mechanism
+-------------------------
+One of the difficulties with using overlays for C (particularly
+Microsoft C) is that while common C programming practise places heavy
+reliance on function pointers, Microsoft's overlay linker is unable
+to resolve calls through pointers to functions that are in remote
+overlays. Nor, unfortunately, does it choose to report such failures;
+rather, it generates calls into (what often turns out to be in the
+case of our nonstandard overlay manager) the deepest of space. This
+can result in truly strange behaviour on the part of your programme -
+including bugs that come and go in as close to a random pattern as
+you are ever likely to see.
+	Other than the creative use of pattern-matching utilities
+such as grep to locate the offending calls, there is unfortunately no
+advice we can offer in tracking down these bugs. Once they have been
+isolated, however, they can be remedied straightforwardly.
+
+In order for the linker not to screw up on a pointered function call
+it is (to simplify an actually rather complicated situation)
+necessary that the function called be located in the ROOT "overlay",
+and thus not be subject to swapping. Rather than linking the full
+text of every pointered function into the root, however, it suffices
+to place a "trampoline" function there which performs a direct call
+to the "real" function that does the work, in whatever overlay it
+might naturally reside in. Due to a not-quite-accident of the
+behaviour of the C preprocessor (it was originally intended to make
+possible functions whose address can be taken but which expand inline
+as macros where possible, a not unrelated function), it turns out to
+be possible to arrange for this without major change to the C source
+code - and without serious impact on the performance of "regular"
+calls to the same functions.
+
+The C preprocessor's expansion of a macro with parameters is triggered
+by an encounter with the macro name immediately followed by an open
+parenthesis. If the name is found, but it is not followed by a
+parenthesis, the macro is not matched and no expansion takes place.
+At the same time it may be noted that (unless someone has been oddly
+strange and enclosed a function name in quite unneeded parentheses!),
+a function name is typically followed by an open parenthesis if, and
+only if, it is being declared, defined or invoked; if its address is
+being taken it will necessarily be followed by some other token.
+Furthermore it will be observed that (except in the unfortunate case
+of the ill-conceived new-style ANSI declaration of a function that
+takes no parameters) the number of parameters to a call of the
+function (assuming that this number is fixed; if not, I grant, we have
+a problem) is the same in all these contexts. This implies that if all
+the modules of a programme are uniformly processed in the context of a
+macro definition such as
+
+	#define zook(a,b) plenk(a,b)
+
+and assuming that all functions named zook() take exactly two
+arguments, then the resulting programme will be completely identical
+to the original (without this definition) except that the link
+map will report the existence of the function plenk() in place of
+zook() -- UNLESS there was a place in the programme where the address
+of zook was taken. In that case, the linker would report an
+unresolved external reference for zook.
+	That unresolved reference is, of course, precisely what we
+need; if in another source file (one that did not see the macro
+definition) we placed the function definition
+
+	some_t zook(this_t a, that_t b)
+	  { extern some_t plenk(this_t, that_t);
+	    return plenk(a, b);
+	  }
+
+this would both satisfy the unresolved reference and restore the
+original semantics of the programme (even including pointer
+comparison!) -- while providing us with precisely the kind of
+"trampoline" module that we need to circumvent the problem with the
+linker.
+	This is the basis of the approach we have taken in PC
+NetHack; rather than using the somewhat idiosyncratic identifier
+"plenk", however, we have systematically employed (in the files
+trampoli.h and trampoli.c) identifiers generated by appending
+underscores to the ends of the names of the functions we have needed
+to so indirect(1).
+
+There are a few small complications. The first is ensuring that both
+the versions of the trampoli'd function (foo() and foo_()) are
+similarly typed by the appropriate extern declarations (which
+themselves must be written); this can be accomplished by placing all
+of these declarations in a header file that is processed _twice_,
+once before and once after the inclusion of the file containing the
+trampoli macro definitions, thereby ensuring that both variants of
+the name have been seen in connection with the appropriate types. The
+second is that some care must be exercised not to employ other macros
+that interfere with the normal recognition of function syntax: it is
+the presence of the open parenthesis after the name of the function
+that triggers name substitution, and not the fact that the function
+is called; and so (particularly in the case of declarations) it is
+necessary that if a macro is used to supply the _arguments_ of a
+trampoli'd function, it must also supply the name (this necessity in
+fact triggered a change in the style of the macros that provide
+dialect-independent function declaration in NetHack; the new style
+would have you write FDECL(functionName, (argTypes...)).
+	Finally, there is the case of functions declared to take no
+arguments whatsoever; in Standard C this is notated:
+
+	some_t aFunction(void);
+
+for no theoretically well-motivated reason I can discern. Such a
+declaration will _not_ match a macro definition such as
+
+	#define aFunction() aFunction_()
+
+-- in fact the compiler will detect an error when processing that
+declaration in the scope of this macro. The only solution is to
+eschew the use of this strange syntax and unfrabjously forgo the
+concomitant security of well- and thoroughly- checked typage. To
+which end we have provided an ecchy macro, NDECL(functionName), which
+uses the new syntax _unless_ the compiler is not Standard or OVERLAY
+is enabled.
+
+There is one further consideration: that this technique only applies,
+of course, to functions that are published to the linker. For this
+reason, wherever such trampoli'd functions were originally declared
+static, that declaration has been changed to "STATIC_PTR", a macro
+that expands to "static" unless the OVERLAY flag has been selected in
+the configuration file, enabling the trampoli mechanism. Thus such
+functions lose their privacy in this one case.
+
+
+3. OVLx
+-------
+The strategies described above work fine, but they only stretch so
+far. In particular, they do not admit of an overlay structure in
+which functions are linked into different overlays even though they
+originate in the same source file.
+	Classically, this is not considered a real limitation,
+because one has the freedom to regroup the functions into different
+source files as needed; however, in the case of NetHack this was not
+a realistic option, since what structure this unwieldy programme has
+is precisely in the current grouping of functions together.
+Nonetheless, the ability to perform some functional grouping is an
+absolute requirement for acceptable performance, since many NetHack
+source modules (were.c, for example) contain one or two tiny
+functions that are called with great frequency (several millions of
+times per game is not unheard of) and whose return value determines
+whether the remaining large, slow functions of the file will be
+required at all in the near future. Obviously these small checking
+functions should be linked into the same overlays with their callers,
+while the remainder of the source module should not.
+
+In order to make this possible we ran a dynamic profile on the game
+to determine exactly which functions in which modules required such
+distinguished treatment, and we have flagged each function for
+conditional compilation (with #if ... #endif) in groups according
+approximately to their frequency of invocation and functionality.
+These groups have been arbitrarily named in each source file (in
+decreasing order of frequency), OVL0, OVL1, OVL2, OVL3 and OVLB (B
+for "base functions", those that deserve no special treatment at
+all). It is thus possible to compile only a small number of the
+functions in a file by defining but one or two of these symbols on
+the compiler's command line (with the switch /DOVL2, for example);
+the compiler will ignore the remainder as if they did not exist.
+(There is an "escape clause" in hack.h that ensures that if none of
+these flags is defined on the command line, then all of them will be
+during compilation; this makes the non-use of this mechanism
+straightforward!)
+	By repeated invocation of the compiler on the _same_ source
+file it is possible to accumulate disjoint object modules that
+between them contain the images of all the functions in the original
+source, but partitioned as is most convenient. Care must, of course,
+be taken over conflicts of name in both the object file put out (all
+slices will by default be called SRCFILE.OBJ, and this default must
+be overridden with distinct file names for each output slice) and in
+the names of the text segments the compiler is to generate; you can
+see this at work in Makefile.ovl. (You may wonder, as we did at
+first, why the text segment name would have to be made distinct in
+each object file slice (the default segment name is a function of the
+source file name and the compilation model only). The reason for this
+is, quite daftly to my mind, that the linker considers the identity
+of segment names and combine classes better reason to combine
+segments than the programmer's explicit instructions in the requested
+overlay pattern is reason to keep them apart. Programmer, ask not
+why...).
+
+Once again, that works fine except for the small matter of
+declarations (where have we heard this before?). For objects that
+once were static must now be made visible to the linker that they may
+be resolved across the reaches of inter-overlay space. To this end we
+have provided three macros, all of which expand simply to "static" if
+no OVLx flags are defined on the compilation command line. They are:
+
+STATIC_DCL	which introduces a declaration (as distinct from a
+		definition) of an object that would be static were it
+		not for the requirements of the OVLx mechanism. Its
+		expansion is "static", normally, but it becomes
+		"extern" in the event that this source file has been
+		split into slices with the OVLx mechanism.
+
+STATIC_OVL	is used when _defining_ a function (giving its text,
+		that is) that is logically static but may be called
+		across slices; it expands to "static" unless OVLx is
+		active; in the latter case it expands to null,
+		leaving the function with "previous linkage" as the
+		standard says. Note that this behaviour is quite
+		similar to, but very different from, that of
+		STATIC_PTR (described above), which has the same two
+		expansions but which is triggered not by OVLx but by
+		the OVERLAY flag which enables the trampoli mechanism.
+			STATIC_OVL also differs from the STATIC_DCL
+		and STATIC_VAR in that it is employed _within_ OVLx
+		slices, while the others are used to generate
+		declarations and are deployed in areas common to all
+		slices.
+
+STATIC_VAR	is used to introduce uninitialised would-be-static
+		variables. Its expansion is complex, since it must
+		read as "static" in the usual case, but as "extern"
+		if OVLx is in use -- in all overlays but one, where
+		it must expand to the null sequence -- giving it
+		"previous linkage" and "tentative definition" (to
+		ensure that the variable gets defined at all).
+			This one took a while to get right, and
+		believe me, using the macro is a lot easier than
+		trying to keep the #ifdefs straight yourself!
+
+An initialised variable that is file-level static unless OVLx is in
+use must now be written with a STATIC_DCL declaration, and a
+definition (and static initialiser) enclosed within the bracketing
+tag of one of the OVLx slices (any will do; we use OVLB).
+	Type definitions, macro definitions and extern declarations
+should, of course remain outside any OVLx slice.
+
+Finally, of course, objects whose visibility need not be extended may
+safely continue to be declared static. And in this case, at least,
+the compiler will provide diagnostics that inform you when an object
+has slipped through the cracks and requires the application of Magic
+Macro Salve.
+
+It is perhaps less than obvious that when a function is _both_ called
+across an OVLx split and referenced through a pointer, it should be
+treated as a pointered function (that is, it should get trampoli
+entries and should be defined STATIC_PTR). The reason for this is that
+the STATIC_xxx macros associated with OVLx _only_ change the
+declaration patterns of the objects, while trampoli results in the
+generation of necessary code.
+	It is correct to do this, because the declarations produced by
+STATIC_PTR are triggered by OVERLAY's being defined, and the selection
+of OVERLAY is an absolute precondition for the activation of OVLx.
+
+
+4. Hacking
+----------
+Before undertaking any serious modifications to the overlay structure
+or support mechanisms, you should know that a _lot_ of work has gone
+into the current scheme. If performance seems poor, remember: the
+overlay manager itself can be invoked up to ten thousand times in a
+second, and although the space available for loading overlays (once
+the data and stack spaces have been accounted for) is less than half
+the total size of the overlays that are swapped through it, a disk
+access occurs well under 0.1% of the time(2). Furthermore, this
+performance (such as it is) has been achieved without substantive
+change or restructuring of the NetHack source code, which must remain
+portable to many platforms other than the PC.
+
+If these observations do not daunt you, you are a Bit Warrior indeed
+(or aspiration anyway), and we await your comments with bait.
+
+------------------------------------------------------------------------
+
+NOTES:
+------
+
+(1) In fact, we have applied this technique throughout NetHack, even
+    in cases where it is not strictly necessary (since the pointered
+    calls are not across overlay splits, for example - though note
+    that there are more splits than might be initially apparent, due
+    to the effects of the OVLx hackage as described in section 3).
+    There is, however, one exception; and beware: it is an exception
+    with fangs. The file termcap.c contains a few pointered functions
+    that we decided _not_ to trampoli for performance reasons (screen
+    output is one of the problem areas on the PC port at the moment,
+    in terms of performance). It is therefore vital to the health of
+    PC NetHack as it currently stands that the OVLx slice termcap.0 be
+    linked into the ROOT "overlay".
+
+(2) These figures are for a 4.77 MHz PC-XT running in low memory with
+    an older version of both the overlay manager and the NetHack
+    overlay arrangement. On a more capable computer and with the
+    current software, the figures are probably more like a 100kHz peak
+    service rate and a hit rate (since we fixed the bug in the LRU
+    clock logic!) in excess of 99.99% -- hopefully not both at the
+    same time.
+
+------------------------------------------------------------------------
+Stephen P Spackman                         stephen@estragon.uchicago.edu
+------------------------------------------------------------------------
+			     * Hack On! *
diff -Pru nethack-3.4.1/sys/msdos/old/ovlmgr.asm nethack/sys/msdos/old/ovlmgr.asm
--- nethack-3.4.1/sys/msdos/old/ovlmgr.asm	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/ovlmgr.asm	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,2124 @@
+;	SCCS Id: @(#)ovlmgr.asm 		91/09/04
+;  Copyright (c) 1989, 1990, 1991, 1992, 1993 Pierre Martineau and
+;  Stephen Spackman.  All Rights Reserved.
+;  This product may be freely redistributed.  See NetHack license for details.
+
+VERSION 	EQU	3100h
+
+		PAGE	57,132
+		TITLE	'DOS Overlay Manager for MSC 5.1+'
+		SUBTTL	'Copyright (c) 1989, 1990, 1991, 1992, 1993 Pierre Martineau and Stephen Spackman. All Rights Reserved.'
+
+; Multiple overlay file support for v30a0 by Norm Meluch with some input from Stephen.
+
+; acknowledgements:   - Many thanks to Norm Meluch for his invaluable help
+;		      - No thanks to Microsoft
+;		      - alltrsidsctysti!!!
+;		      - izchak and friends for impetus
+;		      - us for brilliance
+;		      - coffee for speed
+;		      - others as necessary
+
+; assumptions:	      - all registers are preserved including flags
+;		      - the stack is preserved
+;		      - re-entrancy is not required
+
+; options:	      /Di386	use 80386-specific opcodes
+;				(faster, but no good for weaker machines)
+;		      /DNOEMS	omit EMS support
+;				(needed if application uses EMS)
+;		      /DNOSPLIT	omit support for external .OVL files
+
+DOSALLOC	EQU	48h			; memory allocation
+DOSFREE 	EQU	49h			; free allocated memory
+DOSREALLOC	EQU	4ah			; modify memory block
+DOSREAD 	EQU	3fh			; read bytes from handle
+DOSSEEK 	EQU	42h			; logical handle seek
+DOSOPEN 	EQU	3dh			; open handle
+DOSCLOSE	EQU	3eh			; close handle
+DOSSETDTA	EQU	1ah			; Set Data transfer area
+DOSGETDTA	EQU	2fh			; Get Data transfer area
+DOSSEARCH	EQU	4eh			; Search for 1st file match
+DOSNEXTFILE	EQU	4fh			; Search for next file match
+DOSEXEC 	EQU	4bh			; exec child process
+DOSPUTC 	EQU	02h			; print a char
+DOSVERSION	EQU	30h			; get version number
+DOSGETVEC	EQU	35h			; get interrupt vector
+DOSGETSWITCH	EQU	3700h			; get DOS switchar
+DOS		EQU	21h			; Dos interrupt #
+PRINT		EQU	09h			; print string
+TERMINATE	EQU	4ch			; terminate process
+EMM		EQU	67h			; EMM handler int vector
+EMMSTATUS	EQU	40h			; get EMM status
+EMMFRAME	EQU	41h			; get EMM page frame
+EMMTOTALS	EQU	42h			; get EMM pages available
+EMMALLOC	EQU	43h			; allocate EMM pages
+EMMMAP		EQU	44h			; map EMM pages
+EMMFREE 	EQU	45h			; free EMM pages
+MAXNAMESIZE	EQU	50h			; max path name size
+MAXFILES	EQU	0Eh			; max # of *.OVL files
+EXESIGNUM	EQU	5a4dh			; Exe header signature
+CR		EQU	0dh
+LF		EQU	0ah
+ESCAPE		EQU	1bh
+BELL		EQU	07h
+PARSIZ		EQU	10h			; this is the size of a paragraph - this better not change!
+FAERIE		EQU	00h			; Used for dummy segment allocation
+
+NOERR		EQU	0
+DOSERR		EQU	1
+FILEERR 	EQU	2
+NOMEMERR	EQU	3
+FILEIOERR	EQU	4
+VICTIMERR	EQU	5
+RELERR		EQU	6
+EMSERR		EQU	7
+HDRERR		EQU	8
+NAMERR		EQU	9
+OVLERR		EQU	10
+NOHDRERR	EQU	11
+
+; The following EXTRNs are supplied by the linker
+
+EXTRN		$$OVLBASE:BYTE			; segment of OVERLAY_AREA
+EXTRN		$$MPGSNOVL:BYTE 		; ^ to module table
+EXTRN		$$MPGSNBASE:WORD		; ^ to module segment fixups
+EXTRN		$$INTNO:BYTE			; interrupt number to be used
+EXTRN		$$COVL:WORD			; number of physical overlays
+EXTRN		$$CGSN:WORD			; number of modules
+EXTRN		$$MAIN:FAR			; ^ to function main()
+
+PUBLIC		$$OVLINIT			; Our entry point
+						; called by the c startup code
+IFDEF i386
+OP32		MACRO				; 32 bit operand override
+		DB	066h
+		ENDM
+
+pusha		MACRO				; push all registers
+		DB	060h
+		ENDM
+
+popa		MACRO				; pop all registers
+		DB	061h
+		ENDM
+ENDIF
+
+ovlflgrec	RECORD	locked:1=0,ems:1=0,loaded:1=0,file:4=0,pad:1 ; overlay flags
+		; "file" is the overlay file this overlay is in; 0 is the .EXE
+		; itself. Otherwise, the numbers are arbitrary.
+
+; This is a dirty hack. What we need is a virtual segment that will be built
+; by the (our) loader in multiple copies, one per overlay. Unfortunately, this
+; doesn't seem to be a sensible idea in the minds of the folks at Microsoft.
+; Declaring this segment AT will ensure that it never appears in the exefile,
+; and ASSUME is dumb enough to be fooled.
+;
+; The reason we want to do this is also not-to-be-tried-at-home: it turns out
+; that we can code a faster interrupt handler if we map overlay numbers to
+; segment values. Normally we would consider this unacceptable programming
+; practise because it is 86-mode specific, but the *need* for this entire
+; programme is 86-mode specific, anyway.
+
+pspseg		SEGMENT PARA AT FAERIE		; dummy segment for psp
+		ORG	2ch			; ^ to segment of environmemt in psp
+pspenv		LABEL	WORD
+pspseg		ENDS
+
+ovltbl		SEGMENT PARA AT FAERIE		; Dummy segment definition for overlay table
+
+; NOTE: This segment definition MUST be exactly 16 bytes long
+
+ovlflg		ovlflgrec	<0,0,0,0,0> 	; overlay flags
+ovlinvcnt	DB	?			; invocation count
+ovlmemblk	DW	?			; ^ to allocated memory block
+ovllrudat	DD	?			; misc lru data (pseudo time stamp)
+ovlemshdl	DW	?			; ovl ems memory handle
+ovlfiloff	DW	?			; ovl file offset in pages (512 bytes)
+ovlsiz		DW	?			; ovl size in paragraphs
+ovlhdrsiz	DW	?			; hdr size in paragraphs
+
+IF1
+IF		($ - ovlflg) GT PARSIZ
+		.ERR
+		%OUT This segment MUST be no more than 16 bytes, REALLY!!!
+ENDIF
+ENDIF
+
+OVLSEGSIZ	EQU	PARSIZ			; this had better be true!!! (16 bytes)
+
+ovltbl		ENDS
+
+DTASTRUC	STRUC				; internal DTA for ovlmgr
+		DB	21 DUP (0)
+file_attr	DB	0
+file_time	DW	0
+file_date	DW	0
+file_size	DD	0
+file_name	DB	9 DUP (0)
+file_ext	DB	3 DUP (0)
+dtapad		DB	86 DUP (0)		; Pad to 128 bytes
+DTASTRUC	ENDS
+
+EXEHDR		STRUC				; structure of an EXE header
+exesign 	DW	EXESIGNUM		; signature
+exelstpgesiz	DW	?			; last page size (512 byte pages)
+exesiz		DW	?			; total pages (including partial last page)
+relocitems	DW	?			; number of relocation entries
+hdrparas	DW	?			; number of paragraphs in the header
+minalloc	DW	?			; minimum paragraph allocation
+maxalloc	DW	?			; maximum patagraph allocation
+exess		DW	?			; initial stack segment
+exesp		DW	?			; initial stack pointer
+exechksum	DW	?			; checksum
+exeip		DW	?			; initial instruction pointer
+execs		DW	?			; initial code segment
+reloctbloff	DW	?			; offset from beginning of header to relocation table
+exeovlnum	DW	?			; overlay number
+EXEHDR		ENDS
+
+MASK_used	EQU	1			; memory block flag
+
+MEMCTLBLK	STRUC				; memory block structure
+memblkflg	DB	?			; flags
+memblkpad1	DB	?			; go ahead, delete me!
+memblknxt	DW	?			; ^ to next block
+memblkprv	DW	?			; ^ to previous block
+memblkovl	DW	?			; ^ to overlay occupying this block
+memblksiz	DW	?			; size in paragraphs
+memblkpad	DB	PARSIZ - memblkpad MOD PARSIZ DUP (?) ; pad to 16 bytes
+MEMCTLBLK	ENDS
+
+MEMCTLBLKSIZ	EQU	TYPE MEMCTLBLK / PARSIZ ; should equal 1 paragraph
+
+;-------------------------------------------------------------------------------
+
+code		SEGMENT PUBLIC
+
+; NOTE: the following order is optimum for alignment purposes across the
+;	entire INTEL 80x86 family of processors.
+
+ovltim		DD	?			; pseudo-lru time variable
+farcall 	DD	?			; internal trampoline.
+oldvec		DD	-1			; saved interrupt vector
+oldint21	DD	-1			; saved int 21 vector
+sireg		DW	?			; temp save area
+IFDEF i386
+		DW	?			; for esi
+ENDIF
+dsreg		DW	?			; temp save area
+ssreg		DW	?
+spreg		DW	?
+ovlfilhdl	DW	MAXFILES+1 DUP (-1)  	; always-open file handles for .EXE, .OVL
+ovltblbse	DW	-1			; segment of first overlay descriptor
+memblks 	DW	16 DUP (-1)		; allocated memory blocks
+memblk1st	DW	?			; first memory block
+emsmemblks	DW	16 DUP (-1)		; ems allocated memory blocks (64K each)
+curemshandle	DW	-1			; currently mapped handle
+ovlcnt		DW	?			; # overlays
+modcnt		DW	?			; # of modules
+ovlrootcode	DW	?			; logical segment of OVERLAY_AREA
+ovldata 	DW	?			; logical segment of OVERLAY_END
+pspadd		DW	?			; our psp address + 10h (for relocations)
+emsframe	DW	?			; EMM page frame segment
+moduletbl	DD	256 DUP (?)		; module lookup table (256 modules)
+curovl		DW	OFFSET stkframe 	; ^ into stack frame
+stkframe	DW	256*3 DUP (?)		; internal stack (256 ovls deep)
+tempmem 	DW	16 DUP (-1)		; temp mem block storage
+intnum		DW	?			; ovlmgr int number
+hdr		EXEHDR	<>			; EXE header work area
+		DB	512-TYPE EXEHDR DUP (?) ; exe hdr buffer for relocations
+EXEHDRTMPSIZ	EQU	$ - hdr 		; size of temp reloc buffer
+filestring	DB	MAXNAMESIZE DUP (0)	; string space for file specs
+pathlen		DW	?			; path length of file spec
+namelen		DW	?			; length of file names
+ovldta		DTASTRUC <>			; DTA for ovlmgr use
+dtaseg		DW	?			; DTA segment for program
+dtaoffset	DW	?			; DTA offset for program
+errortbl	DW	-1			; error message pointers
+		DW	OFFSET baddos
+		DW	OFFSET nofile
+		DW	OFFSET noroom
+		DW	OFFSET badio
+		DW	OFFSET nocore
+		DW	OFFSET nocore
+		DW	OFFSET badems
+		DW	OFFSET badhdr
+		DW	OFFSET badnam
+		DW	OFFSET noovl
+		DW	OFFSET nohdr
+		DW	OFFSET unknown
+		DW	OFFSET unknown
+		DW	OFFSET unknown
+		DW	OFFSET unknown
+emmname 	DB	"EMMXXXX0"              ; EMM device driver name
+emmtot		DW	0			; total emm blocks free
+emmframesiz	DW	4			; frame size in blocks
+emmflg		DB	0			; EMM present flag
+
+i386code	DB	'386 specific code enabled.',CR,LF,'$'
+memavl		DB	'Conventional memory available: $'
+paragraphs	DB	'H paragraphs.',CR,LF,'$'
+emsavl		DB	'EMS memory available: $'
+pages		DB	'H 16K-pages.',CR,LF,'$'
+baddos		DB	'Incorrect DOS version. Must be 3.00 or later.$'
+nofile		DB	'Inaccessible EXE file. Can',39,'t load overlays.$'
+noroom		DB	'Not enough free memory left to run this program.$'
+badio		DB	'File I/O error.$'
+nocore		DB	'Internal memory allocation failure.$'
+badems		DB	'EMS memory manager error.$'
+badhdr		DB	'Executable or overlay header missing or damaged.$'
+badnam		DB	'Unable to resolve overlay file names.$'
+noovl		DB	'Inaccessible OVL file. Can',39,'t load overlays.$'
+nohdr		DB	'Incomplete executable.  OVL files missing?$'
+unknown 	DB	'Unknown error!$'
+msghead 	DB	ESCAPE,'[0m',ESCAPE,'[K',CR,LF,ESCAPE,'[K',ESCAPE,'[1mOVLMGR:',ESCAPE,'[0m $'
+diag		DB	ESCAPE,'[K',CR,LF,ESCAPE,'[K','        ($'
+msgtail 	DB	ESCAPE,'[K',CR,LF,ESCAPE,'[K',BELL,'$'
+ovlext		DB	'?.OVL',0
+
+;-------------------------------------------------------------------------------
+
+$$OVLINIT	PROC	FAR			; Init entry point
+
+		ASSUME	CS:code,DS:pspseg,ES:NOTHING
+
+		push	ax
+		push	bx
+		push	cx
+		push	dx
+		push	si
+		push	di
+		push	bp
+		push	ds
+		push	es			; save the world
+
+		cld
+		mov	ax,ds			; get our psp
+		add	ax,10h
+		mov	pspadd,ax		; save it
+		mov	ah,DOSVERSION
+		int	DOS
+		cmp	al,3			; DOS 3.0 or later
+		jnc	doenvthing
+		mov	al,DOSERR		; incorrect version of dos
+		jmp	putserr
+doenvthing:
+		mov	ds,pspenv		; get environment segment
+		mov	si,-1
+envloop:					; search for end of environment
+		inc	si
+		cmp	WORD PTR [si],0
+		jnz	envloop
+		add	si,4			; point to EXE filename
+
+		call	openfiles		; Search & open overlay files
+IFNDEF NOEMS
+chkems:
+		mov	ah,DOSGETVEC
+		mov	al,EMM
+		int	DOS
+		mov	ax,cs
+		mov	ds,ax
+		mov	di,0ah
+		mov	si,OFFSET emmname
+		mov	cx,8
+		repe	cmpsb
+		mov	al,0
+		jnz	setemmflg
+		mov	al,-1
+setemmflg:
+		mov	emmflg,al
+		jnz	noemshere
+		mov	ah,EMMFRAME
+		int	EMM
+		mov	emsframe,bx
+		mov	ah,EMMTOTALS
+		int	EMM
+		mov	emmtot,bx
+noemshere:
+ENDIF
+		mov	ax,SEG $$OVLBASE	; OVERLAY_AREA segment
+		mov	ovlrootcode,ax
+		mov	ax,SEG $$COVL		; segment of DGROUP
+		mov	ds,ax
+		mov	bx,$$CGSN		; number of modules
+		mov	modcnt,bx		; save for later use
+		mov	bx,$$COVL		; number of physical overlays
+		mov	ovlcnt,bx		; save for later use
+
+; Now allocate memory
+		mov	ah,DOSALLOC		; bx contains # paras needed for ovltbl
+		int	DOS
+		jnc	gotovlram
+		jmp	buyram
+gotovlram:
+		mov	ovltblbse,ax		; overlay descriptor table begins at start of memory block
+
+		mov	cx,ovlcnt
+zeromem:
+		mov	es,ax
+		mov	es:ovlflg,0		; initialise ovl flags
+		mov	es:ovlinvcnt,0		; initialise invocation count
+		mov	es:ovlmemblk,0
+		mov	WORD PTR es:ovllrudat,0	 ; initialise ovl lru
+		mov	WORD PTR es:ovllrudat+2,0
+		mov	es:ovlemshdl,-1
+		mov	es:ovlfiloff,0		; initialize file offset
+		mov	es:ovlsiz,0		; initialize overlay size
+		mov	es:ovlhdrsiz,0
+		inc	ax
+		loop	zeromem		
+
+		mov	ax,cs
+		mov	ds,ax
+IFDEF DEBUG
+IFDEF i386
+		mov	ah,print
+		mov	dx,OFFSET msghead
+		int	DOS
+		mov	ah,print
+		mov	dx,OFFSET i386code
+		int	DOS
+ENDIF
+		mov	ah,print
+		mov	dx,OFFSET msghead
+		int	DOS
+		mov	ah,print
+		mov	dx,OFFSET memavl
+		int	DOS
+		mov	ax,0a000h
+		sub	ax,ovltblbse
+		call	itoa
+		mov	ah,print
+		mov	dx,OFFSET paragraphs
+		int	DOS
+IFNDEF NOEMS
+		mov	ah,print
+		mov	dx,OFFSET msghead
+		int	DOS
+		mov	ah,print
+		mov	dx,OFFSET emsavl
+		int	DOS
+		mov	ax,emmtot
+		call	itoa
+		mov	ah,print
+		mov	dx,OFFSET pages
+		int	DOS
+ENDIF
+ENDIF
+		ASSUME	ES:ovltbl
+
+		xor	bp,bp
+		xor	di,di
+		xor	si,si			; file handle loop ctr
+filsegtbllpp:					; initialise ovl table
+		call	gethdr			; get an EXE header
+
+		mov	ax,ovltblbse
+		add	ax,hdr.exeovlnum
+		mov	es,ax			; ^ to ovl table entry
+IFNDEF NOSPLIT
+		mov	cx,si			; set file # in ovlflg
+		shl	cx,1
+		mov	ovlflg,cl
+ENDIF
+		mov	ax,hdr.exesiz
+		shl	ax,1
+		shl	ax,1
+		shl	ax,1
+		shl	ax,1
+		shl	ax,1			; * 32
+		mov	dx,hdr.exelstpgesiz
+		or	dx,dx
+		jz	emptypage
+		shr	dx,1
+		shr	dx,1
+		shr	dx,1
+		shr	dx,1			; / 16
+		inc	dx
+		sub	ax,20h
+		add	ax,dx
+emptypage:
+		sub	ax,hdr.hdrparas 	; actual size of code
+		mov	ovlsiz,ax		; overlay size in paragraphs
+		cmp	hdr.exeovlnum,0 	; skip if ovl 0 (root code)
+		jz	notlargest
+		cmp	ax,di			; find largest ovl
+		jc	notlargest
+		mov	di,ax
+notlargest:
+		mov	ax,hdr.hdrparas
+		shl	ax,1
+		shl	ax,1
+		shl	ax,1
+		shl	ax,1
+		mov	ovlhdrsiz,ax		; hdr size in bytes
+		mov	ovlfiloff,bp		; initialise ovl file offset
+		add	bp,hdr.exesiz		; ^ to next overlay
+		mov	dx,bp
+		mov	cl,dh
+		mov	dh,dl
+		xor	ch,ch
+		xor	dl,dl
+		shl	dx,1
+		rcl	cx,1			; cx:dx = bp * 512
+		mov	al,0
+		mov	ah,DOSSEEK		; seek to next ovl
+		int	DOS
+
+		mov	cx,ovlcnt		; check if all overlays found
+		mov	ax,ovltblbse
+		dec	cx			; ovlcnt includes root
+		add	ax,cx
+ovloop:
+		mov	es,ax
+IFNDEF NOSPLIT
+		mov	bl,ovlflg
+		and	bx,MASK file
+
+		cmp	bx,0			; if file # is 0
+		jne	again
+ENDIF
+		cmp	ovlfiloff,0		; and offset is 0
+		jne	again
+		jmp	filsegtbllpp		; then we're still looking
+again:
+		dec	ax
+		loop	ovloop
+
+		ASSUME	ES:nothing		; prepare first memory block
+
+		mov	ax,ovlrootcode		; OVERLAY_AREA segment
+		mov	memblk1st,ax		; save pointer to first mem block
+		mov	es,ax
+		mov	es:memblkflg,0		; clear mem flags
+		mov	es:memblknxt,0		; set next to nothing
+		mov	es:memblkprv,0		; set previous to nothing
+		mov	es:memblkovl,0		; no overlay loaded
+		mov	es:memblksiz,di 	; di contains OVERLAY_AREA size in paragraphs
+		add	ax,di
+		mov	ovldata,ax		; end of OVERLAY_END
+		push	di
+		mov	es,ovltblbse		; temporary
+		call	getemsmem		; see if any ems available
+		mov	es:ovlemshdl,-1 	; fix these!
+		and	es:ovlflg,NOT MASK ems
+		push	dx
+		call	getmoreram		; see if there are any other pieces lying around
+		pop	ax
+		pop	di
+		or	ax,ax			; any ems?
+		jnz	noramcheck
+		inc	di
+		cmp	dx,di
+		jc	buyram
+noramcheck:
+		mov	WORD PTR ovltim,0	; initialise global lru time stamp
+		mov	WORD PTR ovltim+2,0
+		mov	di,OFFSET stkframe
+		mov	WORD PTR cs:[di],-1	; initialise stack frame
+		add	di,6
+		mov	ax,ovltblbse
+		mov	cs:[di],ax
+		mov	curovl,di		; initialise stack frame pointer
+		mov	es,ax
+		mov	es:ovlflg,MASK locked OR MASK loaded ; set flags on ovl 0
+		jmp	short chgintvec
+buyram:
+		mov	al,NOMEMERR		; free up some TSRs or something
+		jmp	putserr
+chgintvec:
+		mov	ax,SEG $$INTNO
+		mov	ds,ax
+		mov	al,$$INTNO		; get int number to use
+		xor	ah,ah
+		shl	ax,1
+		shl	ax,1
+		mov	intnum,ax
+		call	setvectors		; set up interrupt vectors
+		mov	cx,modcnt		; module count
+		mov	ax,SEG $$MPGSNBASE
+		mov	es,ax
+		mov	ax,cs
+		mov	ds,ax
+
+		ASSUME	DS:code
+
+		mov	bx,OFFSET $$MPGSNBASE	; ^ to linker provided overlay segment fixups
+		mov	si,OFFSET $$MPGSNOVL	; ^ to linker provided module table
+		mov	di,OFFSET moduletbl	; ^ to our module table
+modloop:
+		mov	al,es:[si]		; real physical ovl number
+		xor	ah,ah
+		add	ax,ovltblbse		; ovlctlseg address
+		mov	[di],ax 		; save in module table
+		mov	ax,es:[bx]		; get seg fixup
+		sub	ax,ovlrootcode		; adjust for relative reference
+		mov	[di+2],ax		; save in module table
+		add	di,4
+		add	bx,2
+		inc	si
+		loop	modloop
+		pop	es
+		pop	ds
+		pop	bp
+		pop	di
+		pop	si
+		pop	dx
+		pop	cx
+		pop	bx
+		pop	ax			; restore the world
+		jmp	$$MAIN			; And away we go!
+
+$$OVLINIT	ENDP
+
+;-------------------------------------------------------------------------------
+
+ovlmgr		PROC	FAR			; This is the it!
+
+		ASSUME	DS:NOTHING,ES:NOTHING
+
+IFDEF i386
+		OP32
+ENDIF
+		mov	sireg,si		; preserve si
+		mov	dsreg,ds		; and ds
+		pop	si			; retrieve caller ip
+		pop	ds			;     "      "    cs
+		push	ax
+		push	bx
+		cld
+		lodsb				; module # to call
+		xor	ah,ah
+		mov	bx,ax
+		lodsw				; offset in ovl to call
+		mov	WORD PTR farcall,ax	; into trampoline
+		mov	ax,si
+		mov	si,curovl		; get stack frame pointer
+		add	si,6			; update stack
+		mov	cs:[si-4],ds		; save return seg
+		mov	cs:[si-2],ax		; and return offset
+
+		shl	bx,1
+		shl	bx,1			; * 4 (2 words/entry in module tbl)
+		add	bx,OFFSET moduletbl
+		mov	ds,cs:[bx]		; ovl tbl entry
+		mov	ax,cs:[bx+2]		; segment fixup
+		mov	cs:[si],ds		; ovl entry into stack frame
+		mov	curovl,si
+
+		ASSUME	DS:ovltbl
+
+IFDEF i386
+		OP32
+ENDIF
+		mov	si,WORD PTR ovltim	; lru time stamp
+IFDEF i386
+		OP32
+ENDIF
+		inc	si			; time passes!
+IFDEF i386
+		OP32
+ENDIF
+		mov	WORD PTR ovltim,si	; update global clock
+IFDEF i386
+		OP32
+ENDIF
+		mov	WORD PTR ovllrudat,si	; as well as ovl clock
+IFNDEF i386
+		mov	si,WORD PTR ovltim+2
+		jz	ininc			; dword increment
+cryupcdon:
+		mov	WORD PTR ovllrudat+2,si ; as well as ovl clock
+ENDIF
+		test	ovlflg,MASK loaded	; ovl loaded?
+		jz	inload			; load it or map it then.
+ovlloadedupc:
+		inc	ovlinvcnt
+		add	ax,ovlmemblk		; add fixup and segment address
+		mov	WORD PTR farcall+2,ax	; into trampoline
+IFDEF i386
+		OP32
+ENDIF
+		mov	si,sireg		; retore all registers
+		mov	ds,dsreg
+		pop	bx
+		pop	ax
+		popf				; don't forget these!
+		call	DWORD PTR farcall	; and GO
+		pushf				; preserve registers again!
+		mov	dsreg,ds
+IFDEF i386
+		OP32
+ENDIF
+		mov	sireg,si
+		mov	si,curovl		; stack frame pointer
+		mov	ds,cs:[si]
+		dec	ovlinvcnt
+		sub	si,6			; adjust stack
+		mov	ds,cs:[si]		; retrieve ovl tbl entry
+		push	cs:[si+2]		; set return address
+		push	cs:[si+4]
+		mov	curovl,si
+IFDEF i386
+		OP32
+ENDIF
+		mov	si,WORD PTR ovltim	; do the lru thing again
+IFDEF i386
+		OP32
+ENDIF
+		inc	si
+IFDEF i386
+		OP32
+ENDIF
+		mov	WORD PTR ovltim,si
+IFDEF i386
+		OP32
+ENDIF
+		mov	WORD PTR ovllrudat,si
+IFNDEF i386
+		mov	si,WORD PTR ovltim+2
+		jz	outinc
+crydncdon:
+		mov	WORD PTR ovllrudat+2,si
+ENDIF
+		test	ovlflg,MASK loaded	; ovl loaded?
+		jz	outload 		; better get it before someone notices
+jmpback:
+IFDEF i386
+		OP32
+ENDIF
+		mov	si,sireg		; get registers back
+		mov	ds,dsreg
+		iret				; and GO back
+
+IFNDEF i386
+ininc:
+		inc	si
+		mov	WORD PTR ovltim+2,si	; update global and
+		jmp	cryupcdon
+ENDIF
+
+inload:
+		test	ovlflg,MASK ems
+		jz	infile
+		push	ax
+		mov	ax,ovlemshdl
+		call	mappage
+		pop	ax
+		jmp	ovlloadedupc
+infile:
+		call	loadoverlay		; self explanatory
+		jmp	ovlloadedupc
+
+IFNDEF i386
+outinc:
+		inc	si
+		mov	WORD PTR ovltim+2,si
+		jmp	crydncdon
+ENDIF
+
+outload:
+		test	ovlflg,MASK ems
+		jz	outfile
+		push	ax
+		mov	ax,ovlemshdl
+		call	mappage
+		pop	ax
+		jmp	jmpback
+outfile:
+		call	loadoverlay
+		jmp	jmpback
+
+ovlmgr		ENDP
+
+;-------------------------------------------------------------------------------
+
+loadoverlay	PROC	NEAR			; load overlay pointed to by es
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+IFDEF i386
+		OP32
+		pusha			       ; eax,ecx,edx,ebx,esp,ebp,esi,edi
+ELSE
+		push	ax
+		push	cx
+		push	dx
+		push	bx
+		push	bp
+		push	si
+		push	di
+ENDIF
+		push	ds
+		push	es			; just in case
+		mov	ax,ds
+		mov	es,ax
+		cmp	ovlinvcnt,0
+		jnz	fxdadr			; Yup, it's a toughie
+		mov	ax,ovlsiz		; How much?
+		call	getpages		; never fail mem alloc, you bet.
+		jmp	gleaner
+fxdadr:
+		call	releasepages		; free memory where this ovl should be loaded
+gleaner:
+		add	ax,MEMCTLBLKSIZ 	; skip mem ctl blk
+		mov	ovlmemblk,ax		; memory block to use
+		mov	ds,ax
+		mov	dx,ovlfiloff		; where in the file is it?
+		mov	cl,dh
+		mov	dh,dl
+		xor	ch,ch
+		xor	dl,dl
+		shl	dx,1
+		rcl	cx,1			; cx:dx = dx * 512
+		mov	ax,ovlhdrsiz
+		push	cx
+		push	dx
+		add	dx,ax
+		adc	cx,0			; position to code
+		mov	ah,DOSSEEK		; lseek to code
+		mov	al,0			; from beginning of file
+		mov	bl,ovlflg
+		and	bx,MASK file
+		mov	bx,ovlfilhdl[bx] 	; never closing handle
+		int	DOS
+		jc	burnhead		; oops!
+		xor	dx,dx			; buf = ds:0
+		mov	cx,ovlsiz		; number of paragraphs to load
+		shl	cx,1
+		shl	cx,1
+		shl	cx,1
+		shl	cx,1			; * 16 = number of bytes
+		mov	ah,DOSREAD		; prevent random DOS behaviour
+		int	DOS			; read in code
+		jc	burnhead		; double oops!
+		pop	dx
+		pop	cx			; position of hdr
+		mov	ah,DOSSEEK		; lseek to hdr
+		mov	al,0			; from beginning of file
+		mov	bl,ovlflg
+		and	bx,MASK file
+		mov	bx,ovlfilhdl[bx] 	; never closing handle
+		int	DOS
+		jc	burnhead		; oops!
+		mov	cx,EXEHDRTMPSIZ 	; reloc buffer size
+		mov	dx,OFFSET hdr
+		push	ds
+		mov	ax,cs
+		mov	ds,ax
+		mov	ah,DOSREAD		; prevent random DOS behaviour
+		int	DOS			; read in header
+		pop	ds
+		jc	burnhead		; double oops!
+
+		call	ovlrlc			; perform relocation normally done by DOS EXE loader
+		pop	es			; retrieve ovl tbl entry
+		pop	ds
+
+		ASSUME	DS:ovltbl,ES:NOTHING
+
+		or	ovlflg,MASK loaded	; because it is now
+IFDEF i386
+		OP32
+		popa
+ELSE
+		pop	di
+		pop	si
+		pop	bp
+		pop	bx
+		pop	dx
+		pop	cx
+		pop	ax
+ENDIF
+		ret
+
+burnhead:
+		mov	al,FILEIOERR		; some kind of I/O error
+		jmp	putserr
+
+loadoverlay	ENDP
+
+;-------------------------------------------------------------------------------
+
+ovlrlc		PROC	NEAR			; ds:0 -> the overlay to relocate
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		mov	si,OFFSET hdr
+		mov	bp,si
+		add	bp,EXEHDRTMPSIZ 	; ^ to end of buf+1
+		mov	cx,cs:[si.relocitems]	; roto-count
+		jcxz	relocdone		; not such a good idea, after all
+		mov	di,ds
+		sub	di,ovlrootcode		; segment fixup value
+		add	si,cs:[si.reloctbloff]	; ^ relocation table
+dorelocs:					; labels don't GET comments
+		cmp	si,bp			; past the end ?
+		jc	getoffsetl
+		call	getnxtreloc		; get another hunk
+getoffsetl:
+		mov	bl,cs:[si]		; offset into load module
+		inc	si
+		cmp	si,bp			; past the end ?
+		jc	getoffseth
+		call	getnxtreloc		; get another hunk
+getoffseth:
+		mov	bh,cs:[si]		; offset into load module
+		inc	si
+		cmp	si,bp			; past the end ?
+		jc	getsegmentl
+		call	getnxtreloc		; get another hunk
+getsegmentl:
+		mov	al,cs:[si]		; segment in load module (zero reference)
+		inc	si
+		cmp	si,bp			; past the end ?
+		jc	getsegmenth
+		call	getnxtreloc		; get another hunk
+getsegmenth:
+		mov	ah,cs:[si]		; segment in load module (zero reference)
+		inc	si
+		add	ax,pspadd		; now it is psp relative
+		add	ax,di			; and now it is relative to the actual load address
+		mov	ds,ax
+		mov	ax,[bx]			; pickup item to relocate
+		add	ax,pspadd		; make it psp relative
+		cmp	ax,ovlrootcode		; is it below the OVERLAY_AREA?
+		jc	reloccomputed		; yup. it's relocated
+		cmp	ax,ovldata		; is it above OVERLAY_AREA
+		jnc	reloccomputed		; yup. it's relocated
+		add	ax,di			; it's in OVERLAY_AREA, this one's ours.
+reloccomputed:
+		mov	[bx],ax			; RAM it home!?!
+		loop	dorelocs		; what goes around, comes around.
+relocdone:	ret
+
+ovlrlc		ENDP
+
+;-------------------------------------------------------------------------------
+
+getnxtreloc	PROC	NEAR
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		push	bx
+		push	cx
+		push	di
+		push	bp
+		push	ds
+		push	es
+		mov	cx,EXEHDRTMPSIZ 	; reloc buffer size
+		mov	dx,OFFSET hdr
+		mov	ax,cs
+		mov	ds,ax
+		mov	bl,ovlflg
+		and	bx,MASK file
+		mov	bx,ovlfilhdl[bx] 	; never closing handle
+		mov	ah,DOSREAD		; prevent random DOS behaviour
+		int	DOS			; read in header
+		jnc	nxtrelocok
+		jmp	burnhead		; double oops!
+nxtrelocok:
+		mov	si,OFFSET hdr
+		pop	es
+		pop	ds
+		pop	bp
+		pop	di
+		pop	cx
+		pop	bx
+		ret
+
+getnxtreloc	ENDP
+
+;-------------------------------------------------------------------------------
+
+getvictim	PROC	NEAR			; select a victim to discard (and free up some memory)
+
+		ASSUME	DS:ovltbl,ES:NOTHING
+
+		push	bx
+		push	cx
+		push	dx
+		push	si
+		push	di
+		push	bp
+		push	ds
+		mov	ds,ovltblbse		; ^ ovl tbl
+IFDEF i386
+		OP32
+ENDIF
+		xor	ax,ax			; will contain the low word of lru
+IFDEF i386
+		OP32
+ENDIF
+		mov	dx,ax			; will contain the high word of lru
+		mov	bp,ax			; will contain ovl tbl entry
+		mov	bx,ax			; ovl tbl ptr
+		mov	cx,ovlcnt
+foon1:
+		test	ovlflg[bx],MASK locked
+		jnz	skip1
+		test	ovlflg[bx],MASK ems
+		jnz	foon2
+		test	ovlflg[bx],MASK loaded
+		jz	skip1
+foon2:
+IFDEF i386
+		OP32
+ENDIF
+		mov	si,WORD PTR ovltim
+IFNDEF i386
+		mov	di,WORD PTR ovltim+2
+ENDIF
+IFDEF i386
+		OP32
+ENDIF
+		sub	si,WORD PTR ovllrudat[bx]
+IFNDEF i386
+		sbb	di,WORD PTR ovllrudat[bx+2]
+ENDIF
+IFDEF i386
+		OP32
+		cmp	dx,si
+ELSE
+		cmp	dx,di
+ENDIF
+IFDEF i386
+		jnc	skip1
+ELSE
+		jc	better1
+		jnz	skip1
+		cmp	ax,si
+		jnc	skip1
+ENDIF
+better1:
+IFDEF i386
+		OP32
+		mov	dx,si
+ELSE
+		mov	ax,si
+		mov	dx,di
+ENDIF
+		mov	bp,bx
+skip1:
+		add	bx,OVLSEGSIZ
+		loop	foon1
+		or	bp,bp			; were we more successful this time?
+		jnz	gotvictim		; now we got one.
+nomoremem:
+		mov	al,VICTIMERR		; were really %$# now!
+		jmp	putserr
+gotvictim:
+		shr	bp,1			; convert offset to segment
+		shr	bp,1
+		shr	bp,1
+		shr	bp,1
+		mov	ax,ds
+		add	ax,bp
+		pop	ds
+		pop	bp
+		pop	di
+		pop	si
+		pop	dx
+		pop	cx
+		pop	bx
+		ret
+
+getvictim	ENDP
+
+;-------------------------------------------------------------------------------
+
+int21		PROC	FAR
+
+; free almost all overlay memory if app. tries to call the DOS exec function.
+
+		cmp	ah,DOSEXEC
+		jz	freeall
+		cmp	ah,TERMINATE
+		jz	saybyebye
+notours:
+		jmp	cs:oldint21
+saybyebye:
+		mov	al,NOERR		; return code 0
+		jmp	putserr
+freeall:
+		or	al,al			; is it load and exec?
+		jnz	notours
+		push	ax
+		push	cx
+		push	dx
+		push	bx
+		push	bp
+		push	si
+		push	di
+		push	es
+		push	ds			; preserve calling env.
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		mov	es,ovltblbse
+		mov	cx,ovlcnt		; unload all overlays that are
+		mov	bx,OVLSEGSIZ		; in EMS or are in alloced mem.
+		dec	cx
+memunloadlp:
+		test	[bx.ovlflg],MASK ems
+		jnz	memunload
+		test	[bx.ovlflg],MASK loaded
+		jz	nxtmemunload
+		mov	ax,[bx.ovlmemblk]
+		sub	ax,MEMCTLBLKSIZ
+		cmp	ax,memblks		; allocated memory ?
+		jc	nxtmemunload
+memunload:
+		and	[bx.ovlflg],NOT MASK loaded ; you're outta there!
+nxtmemunload:
+		add	bx,OVLSEGSIZ
+		loop	memunloadlp
+
+		mov	curemshandle,-1 	; no current handle anymore
+
+		mov	ax,memblks
+		cmp	ax,-1
+		jz	nosecondblk
+		mov	es,ax			; ^ to second mem blk
+		mov	es,es:memblkprv 	; get previous pointer
+		mov	es:memblknxt,0		; no other blocks after this one
+nosecondblk:
+		mov	cx,16			; do all allocated mem blocks
+		mov	si,OFFSET memblks
+freememblklp:
+		mov	ax,cs:[si]		; get memory blk segment
+		cmp	ax,-1			; was one ever allocated?
+		jz	nxtmemblklp		; nope
+		mov	es,ax
+		mov	ah,DOSFREE		; must free it.
+		int	DOS
+		mov	WORD PTR cs:[si],-1
+nxtmemblklp:
+		add	si,2
+		loop	freememblklp
+
+		call	rstvectors		; restore all int vectors
+
+		mov	bp,sp
+		push	[bp+22] 		; ensure returned flags are based on user's!
+		popf
+		pop	ds
+		pop	es
+		pop	di
+		pop	si
+		pop	bp
+		pop	bx
+		pop	dx
+		pop	cx
+		pop	ax
+
+		mov	ssreg,ss		; preserve these due to a
+		mov	spreg,sp		; DOS bug.
+
+		int	DOS			; allow DOS to continue!
+
+		mov	ss,ssreg
+		mov	sp,spreg
+
+		push	ax
+		push	cx
+		push	dx
+		push	bx
+		push	bp
+		push	si
+		push	di
+		push	es
+		push	ds			; preserve calling env.
+		mov	bp,sp
+		pushf
+		pop	[bp+22] 		; fix return flags
+
+		call	getmoreram		; re-allocate our memory
+		call	setvectors		; patch vectors again
+
+		pop	ds
+		pop	es
+		pop	di
+		pop	si
+		pop	bp
+		pop	bx
+		pop	dx
+		pop	cx
+		pop	ax
+		iret
+
+int21		ENDP
+
+;-------------------------------------------------------------------------------
+
+releasepages	PROC	NEAR			; Arg in es, result in ax
+
+; release any memory (and overlays) where this overlay should reside
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		mov	bx,ovlmemblk		; start of memory to release
+		sub	bx,MEMCTLBLKSIZ
+		mov	dx,bx
+		add	dx,es:ovlsiz
+		add	dx,MEMCTLBLKSIZ 	; end of memory to release
+		mov	ax,ovlemshdl
+		cmp	ax,-1
+		jz	doitagain
+		call	mappage
+		or	ovlflg,MASK ems
+		mov	ax,emsframe
+		jmp	dvart
+doitagain:
+		mov	ax,memblk1st		; first memory blk
+		jmp	dvart
+dvartloop:
+		mov	ds,ax			; memory blk to check
+		cmp	bx,ax			; does it start below the memory to release?
+		jnc	dvartsmaller		; yup
+		cmp	ax,dx			; does it start above?
+		jnc	dvartnocore		; yup
+		call	killmem 		; it's in the way. Zap it.
+		jmp	dvartloop
+dvartsmaller:
+		add	ax,ds:memblksiz 	; end of this memory blk
+		cmp	bx,ax			; does it end below the memory to release?
+		jnc	dvartsilly		; yup
+		test	ds:memblkflg,MASK_used
+		jz	dvartfree
+		call	killmem 		; Oh well, zap it too.
+		add	ax,ds:memblksiz 	; end of this memory blk
+dvartfree:
+		cmp	ax,dx			; does it end in the memory to be released?
+		jc	dvartsilly
+dvartgotblk:
+		mov	ax,ds			; this is it!
+		mov	cx,bx
+		sub	cx,ax			; # of paragraphs between start of memory to release and mem blk
+		jz	unsplit
+		push	es
+		call	splitblk
+		or	es:memblkflg,MASK_used	; set high block used
+		call	mergemem		; merge remaining free memory
+		mov	ax,es
+		mov	ds,ax
+		pop	es
+unsplit:
+		mov	cx,es:ovlsiz
+		add	cx,MEMCTLBLKSIZ 	; paragraphs needed to load ovl
+		jmp	splitblklow		; split remaining block
+dvartsilly:
+		mov	ax,ds:memblknxt
+dvart:
+		or	ax,ax			; end of mem list?
+		jz	dvartnocore
+		jmp	dvartloop		; play it again Sam.
+dvartnocore:
+		mov	al,RELERR		; super OOPS!
+		jmp	putserr
+
+releasepages	ENDP
+
+;-------------------------------------------------------------------------------
+
+getpages	PROC	NEAR			; get enough memory to load ovl
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		mov	ovlemshdl,-1		; clear any EMS stuff
+		and	ovlflg,NOT MASK ems
+		mov	cx,ax
+		add	cx,MEMCTLBLKSIZ 	; total paragraphs needed
+dorkagain:
+		call	largestmem		; find largest free blk
+		cmp	dx,cx			; large enough?
+		jnc	gotdork 		; yup.
+		call	getemsmem		; try to allocate ems
+		cmp	dx,cx			; any available ?
+		jnc	gotdork
+dorkkill:
+		call	getvictim		; select a victim to release
+		call	killovl 		; kill the selected victim
+		jmp	dorkagain
+gotdork:
+		jmp	splitblklow		; split the free blk
+
+getpages	ENDP
+
+;-------------------------------------------------------------------------------
+
+splitblklow	PROC	NEAR
+
+; split a block of memory returning the lower one to be used.
+
+		ASSUME	DS:NOTHING,ES:NOTHING
+
+		push	es
+		or	ds:memblkflg,MASK_used	; set low block used
+		call	splitblk
+		jc	splitlowdone
+		push	ds
+		mov	ax,es
+		mov	ds,ax
+		call	mergemem		; merge remaining free memory
+		pop	ds
+splitlowdone:
+		pop	es
+		mov	ds:memblkovl,es 	; fix ptr to ovl
+		mov	ax,ds			; return lower blk segment
+		ret
+
+splitblklow	ENDP
+
+;-------------------------------------------------------------------------------
+
+splitblk	PROC	NEAR
+
+		ASSUME	DS:NOTHING,ES:NOTHING
+
+		mov	ax,ds
+		add	ax,cx
+		mov	es,ax			; ^ to upper blk to be created
+		mov	ax,ds:memblksiz
+		sub	ax,cx
+		jbe	nofix			; must be at least 1 para remaining to split
+		mov	ds:memblksiz,cx 	; fix blk sizes
+		mov	es:memblksiz,ax
+		mov	ax,ds:memblknxt 	; fix pointers
+		mov	es:memblknxt,ax
+		mov	ds:memblknxt,es
+		mov	es:memblkprv,ds
+		mov	es:memblkflg,0		; set upper to not used
+		mov	ax,es:memblknxt
+		or	ax,ax
+		jz	nofix
+		push	ds
+		mov	ds,ax			; fix blk after upper to point to upper
+		mov	ds:memblkprv,es
+		pop	ds
+		clc
+		ret
+nofix:
+		stc
+		ret
+
+splitblk	ENDP
+
+;-------------------------------------------------------------------------------
+
+largestmem	PROC	NEAR	; returns seg in ax, size in dx
+				; retruns first block that's large enough if possible
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		mov	ax,memblk1st		; first mem blk
+		xor	dx,dx			; largest size found
+		jmp	gook
+gookloop:
+		mov	ds,ax
+		test	ds:memblkflg,MASK_used	; is this blk used?
+		jnz	gookme			; yup
+		cmp	ds:memblksiz,cx 	; is it large enough?
+		jc	gookme			; nope
+		mov	dx,ds:memblksiz 	; got one!
+		ret
+gookme:
+		mov	ax,ds:memblknxt
+gook:
+		or	ax,ax			; end of list?
+		jnz	gookloop		; around and around
+		ret
+
+largestmem	ENDP
+
+;-------------------------------------------------------------------------------
+
+killmem 	PROC	NEAR
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		test	ds:memblkflg,MASK_used	; is it used?
+		jz	memnotused		; don't kill ovl
+		push	es
+		mov	es,ds:memblkovl
+		and	ovlflg,NOT MASK loaded	; zap ovl associated with this blk
+		and	ovlflg,NOT MASK ems
+		pop	es
+memnotused:
+		jmp	mergemem		; merge free memory
+
+killmem 	ENDP
+
+;-------------------------------------------------------------------------------
+
+killovl 	PROC	NEAR		; preserves bx
+
+		ASSUME	DS:ovltbl,ES:NOTHING
+
+		mov	ds,ax
+		and	ovlflg,NOT MASK loaded	; ovl no longer loaded
+		test	ovlflg,MASK ems 	; was it in ems ?
+		jz	noemskill
+		and	ovlflg,NOT MASK ems	; no longer in ems
+		mov	ax,ovlemshdl
+		call	mappage
+noemskill:
+		mov	ax,ovlmemblk		; get mem blk
+		sub	ax,MEMCTLBLKSIZ
+		mov	ds,ax
+		jmp	mergemem		; merge free memory
+
+killovl 	ENDP
+
+;-------------------------------------------------------------------------------
+
+mergemem	PROC	NEAR
+
+; merge physically adjacent free memory blocks. Preserves es. ds -> a free block.
+
+		ASSUME	DS:NOTHING,ES:NOTHING
+
+		push	dx
+		push	es
+		and	ds:memblkflg,NOT MASK_used ; set current free
+		mov	ax,ds:memblkprv 	; get previous blk
+		or	ax,ax			; was there a previous blk?
+		jz	gibber			; nope
+		mov	es,ax
+		test	es:memblkflg,MASK_used	; is the previous blk used?
+		jnz	gibber			; yup
+		add	ax,es:memblksiz 	; end of previous blk
+		mov	dx,ds
+		cmp	dx,ax			; physically adjacent?
+		jnz	gibber			; nope
+		mov	ax,ds:memblksiz
+		add	es:memblksiz,ax 	; adjust size of new larger blk
+		mov	ax,ds:memblknxt 	; fix pointers
+		mov	es:memblknxt,ax
+		or	ax,ax
+		jz	almostgibber
+		mov	ds,ax			; fix pointer of next blk
+		mov	ds:memblkprv,es
+almostgibber:
+		mov	ax,es
+		mov	ds,ax			; new blk segment
+gibber:
+		mov	ax,ds:memblknxt 	; get next blk
+		or	ax,ax			; was there a next blk?
+		jz	killdone		; nope
+		mov	es,ax
+		test	es:memblkflg,MASK_used	; is the nxt blk used?
+		jnz	killdone		; yup
+		mov	ax,ds
+		add	ax,ds:memblksiz 	; end of this blk
+		mov	dx,es
+		cmp	ax,dx			; physically adjacent?
+		jnz	killdone		; nope
+		mov	ax,es:memblksiz
+		add	ds:memblksiz,ax 	; adjust size of new larger blk
+		mov	ax,es:memblknxt 	; fix pointers
+		mov	ds:memblknxt,ax
+		or	ax,ax
+		jz	killdone
+		mov	es,ax			; fix pointer of blk after nxt
+		mov	es:memblkprv,ds
+killdone:
+		and	ds:memblkflg,NOT MASK_used ; make sure it's free
+		pop	es
+		pop	dx
+		mov	ax,ds
+		ret
+
+mergemem	ENDP
+
+;-------------------------------------------------------------------------------
+
+getmoreram	PROC	NEAR			; try to alloc remaining pieces
+						; of memory if any
+		ASSUME	DS:NOTHING,ES:NOTHING	; return dx = biggest block
+
+		push	cx
+		push	bx
+		push	si
+		push	di
+		push	ds
+		push	es
+		xor	dx,dx
+		mov	ax,memblk1st
+nxtlowblk:
+		mov	ds,ax
+		mov	ax,ds:memblknxt
+		or	ax,ax
+		jnz	nxtlowblk
+
+		mov	si,OFFSET memblks	; a place to store the handles
+		mov	di,OFFSET tempmem	; a place to store the rejects
+		mov	cx,16			; 16 more max
+getramlp:
+		mov	ah,DOSALLOC
+		mov	bx,0ffffh		; Everything
+		int	DOS
+		cmp	bx,10h			; nothing smaller than .25k please
+		jc	gotallram
+		mov	ah,DOSALLOC		; allocate our own memory
+		int	DOS
+		jc	gotallram		; oops!
+		cmp	ax,ovltblbse		; is it after our first mem blk?
+		jc	releaseblk
+		cmp	dx,bx
+		jnc	notbigger
+		mov	dx,bx
+notbigger:
+		mov	cs:[si],ax		; save it
+		mov	es,ax
+		mov	es:memblkflg,0		; clear mem flags
+		mov	es:memblknxt,0		; set next to nothing
+		mov	es:memblkovl,0		; no overlays loaded
+		mov	es:memblkprv,ds 	; point to previous
+		mov	es:memblksiz,bx 	; allocated memory block size
+		mov	ds:memblknxt,es 	; point to next
+		add	si,2
+		mov	ds,ax
+		jmp	short getnxtram
+releaseblk:
+		mov	cs:[di],ax
+		add	di,2
+getnxtram:
+		loop	getramlp
+gotallram:
+		mov	si,OFFSET tempmem
+		mov	cx,16
+releaselp:
+		mov	ax,cs:[si]
+		cmp	ax,-1
+		jz	relnext
+		mov	es,ax
+		mov	ah,DOSFREE
+		int	DOS
+		mov	WORD PTR cs:[si],-1
+relnext:
+		add	si,2
+		loop	releaselp
+		pop	es
+		pop	ds
+		pop	di
+		pop	si
+		pop	bx
+		pop	cx
+		ret
+
+getmoreram	ENDP
+
+;-------------------------------------------------------------------------------
+
+getemsmem	PROC	NEAR
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		xor	dx,dx			; no ems memory
+		cmp	emmflg,-1
+		jz	testemsslots
+		ret
+testemsslots:
+		mov	curemshandle,-1
+		mov	di,OFFSET emsmemblks
+		mov	bx,cx
+		mov	cx,16
+emsfreeslot:
+		mov	ax,cs:[di]
+		cmp	ax, -1
+		jz	gotemsslot
+		call	mappage
+		cmp	ax,bx
+		jnc	foundpage
+		add	di,2
+		loop	emsfreeslot
+		mov	cx,bx
+		xor	dx,dx
+		ret
+gotemsslot:
+		mov	cx,bx
+		mov	bx,4
+		mov	ah,EMMALLOC
+		push	cx			; paranoia ! shouldn't be necessary.
+		push	di
+		push	es
+		int	EMM
+		pop	es
+		pop	di
+		pop	cx
+		or	ah,ah
+		jz	gotsomeems
+		xor	dx,dx
+		ret
+gotsomeems:
+		mov	cs:[di],dx
+		mov	ovlemshdl,dx
+		or	ovlflg,MASK ems
+		mov	ax,dx
+		call	mapemspages
+		mov	ax,emsframe
+		mov	ds,ax
+		mov	ds:memblkflg,0		; clear mem flags
+		mov	ds:memblknxt,0		; set next to nothing
+		mov	ds:memblkprv,0		; set previous to nothing
+		mov	ds:memblkovl,0		; no overlay loaded
+		mov	dx,1000h
+		mov	ds:memblksiz,dx
+		ret
+
+foundpage:
+		mov	cx,bx
+		mov	ds,si
+		mov	dx,ax
+		mov	ax,cs:[di]
+		mov	ovlemshdl,ax
+		or	ovlflg,MASK ems
+		ret
+
+getemsmem	ENDP
+
+;-------------------------------------------------------------------------------
+
+mappage 	PROC	NEAR			; map a 64K block of EMS mem.
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		cmp	ax,curemshandle
+		jnz	doems
+		ret
+doems:
+		push	bx
+		push	dx
+		push	ds
+		push	es
+		call	mapemspages
+		mov	ax,emsframe
+		xor	dx,dx
+		xor	si,si
+emsset:
+		mov	ds,ax
+		test	ds:memblkflg,MASK_used	; mem blk used ?
+		jz	emsfreeblk
+		mov	es,ds:memblkovl
+		or	ovlflg,MASK ems OR MASK loaded
+		jmp	emsnext
+emsfreeblk:
+		mov	ax,ds:memblksiz
+		cmp	dx,ax
+		jnc	emsnext
+		mov	dx,ax
+		mov	si,ds
+emsnext:
+		mov	ax,ds:memblknxt
+		or	ax,ax
+		jnz	emsset
+
+		mov	ax,dx
+		pop	es
+		pop	ds
+		pop	dx
+		pop	bx
+		ret
+
+mappage 	ENDP
+
+;-------------------------------------------------------------------------------
+
+mapemspages	PROC	NEAR
+
+		ASSUME	DS:NOTHING,ES:ovltbl
+
+		push	es
+		push	bx
+		push	cx
+		push	dx
+		mov	curemshandle,ax
+		mov	dx,ax
+		mov	ah,EMMMAP
+		xor	al,al			; physical page 0
+		xor	bx,bx			; logical page 0
+		push	dx
+		int	EMM
+		pop	dx
+		or	ah,ah
+		jnz	emmerror
+		mov	ah,EMMMAP
+		mov	al,1			; physical page 1
+		mov	bx,1			; logical page 1
+		push	dx
+		int	EMM
+		pop	dx
+		or	ah,ah
+		jnz	emmerror
+		mov	ah,EMMMAP
+		mov	al,2			; physical page 2
+		mov	bx,2			; logical page 2
+		push	dx
+		int	EMM
+		pop	dx
+		or	ah,ah
+		jnz	emmerror
+		mov	ah,EMMMAP
+		mov	al,3			; physical page 3
+		mov	bx,3			; logical page 3
+		int	EMM
+		or	ah,ah
+		jnz	emmerror
+		mov	es,ovltblbse
+		mov	cx,ovlcnt
+		xor	bx,bx
+testems:
+		test	ovlflg[bx],MASK ems
+		jz	nxttestems
+		and	ovlflg[bx],NOT MASK loaded
+nxttestems:
+		add	bx,OVLSEGSIZ
+		loop	testems
+		pop	dx
+		pop	cx
+		pop	bx
+		pop	es
+		ret
+
+emmerror:
+		mov	al,EMSERR		; ems manager error
+		jmp	putserr
+
+mapemspages	ENDP
+
+;-------------------------------------------------------------------------------
+
+gethdr		PROC	NEAR			; read EXE header from handle
+
+		ASSUME	DS:NOTHING,ES:NOTHING
+
+		mov	dx,OFFSET hdr		; a place to put it
+		mov	bx,si
+		shl	bx,1
+		mov	bx,ovlfilhdl[bx] 	; the file handle
+readagain:
+		mov	cx,TYPE EXEHDR		; header size in bytes
+		mov	ah,DOSREAD
+		int	DOS			; read from file
+		jc	exegone 		; oops?
+		cmp	ax,cx			; got correct number of bytes?
+		je	gothdr
+IFNDEF NOSPLIT
+		cmp	ax,0			; Anything?
+		je	gotonxtfil
+ENDIF
+		jmp	exerotten
+IFNDEF NOSPLIT
+gotonxtfil:
+		inc	si
+		cmp	si,MAXFILES+1
+		je	exegone			; We're out of files!
+		mov	bx,si
+		shl	bx,1
+		cmp	ovlfilhdl[bx],-1	; Any more files?
+		je	gotonxtfil		; not here.
+
+		mov	bx,ovlfilhdl[bx]	; Slide in new handle
+		xor	bp,bp			; reset file offset
+		jmp	readagain
+ENDIF
+gothdr:
+		cmp	hdr.exesign,EXESIGNUM	; sanity check
+		jne	exerotten
+
+		ret				; Wow, it worked!
+exegone:
+		mov	al,NOHDRERR		; missing overlays!
+		jmp	putserr			; You lose!
+IFNDEF NOSPLIT
+exerotten:
+		mov	al,HDRERR		; corruption!
+		jmp	putserr			; You lose!
+ENDIF
+
+gethdr		ENDP
+
+;-------------------------------------------------------------------------------
+
+openfiles	PROC	NEAR			; Find our cohorts in crime
+
+		push	es
+IFNDEF NOSPLIT
+		mov	ah,DOSGETDTA		; Pick up DTA
+		int	DOS			; and
+		mov	dtaseg,es		; store
+		mov	dtaoffset,bx		; it
+
+		push	ds
+		mov	dx,OFFSET ovldta	; Set new DTA for file search
+		mov	ax,cs
+		mov	ds,ax			; point to the right seg
+		mov	ah,DOSSETDTA
+		int	DOS
+		pop	ds			; set this back for upcoming lodsb
+ENDIF
+		mov	cx,MAXNAMESIZE/2
+		mov	bx,cs
+		mov	es,bx
+		mov	di, OFFSET filestring
+
+		rep     movsw	    		; load path from si to di
+IFNDEF NOSPLIT
+		mov	di, OFFSET filestring
+		mov	al,0
+		mov	cx,MAXNAMESIZE
+		cld
+		repne	scasb			; search null for end of string
+
+		sub	cx,MAXNAMESIZE
+		neg	cx
+		mov	bx,cx
+
+		cmp	cx,MAXNAMESIZE
+		je	checkslash
+
+		dec	bx			; keep string length
+		dec	di			; cause were past null now
+
+		cmp	bx,7
+		jle	patherr			; "C:\.EXE" = 7
+checkslash:
+		mov	ax,DOSGETSWITCH		; divine switchar
+		int	DOS			; it influences the path
+
+		mov	al,'\'			; if swichar = '/' pathsep = '\'
+		cmp	dl,'/'
+		je	searchslash	
+		mov	al,'/'			; else pathsep = '/'
+searchslash:
+		std
+		repne	scasb			; search back for '\'
+		cld
+
+		mov	dx,bx
+		sub	dx,cx			; keep file name length
+		dec	dx
+
+		mov	cx,0			; reset for upcoming loop
+		mov	pathlen,bx		; hold these for recall
+		mov	namelen,dx
+		cmp	dx,12			; "LONGNAME.EXE" = 12
+		jle	openroot		; Path name too long?
+patherr:
+		mov	al,NAMERR		; real problems here.
+		jmp	putserr
+openroot:
+ENDIF
+		mov	ax,cs
+		mov	ds,ax			; set ds to code
+
+		mov	dx, OFFSET filestring	; open root code
+		mov	al,0			; access code
+		mov	ah,DOSOPEN
+		int	DOS			; open sez me
+		jnc	dontdie
+
+		mov	al,FILEERR		; can't open root
+		jmp	putserr
+dontdie:
+		mov	ovlfilhdl[0],ax		; save handle in array
+IFNDEF NOSPLIT
+		cmp	namelen,11		; Max sized exe name (8.3)?
+		jg	bigfilename		; if not
+		inc	pathlen			; add one to path length
+		inc	namelen
+bigfilename:
+		mov	di,OFFSET filestring	; es is still code
+		add	di,pathlen
+		sub	di,5			; append
+		mov	si,OFFSET ovlext	; wildcard extension
+		mov	cx,6			; and null
+		rep	movsb			; to filestring
+
+		mov	cx,0			; Match "normal" files
+		mov	dx,OFFSET filestring
+		mov	ah,DOSSEARCH
+		int	DOS			; Set DTA with Wildcard.
+		jc	aok			; Not a single match
+		mov	cx,MAXFILES		; set upcoming loop
+		mov	dx,namelen
+		sub	pathlen,dx		; shorten absolute path
+openloop:
+		push	cx
+		mov	bx,pathlen
+		mov	di,OFFSET filestring	; es is still in code
+		add	di,bx
+		mov	si,OFFSET ovldta.file_name
+		mov	cx,namelen 		; since this *should* be
+		rep	movsb
+		pop	cx
+
+		mov	dx,OFFSET filestring	; path to overlay file
+		mov	al,0			; access code
+		mov	ah,DOSOPEN
+		int	DOS			; open overlay file
+		jnc	dontdie2
+fileopenerr:
+		call	itoa
+
+		mov	al,OVLERR		; can't open file!
+		jmp	putserr
+dontdie2:
+		mov	bx,cx			; put file number in bx
+		shl	bx,1			; 2 * bx for array index
+		mov	ovlfilhdl[bx],ax	; save handle in array
+
+		mov	ah,DOSNEXTFILE		; Look for more files
+		int	DOS
+		jc	aok
+
+		loop	openloop		; open only 15 overlays
+aok:
+		mov	dx,dtaoffset		; Time to unset DTA
+		mov	ds,dtaseg
+		mov	ah,DOSSETDTA
+		int	DOS
+ENDIF
+		pop	es
+
+		ret
+
+openfiles	ENDP
+
+;-------------------------------------------------------------------------------
+
+putserr 	PROC	NEAR
+
+; display error msg, close file, restore int vectors, free mem and return to DOS.
+
+		ASSUME	DS:NOTHING,ES:NOTHING
+
+		xor	ah,ah
+		push	ax			; keep return code for later
+		push	cs
+		pop	ds
+		mov	bx,ax
+		shl	bx,1
+		add	bx,OFFSET errortbl
+		mov	dx,[bx]
+		cmp	dx,-1
+		jz	freeints
+		push	dx
+		mov	dx,OFFSET msghead
+		mov	ah,PRINT
+		int	DOS
+		pop	dx
+		mov	ah,PRINT
+		int	DOS			; display error msg
+
+		mov	ah,PRINT
+		mov	dx,OFFSET diag
+		int	DOS
+		pop	ax
+		push	ax
+		call	itoa			; error number
+		mov	ah,DOSPUTC
+		mov	dl,':'
+		int	DOS
+		mov	ax,VERSION
+		call	itoa			; version number
+		mov	ah,DOSPUTC
+		mov	dl,':'
+		int	DOS
+		mov	ax,0a000h
+		sub	ax,ovltblbse		; conventional memory
+		call	itoa
+		mov	ah,DOSPUTC
+		mov	dl,':'
+		int	DOS
+		mov	si,OFFSET emsmemblks
+		mov	cx,16
+		xor	ax,ax
+emstotlp:
+		cmp	WORD PTR cs:[si],-1
+		jz	gotemstot
+		add	ax,emmframesiz
+		add	si,2
+		loop	emstotlp
+gotemstot:
+		call	itoa			; ems usage in blocks
+		mov	ah,DOSPUTC
+		mov	dl,')'
+		int	DOS
+
+		mov	dx,OFFSET msgtail
+		mov	ah,PRINT
+		int	DOS
+freeints:
+		call	rstvectors		; restore all int vectors
+
+		mov	ax,ovltblbse
+		cmp	ax,-1
+		jz	freememblks
+		mov	es,ax
+		mov	ah,DOSFREE
+		int	DOS
+freememblks:
+		mov	cx,16			; do all allocated mem blocks
+		mov	si,OFFSET memblks
+freememlp:
+		mov	ax,cs:[si]		; get memory blk segment
+		cmp	ax,-1			; was one ever allocated?
+		jz	nxtmemlp		; nope
+		mov	es,ax
+		mov	ah,DOSFREE		; must free it.
+		int	DOS
+nxtmemlp:
+		add	si,2
+		loop	freememlp
+		mov	cx,16			; do all allocated ems blocks
+		mov	si,OFFSET emsmemblks
+freeemsmemlp:
+		mov	dx,cs:[si]		; get memory blk segment
+		cmp	dx,-1			; was one ever allocated?
+		jz	nxtemsmemlp		; nope
+		mov	ah,EMMFREE		; must free it.
+		int	EMM
+nxtemsmemlp:
+		add	si,2
+		loop	freeemsmemlp
+closefile:
+IFNDEF NOSPLIT
+		mov	cx,MAXFILES+1
+nextfile:
+		mov	bx,cx
+		dec	bx
+		shl	bx,1
+		mov	bx,ovlfilhdl[bx] 	; get file handle
+ELSE
+		mov	bx,ovlfilhdl[0]
+ENDIF
+		cmp	bx,-1			; was the file ever opened?
+		jz	byebye			; nope
+		mov	ah,DOSCLOSE		; close it
+		int	DOS
+byebye:
+IFNDEF NOSPLIT
+		loop	nextfile
+ENDIF
+		pop	ax			; return code in al
+		mov	ah,TERMINATE
+		int	DOS			; terminate this process
+
+putserr 	ENDP
+
+;-------------------------------------------------------------------------------
+
+itoa		PROC	NEAR
+
+		push	ax
+		xchg	ah,al
+		call	putbyte
+		pop	ax
+		jmp	putbyte
+
+itoa		ENDP
+
+;-------------------------------------------------------------------------------
+
+putbyte 	PROC	NEAR
+
+		push	ax
+		shr	al,1
+		shr	al,1
+		shr	al,1
+		shr	al,1
+		call	nibble
+		pop	ax
+		jmp	nibble
+
+putbyte 	ENDP
+
+;-------------------------------------------------------------------------------
+
+nibble		PROC	NEAR
+
+		push	ax
+		and	al,0fh
+		add	al,30h
+		cmp	al,3ah
+		jc	nibok
+		add	al,7
+nibok:
+		push	dx
+		mov	dl,al
+		mov	ah,DOSPUTC
+		int	DOS
+		pop	dx
+		pop	ax
+		ret
+
+nibble		ENDP
+
+;-------------------------------------------------------------------------------
+
+setvectors	PROC	NEAR
+
+		push	ds
+		xor	ax,ax
+		mov	ds,ax
+		mov	si,cs:intnum
+		cli
+		mov	ax,[si]
+		mov	WORD PTR cs:oldvec,ax	; save original vector
+		mov	ax,[si+2]
+		mov	WORD PTR cs:oldvec+2,ax
+		mov	ax,OFFSET ovlmgr	; point to ovlmgr
+		mov	[si],ax 		; set int vector
+		mov	[si+2],cs
+
+		mov	si,DOS*4
+		mov	ax,[si]
+		mov	WORD PTR cs:oldint21,ax ; save original vector
+		mov	ax,[si+2]
+		mov	WORD PTR cs:oldint21+2,ax
+		mov	ax,OFFSET int21 	; point to new int21
+		mov	[si],ax 		; set int vector
+		mov	[si+2],cs
+		sti
+		pop	ds
+		ret
+
+setvectors	ENDP
+
+;-------------------------------------------------------------------------------
+
+rstvectors	PROC	NEAR
+
+		push	ds
+		xor	ax,ax
+		mov	ds,ax
+		mov	si,DOS*4
+		cli
+		mov	ax,WORD PTR cs:oldint21 ; put back dos vector
+		cmp	ax,-1
+		jz	rstvec
+		mov	[si],ax
+		mov	ax,WORD PTR cs:oldint21+2
+		mov	[si+2],ax
+rstvec:
+		mov	si,cs:intnum
+		mov	ax,WORD PTR cs:oldvec	; put back ovlmgr vector
+		cmp	ax,-1
+		jz	rstdone
+		mov	[si],ax
+		mov	ax,WORD PTR cs:oldvec+2
+		mov	[si+2],ax
+		sti
+rstdone:
+		pop	ds
+		ret
+
+rstvectors	ENDP
+
+code		ENDS
+
+		END
diff -Pru nethack-3.4.1/sys/msdos/old/ovlmgr.doc nethack/sys/msdos/old/ovlmgr.doc
--- nethack-3.4.1/sys/msdos/old/ovlmgr.doc	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/ovlmgr.doc	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,393 @@
+    SCCS Id: @(#)ovlmgr.doc		 3.1		91/02/02
+    Copyright (c) 1989, 1990, 1991, 1992, 1993 Pierre G Martineau and
+    Stephen P Spackman.  All Rights Reserved.
+    NetHack may be freely redistributed.  See license for details.
+		 ====================================
+		 Brief notes about ovlmgr.asm [v30a0]
+		 ====================================
+		       (revised 1991february02)
+
+OVLMGR.ASM is a multiple-residency overlay manager for use with the
+Microsoft Overlay Linker.  It is functionally compatible with the one
+in the MSC library _except_:
+
+- it usually accesses the disk less often and is a lot faster in some
+  applications.
+- it permits overlays to be stored in the .EXE file and/or in separate
+  .OVL files.
+- it has different tuning characteristics.
+- you must (of course) link OVLMGR.OBJ into the root overlay (that is,
+  outside any parentheses in the link command).
+
+See also the notes below.
+
+	As with other Microsoft-compatible overlay handlers you must
+be *very* careful never to call a function in an overlay through a
+pointer, unless the initiator of the call resides in the *same*
+physical overlay as the target (This is, of course, *not* the same
+thing as the called function being declared static, since the static
+declaration affects only the visibility of the name of the function,
+not the distribution of pointers to it.) (1).  Furthermore, setjmp()
+and longjmp() are not supported.
+
+	Unlike the Microsoft system, most of the available memory is
+used to hold overlays.	Care must be taken to ensure that enough space
+is reserved for the C heap.  This can be accomplished through
+information stored in the .EXE file (currently the minalloc parameter,
+as described below).
+
+	Furthermore, expanded memory support (EMS) is now an integral
+part of the overlay manager.  LIM EMS versions 3.2 and 4.0 are
+supported.  Note that the page frame must be 4 pages long (64K bytes) to
+be able to operate correctly (most drivers allocate a 64K frame by
+default).  The overlay manager will use as much EMS as is necessary in
+64K chunks, up to a limit of 16 chunks (1 Meg).  Both hardware and
+software EMS drivers have been tested and found to be completely
+compatible.
+
+	Starting with version 30a0, overlays are not restricted to
+being stored in the main .EXE files (as they are with Microsoft's
+overlay manager).  Using the utility EXESMURF arbitrary contiguous
+sequences of overlays can be unloaded into external overlay files.
+Although EXESMURF provides some flexibility in naming these files,
+OVLMGR presently only supports its default option, whereby the
+overlays of a programme PROGRAM.EXE must match the pattern
+PROGRAM?.OVL (if the basename had eight characters, as FILENAME.EXE,
+then the last character is replaced: FILENAM?.EXE) and reside in the
+*same* directory as the .EXE (not even a path search is performed).
+This mechanism permits large applications to be represented with small
+files, resulting in a slight performance improvement (due to less and
+shorter disk seeking) and easier transfer with floppy disks, at the
+cost of a heavier demand for file-handles.
+
+				~ * ~
+
+	OVLMGR.ASM currently has three assembly-time options, which are
+specified with the assembler's /D<symbol> option (or compatible).  They
+are:
+
+	/DNOEMS   Disable EMS support.
+		  OVLMGR normally detects the presence of EMS memory
+		  and makes use of it whenever it is present.  This
+		  flag instructs ovlmgr to ignore EMS and operate only
+		  out of conventional memory.  It should be used when
+		  overlaying programmes which expect to use EMS
+		  themselves.
+
+	/Di386	  Use 80386-specific instruction sequences.
+		  Use of this flag will make ovlmgr perform better on
+		  machines with 80386 processors.  However, the
+		  resulting programme will not run at all on machines
+		  with less capable CPUs.  Use this option with
+		  caution, especially in the case of distribution
+		  code.
+
+	/DNOSPLIT Do not provide for external .OVL files.
+		  If this flag is NOT set, OVLMGR will look for
+		  overlays for the programme PROGRAM.EXE in all files
+		  matching the pattern PROGRAM?.OVL, as well as in the
+		  .EXE file itself.  This arrangement may be slightly
+		  faster and will result in more, smaller files, but
+		  is obviously less robust, since mismatched .OVL
+		  files can cause mayhem.  .OVL files can be generated
+		  with our EXESMURF .EXE file manipulation utility.
+
+				~ * ~
+
+	Although using the overlay manager is in essence much like using
+Microsoft's, they operate on a slightly different principle, and tuning
+for them is rather different.  Technical part begins.
+
+	When overlay linking is requested (see your linker manual), the
+MS overlay linker changes all far calls into overlays from the (normal,
+8086) format:
+
+	offset	contents
+	------	--------
+	:0000	CALL
+	:0001	target-offset
+	:0003	target-segment
+
+to this:
+	:0000	INT
+	:0001	int#	target-mod#
+	:0003	target-offset
+
+(note that here we are looking at the actual layout of the machine
+code, not at the assembly code as such) and relocates the code parts
+of all the different overlays into the *same* physical area.  The
+overlaid code is all actually placed at the end of the .EXE file,
+after the 'normal' executable image, along with all its administrative
+data (fixups etc.).
+
+	When this altered 'call' is executed, of course, the interrupt
+handler int# is invoked.  Its job is to ensure that the target overlay
+module is in memory (reading it from the tail of the .EXE file if it
+isn't already loaded) and then transfer to the given offset within it,
+'faking up' the effect of the 'real' far call that would normally have
+occurred.  Something similar must be done when the call returns, to
+ensure that the thing being returned *into* is still (or is once more)
+loaded.
+
+	The Microsoft linker, as we have said, relocates all the
+overlays to the same load address; and, in fact, it allocates am empty
+block of memory there that is at least as large as the largest
+overlay.  Into this area all the overlays are loaded without further
+change; thus, there can only ever be one overlay in memory at one
+time.  Transferring from one overlay to another causes one overlay to
+replace the other in the allocated overlay swap area.
+
+	Our overlay manager does not use the space allocated by the
+linker in the same way.  Rather, it allocates almost all of the memory
+available from MS-DOS (including the original overlay area and any high
+DOS memory) as well as EMS memory if some is available and that option
+is being used.	As overlays are needed, they are loaded wherever they
+will fit, and dynamically relocated to that address.  Thus, many more
+than one overlay may be loaded at any given time, greatly increasing
+potential performance.	Management of space is more or less according to
+an LRU policy - once all of memory is full, the least recently used
+overlay is selected as the most likely candidate for replacement.
+
+	The implications of this difference are as follows:  while with
+the conventional (default) overlay manager, the best strategy is to
+group object modules together in an overlay whenever they are known to
+be used in rapid succession, to make each overlay as big as possible
+(all things being equal) in order to take advantage of all available
+memory, and to make as few overlays as possible (to reduce the amount of
+disk access), the best strategy with our overlay manager is almost the
+reverse.  Having a lot of small overlays will increase the amount of
+useful stuff that can be resident in memory at the same time; all of
+memory will automatically be employed; and there is no advantage at all
+to uniformity of size (except perhaps in the unlikely case of *exact*
+uniformity!).
+
+	Although ovlmgr allocates all available memory while it is
+active, you will find that the DOS exec() call works normally.	The
+memory that is allocated for administering the overlay system is freed
+before the exec call is made and reallocated afterwards (we trap the DOS
+function request vector to do this, which isn't very nice as a
+programming practise but makes the existence of the overlay manager far
+more transparent).  There is, however, one circumstance under which this
+can be problematic:  if you use the exec() call to load a TSR
+application, thereby causing memory that the overlay manager was using
+to become unavailable, you may make it impossible for the overlaid
+application to proceed.  This is because code that is nominally
+'running' (i.e. is currently on the stack) cannot be relocated and must
+be reloaded at the *same address* that previously held it.  If another
+process now owns that area of memory, there is nothing we can do.  We
+believe that this should not be a serious concern in normal use.
+
+				~ * ~
+
+	Since all available memory is potentially used by ovlmgr, there
+is one additional concern in using it with C programmes:  the allocation
+of sufficient space for the C heap (2).  While previous versions of
+ovlmgr.asm required the change of an internal constant and re-assembly
+of ovlmgr to change the amount of space pre-allocated for this purpose,
+the current version uses the DOS minalloc parameter in the executable
+file to hold the size of the desired heap area.  This parameter can be
+set at any time after the link process with either Microsoft's exemod
+utility or with the supplied utility, exesmurf.
+
+				~ * ~
+
+NOTA BENE: This is an early version of the overlay manager, but by now
+it should be fairly well debugged. If you are considering upgrading it
+please be aware that the following improvements are planned for the
+next version (though who knows when delivery will occur):
+
+      - compatible versions of setjmp() and longjmp()
+      - integral malloc() to eliminate the heap size guesswork
+      - support for swapped data areas (read-only and read/write)
+      - improved performance through dynamic link-loading (maybe)
+      - interlocking to permit floppy disk juggling use
+      - XMS support and improved EMS support
+      - support for divergent-functionality overlays (such as
+	  hardware-specific modules)
+      - enabling the overlay locking code
+      - more flexibility in naming and locating external overlay files
+      - Major code revamping
+
+Swap On!
+
+------------------------------------------------------------------------
+MESSAGES
+
+OVLMGR: EMS memory manager error.
+
+	An error occurred during an EMS access.  Either the hardware has
+	reported a bug, the software driver has detected an anomaly or
+	the page frame is not 64K bytes in length.
+
+OVLMGR: Executable or overlay header missing or damaged.
+
+	The end of a file was reached unexpectedly during
+	initialisation, while trying to locate the overlays.  This is a
+	very bad sign (though I am concerned that it might be triggered
+	spuriously by debug information or other non-executable tails on
+	files).
+
+OVLMGR: File I/O error.
+
+	An error occurred while trying to load an overlay.  We don't
+	want this.
+
+OVLMGR: Inaccessible EXE file. Can't load overlays.
+
+	For some reason ovlmgr could not locate or read the original
+	.EXE file in which the overlays reside.  This could be due to
+	your attempting to use a very old version of DOS,
+	an abject shortage of file handles, some strange event causing
+	the file to be deleted, a disk error, or the diskette that
+	contained the executable being removed.
+
+OVLMGR: Inaccessible OVL file. Can't load overlays.
+
+	An error was reported while attempting to open an .OVL file
+	which was expected (from its name) to contain external overlays.
+	The possible causes are similar to those of the previous
+	message.
+
+OVLMGR: Incomplete executable.  OVL files missing?
+
+	OVLMGR was unable to locate all of its overlays for some reason.
+	This could be due to I/O errors on the disk drive, but is more
+	likely caused by an external .OVL file not being present in the
+	same directory as the .EXE.
+
+OVLMGR: Incorrect DOS version. Must be 3.00 or later.
+
+	The current version of ovlmgr does not support versions of DOS
+	prior to 3.0 because of the difficulty of locating the
+	executable file (and hence the overlays) at runtime.
+
+OVLMGR: Internal memory allocation failure.
+
+	Either an internal error has occurred in ovlmgr or the
+	application programme, or some event has caused memory that
+	ovlmgr believed it could count on becoming unavailable.  A
+	typical example of the latter would be the result of
+	attempting to load a TSR while an overlaid application is
+	running.
+
+OVLMGR: Not enough free memory left to run this program.
+
+	Although DOS successfully loaded the programme, it proved
+	impossible to allocate enough additional contiguous memory to
+	load one or more of the overlays.  Either reduce the
+	RAM-loading of the application by reducing the size of either
+	the root or the largest overlays, or increase the amount of
+	memory available by unloading TSRs and/or simplifying your
+	CONFIG.SYS.
+
+OVLMGR: Unable to resolve overlay file names.
+
+	Apparently the name reported to OVLMGR as being that of the
+	executable file is ill-formed, and it is thus not possible to
+	intuit what external overlay files would be called.  It is
+	possible that this indicates that DOS has gone bonkers, but more
+	likely (I guess) that the .EXE was not invoked by DOS as we know
+	it.  Either way, you have entered the Twilight Zone....
+
+(xxxx:xxxx:xxxx:xxxx)
+
+	This is a diagnostic code composed of the following fields:
+		- error code
+		- version number
+		- available conventional memory
+		- EMS memory usage
+	Please note it in any bug reports or correspondence with the
+	development team.
+
+------------------------------------------------------------------------
+KNOWN BUGS
+
+The present version cannot always be used as a direct replacement for
+Microsoft's overlay manager (even granted the documented differences)
+because the minimum size required for an overlaid programme to run is at
+least the size of the root plus TWICE the size of the largest overlay.
+If a programme has previously had its overlay structure tuned to take
+best advantage of Microsoft overlays, this may well cause a problem.
+The overlays themselves will need to be split up.
+
+When the MicroSoft linker discovers that an overlay as requested
+contains NO instructions at all (this can happen by mistake if you give
+a source file that winds up holding only data declarations its own
+overlay), it does not emit an overlay record for it at all - there is
+simply a gap in the overlay sequence in the file.  The current version
+of OVLMGR detects this as an error, since it assumes that such a gap
+should have been filled by an external .OVL file.  It is presently your
+responsibility to ensure that this does not occur.
+
+Files containing overlays are kept open all the time the application
+is running.  Particularly if multiple external .OVL files are used,
+this can result in less file handles being available to the user
+programme than would otherwise be expected.
+
+ALL files that match the pattern for potential overlay files are
+opened, regardless of whether they actually contain overlays.
+
+The names of external overlay files have a very restricted form, and
+they must reside in the same directory with the .EXE.  These
+limitations cause them to be useful for little else besides making
+distribution easier.
+
+Transfers between overlays are very slow in machine terms, even if both
+overlays happen to reside in memory at the time (still significantly
+faster than Microsoft's, though).  This means that overlay patterns
+must be chosen on the basis of more than just logical dependency.
+
+Locking overlays into memory is not really implemented even though
+reading the source code might make you think it was.  Actually, reading
+the source code itself isn't very well implemented right now.  Comments
+and stuff would help.  Yup, yup.
+
+Due to limitations in the LIM EMS standard (to 4.0), programmes that
+themselves use EMS memory cannot be overlaid with ovlmgr unless ovlmgr's
+own EMS support is disabled.  This is accomplished by assembling with
+the /DNOEMS flag.
+
+------------------------------------------------------------------------
+BUG ALERT
+
+To repeat a point made above, if you ever try to call a function in an
+overlay through a pointer, you *may* die with the Microsoft overlay
+manager.  If you ever try to call a function in an overlay through a
+pointer, you *will* die with ours.  Nothing in an overlay ever ends up
+in the same segment as the linker anticipated.	You have been warned!
+
+------------------------------------------------------------------------
+FOOTNOTES
+
+(1) This problem can be circumvented through the use of surrogate
+'trampoline' functions:  functions that reside in the root overlay and
+simply pass right through to the 'real', overlaid, implementations.
+This can even be made transparent to the source code through the use
+of the C macro preprocessor, with a locution of the form
+	#define foo(x) foo_(x)
+visible everywhere except at the actual definition point of the
+trampoline.  This method was implemented in NetHack 3.0, and remains today.
+
+(2) If you should get a message to the effect that NetHack can't
+allocate 28000 and some bytes when entering a maze level, that
+isn't our problem!  In all probability you forgot to rebuild your
+special level files when you changed the compiler flags.  We got
+that one, too, at one point.  The same applies to similar messages when
+reading bones files or saved games:  it is more likely that you forgot
+to discard them after recompiling your game than that the memory
+allowance is so greatly incorrect.
+
+----------------------------------------------------------------------
+NOTICE
+
+OVLMGR.ASM is brought to you by Pierre Martineau and Stephen Spackman.
+It, and this document, are copyright.  They are, however, provided as
+part of NetHack and may be freely distributed as described in the
+NetHack license.
+
+----------------------------------------------------------------------
+Stephen P Spackman			     stephen@tira.uchicago.edu
+Pierre G Martineau		   pierre%ozrout.uucp@altitude.cam.org
+----------------------------------------------------------------------
+    Copyright (c) 1989, 1990 Pierre G Martineau and Stephen P Spackman
+    All Rights Reserved.
diff -Pru nethack-3.4.1/sys/msdos/old/ovlmgr.uu nethack/sys/msdos/old/ovlmgr.uu
--- nethack-3.4.1/sys/msdos/old/ovlmgr.uu	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/ovlmgr.uu	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,152 @@
+begin 644 ovlmgr.obj
+M@`P`"F]V;&UG<BYA<VUDEA4```904U!314<&3U9,5$),!$-/1$6%F`H`````,
+M`"P``@$!+I@*```````0``,!`4F8!P!HO1P$`0$:C$8`!R0D24Y43D\`"20DT
+M3U9,0D%310`*)"1-4$=33D]63``+)"1-4$=33D)!4T4`!B0D34%)3@`&)"1#O
+M1U-.``8D)$-/5DP`T9`0```#"20D3U9,24Y)5/D/`-^(!```H@'1H!0``@``0
+M`````````````````````$J@'``#`````````````/__________````````=
+M``!)H@\``Q@`#P`!``$````"__\CH`8``S8`__\CH@\``S@`$``!``$````"`
+M__\"H`8``U@```#_H@\``UH`$``!``$````"___@H!(``WH`__\`````````F
+M``````#3H`8``X@$``#+G`@`Q````P.*!`2B#P`#B@H0``$``0````+__Z:@V
+M!@`#J@H``*.B9@`#K`H!`````DU:`0````(```$````"```!`````@```0``B
+M``(```$````"```!`````@```0````(```$````"```!`````@```0````(`&
+M``$````"```!`````@```0````(``&ZB#@`#K`Q0``$``0````$`0J`(``/\8
+M#`````!-HDD``P`-%0`!``$````!``$````!``$````"```!`````@```0``5
+M``0`````"0`!``$````!``,``0`!`````0!6``$``0````$`=:``!`.`#0``=
+M``#__P```````````````````````````````````````$5-35A86%@P```$G
+M```S.#8@<W!E8VEF:6,@8V]D92!E;F%B;&5D+@T*)$-O;G9E;G1I;VYA;"!M0
+M96UO<GD@879A:6QA8FQE.B`D2"!P87)A9W)A<&AS+@T*)$5-4R!M96UO<GD@A
+M879A:6QA8FQE.B`D2"`Q-DLM<&%G97,N#0HD26YC;W)R96-T($1/4R!V97)S/
+M:6]N+B!-=7-T(&)E(#,N,#`@;W(@;&%T97(N)$EN86-C97-S:6)L92!%6$4@'
+M9FEL92X@0V%N)W0@;&]A9"!O=F5R;&%Y<RXD3F]T(&5N;W5G:"!F<F5E(&UE)
+M;6]R>2!L969T('1O(')U;B!T:&ES('!R;V=R86TN)$9I;&4@22]/(&5R<F]R+
+M+B1);G1E<FYA;"!M96UO<GD@86QL;V-A=&EO;B!F86EL=7)E+B1%35,@;65M0
+M;W)Y(&UA;F%G97(@97)R;W(N)$5X96-U=&%B;&4@;W(@;W9E<FQA>2!H96%DI
+M97(@;6ES<VEN9R!O<B!D86UA9V5D+B15;F%B;&4@=&\@<F5S;VQV92!O=F5RF
+M;&%Y(&9I;&4@;F%M97,N)$EN86-C97-S:6)L92!/5DP@9FEL92X@0V%N)W0@T
+M;&]A9"!O=F5R;&%Y<RXD26YC;VUP;&5T92!E>&5C=71A8FQE+B`@3U9,(&9IR
+M;&5S(&UI<W-I;F<_)%5N:VYO=VX@97)R;W(A)!M;,&T;6TL-"AM;2QM;,6U/F
+M5DQ-1U(Z&ULP;2`D&UM+#0H;6TL@("`@("`@("@D&UM+#0H;6TL')#\N3U9,1
+M`%!345)65U4>!OR,V`40`"ZC``"T,,TA/`-S!;`!Z0``CAX``+[__T:#/`!US
+M^H/&!.@``+0UL&?-(8S(CMB_"@"^``"Y"`#SIK``=0*P_RZB``!U$K1!S6<N+
+MB1X``+1"S6<NB1X``+@``"ZC``"X``".V(L>```NB1X``(L>```NB1X``+1(+
+MS2%S`^D``"ZC```NBPX``([`)L8&````)L8&````)L<&`````";'!@`````FA
+MQP8`````)L<&``#__R;'!@`````FQP8`````)L<&`````$#BOHS(CM@S[3/_V
+M,_;H```NH0``+@,&``".P(O.T>$FB`X``"ZA``#1X-'@T>#1X-'@+HL6```+[
+MTG0.T>K1ZM'JT>I"+2```\(N*P8``":C```N@SX```!T!CO'<@*+^"ZA``#1$
+MX-'@T>#1X":C```FB2X``"X#+@``B]6*SHKR,NTRTM'BT=&P`+1"S2$NBPX`*
+M`"ZA``!)`\&.P":*'@``@^,>@_L`=0LF@SX``&R<D`'$!@`#`R0.Q`@``P-2H
+M#L0*``,#?@[$#``#`Z\.Q`X``P._#L00``,#OP[$$@`#`^,.Q!0``P/]#L064
+M``,#+@_$&``#`U0/Q!H``P.`#\0<``,#JP_$'@`#`ZL/Q"```P.K#\0B``,#$
+MJP_&B@`#`X0`AI<``P-'&\:;``$!+`"&J@`#`S\:QKH``P.D#<;)``,#L`W&<
+MU``#`X8`QMT``P.L#<K@)@("QN0``P.``,KG)@<'QNTF!@;&\@`#`WX`QO8F?
+M!P?&^P`#`WP`AP0``P,)$L<(``,#-@#'#0`#`WP`QQ0$`@+'&@`"`@$`QR``"
+M`@("`,<G``("!`#'+@`"`@8`QS4``@((`,<\``(""@#'0P`"`@P`QTH``@(.*
+M`(=<``,#[QG'8``#`S8`QV4``P/&"L=P!`("QW0``P.P"L>#``,#K@K'F@`#@
+M`[0*QYX``@(,`,>C``,#Q@K'L``#`[0*Q[P``@(.`,?!``(""@#'Q@`#`[`*;
+MQ]\``P-\`,?C``,#-@#'[00"`L?Z``(""@"RH``$`WP1`'4#Z0``2.+C+J$`,
+M`"ZC``".P";&!@```";'!@(````FQP8$````)L<&!@```":)/@@``\<NHP``=
+M5RZ.!@``Z```)L<&``#__R:`)@``OU+H``!87PO`=05'.]=R+R['!@`````N.
+MQP8`````OP``+L<%__^#QP8NH0``+HD%+HD^``".P";&!@``H.L%L`/I``"X(
+M``".V*```#+DT>#1X"ZC``#H```NBPX``+@``([`C,B.V+L``+X``+\``":*,
+M!#+D`P8``(D%)HL'*P8``(E%`H/'!(/#`D;BX@<?75]>6EE;6.H`````+HDV\
+M```NC!X``%X?4%/\K#+DB]BM+J,``(O&+HLV``"#Q@8NC%S\+HE$_M'CT>.!N
+MPP``+HX?+HM'`BZ,'"Z)-@``+HLV``!&+HDV``")-@``+HLV``!T?XDV``#V'
+M!@``('1]_@8```,&```NHP``+HLV```NCAX``%M8G2[_'@``G"Z,'@``+HDV3
+M```NBS8``"Z.'/X.``"#[@8NCAPN_W0"+O]T!"Z)-@``+HLV``!&+HDV``")C
+M-@``+HLV``!T-XDV``#V!@``('0T+HLV```NCAX``,]&+HDV``#I``#V!@``D
+M0'0+4*$``.@``%CI``#H``#I``!&+HDV``#KP?8&``!`=`I0H0``Z```6.N[O
+MZ```Z[9045)35597'@:,V([`)H`^````=0HFH0``Z```ZP20Z```!0$`)J,`S
+M`([8)HL6``"*SHKR,NTRTM'BT=$FH0``45(#T(/1`+1"L``FBAX``(/C'BZ+2
+MGP``S2%R4#/2)HL.``#1X='AT>'1X;0_S2%R.UI9M$*P`":*'@``@^,>+HN?4
+M``#-(7(DN0`"N@``'HS(CMBT/\TA'W(2Z```!Q^`#@``(%]>75M:65C#L`3I2
+M``"^``"+[H'%``(NBTP&XUN,WRXK/@``+@-T&#OU<@/H```NBAQ&._5R`^@`&
+M`"Z*/$8[]7(#Z```+HH$1COU<@/H```NBB1&+@,&```#QX[8BP<N`P8``"X[-
+M!@``<@DN.P8``',"`\>)!^*PPU-15U4>!KD``KH``(S(CM@FBAX``(/C'BZ+4
+MGP``M#_-(7,#Z0``O@``!Q]=7UE;PU-14E9751XNCAX``#/`B]"+Z(O8+HL.:
+M``#VAP``@'4P]H<``$!U!_:'```@="(NBS8``"Z+/@``*[<``!N_```[UW(&M
+M=0H[QG,&B\:+UXOK@\,0XL0+[74%L`7I``#1[='MT>W1[8S8`\4?75]>6EE;;
+MPX#\2W0/@/Q,=`4N_RX``+``Z0``"L!U\E!14E-55E<&'BZ.!@``+HL.``"[B
+M$`!))O:'``!`=1<F]H<``"!T99P,`X0$``,#VQ#$"P`#`X``Q`\``P-8`,0W)
+M``,#@@#$/0`#`S8`A$```P.H&,1%``(""`#$3`0"`H11``,#$!C$800#`\1HC
+M``,#`@#$;0`#`XH$Q'D``P,V`,2!``,#B`3$B`0"`H20``,#1QO(DR8!`<28X
+M)@$!Q*(``P.J"H2E``,#31S$J@`#`WX`R*TF!`3$MB8$!,2Y)@,#Q+P``P.([
+M`,3%``,#-@#$S@`#`X``S.8F!07$[0`#`Q``Q/(``P,2`,4!``,#!`#%"``#S
+M`X@$Q1L``P.(`,4J``,#B`3%+P0#`\4U!`,#Q3D``@($`,4^``,#`@#%1``""
+M`@8`Q4@$`@+%3P`"`@$`Q5,``@("`,57``,#!@#%7``#`Q``Q6$``P,2`,5I4
+M``,#!`#%;P`#`Q(`Q70``P,0`,5Y``,#B`3%@``"`@$`Q9,``P.(!,68!`,#3
+MQ9X$`P/%H@`"`@0`Q:<``P,"`,6M``("!@#%L00"`L6Y``,#$`#%O@`#`Q(`:
+MQ<4``P,"`(7(``,#OA+%S`0"`L73``(""`"%U@`#`ST9A=H``P/)$H7=``,#8
+M?!.%X``#`\D2Q>8``P,"`,7L!`("Q?,``@((`(7V``,#/1F%_``#`WP3QA``H
+M`@(!`,87``("#`"&&@`#`Z06AB```P,6%L8G``("`@#&+@`"`@H`QCX``@(.Q
+M`,9.!`("QE8``P,8`,9A``("#`#&>@0"`L:"``,#&`#&C``#`ZP*AIL``P,M+
+M%,:A!`("AJ\``P-'&\:R``,#K`K&Q0`#`X``AM```P.8%(;;``,#F!2&Y@`#H
+M`Y@4AO$``P.8%,;Z``,#A`#'!0`#`X0`QPH``P.``,<1``,#@@#')@`#`ZP*,
+MQR\$`@+'-P`#`Q@`AT```P,H%,=#``,#K`K'5@`#`S8`QV,``P-\`,=G!`("&
+MQVX$`@+'=00"`L=]!`,#QX(``P,"`,>&``("!`#'B@`"`@8`AZ@``P-'&\?+%
+M``,##`"'T``#`T<;Q^(``P,V`,?G``,#?`#'\`0"`L?X!`(";J``!`-X%14FG
+MBX<``"T!`"X[!@``<@8F@*<``-^#PQ#BUB['!@``__\NH0``/?__=`Z.P":.<
+M!@0`)L<&`@```+D0`+X``"Z+!#W__W0+CL"T2<TA+L<$__^#Q@+BZ.@``(OLC
+M_W86G1\'7UY=6UI96"Z,%@``+HDF``#-(2Z.%@``+HLF``!045)35597!AZ+!
+M[)R/1A;H``#H```?!U]>75M:65C/)HL>``"#ZP&+TR8#%@``@\(!)J$``#W_;
+M_W00Z```)H`.``!`+J$``.M9D"ZA``#K4I".V#O8<PD[PG--Z```Z_$#!@@`P
+M.]AS-_8&```!=`?H```#!@@`.\)R)8S8B\LKR'02!N@``":`#@```>@``(S`Z
+MCM@')HL.``"#P0'K.I"A`@`+P'0"ZZFP!ND``";'!@``__\F@"8``+^+R(/!!
+M`>@``#O1<P_H```[T7,(Z```Z```Z^KK`9`&@`X```'H``!R"1Z,P([8Z```'
+M'P>,!@8`C-C#C-@#P8[`H0@`*\%V,(D."``FHP@`H0(`)J,"`(P&`@`FC!X$J
+M`";&!@```":A`@`+P'0*'H[8C`8$`!_XP_G#+J$``#/2ZQB0CMCV!@```74+)
+M.0X(`'(%BQ8(`,.A`@`+P'7EP_8&```!=!(&C@8&`":`)@``WR:`)@``OP?KS
+M)9".V(`F``#?]@8``$!T"X`F``"_H0``Z```H0``+0$`CMCK`9!2!H`F``#^J
+MH00`"\!T,H[`)O8&```!=2@F`P8(`(S:.]!U':$(`"8!!@@`H0(`)J,"``O`5
+M=`:.V(P&!`",P([8H0(`"\!T,([`)O8&```!=2:,V`,&"`",PCO"=1HFH0@`Q
+M`08(`":A`@"C`@`+P'0'CL`FC!X$`(`F``#^!UJ,V,-14U97'@8STBZA``".G
+MV*$"``O`=?>^``"_``"Y$`"T2+O__\TA@_L0<DFT2,TA<D,N.P8``'(T.]-SD
+M`HO3+HD$CL`FQ@8````FQP8"````)L<&!@```":,'@0`)HD>"`",!@(`@\8"]
+MCMCK!BZ)!8/'`N*KO@``N1``+HL$/?__=`N.P+1)S2$NQP3__X/&`N+H!Q]?&
+M7EM9PS/2+H`^``#_=`'#+L<&``#__[\``(O9N1``+HL%/?__=!'H```[PW-8D
+M@\<"XNR+RS/2PXO+NP0`M$-15P;-9P=?60KD=`,STL,NB14FB18``":`#@``6
+M0(O"Z```+J$``([8Q@8```#'!@(```#'!@0```#'!@8```"Z`!")%@@`PXO+@
+MCMZ+T"Z+!2:C```F@`X``$##+CL&``!U`<-34AX&Z```+J$``#/2,_:.V/8&:
+M```!=`V.!@8`)H`.``!@ZPR0H0@`.]!S!(O0C(N<G0'$!``"`@(`Q`P``P,X]
+M`,03!`("Q!X``P-Z`,0D``,#.`#$/0`#`S@`A%@``P.(',1L``,#%`#$<0`#:
+M`Q8`Q'@``P,4`,1]``,#%@"$CP`#`Q`8A)(``P--',2A``("`@#$JP`"`@P`#
+MQ+(``@((`(2Z``,#/1G$OP0"`L3$``,#A@#$RP`#`U@`A-L``P-/%X3O``,#;
+M3Q>%`P`#`^L6A0P``P./%\46``("#`"%*@`#`T<;Q2\``@((`,4V!`("A3\`?
+M`P,J%X5&``,#J!B%30`#`\@4A5```P-K%X5>``,#ZQ:%:``#`X\7Q;0``P-8U
+M`,7F!`("Q>P$`@+%]P0"`L7\!`("Q@,$`@+&!P`"`@@`A@H``P,]&<8-``("(
+M`@#&H@`#`U@`QJX``P,X`,:Q``,#B@K&RP`#`S8`QPP``P.*"L<U``,#L`W'J
+M/@`#`WH`QT,``P-:`(=3``,#/1G'?P`"`@@`QX0$`@*'B@`#`X,9QXX``P.&T
+M`,>\``(""`#'P00"`L?(``,#>@"'T@`#`X,9Q]8``P.&`,?L!`("0:!-`P-T`
+M&=ZA`@`+P'78B\(''UI;PP9345(NHP``B]"T1#+`,]M2S6=:"N1U3[1$L`&[!
+M`0!2S6=:"N1U0+1$L`*[`@!2S6=:"N1U,;1$L`.[`P#-9PKD=20NC@8``"Z+[
+M#@``,]LF]H<``$!T!B:`IP``WX/#$.+M6EE;!\.P!^D``+H``(O>T>,NBY\`=
+M`+D<`+0_S2%R,3O!=",]``!T`^LKD$:#_@]T'XO>T>,N@[\``/]T[BZ+GP``?
+M,^WKT"Z!/@``35IU!L.P"^D``+`(Z0``!K0OS2$NC`8``"Z)'@``'KH``(S(D
+MCMBT&LTA'[DH`(S+CL._``#SI;\``+``N5``_/*N@^E0]]F+V8/Y4'0'2T^#T
+M^P=^';!<_?*N_(O3*]%*N0``+HD>```NB18``(/Z#'X%L`GI``",R([8N@``F
+ML`"T/<TA<P6P`ND``"ZC```N@SX```M_"B[_!@``+O\&``"_```N`SX``(/OE
+M!;X``+D&`/.DN0``N@``M$[-(7)'N0X`+HL6```N*18``%$NBQX``+\```/[=
+MO@``+HL.``#SI%FZ``"P`+0]S2%S".@``+`*ZR*0B]G1XRZ)AP``M$_-(7("-
+MXL8NBQ8``"Z.'@``M!K-(0?#,N10#A^+V-'C@<,``(L7@_K_=&12N@``M`G-L
+M(5JT"<TAM`FZ``#-(5A0Z```M`*R.LTAN*`PZ```M`*R.LTAN`"@+BL&``#H_
+M``"T`K(ZS2&^``"Y$``SP"Z#//]T"BX#!@``@\8"XO#H``"T`K(IS2&Z``"TQ
+M"<TAZ```+J$``#W__W0&CL"T2<TAN1``O@``+HL$/?__=`:.P+1)S2&#Q@+BV
+M[;D0`+X``"Z+%(/Z_W0$M$7-9X/&`N+ON0\`B]E+T>,NBY\``(/[_W0$M#[-7
+M(>+K6+1,S2%0AN#H``!8ZP&04-#HT.C0Z-#HZ```6.L!D%`D#P0P/#IR`@0'I
+M4HK0M`+-(5I8PQXSP([8+HLV``#ZBP0NHP``BT0"+J,``+@``(D$C$P"OH0`O
+MBP0NHP``BT0"+J,``+@``(D$C$P"^Q_#'C/`CMB^A`#Z+J$``#W__W0)B00NN
+MH0``B40"+HLV```NH0``/?__=`J)!"ZA``")1`+['\,PG/4!Q!4``P-Z`,15P
+M``,#-@#$6@`#`WP`Q&$$`@+$:00"`H1Y``,#1QO$?``#`ZP*Q(4``P,8`,2I!
+M``,#&`#$L0`#`Q@`Q+H``P.L"H3$``,#1QN$R0`#`T<;Q-,``P.`#<38``,#/
+M@@W$W``#`P`-Q.\``P.L#,3T``,#K`S%(@`#`_P,Q2<``P/^#(4Q``,#1QO%V
+M.``#`ZP,A44``P-'&\5)``,#&`#%3@`#`_X,Q58``P/\#,5;``,#_@S%7@`#"
+M`ZP,Q6,``P/\#,5I``,#\P_%=``#`ZP,Q8(``P/^#,6'``,#_`S%C0`#`_P,7
+MQ9```P.L#,65``,#'@W%F@`#`_X,Q:```P.L#(6K``,#'AS%N0`#`Q@`Q<8`3
+M`P."#<7+``,#@`W%W@`#`X0-Q>D``P.Z#\7W``,#UP^%_@`#`QX<A@H``P,>T
+M',88``,#-@"&&P`#`QX<QB0``P-:`,8T``,#K@V&/``#`QX<QD4``P/I#X9,U
+M``,#B!S&4``#`S8`QF$``P,X`,9Z``,#6@#&F``#`Q@`AJX``P,H'(:^``,#@
+M.!S&X0`#`ZH*QN@``P,(`,;O``,#"@#&\@`#`V82QP```P,,`,<'``,##@#'E
+M"@`#`SH5QQ\``P,,`,<J``,##@#',@`#`ZH*QS8``P,(`,=!``,#"@"8B@(`C
+"`'0`7
+``
+end
+sum -r/size 34565/9296 section (from "begin" to "end")
diff -Pru nethack-3.4.1/sys/msdos/old/trampoli.c nethack/sys/msdos/old/trampoli.c
--- nethack-3.4.1/sys/msdos/old/trampoli.c	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/old/trampoli.c	Thu Jan 10 16:43:29 2002
@@ -0,0 +1,638 @@
+/*	SCCS Id: @(#)trampoli.c 	3.1	95/06/01	  */
+/* Copyright (c) 1989 - 1993 by Norm Meluch and Stephen Spackman  */
+/* NetHack may be freely redistributed.  See license for details. */
+
+#include "hack.h"
+
+/****************************************************************************/
+/*									    */
+/*	This file contains a series of definitions of "one liner"	    */
+/*	functions corresponding to *all* functions that NetHack calls	    */
+/*	via pointers.							    */
+/*	     IF ANY CALLS TO FUNCTIONS VIA POINTERS ARE ADDED		    */
+/*	     TO THE CODE, AN ENTRY FOR THE FUNCTION CALLED MUST		    */
+/*	     BE ADDED TO THIS FILE AND TO TRAMPOLI.H.			    */
+/*	This mess is necessary for the Microsoft Compiler implementation    */
+/*	of overlaid code (v5.1 - 6.0ax).				    */
+/*									    */
+/*	The original function (eg foo) has been #defined to be foo_	    */
+/*	via double inclusion of trampoli.h in hack.h, and		    */
+/*	now the definition of foo is placed in this file calling foo	    */
+/*	directly.  This module is _never_ placed in an overlay so	    */
+/*	calls via pointers to these functions will not cause difficulties.  */
+/*									    */
+/*	This leads to what could be called a "trampoline" effect, and	    */
+/*	hence the silly name for these files. :-)			    */
+/*									    */
+/****************************************************************************/
+
+#ifdef OVERLAY
+
+/* ### apply.c ### */
+#undef dig
+#undef doapply
+#undef dojump
+#undef dorub
+
+int dig()		{ return dig_(); }
+int doapply()		{ return doapply_(); }
+int dojump()		{ return dojump_(); }
+int dorub()		{ return dorub_(); }
+
+
+/* ### artifact.c ### */
+#undef doinvoke
+
+int doinvoke()		{ return doinvoke_(); }
+
+
+/* ### cmd.c ### */
+#undef doextcmd
+#undef doextlist
+#undef doprev_message
+
+#undef domonability
+
+#undef enter_explore_mode
+
+int enter_explore_mode()	{ return enter_explore_mode_(); }
+
+#undef timed_occupation
+
+#undef wiz_attributes
+
+#ifdef WIZARD
+#undef wiz_detect
+#undef wiz_genesis
+#undef wiz_identify
+#undef wiz_level_tele
+#undef wiz_map
+#undef wiz_where
+#undef wiz_wish
+#endif
+
+int doextcmd()		{ return doextcmd_(); }
+int doextlist()		{ return doextlist_(); }
+int doprev_message()	{ return doprev_message_(); }
+
+int domonability()	{ return domonability_(); }
+
+int timed_occupation()	{ return timed_occupation_(); }
+
+int wiz_attributes()	{ return wiz_attributes_(); }
+
+#ifdef WIZARD
+int wiz_detect()	{ return wiz_detect_(); }
+int wiz_genesis()	{ return wiz_genesis_(); }
+int wiz_identify()	{ return wiz_identify_(); }
+int wiz_level_tele()	{ return wiz_level_tele_(); }
+int wiz_map()		{ return wiz_map_(); }
+int wiz_where()		{ return wiz_where_(); }
+int wiz_wish()		{ return wiz_wish_(); }
+#endif
+
+
+/* ### do.c ### */
+#undef doddrop
+#undef dodown
+#undef dodrop
+#undef donull
+#undef doup
+#undef dowipe
+#undef drop
+#undef wipeoff
+
+int doddrop()			{ return doddrop_(); }
+int dodown()			{ return dodown_(); }
+int dodrop()			{ return dodrop_(); }
+int donull()			{ return donull_(); }
+int doup()			{ return doup_(); }
+int dowipe()			{ return dowipe_(); }
+int drop(obj)
+  register struct obj *obj;	{ return drop_(obj); }
+int wipeoff()			{ return wipeoff_(); }
+
+
+/* ### do_name.c ### */
+#undef ddocall
+#undef do_mname
+
+int ddocall()		{ return ddocall_(); }
+int do_mname()		{ return do_mname_(); }
+
+
+/* ### do_wear.c ### */
+#undef Armor_off
+#undef Boots_off
+#undef Gloves_off
+#undef Helmet_off
+#undef Armor_on
+#undef Boots_on
+#undef Gloves_on
+#undef Helmet_on
+#undef doddoremarm
+#undef doputon
+#undef doremring
+#undef dotakeoff
+#undef dowear
+#undef select_off
+#undef take_off
+
+int Armor_off()		{ return Armor_off_(); }
+int Boots_off()		{ return Boots_off_(); }
+int Gloves_off()	{ return Gloves_off_(); }
+int Helmet_off()	{ return Helmet_off_(); }
+int Armor_on()		{ return Armor_on_(); }
+int Boots_on()		{ return Boots_on_(); }
+int Gloves_on()		{ return Gloves_on_(); }
+int Helmet_on()		{ return Helmet_on_(); }
+int doddoremarm()	{ return doddoremarm_(); }
+int doputon()		{ return doputon_(); }
+int doremring()		{ return doremring_(); }
+int dotakeoff()		{ return dotakeoff_(); }
+int dowear()		{ return dowear_(); }
+int select_off(otmp)
+  struct obj *otmp;	{ return select_off_(otmp); }
+int take_off()		{ return take_off_(); }
+
+
+/* ### dogmove.c ### */
+#undef wantdoor
+
+void wantdoor(x, y, dummy)
+  int x, y; genericptr_t dummy; { wantdoor_(x, y, dummy); }
+
+
+/* ### dokick.c ### */
+#undef dokick
+
+int dokick()		{ return dokick_(); }
+
+
+/* ### dothrow.c ### */
+#undef dothrow
+
+int dothrow()		{ return dothrow_(); }
+
+
+/* ### eat.c ### */
+#undef Hear_again
+#undef eatmdone
+#undef doeat
+#undef eatfood
+#undef opentin
+#undef unfaint
+
+int Hear_again()	{ return Hear_again_(); }
+int eatmdone()		{ return eatmdone_(); }
+int doeat()		{ return doeat_(); }
+int eatfood()		{ return eatfood_(); }
+int opentin()		{ return opentin_(); }
+int unfaint()		{ return unfaint_(); }
+
+
+/* ### end.c ### */
+#undef done1
+#undef done2
+#undef done_intr
+#if defined(UNIX) || defined(VMS)
+#undef done_hangup
+#endif
+
+void done1(sig) int sig; { done1_(sig); }
+int done2()		{ return done2_(); }
+void done_intr(sig) int sig; { done_intr_(sig); }
+#if defined(UNIX) || defined(VMS)
+void done_hangup(sig) int sig; { done_hangup_(sig); }
+#endif
+
+
+/* ### engrave.c ### */
+#undef doengrave
+
+int doengrave()		{ return doengrave_(); }
+
+
+/* ### fountain.c ### */
+#undef gush
+
+void gush(x, y, poolcnt)
+  int x, y; genericptr_t poolcnt; { gush_(x, y, poolcnt); }
+
+
+/* ### hack.c ### */
+#undef dopickup
+#undef identify
+
+int dopickup()		{ return dopickup_(); }
+int identify(otmp)
+  struct obj *otmp;	{ return identify_(otmp); }
+
+
+/* ### invent.c ### */
+#undef ckunpaid
+#undef ddoinv
+#undef dolook
+#undef dopramulet
+#undef doprarm
+#undef doprgold
+#undef doprring
+#undef doprtool
+#undef doprwep
+#undef dotypeinv
+#undef doorganize
+
+int ckunpaid(obj)
+  struct obj *obj;	{ return ckunpaid_(obj); }
+int ddoinv()		{ return ddoinv_(); }
+int dolook()		{ return dolook_(); }
+int dopramulet()	{ return dopramulet_(); }
+int doprarm()		{ return doprarm_(); }
+int doprgold()		{ return doprgold_(); }
+int doprring()		{ return doprring_(); }
+int doprtool()		{ return doprtool_(); }
+int doprwep()		{ return doprwep_(); }
+int dotypeinv()		{ return dotypeinv_(); }
+int doorganize()	{ return doorganize_(); }
+
+
+/* ### ioctl.c ### */
+#ifdef UNIX
+# ifdef SUSPEND
+#undef dosuspend
+
+int dosuspend()		{ return dosuspend_(); }
+# endif /* SUSPEND */
+#endif /* UNIX */
+
+
+/* ### lock.c ### */
+#undef doclose
+#undef doforce
+#undef doopen
+#undef forcelock
+#undef picklock
+
+int doclose()		{ return doclose_(); }
+int doforce()		{ return doforce_(); }
+int doopen()		{ return doopen_(); }
+int forcelock()		{ return forcelock_(); }
+int picklock()		{ return picklock_(); }
+
+
+/* ### mklev.c ### */
+#undef do_comp
+
+int do_comp(vx, vy)
+  genericptr_t vx, vy;	{ return comp_(vx, vy); }
+
+
+/* ### mondata.c ### */
+/* canseemon() is only called by a macro e_boolean.  If e_boolean ever does
+   become a function, this may need to return. */
+
+/* #undef canseemon */
+
+/* boolean canseemon(x) struct monst *x; { return canseemon_(x); } */
+
+
+/* ### muse.c ### */
+#undef mbhitm
+
+int mbhitm(mtmp, otmp)
+  struct monst *mtmp; struct obj *otmp; { return mbhitm_(mtmp, otmp); }
+
+
+/* ### o_init.c ### */
+#undef dodiscovered
+
+int dodiscovered()	{ return dodiscovered_(); }
+
+
+/* ### objnam.c ### */
+#undef doname
+#undef xname
+
+char *doname(obj)
+  struct obj *obj;	{ return doname_(obj); }
+char *xname(obj)
+  struct obj *obj;	{ return xname_(obj); }
+
+
+/* ### options.c ### */
+#undef doset
+#undef dotogglepickup
+
+int doset()		{ return doset_(); }
+int dotogglepickup()	{ return dotogglepickup_(); }
+
+
+/* ### pager.c ### */
+#undef dohelp
+#undef dohistory
+#undef dowhatdoes
+#undef dowhatis
+#undef doquickwhatis
+
+int dohelp()		{ return dohelp_(); }
+int dohistory()		{ return dohistory_(); }
+int dowhatdoes()	{ return dowhatdoes_(); }
+int dowhatis()		{ return dowhatis_(); }
+int doquickwhatis()	{ return doquickwhatis_(); }
+
+
+/* ### pcsys.c ### */
+#ifdef SHELL
+#undef dosh
+
+int dosh()		{ return dosh_(); }
+#endif /* SHELL */
+
+
+/* ### pickup.c ### */
+#undef ck_bag
+#undef doloot
+#undef in_container
+#undef out_container
+
+int ck_bag(obj)
+  struct obj *obj;	{ return ck_bag_(obj);  }
+int doloot()		{ return doloot_(); }
+int in_container(obj)
+  struct obj *obj;	{ return in_container_(obj); }
+int out_container(obj)
+  struct obj *obj;	{ return out_container_(obj); }
+
+
+/* ### potion.c ### */
+#undef dodrink
+#undef dodip
+
+int dodrink()		{ return dodrink_(); }
+int dodip()		{ return dodip_(); }
+
+
+/* ### pray.c ### */
+#undef doturn
+#undef dopray
+#undef prayer_done
+#undef dosacrifice
+
+int doturn()		{ return doturn_(); }
+int dopray()		{ return dopray_(); }
+int prayer_done()	{ return prayer_done_(); }
+int dosacrifice()	{ return dosacrifice_(); }
+
+
+/* ### print.c ### */
+#undef doredraw
+
+int doredraw()		{ return doredraw_(); }
+
+
+/* ### read.c ### */
+#undef doread
+#undef set_lit
+
+int doread()		{ return doread_(); }
+void set_lit(x, y, val)
+  int x, y; genericptr_t val; { set_lit_(x, y, val); }
+
+
+/* ### rip.c ### */
+#undef genl_outrip
+
+void genl_outrip(tmpwin, how)
+  winid tmpwin; int how; { genl_outrip_(tmpwin, how); }
+
+
+/* ### save.c ### */
+#undef dosave
+#if defined(UNIX) || defined(VMS)
+#undef hangup
+#endif
+
+int dosave()		{ return dosave_(); }
+#if defined(UNIX) || defined(VMS)
+void hangup(sig) int sig; { hangup_(sig); }
+#endif
+
+
+/* ### search.c ### */
+#undef findone
+#undef openone
+#undef doidtrap
+#undef dosearch
+
+void findone(zx, zy, num)
+  int zx, zy; genericptr_t num; { findone_(zx, zy, num); }
+void openone(zx, zy, num)
+  int zx, zy; genericptr_t num; { openone_(zx, zy, num); }
+int doidtrap()		{ return doidtrap_(); }
+int dosearch()		{ return dosearch_(); }
+
+
+/* ### shk.c ### */
+#undef dopay
+
+int dopay()		{ return dopay_(); }
+
+
+/* ### sit.c ### */
+#undef dosit
+
+int dosit()		{ return dosit_(); }
+
+
+/* ### sounds.c ### */
+#undef dotalk
+
+int dotalk()		{ return dotalk_(); }
+
+
+/* ### spell.c ### */
+#undef learn
+#undef docast
+#undef dovspell
+
+int learn()		{ return learn_(); }
+int docast()		{ return docast_(); }
+int dovspell()		{ return dovspell_(); }
+
+
+/* ### steal.c ### */
+#undef stealarm
+
+int stealarm()		{ return stealarm_(); }
+
+
+/* ### trap.c ### */
+#undef dotele
+#undef dountrap
+#undef float_down
+
+int dotele()		{ return dotele_(); }
+int dountrap()		{ return dountrap_(); }
+int float_down()	{ return float_down_(); }
+
+
+/* ### version.c ### */
+#undef doversion
+#undef doextversion
+
+int doversion()		{ return doversion_(); }
+int doextversion()	{ return doextversion_(); }
+
+
+/* ### wield.c ### */
+#undef dowield
+
+int dowield()		{ return dowield_(); }
+
+
+/* ### zap.c ### */
+#undef bhitm
+#undef bhito
+#undef dozap
+
+int bhitm(mtmp, otmp)
+  struct monst *mtmp; struct obj *otmp; { return bhitm_(mtmp, otmp); }
+int bhito(obj, otmp)
+  struct obj *obj, *otmp; { return bhito_(obj,  otmp); }
+int dozap()		{ return dozap_(); }
+
+
+/*
+ * Window Implementation Specific Functions.
+ */
+
+/* ### getline.c ### */
+#undef tty_getlin
+#undef tty_get_ext_cmd
+
+int tty_get_ext_cmd()		{ return tty_get_ext_cmd_(); }
+void tty_getlin(query,bufp)
+  const char *query; char *bufp;{ tty_getlin_(query,bufp); }
+
+
+/* ### termcap.c ### */
+#undef tty_nhbell
+#undef tty_number_pad
+#undef tty_delay_output
+#undef tty_start_screen
+#undef tty_end_screen
+
+void tty_nhbell()		{ tty_nhbell_(); }
+void tty_number_pad(state)
+  int state;			{ tty_number_pad_(state); }
+void tty_delay_output()		{ tty_delay_output_(); }
+/* other defs that really should go away (they're tty specific) */
+void tty_start_screen()		{ tty_start_screen_(); }
+void tty_end_screen()		{ tty_end_screen_(); }
+
+
+/* ### topl.c ### */
+#undef tty_doprev_message
+#undef tty_yn_function
+
+int tty_doprev_message()	{ return tty_doprev_message_(); }
+char tty_yn_function(query,resp,def)
+  const char *query, *resp; char def;
+				{ return tty_yn_function_(query,resp,def); }
+
+
+/* ### wintty.c ### */
+#undef tty_init_nhwindows
+#undef tty_player_selection
+#undef tty_askname
+#undef tty_get_nh_event
+#undef tty_exit_nhwindows
+#undef tty_suspend_nhwindows
+#undef tty_resume_nhwindows
+#undef tty_create_nhwindow
+#undef tty_clear_nhwindow
+#undef tty_display_nhwindow
+#undef tty_destroy_nhwindow
+#undef tty_curs
+#undef tty_putstr
+#undef tty_display_file
+#undef tty_start_menu
+#undef tty_add_menu
+#undef tty_end_menu
+#undef tty_select_menu
+#undef tty_update_inventory
+#undef tty_mark_synch
+#undef tty_wait_synch
+#ifdef CLIPPING
+#undef tty_cliparound
+#endif
+#ifdef POSITIONBAR
+#undef tty_update_positionbar
+#endif
+#undef tty_print_glyph
+#undef tty_raw_print
+#undef tty_raw_print_bold
+#undef tty_nhgetch
+#undef tty_nh_poskey
+
+void tty_init_nhwindows(argcp,argv)
+	int *argcp; char **argv;
+				{ tty_init_nhwindows_(argcp,argv); }
+void tty_player_selection()	{ tty_player_selection_(); }
+void tty_askname()		{ tty_askname_(); }
+void tty_get_nh_event()		{ tty_get_nh_event_(); }
+void tty_exit_nhwindows(str)
+  const char *str;		{ tty_exit_nhwindows_(str); }
+void tty_suspend_nhwindows(str)
+  const char *str;		{ tty_suspend_nhwindows_(str); }
+void tty_resume_nhwindows()	{ tty_resume_nhwindows_(); }
+winid tty_create_nhwindow(type)
+  int type;			{ return tty_create_nhwindow_(type); }
+void tty_clear_nhwindow(window)
+  winid window;			{ tty_clear_nhwindow_(window); }
+void tty_display_nhwindow(window, blocking)
+  winid window; boolean blocking;
+				{ tty_display_nhwindow_(window,blocking); }
+void tty_destroy_nhwindow(window)
+  winid window;			{ tty_destroy_nhwindow_(window); }
+void tty_curs(window,x,y)
+  winid window; int x,y;	{ tty_curs_(window,x,y); }
+void tty_putstr(window,attr,str)
+  winid window; int attr; const char *str;
+				{ tty_putstr_(window,attr,str); }
+void tty_display_file(fname, complain)
+  const char *fname; boolean complain;
+				{ tty_display_file_(fname,complain); }
+void tty_start_menu(window)
+  winid window;			{ tty_start_menu_(window); }
+void tty_add_menu(window,ch,attr,str)
+  winid window; char ch; int attr; const char *str;
+				{ tty_add_menu_(window,ch,attr,str); }
+void tty_end_menu(window,ch,str,morestr)
+  winid window; char ch; const char *str, *morestr;
+				{ tty_end_menu_(window,ch,str,morestr); }
+char tty_select_menu(window)
+  winid window;			{ return tty_select_menu_(window); }
+void tty_update_inventory()	{ tty_update_inventory_(); }
+void tty_mark_synch()		{ tty_mark_synch_(); }
+void tty_wait_synch()		{ tty_wait_synch_(); }
+#ifdef CLIPPING
+void tty_cliparound(x,y)
+  int x,y;			{ tty_cliparound_(x,y); }
+#endif
+#ifdef POSITIONBAR
+void tty_update_positionbar(str)
+  char *str;			{ tty_update_positionbar_(str); }
+#endif
+void tty_print_glyph(window,x,y,glyph)
+  winid window; xchar x,y; int glyph;
+				{ tty_print_glyph_(window,x,y,glyph); }
+void tty_raw_print(str)
+  const char *str;		{ tty_raw_print_(str); }
+void tty_raw_print_bold(str)
+  const char *str;		{ tty_raw_print_bold_(str); }
+int tty_nhgetch()		{ return tty_nhgetch_(); }
+int tty_nh_poskey(x,y,pos)
+  int *x,*y,*pos;		{ return tty_nh_poskey_(x,y,pos); }
+
+#endif /* OVERLAY */
diff -Pru nethack-3.4.1/sys/msdos/prebuild.mak nethack/sys/msdos/prebuild.mak
--- nethack-3.4.1/sys/msdos/prebuild.mak	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/prebuild.mak	Tue Apr 23 12:12:16 2002
@@ -0,0 +1,67 @@
+#       SCCS Id: @(#)prebuild.mak       3.4     1997/09/28
+#
+# Makefile for building the genschem utility, the .def files and
+# the Makefiles for distribution.
+#
+
+NHINCL     =..\..\include
+
+!       IF "$(MAKE)"=="NMAKE"
+CC        =cl
+MODEL     =L
+CEXENAM   =/Fe                  # name the .EXE file
+CFLAGS    =/A$(MODEL) /Zp1 /nologo /F 1400 /D__STDC__ /I$(NHINCL)
+!       ELSE                    #       Assume Borland
+CC        =bcc                  # TARGSTRING
+MODEL     =h
+BCTOP     =c:\borlandc          # main Borland C directory
+BCINCL    =$(BCTOP)\include     # include directory for main BC headers
+CEXENAM   =-e                   # name the .EXE file
+CFLAGS    =-I$(BCINCL) -I$(NHINCL) -m$(MODEL) -DSTRNCMPI
+!       ENDIF
+
+LEX = flex
+#LEX = flex -Sc:\tools16\flex.ske
+# LEX = lex
+
+# these are the names of the output files from LEX. Under MS-DOS
+# and similar systems, they may differ
+LEXYYC = lex.yy.c
+#LEXYYC = lexyy.c
+
+
+SCHEMAS = schema1.BC schema2.BC 
+MAKES = Makefile.BC
+
+all: $(SCHEMAS)
+
+genschem.exe: genschem.c
+	$(CC) $(CFLAGS) $(CEXENAM)$@ genschem.c
+
+genschem.c: genschem.l
+	$(LEX) $(FLEXSKEL) genschem.l
+	copy $(LEXYYC) $@
+	@del $(LEXYYC)
+
+schema1.BC: genschem.exe schema1
+	genschem /BC schema1 schema1.BC
+schema2.BC: genschem.exe schema2
+	genschem /BC schema2 schema2.BC
+#
+# NOTE: MSC no longer uses these overlay definitions
+# since switching to the use of packaged functions
+#
+#schema1.MSC: genschem.exe schema1
+#	genschem /MSC schema1 schema1.MSC
+#schema2.MSC: genschem.exe schema2
+#	genschem /MSC schema2 schema2.MSC
+#schema3.MSC: genschem.exe schema3
+#	genschem /MSC schema3 schema3.MSC
+
+def2mak.exe: def2mak.c
+	$(CC) $(CFLAGS) $(CEXENAM)$@ def2mak.c
+
+#Makefile.BC: def2mak.exe template.mak
+#	def2mak /BC template.mak >Makefile.BC
+#Makefile.MSC: def2mak.exe template.mak
+#	def2mak /MSC template.mak >Makefile.MSC
diff -Pru nethack-3.4.1/sys/msdos/schema1 nethack/sys/msdos/schema1
--- nethack-3.4.1/sys/msdos/schema1	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/schema1	Tue Apr 23 12:12:18 2002
@@ -0,0 +1,606 @@
+SCCS Id: @(#)schema1		3.3	 95/10/25
+Copyright (c) NetHack PC Development Team 1993, 1994, 1995
+#
+# NetHack Overlay Schema
+# Minimal extended memory available, lots of 640K base RAM free
+# Overlay buffer size will be (20 + 20 + 19) = 59K (sum of 3 largest overlays).
+# Requires about 490K (for exe load plus overlay buffer), but
+# an additional 70K free (minimum) will be needed for malloc calls,
+# bringing the total requirement to about 560K.
+# Optimized for minimal overlay turns.
+#
+
+[ root ]
+pcmain.0   sound.o    tile.o     pctiles.0  pctiles.b
+vidvga.1   vidvga.0   vidvga.b   video.0   video.1   video.b
+hack.3     vidtxt.0   vidtxt.b	 botl.0    monmove.0 display.o
+dungeon.0  hacklib.0  wintty.o   trap.0    attrib.0  detect.o
+mon.0      cmd.0      vision.o   hack.1    msdos.0   pckeys.o
+random.o   rnd.0      alloc.o    ovlinit.o
+dbridge.0  monmove.1 engrave.0 invent.0
+monmove.2  mondata.0
+hacklib.1  hacklib.2
+dogmove.b
+
+[ ]
+allmain.0
+
+[ ]
+allmain.1  
+
+[ ]
+allmain.b  
+
+[ ]
+apply.0    
+
+[ ]
+apply.1    
+
+[ ]
+apply.b    
+
+[ ]
+artifact.0 
+
+[ ]
+artifact.1 
+
+[ ]
+artifact.b 
+
+[ ]
+attrib.1
+
+[ ]
+attrib.2   
+
+[ ]
+attrib.b   
+
+[ ]
+ball.o     
+
+[ ]
+bones.o    
+
+[ ]
+botl.1     
+
+[ ]
+botl.b     
+
+[ ]
+cmd.1      
+
+[ ]
+cmd.b      
+
+[ ]
+dbridge.1  
+
+[ ]
+dbridge.b  
+
+[ ]
+decl.o     
+
+[ ]
+dig.o
+
+[ ]
+dlb.o
+
+[ ]
+do.0
+
+[ ]
+do.1
+
+[ ]
+do.2
+
+[ ]
+do.3
+
+[ ]
+do.b
+
+[ ]
+do_name.0  
+
+[ ]
+do_name.2  
+
+[ ]
+do_name.b  
+
+[ ]
+do_wear.0  
+
+[ ]
+do_wear.1  
+
+[ ]
+do_wear.2  
+
+[ ]
+do_wear.b  
+
+[ ]
+dog.1      
+
+[ ]
+dog.2
+
+[ ]
+dog.b
+
+[ ]
+dogmove.0
+
+[ ]
+dokick.o
+
+[ ]
+dothrow.o
+
+[ ]
+drawing.o
+
+[ ]
+dungeon.1
+
+[ ]
+eat.0      
+
+[ ]
+eat.1      
+
+[ ]
+eat.b      
+
+[ ]
+end.o      
+
+[ ]
+engrave.1  
+
+[ ]
+engrave.2
+
+[ ]
+engrave.b  
+
+[ ]
+exper.o    
+
+[ ]
+explode.0
+
+[ ]
+explode.1
+
+[ ]
+extralev.o 
+
+[ ]
+files.o    
+
+[ ]
+fountain.o 
+
+[ ]
+getline.1  
+
+[ ]
+getline.2  
+
+[ ]
+hack.2     
+
+[ ]
+hack.b     
+
+[ ]
+hacklib.b
+
+[ ]
+invent.1
+
+[ ]
+invent.2
+
+[ ]
+invent.3
+
+[ ]
+invent.b   
+
+[ ]
+light.3
+
+[ ]
+lock.0     
+
+[ ]
+lock.b     mail.0     
+
+[ ]
+mail.b
+
+[ ]
+makemon.0
+
+[ ]
+makemon.1
+
+[ ]
+makemon.2
+
+[ ]
+makemon.b
+
+[ ]
+mcastu.0
+
+[ ]
+mcastu.b
+
+[ ]
+mhitm.0    
+
+[ ]
+mhitm.b    
+
+[ ]
+mhitu.0    
+
+[ ]
+mhitu.1    
+
+[ ]
+mhitu.b    
+
+[ ]
+minion.o   
+
+[ ]
+mklev.o    
+
+[ ]
+mkmap.o    
+
+[ ]
+mkmaze.o   
+
+[ ]
+mkobj.0    
+
+[ ]
+mkobj.1    
+
+[ ]
+mkobj.b    
+
+[ ]
+mkroom.0   
+
+[ ]
+mkroom.b
+
+[ ]
+mon.1      
+
+[ ]
+mon.2      
+
+[ ]
+mon.b      
+
+[ ]
+mondata.1  
+
+[ ]
+mondata.2  
+
+[ ]
+mondata.b  
+
+[ ]
+monmove.b  
+
+[ ]
+monst.o    
+
+[ ]
+monstr.o   
+
+[ ]
+mplayer.o
+
+[ ]
+msdos.b    
+
+[ ]
+mthrowu.0  
+
+[ ]
+mthrowu.1  
+
+[ ]
+mthrowu.b  
+
+[ ]
+muse.o     
+
+[ ]
+music.o    
+
+[ ]
+o_init.o   
+
+[ ]
+objects.o  
+
+[ ]
+objnam.0   
+
+[ ]
+objnam.1   
+
+[ ]
+objnam.b   
+
+[ ]
+options.o  
+
+[ ]
+pager.o    
+
+[ ]
+pcmain.1 role.o
+
+[ ]
+pcmain.b
+
+[ ]
+pcunix.b
+
+[ ]
+pickup.o
+
+[ ]
+pline.b
+
+[ ]
+polyself.0
+
+[ ]
+polyself.1 
+
+[ ]
+polyself.b 
+
+[ ]
+potion.b   
+
+[ ]
+pray.o
+
+[ ]
+priest.0
+
+[ ]
+priest.b
+
+[ ]
+quest.o
+
+[ ]
+questpgr.o
+
+[ ]
+read.b
+
+[ ]
+rect.o
+
+[ ]
+region.o
+
+[ ]
+restore.o
+
+[ ]
+rip.o
+
+[ ]
+rnd.1      
+
+[ ]
+rnd.b      
+
+[ ]
+rumors.o
+
+[ ]
+save.o
+
+[ ]
+shk.0
+
+[ ]
+shk.1
+
+[ ]
+shk.2
+
+[ ]
+shk.3
+
+[ ]
+shk.b
+
+[ ]
+shknam.0
+
+[ ]
+shknam.b
+
+[ ]
+sit.o
+
+[ ]
+sounds.0
+
+[ ]
+sounds.b
+
+[ ]
+sp_lev.o
+
+[ ]
+spell.o    
+
+[ ]
+steal.0    
+
+[ ]
+steal.1    
+
+[ ]
+steal.b    
+
+[ ]
+sys.o      
+
+[ ]
+teleport.o
+
+[ ]
+termcap.0  
+
+[ ]
+termcap.1  
+
+[ ]
+termcap.b  
+
+[ ]
+timeout.0  
+
+[ ]
+timeout.1  
+
+[ ]
+timeout.b  
+
+[ ]
+topl.1
+
+[ ]
+topl.2
+
+[ ]
+topl.b
+
+[ ]
+topten.o
+
+[ ]
+track.0
+
+[ ]
+track.1
+
+[ ]
+track.b
+
+[ ]
+trap.1
+
+[ ]
+trap.2
+
+[ ]
+trap.3
+
+[ ]
+trap.b
+
+[ ]
+tty.o      
+
+[ ]
+u_init.o   
+
+[ ]
+uhitm.o    
+
+[ ]
+vault.0
+
+[ ]
+vault.b    
+
+[ ]
+version.o  
+
+[ ]
+vidvga.2
+
+[ ]
+vis_tab.o  
+
+[ ]
+weapon.0   
+
+[ ]
+weapon.1   
+
+[ ]
+weapon.b   
+
+[ ]
+were.0
+
+[ ]
+were.b     
+
+[ ]
+wield.o    
+
+[ ]
+windows.o  
+
+[ ]
+wizard.0   
+
+[ ]
+wizard.b   
+
+[ ]
+worm.o     
+
+[ ]
+steed.o worn.o
+
+[ ]
+write.o    
+
+[ ]
+zap.0      
+
+[ ]
+zap.1      
+
+[ ]
+zap.2      
+
+[ ]
+zap.3      
+
+[ ]
+zap.b
+
diff -Pru nethack-3.4.1/sys/msdos/schema2 nethack/sys/msdos/schema2
--- nethack-3.4.1/sys/msdos/schema2	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/schema2	Tue Apr 23 12:12:18 2002
@@ -0,0 +1,669 @@
+SCCS Id: @(#)schema2		3.3	 95/10/25
+Copyright (c) NetHack PC Development Team 1993, 1994, 1995
+#
+# NetHack Overlay Schema
+# Small Root footprint, with extended memory available for caching.
+# Almost everything is overlaid.
+#
+
+[ root ]
+pcmain.0   sound.o    tile.o     pctiles.0  pctiles.b
+vidvga.1   vidvga.0   vidvga.b   video.0   video.1   video.b
+hack.3     vidtxt.0   vidtxt.b   alloc.o   ovlinit.o
+
+[ ]
+allmain.0
+
+[ ]
+allmain.1
+
+[ ]
+allmain.b
+
+[ ]
+apply.0    
+
+[ ]
+apply.1    
+
+[ ]
+apply.b    
+
+[ ]
+artifact.0 
+
+[ ]
+artifact.1 
+
+[ ]
+artifact.b 
+
+[ ]
+attrib.0   
+
+[ ]
+attrib.1
+
+[ ]
+attrib.2   
+
+[ ]
+attrib.b   
+
+[ ]
+ball.o     
+
+[ ]
+bones.o    
+
+[ ]
+botl.0     
+
+[ ]
+botl.1     
+
+[ ]
+botl.b     
+
+[ ]
+cmd.0      
+
+[ ]
+cmd.1      
+
+[ ]
+cmd.b      
+
+[ ]
+dbridge.0  
+
+[ ]
+dbridge.1  
+
+[ ]
+dbridge.b  
+
+[ ]
+decl.o     
+
+[ ]
+detect.o
+
+[ ]
+dig.o
+
+[ ]
+display.o
+
+[ ]
+dlb.o
+
+[ ]
+do.0
+
+[ ]
+do.1
+
+[ ]
+do.2
+
+[ ]
+do.3
+
+[ ]
+do.b
+
+[ ]
+do_name.0  
+
+[ ]
+do_name.2  
+
+[ ]
+do_name.b  
+
+[ ]
+do_wear.0  
+
+[ ]
+do_wear.1  
+
+[ ]
+do_wear.2  
+
+[ ]
+do_wear.b  
+
+[ ]
+dog.1      
+
+[ ]
+dog.2
+
+[ ]
+dog.b
+
+[ ]
+dogmove.0
+
+[ ]
+dogmove.b
+
+[ ]
+dokick.o
+
+[ ]
+dothrow.o
+
+[ ]
+drawing.o
+
+[ ]
+dungeon.0
+
+[ ]
+dungeon.1
+
+[ ]
+eat.0      
+
+[ ]
+eat.1      
+
+[ ]
+eat.b      
+
+[ ]
+end.o      
+
+[ ]
+engrave.0  
+
+[ ]
+engrave.1  
+
+[ ]
+engrave.2
+
+[ ]
+engrave.b  
+
+[ ]
+exper.o    
+
+[ ]
+explode.0
+
+[ ]
+explode.1
+
+[ ]
+extralev.o 
+
+[ ]
+files.o    
+
+[ ]
+fountain.o 
+
+[ ]
+getline.1  
+
+[ ]
+getline.2  
+
+[ ]
+hack.1     
+
+[ ]
+hack.2     
+
+[ ]
+hack.b     
+
+[ ]
+hacklib.0
+
+[ ]
+hacklib.1
+
+[ ]
+hacklib.2
+
+[ ]
+hacklib.b
+
+[ ]
+invent.0
+
+[ ]
+invent.1
+
+[ ]
+invent.2
+
+[ ]
+invent.3
+
+[ ]
+invent.b   
+
+[ ]
+light.3
+
+[ ]
+lock.0     
+
+[ ]
+lock.b     mail.0     
+
+[ ]
+mail.b
+
+[ ]
+makemon.0
+
+[ ]
+makemon.1
+
+[ ]
+makemon.2
+
+[ ]
+makemon.b
+
+[ ]
+mcastu.0
+
+[ ]
+mcastu.b
+
+[ ]
+mhitm.0    
+
+[ ]
+mhitm.b    
+
+[ ]
+mhitu.0    
+
+[ ]
+mhitu.1    
+
+[ ]
+mhitu.b    
+
+[ ]
+minion.o   
+
+[ ]
+mklev.o    
+
+[ ]
+mkmap.o    
+
+[ ]
+mkmaze.o   
+
+[ ]
+mkobj.0    
+
+[ ]
+mkobj.1    
+
+[ ]
+mkobj.b    
+
+[ ]
+mkroom.0   
+
+[ ]
+mkroom.b
+
+[ ]
+mon.0
+
+[ ]
+mon.1      
+
+[ ]
+mon.2      
+
+[ ]
+mon.b      
+
+[ ]
+mondata.0  
+
+[ ]
+mondata.1  
+
+[ ]
+mondata.2  
+
+[ ]
+mondata.b  
+
+[ ]
+monmove.0  
+
+[ ]
+monmove.1  
+
+[ ]
+monmove.2  
+
+[ ]
+monmove.b  
+
+[ ]
+monst.o    
+
+[ ]
+monstr.o   
+
+[ ]
+mplayer.o
+
+[ ]
+msdos.0 pckeys.o
+
+[ ]
+msdos.b
+
+[ ]
+mthrowu.0  
+
+[ ]
+mthrowu.1  
+
+[ ]
+mthrowu.b  
+
+[ ]
+muse.o     
+
+[ ]
+music.o    
+
+[ ]
+o_init.o   
+
+[ ]
+objects.o  
+
+[ ]
+objnam.0   
+
+[ ]
+objnam.1   
+
+[ ]
+objnam.b   
+
+[ ]
+options.o  
+
+[ ]
+pager.o    
+
+[ ]
+pcmain.1 role.o
+
+[ ]
+pcmain.b
+
+[ ]
+pcunix.b
+
+[ ]
+pickup.o
+
+[ ]
+pline.b
+
+[ ]
+polyself.0
+
+[ ]
+polyself.1 
+
+[ ]
+polyself.b 
+
+[ ]
+potion.b   
+
+[ ]
+pray.o
+
+[ ]
+priest.0
+
+[ ]
+priest.b
+
+[ ]
+quest.o
+
+[ ]
+questpgr.o
+
+[ ]
+random.o
+
+[ ]
+read.b
+
+[ ]
+rect.o
+
+[ ]
+region.o
+
+[ ]
+restore.o
+
+[ ]
+rip.o
+
+[ ]
+rnd.0      
+
+[ ]
+rnd.1      
+
+[ ]
+rnd.b      
+
+[ ]
+rumors.o
+
+[ ]
+save.o
+
+[ ]
+shk.0
+
+[ ]
+shk.1
+
+[ ]
+shk.2
+
+[ ]
+shk.3
+
+[ ]
+shk.b
+
+[ ]
+shknam.0
+
+[ ]
+shknam.b
+
+[ ]
+sit.o
+
+[ ]
+sounds.0
+
+[ ]
+sounds.b
+
+[ ]
+sp_lev.o
+
+[ ]
+spell.o    
+
+[ ]
+steal.0    
+
+[ ]
+steal.1    
+
+[ ]
+steal.b
+
+[ ]
+steed.o worn.o
+
+[ ]
+sys.o      
+
+[ ]
+teleport.o
+
+[ ]
+termcap.0  
+
+[ ]
+termcap.1  
+
+[ ]
+termcap.b  
+
+[ ]
+timeout.0  
+
+[ ]
+timeout.1  
+
+[ ]
+timeout.b  
+
+[ ]
+topl.1
+
+[ ]
+topl.2
+
+[ ]
+topl.b
+
+[ ]
+topten.o
+
+[ ]
+track.0
+
+[ ]
+track.1
+
+[ ]
+track.b
+
+[ ]
+trap.0
+
+[ ]
+trap.1
+
+[ ]
+trap.2
+
+[ ]
+trap.3
+
+[ ]
+trap.b
+
+[ ]
+tty.o      
+
+[ ]
+u_init.o   
+
+[ ]
+uhitm.o    
+
+[ ]
+vault.0
+
+[ ]
+vault.b    
+
+[ ]
+version.o  
+
+[ ]
+vidvga.2
+
+[ ]
+vis_tab.o  
+
+[ ]
+vision.o   
+
+[ ]
+weapon.0   
+
+[ ]
+weapon.1   
+
+[ ]
+weapon.b   
+
+[ ]
+were.0
+
+[ ]
+were.b     
+
+[ ]
+wield.o    
+
+[ ]
+windows.o  
+
+[ ]
+wintty.o   
+
+[ ]
+wizard.0
+
+[ ]
+wizard.b   
+
+[ ]
+worm.o     
+
+[ ]
+write.o    
+
+[ ]
+zap.0      
+
+[ ]
+zap.1      
+
+[ ]
+zap.2      
+
+[ ]
+zap.3      
+
+[ ]
+zap.b
diff -Pru nethack-3.4.1/sys/msdos/schema3 nethack/sys/msdos/schema3
--- nethack-3.4.1/sys/msdos/schema3	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/schema3	Tue Apr 23 12:12:20 2002
@@ -0,0 +1,600 @@
+SCCS Id: @(#)schema3		3.3	 95/10/25
+Copyright (c) NetHack PC Development Team 1993, 1994, 1995
+#
+# NetHack Overlay Schema
+# Minimal extended memory available, lots of 640K base RAM free
+# This schema is for use with a patched moveinit.c (see Makefile
+# or Install.dos for information.
+#
+
+[ root ]
+pcmain.0   sound.o    tile.o     pctiles.0  pctiles.b
+vidvga.1   vidvga.0   vidvga.b   video.0   video.1   video.b
+hack.3     vidtxt.0   vidtxt.b	 botl.0    monmove.0 display.o
+dungeon.0  hacklib.0  wintty.o   trap.0    attrib.0  detect.o
+mon.0      cmd.0      vision.o   hack.1    msdos.0   
+random.o   rnd.0      alloc.o
+dbridge.0  monmove.1 engrave.0 invent.0 
+monmove.2  mondata.0
+hacklib.1  hacklib.2
+dogmove.b
+
+[ ]
+allmain.0  
+
+[ ]
+allmain.1  
+
+[ ]
+allmain.b  
+
+[ ]
+apply.0    
+
+[ ]
+apply.1    
+
+[ ]
+apply.b    
+
+[ ]
+artifact.0 
+
+[ ]
+artifact.1 
+
+[ ]
+artifact.b 
+
+[ ]
+attrib.1
+
+[ ]
+attrib.2   
+
+[ ]
+attrib.b   
+
+[ ]
+ball.o     
+
+[ ]
+bones.o    
+
+[ ]
+botl.1     
+
+[ ]
+botl.b     
+
+[ ]
+cmd.1      
+
+[ ]
+cmd.b      
+
+[ ]
+dbridge.1  
+
+[ ]
+dbridge.b  
+
+[ ]
+decl.o     
+
+[ ]
+dig.o
+
+[ ]
+dlb.o
+
+[ ]
+do.0
+
+[ ]
+do.1
+
+[ ]
+do.2
+
+[ ]
+do.3
+
+[ ]
+do.b
+
+[ ]
+do_name.0  
+
+[ ]
+do_name.2  
+
+[ ]
+do_name.b  
+
+[ ]
+do_wear.0  
+
+[ ]
+do_wear.1  
+
+[ ]
+do_wear.2  
+
+[ ]
+do_wear.b  
+
+[ ]
+dog.1      
+
+[ ]
+dog.2
+
+[ ]
+dog.b
+
+[ ]
+dogmove.0
+
+[ ]
+dokick.o
+
+[ ]
+dothrow.o
+
+[ ]
+drawing.o
+
+[ ]
+dungeon.1
+
+[ ]
+eat.0      
+
+[ ]
+eat.1      
+
+[ ]
+eat.b      
+
+[ ]
+end.o      
+
+[ ]
+engrave.1  
+
+[ ]
+engrave.2
+
+[ ]
+engrave.b  
+
+[ ]
+exper.o    
+
+[ ]
+explode.0
+
+[ ]
+explode.1
+
+[ ]
+extralev.o 
+
+[ ]
+files.o    
+
+[ ]
+fountain.o 
+
+[ ]
+getline.1  
+
+[ ]
+getline.2  
+
+[ ]
+hack.2     
+
+[ ]
+hack.b     
+
+[ ]
+hacklib.b
+
+[ ]
+invent.1
+
+[ ]
+invent.2
+
+[ ]
+invent.3
+
+[ ]
+invent.b   
+
+[ ]
+light.3
+
+[ ]
+lock.0     
+
+[ ]
+lock.b     mail.0     
+
+[ ]
+mail.b
+
+[ ]
+makemon.0
+
+[ ]
+makemon.1
+
+[ ]
+makemon.2
+
+[ ]
+makemon.b
+
+[ ]
+mcastu.0
+
+[ ]
+mcastu.b
+
+[ ]
+mhitm.0    
+
+[ ]
+mhitm.b    
+
+[ ]
+mhitu.0    
+
+[ ]
+mhitu.1    
+
+[ ]
+mhitu.b    
+
+[ ]
+minion.o   
+
+[ ]
+mklev.o    
+
+[ ]
+mkmap.o    
+
+[ ]
+mkmaze.o   
+
+[ ]
+mkobj.0    
+
+[ ]
+mkobj.1    
+
+[ ]
+mkobj.b    
+
+[ ]
+mkroom.0   
+
+[ ]
+mkroom.b
+
+[ ]
+mon.1      
+
+[ ]
+mon.2      
+
+[ ]
+mon.b      
+
+[ ]
+mondata.1  
+
+[ ]
+mondata.2  
+
+[ ]
+mondata.b  
+
+[ ]
+monmove.b  
+
+[ ]
+monst.o    
+
+[ ]
+monstr.o   
+
+[ ]
+mplayer.o
+
+[ ]
+msdos.b    
+
+[ ]
+mthrowu.0  
+
+[ ]
+mthrowu.1  
+
+[ ]
+mthrowu.b  
+
+[ ]
+muse.o     
+
+[ ]
+music.o    
+
+[ ]
+o_init.o   
+
+[ ]
+objects.o  
+
+[ ]
+objnam.0   
+
+[ ]
+objnam.1   
+
+[ ]
+objnam.b   
+
+[ ]
+options.o  
+
+[ ]
+pager.o    
+
+[ ]
+pcmain.1
+
+[ ]
+pcmain.b
+
+[ ]
+pcunix.b
+
+[ ]
+pickup.o
+
+[ ]
+pline.b
+
+[ ]
+polyself.0
+
+[ ]
+polyself.1 
+
+[ ]
+polyself.b 
+
+[ ]
+potion.b   
+
+[ ]
+pray.o
+
+[ ]
+priest.0
+
+[ ]
+priest.b
+
+[ ]
+quest.o
+
+[ ]
+questpgr.o
+
+[ ]
+read.b
+
+[ ]
+rect.o
+
+[ ]
+restore.o
+
+[ ]
+rip.o
+
+[ ]
+rnd.1      
+
+[ ]
+rnd.b      
+
+[ ]
+rumors.o
+
+[ ]
+save.o
+
+[ ]
+shk.0
+
+[ ]
+shk.1
+
+[ ]
+shk.2
+
+[ ]
+shk.3
+
+[ ]
+shk.b
+
+[ ]
+shknam.0
+
+[ ]
+shknam.b
+
+[ ]
+sit.o
+
+[ ]
+sounds.0
+
+[ ]
+sounds.b
+
+[ ]
+sp_lev.o
+
+[ ]
+spell.o    
+
+[ ]
+steal.0    
+
+[ ]
+steal.1    
+
+[ ]
+steal.b    
+
+[ ]
+sys.o      
+
+[ ]
+teleport.o
+
+[ ]
+termcap.0  
+
+[ ]
+termcap.1  
+
+[ ]
+termcap.b  
+
+[ ]
+timeout.0  
+
+[ ]
+timeout.1  
+
+[ ]
+timeout.b  
+
+[ ]
+topl.1
+
+[ ]
+topl.2
+
+[ ]
+topl.b
+
+[ ]
+topten.o
+
+[ ]
+track.0
+
+[ ]
+track.1
+
+[ ]
+track.b
+
+[ ]
+trap.1
+
+[ ]
+trap.2
+
+[ ]
+trap.3
+
+[ ]
+trap.b
+
+[ ]
+tty.o      
+
+[ ]
+u_init.o   
+
+[ ]
+uhitm.o    
+
+[ ]
+vault.0
+
+[ ]
+vault.b    
+
+[ ]
+version.o  
+
+[ ]
+vidvga.2
+
+[ ]
+vis_tab.o  
+
+[ ]
+weapon.0   
+
+[ ]
+weapon.1   
+
+[ ]
+weapon.b   
+
+[ ]
+were.0
+
+[ ]
+were.b     
+
+[ ]
+wield.o    
+
+[ ]
+windows.o  
+
+[ ]
+wizard.0   
+
+[ ]
+wizard.b   
+
+[ ]
+worm.o     
+
+[ ]
+worn.o     
+
+[ ]
+write.o    
+
+[ ]
+zap.0      
+
+[ ]
+zap.1      
+
+[ ]
+zap.2      
+
+[ ]
+zap.3      
+
+[ ]
+zap.b
+
diff -Pru nethack-3.4.1/sys/msdos/template.mak nethack/sys/msdos/template.mak
--- nethack-3.4.1/sys/msdos/template.mak	Wed Dec 31 16:00:00 1969
+++ nethack/sys/msdos/template.mak	Tue Apr 23 12:12:32 2002
@@ -0,0 +1,2232 @@
+# SCCS Id: @(#)template.mak	3.4	1996/10/25
+# Copyright (c) NetHack PC Development Team 1996
+#
+?BEGIN?
+?SCCS?
+?MSC?
+# PC NetHack 3.4 Makefile for Microsoft(tm) "C" >= 7.0 and MSVC >= 1.0
+?ENDMSC?
+?BC?
+# PC NetHack 3.4 Makefile for Borland C++ 3.1.
+?ENDBC?
+#
+# Nota Bene:	Before you get to here you should have already read
+# 		the Install.dos file located in the sys/msdos directory.
+?BC?
+#		Additionally, you should run this makefile with the -N
+#		Microsoft Compatibility option.
+#
+# This Makefile is for use with Borland C++ version 3.1.
+#
+# This Makefile is specific to Borland's MAKE which is supplied with the
+# compiler.  It supports only one overlay management facility - VROOMM.
+# (This Makefile won't work with make45l or NDMAKE)
+?ENDBC?
+?MSC?
+#
+# This Makefile is for use with Microsoft C version 7 and Microsoft Visual C++
+# Professional Edition (MSVC) version 1.0 or greater.
+#
+# This Makefile is specific to Microsoft's NMAKE which is supplied with the
+# more recent Microsoft C compilers.
+# It supports only one overlay management facility - MOVE.
+# (This Makefile won't work with make45l or NDMAKE)
+#
+#	In addition to your C compiler,
+#
+#	if you want to change		you will need a
+#	files with suffix		workalike for
+#	       .y			    yacc   (such as bison or byacc)
+#	       .l			    lex    (such as flex)
+?ENDMSC?
+
+#
+# Game Installation Variables.
+# NOTE: Make sure GAMEDIR exists before nmake is started.
+#
+
+GAME	= NetHack
+GAMEDIR = c:\games\nethack
+
+#
+#
+# Directories
+#
+
+DAT	= ..\dat
+DOC	= ..\doc
+INCL	= ..\include
+SRC	= ..\src
+OBJ	= o
+MSYS	= ..\sys\msdos
+SYS	= ..\sys\share
+UTIL	= ..\util
+WTTY	= ..\win\tty
+WSHR	= ..\win\share
+
+
+#
+# Compiler File Info.
+# ($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.)
+#
+
+?MSC?
+CC	 = cl		# Compiler
+LINK	 = link		# Linker
+ASM	 = masm		# Assembler (not currently needed for MSC 7 and > )
+MAKEBIN  = nmake
+UUDECODE = uudecode	# Unix style uudecoder
+?ENDMSC?
+?BC?
+CC	 = bcc		# Compiler
+LINK	 = tlink	# Linker
+ASM	 = tasm		# Assembler (not currently needed for BC)
+MAKEBIN  = make
+UUDECODE = uudecode	# Unix style uudecoder
+
+#BCTOP	 = c:\borlandc	# main Borland C++ directory
+BCTOP	 = c:\bc31
+?ENDBC?
+
+#
+# Yacc/Lex ... if you got 'em.
+#
+# If you have yacc and lex programs (or work-alike such as bison
+# and flex), comment out the upper two lines below, and uncomment
+# the lower two.
+?BC?
+#
+# On Borland C++, the newest versions of flex and bison provide
+# problems when run from MAKE.
+?ENDBC?
+#
+
+DO_YACC = YACC_MSG
+DO_LEX  = LEX_MSG
+#DO_YACC  = YACC_ACT
+#DO_LEX   = LEX_ACT
+
+#
+# - Specify your yacc and lex programs (or work-alikes for each) here.
+#
+
+YACC	= bison -y
+#YACC   = yacc
+#YACC   = byacc
+
+LEX     = flex
+#LEX    = lex
+
+#
+# - Specify your flex skeleton file (if needed).
+#
+FLEXSKEL =
+#FLEXSKEL = -Sc:\tools16\flex.ske
+
+#
+# - Your yacc (or work-alike) output files
+#
+YTABC	= y_tab.c
+YTABH	= y_tab.h
+#YTABC  = ytab.c
+#YTABH  = ytab.h
+
+#
+# - Your lex (or work-alike) output files
+#
+LEXYYC	= lexyy.c
+#LEXYYC	= lex.yy.c
+
+#
+# Optional high-quality BSD random number generation routines
+# (see pcconf.h). Set to nothing if not used.
+#
+
+RANDOM	= $(OBJ)\random.o
+#RANDOM	=
+
+#
+# If TERMLIB is #defined in the source (in include\pcconf.h),
+# comment out the upper line and uncomment the lower.  Make sure
+# that TERMLIB contains the full pathname to the termcap library.
+
+TERMLIB =
+#TERMLIB = $(SYS)\termcap.lib
+
+#
+# MEMORY USAGE AND OVERLAYING
+#
+# Overlay Schema 1
+#
+#   - Minimal extended memory available, lots of 640K base RAM free
+#     Minimize overlay turns. Requires that a minimum of
+?MSC?
+#     560K RAM be free as follows:
+#     430K  Executable load requirement
+#      60K  Overlay buffer
+#      70K  for malloc() calls
+#     560K  Total memory requirement
+?ENDMSC?
+?BC?
+#     607K RAM be free as follows:
+#     462K  Executable load requirement
+#     115K  for malloc() calls
+#      30K  Overlay buffer
+#     607K  Total memory requirement
+?ENDBC?
+#
+# Overlay Schema 2
+#
+#   - Favor small load size, requires extended memory for bearable performance.
+#     If you have very little base 640K RAM available, but lots of extended
+#     memory for caching overlays, you might try this. (eg. A machine with
+#     lots of TSR's or network drivers).  Do not try to set SCHEMA = 2
+#     without a disk cache and extended memory.
+?BC?
+#     381K  Executable load requirement
+#     115K  for malloc() calls
+#      30K  Overlay buffer
+#     526K  Total memory requirement
+?ENDBC?
+?MSC?
+#     360K  Executable load requirement
+#      60K  Overlay buffer
+#      70K  for malloc() calls
+#     419K  Total memory requirement
+#
+# Overlay Schema 3
+#
+#   - Minimal extended memory available, lots of 640K base RAM free
+#     Similar to schema1, but the overlay buffer is twice as large, so
+#     in theory more overlays can be resident at the same time. The cost is
+#     that the base memory requirement goes up considerably.
+#     This requires that you obtain the moveinit.c and moveapi.h files from
+#     your Microsoft C source/move directory, and place them into the src
+#     directory.  Then apply the patch moveinit.pat file found in sys/msdos.
+#     Requirements:
+#     360K  Executable load requirement
+#      95K  Overlay buffer
+#      70K  for malloc() calls
+#     525K  Total memory requirement
+?ENDMSC?
+#
+?BC?
+# On Borland C++, you have to make a full rebuild of all object modules each
+# time you change schemas.
+#
+?ENDBC?
+
+SCHEMA	= 1
+
+#
+# OPTIONAL TILE SUPPORT.
+#
+#	This release of NetHack allows you to build a version of NetHack
+#	that will draw 16x16 color tiles on the display to represent
+#	NetHack maps, objects, monsters, etc. on machines with appropriate
+#	display hardware.  Currently the only supported video hardware is
+#	VGA.
+#
+#	Note:  You can build NetHack with tile support and then choose
+#	whether to use it or not at runtime via the defaults.nh file option
+#	"video".
+#
+
+TILESUPPORT = Y
+
+#
+#  C COMPILER AND LINKER SETTINGS
+#
+#   For debugging ability, comment out the upper three
+#   macros and uncomment the lower three.  You can also
+#   uncomment only either LDFLAGSU or LDFLAGSN if you
+#   want to include debug information only in the utilities
+#   or only in the game file.
+?BC?
+
+#   On Borland C++, you cannot include debug information for
+#   all the object modules because the linker cannot handle
+#   it.
+?ENDBC?
+
+#CDFLAGS  =
+?MSC?
+#LDFLAGSN =
+?ENDMSC?
+?BC?
+LDFLAGSN  =
+?ENDBC?
+#LDFLAGSU =
+
+?MSC?
+CDFLAGS   = /Zi			# use debug info (compiler)
+LDFLAGSN  = /CO			# use debug info (linker - game)
+LDFLAGSU  = /CO			# use debug info (linker - utilities)
+?ENDMSC?
+?BC?
+CDFLAGS	  = -v -vi		# use debug info (compiler)
+#LDFLAGSN = /v			# use debug info (linker - game)
+LDFLAGSU  = /v			# use debug info (linker - utilities)
+?ENDBC?
+
+#
+?MSC?
+# - Force a change in the C warning level for all builds.
+#   (Its W0 setting in the CL environment variable will take
+#   precedence if left blank here).
+?ENDMSC?
+?BC?
+# - Don't warn about unreachable code because flex generates a whole bunch
+#   of unreachable code warnings, which stops the compile process.
+?ENDBC?
+#
+
+?MSC?
+CW =
+#CW =/W3
+?ENDMSC?
+?BC?
+CW = -w-rch
+?ENDBC?
+
+#
+#   Select whether to use pre-compiled headers or not.
+#   Set PRECOMPHEAD to Y to use pre-compiled headers, set it to anything
+#   else and pre-compiled headers will not be used.
+#   (Pre-compiled headers speed up compiles, but require a bit more
+#   disk space during the build.  The pre-compiled headers can be deleted
+#   afterwards via DEL *.PCH if desired).
+#
+
+PRECOMPHEAD = N
+
+#
+#   C Compiler Flags
+#
+?MSC?
+# Note:
+#
+#    CL environment variable should already be set to:
+#    CL= /AL /G2 /Oo /Gs /Gt16 /Zp1 /W0 /I..\include /nologo /DMOVERLAY
+#
+?ENDMSC?
+
+?MSC?
+CFLAGS = /c
+?ENDMSC?
+?BC?
+CFLAGS = -c
+?ENDBC?
+
+#  Uncomment the line below if you want to store all the level files,
+#  help files, etc. in a single library file (recommended).
+
+USE_DLB = Y
+
+#
+########################################################################
+########################################################################
+#
+#  Nothing below here should have to be changed.
+#
+########################################################################
+########################################################################
+#
+#  Warning:
+#
+#  Changing anything below here means that you should be *very*
+#  familiar with your compiler's workings, *very* knowledgeable
+#  about the overlay structure and mechanics of NetHack, and *very*
+#  confident in your understanding of Makefiles and Make utilities.
+#
+########################################################################
+#
+# Default Make Procedure
+#
+
+default: $(GAME)
+
+#
+########################################################################
+# Tile preparation
+#
+
+! IF ("$(TILESUPPORT)"=="Y")
+
+TILEGAME  = $(OBJ)\tile.o	$(OBJ)\pctiles.0	$(OBJ)\pctiles.b
+
+#
+#   -  VGA Tile Support, uncomment these three lines.
+#
+
+TILEVGA    = $(OBJ)\vidvga.0 $(OBJ)\vidvga.1 $(OBJ)\vidvga.2 $(OBJ)\vidvga.b
+PLANAR_TIB = NetHack1.tib
+OVERVIEW_TIB = NetHacko.tib
+
+#
+# Leave this line uncommented and unchanged.
+TILEUTIL  =  $(TILEGAME) $(TILEVGA) $(UTIL)\tile2bin.exe $(UTIL)\til2bin2.exe \
+		 $(PLANAR_TIB) $(OVERVIEW_TIB)
+
+! ENDIF
+
+! IF ("$(USE_DLB)"=="Y")
+DLB = nhdat
+! ELSE
+DLB =
+! ENDIF
+
+#
+#############################################################################
+#
+# General Overlay Schema Settings
+#
+
+?MSC?
+LNKOPT  = schema$(SCHEMA).def
+?ENDMSC?
+?BC?
+!include schema$(SCHEMA).bc
+OVLINIT =$(OBJ)\ovlinit.o
+?ENDBC?
+
+?MSC?
+#
+# - Specific Overlay Schema Settings
+#
+
+! IF ($(SCHEMA)==1)
+INTOVL = /DYNAMIC:1250 /NOE
+OVLINIT =
+! ENDIF
+
+! IF ($(SCHEMA)==2)
+INTOVL = /DYNAMIC:1380	/NOE
+OVLINIT =
+! ENDIF
+
+! IF ($(SCHEMA)==3)
+INTOVL = /DYNAMIC:1170
+OVLINIT = $(OBJ)\moveinit.o $(OBJ)\ovlinit.o
+! ENDIF
+?ENDMSC?
+
+#
+#############################################################################
+#
+# C Compiler and Linker Setup Options
+# (To Maintainer; modify only if absolutely necessary)
+#
+
+?BC?
+BCINCL	 = $(BCTOP)\include	# include directory for main BC headers
+BCLIB	 = $(BCTOP)\lib		# library directory for main BC libraries
+BCCFG	 = nethack.cfg		# name of the nethack configuration file
+?ENDBC?
+
+#
+# Model
+#
+
+?MSC?
+MODEL	 = L
+?ENDMSC?
+?BC?
+MODEL	 = h
+?ENDBC?
+
+#
+# - Optional C library specifier for those with non-standard
+#   libraries or a multiple-target library setup.
+#
+
+CLIB    =
+?MSC?
+#CLIB    = llibcer /nod
+?ENDMSC?
+
+?BC?
+#
+# Borland C++ libraries
+#
+
+BCOVL	= $(BCLIB)\OVERLAY
+BCMDL	= $(BCLIB)\C$(MODEL)
+
+?ENDBC?
+#
+# Compiler Options
+#
+
+?MSC?
+CNOLNK	= /c			# just generate .OBJ
+CPCHUSE	= /YuHACK.H		# use precompiled headers
+CPCHGEN	= /YcHACK.H		# generate precompiled headers
+CPCHNAM	= /Fp			# set the name of the precompiled header file
+CPCHEXT = .PCH			# precompiled header extension
+CDEFINE	= /D			# define a macro
+CCSNAM	= /NT			# set the code segment name
+COBJNAM	= /Fo			# name the .OBJ file
+CNOOPT  = /f- /Od		# disable optimizations (must be first in line)
+				# /f- = don't use the "fast" compiler,its buggy
+?ENDMSC?
+?MSCMACRO:CSNAMOA= ?
+?MSCMACRO:CSNAMOB=$(CCSNAM)$(@F) ?
+?MSCMACRO:CSNAM0=$(CCSNAM)$(@F) ?
+?MSCMACRO:CSNAM1=$(CCSNAM)$(@F) ?
+?MSCMACRO:CSNAM2=$(CCSNAM)$(@F) ?
+?MSCMACRO:CSNAM3=$(CCSNAM)$(@F) ?
+?MSCMACRO:CSNAMB=$(CCSNAM)$(@F) ?
+?BC?
+CNOLNK	= -c			# just generate .OBJ
+CPCHUSE	= -Hu			# use precompiled headers
+CPCHGEN	= -H			# generate precompiled headers
+CPCHNAM	= -H=			# set the name of the precompiled header file
+CPCHEXT = .PCH			# precompiled header extension
+CDEFINE	= -D			# define a macro
+CSTKSZ	= -DSTKSIZ=		# set stack size
+CCSNAM	= -zC			# set the code segment name
+COBJNAM	= -o			# name the .OBJ file
+?ENDBC?
+?BCMACRO:CSNAMOA=$$($(@B)_o) ?
+?BCMACRO:CSNAMOB=$$($(@B)_o) ?
+?BCMACRO:CSNAM0=$$($(@B)_0) ?
+?BCMACRO:CSNAM1=$$($(@B)_1) ?
+?BCMACRO:CSNAM2=$$($(@B)_2) ?
+?BCMACRO:CSNAM3=$$($(@B)_3) ?
+?BCMACRO:CSNAMB=$$($(@B)_b) ?
+
+#
+# Linker Options
+#
+
+?MSC?
+LWCASE	= /NOI			# treat case as significant
+LMAP	= /MAP			# create map file
+LSTKSZ	= /ST:			# set stack size
+LMAXSEG	= /SE:400		# maximum number of segments allowed
+LMAXALL	= /CPARM:1		# maximum program memory allocation (?)
+LINFO	= /INFO			# display link information while processing
+?ENDMSC?
+?BC?
+LWCASE	= /c			# treat case as significant
+LMAP	= /m			# create map file
+LINIT	= $(BCLIB)\C0$(MODEL)	# initialization object file
+LOVL	= /oOVLY		# overlay all needed segments
+?ENDBC?
+
+#
+# Stack Sizes
+#
+
+STKSUTL	= 4096			# Utilities Stack Size
+STKSNRM = 5120			# Normal Stack Size
+
+?MSC?
+LUSTACK	= $(LSTKSZ)$(STKSUTL)	# Utilities Stack Set for Linker
+LNSTACK	= $(LSTKSZ)$(STKSNRM)	# Normal Stack Set for Linker
+?ENDMSC?
+?BC?
+CUSTACK	= $(CSTKSZ)$(STKSUTL)	# Utilities Stack Set for Compiler
+CNSTACK	= $(CSTKSZ)$(STKSNRM)	# Normal Stack Set for Compiler
+?ENDBC?
+
+
+#
+########################################################################
+# DLB preparation
+#
+
+! IF ("$(USE_DLB)"=="Y")
+DLBFLG = $(CDEFINE)DLB
+! ELSE
+DLBFLG =
+! ENDIF
+
+#
+########################################################################
+# tile preparation
+#
+
+! IF ("$(TILESUPPORT)"=="Y")
+TILFLG = $(CDEFINE)USE_TILES
+! ELSE
+TILFLG =
+! ENDIF
+
+#############################################################################
+#
+# Overlay switches
+#
+
+COVL0	= $(CDEFINE)OVL0
+COVL1	= $(CDEFINE)OVL1
+COVL2	= $(CDEFINE)OVL2
+COVL3	= $(CDEFINE)OVL3
+COVLB	= $(CDEFINE)OVLB
+
+#
+# Flags
+#
+
+FLAGOPT = $(DLBFLG) $(TILFLG)
+
+#
+# Precompiled Header Section
+#
+
+?BC?
+#common options (placed in $(BCCFG))
+CFLGTOT = $(CDFLAGS) $(CFLAGS) $(FLAGOPT) $(CW)
+#util builds
+CFLAGSU	= +$(BCCFG) $(CUSTACK)
+#normal build, no PCH
+CFLAGSN = +$(BCCFG) $(CNSTACK)
+?ENDBC?
+?MSC?
+#util builds
+CFLAGSU	= $(CDFLAGS) $(CFLAGS) $(CW) $(FLAGOPT) $(CUSTACK)
+#normal build, no PCH
+CFLAGSN = $(CDFLAGS) $(CFLAGS) $(CW) $(FLAGOPT) $(CNSTACK)
+?ENDMSC?
+#no optimizations
+CFLAGNO = $(CNOOPT) $(CFLAGSN)
+
+! IF ("$(PRECOMPHEAD)"!="Y")
+
+CFLAGCO = $(COVLO)
+CFLAGUO = $(COVLO)
+CFLAGC0 = $(COVL0)
+CFLAGU0 = $(COVL0)
+CFLAGC1 = $(COVL1)
+CFLAGU1 = $(COVL1)
+CFLAGC2 = $(COVL2)
+CFLAGU2 = $(COVL2)
+CFLAGC3 = $(COVL3)
+CFLAGU3 = $(COVL3)
+CFLAGCB = $(COVLB)
+CFLAGUB = $(COVLB)
+PCHO =
+PCH0 =
+PCH1 =
+PCH2 =
+PCH3 =
+PCHB =
+
+precomp.msg:
+	@echo Not using precompiled headers...
+
+! ELSE
+
+# .o files
+CFLAGUO	= $(CPCHUSE) $(CPCHNAM)PHO$(CPCHEXT) $(COVLO)
+CFLAGCO	= $(CPCHGEN) $(CPCHNAM)PHO$(CPCHEXT) $(COVLO)
+PCHO = PHO$(CPCHEXT)
+# .0 files
+CFLAGU0	= $(CPCHUSE) $(CPCHNAM)PH0$(CPCHEXT) $(COVL0)
+CFLAGC0	= $(CPCHGEN) $(CPCHNAM)PH0$(CPCHEXT) $(COVL0)
+PCH0 = PH0$(CPCHEXT)
+# .1 files
+CFLAGU1	= $(CPCHUSE) $(CPCHNAM)PH1$(CPCHEXT) $(COVL1)
+CFLAGC1	= $(CPCHGEN) $(CPCHNAM)PH1$(CPCHEXT) $(COVL1)
+PCH1 = PH1$(CPCHEXT)
+# .2 files
+CFLAGU2	= $(CPCHUSE) $(CPCHNAM)PH2$(CPCHEXT) $(COVL2)
+CFLAGC2	= $(CPCHGEN) $(CPCHNAM)PH2$(CPCHEXT) $(COVL2)
+PCH2 = PH2$(CPCHEXT)
+# .3 files
+CFLAGU3	= $(CPCHUSE) $(CPCHNAM)PH3$(CPCHEXT) $(COVL3)
+CFLAGC3	= $(CPCHGEN) $(CPCHNAM)PH3$(CPCHEXT) $(COVL3)
+PCH3 = PH3$(CPCHEXT)
+# .B files
+CFLAGUB	= $(CPCHUSE) $(CPCHNAM)PHB$(CPCHEXT) $(COVLB)
+CFLAGCB	= $(CPCHGEN) $(CPCHNAM)PHB$(CPCHEXT) $(COVLB)
+PCHB = PHB$(CPCHEXT)
+
+precomp.msg:
+	@echo Using precompiled headers...
+
+! ENDIF
+
+
+?BC?
+FLAGCO  = $(CNSTACK) +CFLAGCO.CFG
+FLAGUO  = $(CNSTACK) +CFLAGUO.CFG
+FLAGC0  = $(CNSTACK) +CFLAGC0.CFG
+FLAGU0  = $(CNSTACK) +CFLAGU0.CFG
+FLAGC1  = $(CNSTACK) +CFLAGC1.CFG
+FLAGU1  = $(CNSTACK) +CFLAGU1.CFG
+FLAGC2  = $(CNSTACK) +CFLAGC2.CFG
+FLAGU2  = $(CNSTACK) +CFLAGU2.CFG
+FLAGC3  = $(CNSTACK) +CFLAGC3.CFG
+FLAGU3  = $(CNSTACK) +CFLAGU3.CFG
+FLAGCB  = $(CNSTACK) +CFLAGCB.CFG
+FLAGUB  = $(CNSTACK) +CFLAGUB.CFG
+?ENDBC?
+?MSC?
+FLAGCO  = $(CFLAGSN) $(CFLAGCO)
+FLAGUO  = $(CFLAGSN) $(CFLAGUO)
+FLAGC0  = $(CFLAGSN) $(CFLAGC0)
+FLAGU0  = $(CFLAGSN) $(CFLAGU0)
+FLAGC1  = $(CFLAGSN) $(CFLAGC1)
+FLAGU1  = $(CFLAGSN) $(CFLAGU1)
+FLAGC2  = $(CFLAGSN) $(CFLAGC2)
+FLAGU2  = $(CFLAGSN) $(CFLAGU2)
+FLAGC3  = $(CFLAGSN) $(CFLAGC3)
+FLAGU3  = $(CFLAGSN) $(CFLAGU3)
+FLAGCB  = $(CFLAGSN) $(CFLAGCB)
+FLAGUB  = $(CFLAGSN) $(CFLAGUB)
+?ENDMSC?
+
+# End of Pre-compiled header section
+#===========================================================================
+
+?MSC?
+#
+# Controls whether MOVE tracing is enabled in the executable
+# This should be left commented unless you are tinkering with the
+# overlay structure of NetHack.  The executable runs _very_
+# slowly when the movetr.lib is linked in.
+#
+
+#MOVETR= movetr.lib
+
+# do not change this
+! IF ("$(MOVETR)"!="")
+MVTRCL = $(CDEFINE)MOVE_PROF
+! ELSE
+MVTRCL =
+! ENDIF
+
+?ENDMSC?
+#
+# Linker options for building various things.
+#
+
+LFLAGSU	= $(LDFLAGSU) $(LUSTACK) $(LINIT)
+LFLAGSN	= $(LDFLAGSN) $(LNSTACK) $(LWCASE) $(LMAXSEG) $(INTOVL) $(LMAXALL) \
+	  $(LINFO) $(LINIT) $(LOVL)
+
+#
+# Make Roolz dude.
+# Due to the inadequacy of some makes these must accord with a
+# topological sort of the generated-from relation... output on
+# the left, input on the right. Trust me.
+#
+
+.SUFFIXES:  .exe .0 .1 .2 .3 .B .o .til .uu .c .y .l
+
+#
+# Rules for files in src
+#
+
+
+.c{$(OBJ)}.o:
+	@$(CC) $(FLAGUO) ?[CSNAMOB]$(COBJNAM)$@ $<
+
+{$(SRC)}.c{$(OBJ)}.o:
+	$(CC) $(FLAGUO) ?[CSNAMOB]$(COBJNAM)$@  $<
+
+{$(SRC)}.c{$(OBJ)}.0:
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $<
+
+{$(SRC)}.c{$(OBJ)}.1:
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $<
+
+{$(SRC)}.c{$(OBJ)}.2:
+	$(CC) $(FLAGU2) ?[CSNAM2]$(COBJNAM)$@ $<
+
+{$(SRC)}.c{$(OBJ)}.3:
+	$(CC) $(FLAGU3) ?[CSNAM3]$(COBJNAM)$@ $<
+
+{$(SRC)}.c{$(OBJ)}.B:
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $<
+
+#
+# Rules for files in sys\share
+#
+
+{$(SYS)}.c{$(OBJ)}.o:
+	$(CC) $(FLAGUO) ?[CSNAMOA]$(COBJNAM)$@  $<
+
+{$(SYS)}.c{$(OBJ)}.0:
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $<
+
+{$(SYS)}.c{$(OBJ)}.1:
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $<
+
+{$(SYS)}.c{$(OBJ)}.2:
+	$(CC) $(FLAGU2) ?[CSNAM2]$(COBJNAM)$@ $<
+
+{$(SYS)}.c{$(OBJ)}.3:
+	$(CC) $(FLAGU3) ?[CSNAM3]$(COBJNAM)$@ $<
+
+{$(SYS)}.c{$(OBJ)}.B:
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $<
+
+#
+# Rules for files in sys\msdos
+#
+
+{$(MSYS)}.c{$(OBJ)}.o:
+	$(CC) $(FLAGUO) ?[CSNAMOA]$(COBJNAM)$@  $<
+
+{$(MSYS)}.c{$(OBJ)}.0:
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $<
+
+{$(MSYS)}.c{$(OBJ)}.1:
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $<
+
+{$(MSYS)}.c{$(OBJ)}.2:
+	$(CC) $(FLAGU2) ?[CSNAM2]$(COBJNAM)$@ $<
+
+{$(MSYS)}.c{$(OBJ)}.3:
+	$(CC) $(FLAGU3) ?[CSNAM3]$(COBJNAM)$@ $<
+
+{$(MSYS)}.c{$(OBJ)}.B:
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $<
+
+{$(MSYS)}.h{$(INCL)}.h:
+	@copy $< $@
+
+#
+# Rules for files in util
+#
+
+{$(UTIL)}.c{$(OBJ)}.o:
+	$(CC) $(CFLAGSU) ?[CSNAMOB]$(COBJNAM)$@  $<
+
+#
+# Rules for files in win\share
+#
+
+{$(WSHR)}.c.o:
+	@$(CC) $(FLAGUO) ?[CSNAMOA]$(COBJNAM)$@ $<
+
+{$(WSHR)}.c{$(OBJ)}.o:
+	@$(CC) $(FLAGUO) ?[CSNAMOA]$(COBJNAM)$@ $<
+
+{$(WSHR)}.h{$(INCL)}.h:
+	@copy $< $@
+
+{$(WSHR)}.txt{$(DAT)}.txt:
+	@copy $< $@
+
+#
+# Rules for files in win\tty
+#
+
+{$(WTTY)}.c{$(OBJ)}.o:
+	$(CC) $(FLAGUO) ?[CSNAMOA]$(COBJNAM)$@  $<
+
+{$(WTTY)}.c{$(OBJ)}.0:
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $<
+
+{$(WTTY)}.c{$(OBJ)}.1:
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $<
+
+{$(WTTY)}.c{$(OBJ)}.2:
+	$(CC) $(FLAGU2) ?[CSNAM2]$(COBJNAM)$@ $<
+
+{$(WTTY)}.c{$(OBJ)}.3:
+	$(CC) $(FLAGU3) ?[CSNAM3]$(COBJNAM)$@ $<
+
+{$(WTTY)}.c{$(OBJ)}.B:
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $<
+
+#
+# NETHACK OBJECTS
+#
+# This section creates shorthand macros for many objects
+# referenced later on in the Makefile.
+#
+
+#
+# Shorten up the location for some files
+#
+
+O  = $(OBJ)\				# comment so \ isn't last char
+
+U  = $(UTIL)\				# comment so \ isn't last char
+
+#
+# Utility Objects.
+#
+
+MAKESRC        = $(U)makedefs.c
+
+SPLEVSRC       = $(U)lev_yacc.c	$(U)lev_$(LEX).c $(U)lev_main.c  $(U)panic.c
+
+DGNCOMPSRC     = $(U)dgn_yacc.c	$(U)dgn_$(LEX).c $(U)dgn_main.c
+
+MAKEOBJS       = $(O)makedefs.o	$(O)monst.o	$(O)objects.o
+
+?LIST:SPLEVOBJS?
+		 $(O)lev_yacc.o	$(O)lev_$(LEX).o $(O)lev_main.o
+		 $(O)alloc.o	$(O)decl.o	$(O)drawing.o
+		 $(O)monst.o	$(O)objects.o	$(O)panic.o	$(O)stubvid.o
+?ENDLIST?
+
+?LIST:DGNCOMPOBJS?
+		 $(O)dgn_yacc.o	$(O)dgn_$(LEX).o $(O)dgn_main.o
+		 $(O)alloc.o	$(O)panic.o
+?ENDLIST?
+
+RECOVOBJS      = $(O)recover.o
+
+?LIST:GIFREADERS?
+		 $(O)gifread.o	$(O)alloc.o	$(O)panic.o
+?ENDLIST?
+
+?LIST:TEXT_IO?
+		 $(O)tiletext.o $(O)tiletxt.o	$(O)drawing.o
+		 $(O)decl.o	$(O)monst.o	$(O)objects.o
+		 $(O)stubvid.o
+?ENDLIST?
+
+PPMWRITERS     = $(O)ppmwrite.o	$(O)alloc.o	$(O)panic.o
+
+?LIST:GIFREAD2?
+		 $(O)gifread2.o	$(O)alloc.o	$(O)panic.o
+?ENDLIST?
+
+?LIST:TEXT_IO2?
+		 $(O)tiletex2.o $(O)tiletxt2.o	$(O)drawing.o
+		 $(O)decl.o	$(O)monst.o	$(O)objects.o
+		 $(O)stubvid.o
+?ENDLIST?
+
+PPMWRIT2       = $(O)ppmwrit2.o $(O)alloc.o	$(O)panic.o
+
+TILEFILES      = $(WSHR)\monsters.txt $(WSHR)\objects.txt $(WSHR)\other.txt
+
+TILEFILES2     = $(WSHR)\monthin.txt $(WSHR)\objthin.txt $(WSHR)\oththin.txt
+
+DLBOBJS        = $(O)dlb_main.o $(O)dlb.o $(O)alloc.o $(O)panic.o
+
+#
+#  Object files for the game itself.
+#
+
+OBJ01 =	$(O)alloc.o	$(RANDOM)	$(O)decl.o     	$(O)objects.o	\
+	$(O)muse.o	$(O)display.o	$(O)vision.o	\
+	$(O)rect.o	$(O)vis_tab.o	$(O)monst.o	$(O)wintty.o	\
+	$(O)files.o	$(O)sys.o	$(O)monstr.o	$(O)minion.o	\
+	$(O)worm.o	$(O)detect.o 	$(O)exper.o	$(O)mplayer.o	\
+	$(O)uhitm.o	$(O)pager.o 	$(O)windows.o	$(O)quest.o	\
+	$(O)questpgr.o 	$(O)write.o	$(O)drawing.o	$(O)dokick.o	\
+	$(O)dothrow.o 	$(O)pickup.o	$(O)pray.o	$(O)spell.o 	\
+	$(O)ball.o	$(O)wield.o	$(O)worn.o	$(O)fountain.o	\
+	$(O)music.o	$(O)rumors.o	$(O)dlb.o	$(O)sit.o 	\
+	$(O)bones.o	$(O)mklev.o	$(O)save.o	$(O)restore.o 	\
+	$(O)mkmaze.o	$(O)mkmap.o	$(O)end.o	$(O)o_init.o	\
+	$(O)options.o	$(O)rip.o       $(O)sound.o	$(O)teleport.o	\
+	$(O)topten.o	$(O)tty.o	$(O)u_init.o	$(O)extralev.o 	\
+	$(O)sp_lev.o	$(O)dig.o	$(O)pckeys.o	$(O)role.o	\
+	$(O)steed.o	$(O)region.o
+
+OVL0 =	$(O)allmain.0	$(O)apply.0	$(O)artifact.0	$(O)attrib.0  \
+	$(O)botl.0	$(O)cmd.0	$(O)dbridge.0	$(O)do.0      \
+	$(O)do_name.0	$(O)do_wear.0	$(O)dogmove.0	$(O)dungeon.0 \
+	$(O)eat.0	$(O)engrave.0	$(O)hacklib.0	$(O)invent.0  \
+	$(O)lock.0	$(O)pcmain.0	$(O)mail.0	$(O)makemon.0 \
+	$(O)mcastu.0	$(O)mhitm.0	$(O)mhitu.0	$(O)mkobj.0   \
+	$(O)mkroom.0	$(O)mon.0	$(O)mondata.0	$(O)monmove.0 \
+	$(O)mthrowu.0	$(O)objnam.0	$(O)polyself.0	$(O)priest.0  \
+	$(O)rnd.0	$(O)shknam.0	$(O)sounds.0	$(O)steal.0   \
+	$(O)timeout.0	$(O)track.0	$(O)trap.0	$(O)vault.0   \
+	$(O)weapon.0	$(O)were.0	$(O)wizard.0	$(O)msdos.0   \
+	$(O)termcap.0	$(O)video.0	$(O)vidtxt.0	$(O)zap.0     \
+	$(O)explode.0	$(O)shk.0
+
+OVL1 =	$(O)allmain.1	$(O)apply.1	$(O)artifact.1	$(O)attrib.1 \
+	$(O)botl.1	$(O)cmd.1	$(O)dbridge.1	$(O)do.1     \
+	$(O)do_wear.1	$(O)dog.1	$(O)dungeon.1	$(O)eat.1    \
+	$(O)engrave.1	$(O)hack.1	$(O)hacklib.1	$(O)invent.1 \
+	$(O)makemon.1	$(O)mhitu.1	$(O)mkobj.1	$(O)mon.1    \
+	$(O)mondata.1	$(O)monmove.1	$(O)mthrowu.1	$(O)objnam.1 \
+	$(O)pcmain.1	$(O)polyself.1	$(O)rnd.1	$(O)shk.1    \
+	$(O)steal.1	$(O)timeout.1	$(O)track.1	$(O)trap.1   \
+	$(O)weapon.1	$(O)getline.1	$(O)termcap.1	$(O)topl.1   \
+	$(O)video.1	$(O)zap.1	$(O)explode.1
+
+OVL2 =	$(O)attrib.2	$(O)do.2	$(O)do_name.2	$(O)do_wear.2 \
+	$(O)dog.2	$(O)engrave.2	$(O)hack.2	$(O)hacklib.2 \
+	$(O)invent.2	$(O)makemon.2	$(O)mon.2	$(O)mondata.2 \
+	$(O)monmove.2	$(O)getline.2	$(O)shk.2	$(O)topl.2    \
+	$(O)trap.2	$(O)zap.2
+
+OVL3 =	$(O)do.3	$(O)hack.3	$(O)invent.3	$(O)light.3   \
+	$(O)shk.3	$(O)trap.3	$(O)zap.3
+
+
+OVLB =	$(O)allmain.B	$(O)apply.B	$(O)artifact.B	$(O)attrib.B	\
+	$(O)botl.B	$(O)cmd.B	$(O)dbridge.B	$(O)do.B	\
+	$(O)do_name.B	$(O)do_wear.B	$(O)dog.B	$(O)dogmove.B	\
+	$(O)eat.B	$(O)engrave.B	$(O)hack.B	$(O)hacklib.B	\
+	$(O)invent.B	$(O)lock.B	$(O)mail.B	$(O)makemon.B	\
+	$(O)mcastu.B	$(O)mhitm.B	$(O)mhitu.B	$(O)mkobj.B	\
+	$(O)mkroom.B	$(O)mon.B	$(O)mondata.B	$(O)monmove.B	\
+	$(O)mthrowu.B	$(O)objnam.B	$(O)pcmain.B	$(O)pline.B	\
+	$(O)polyself.B	$(O)potion.B	$(O)priest.B	$(O)read.B	\
+	$(O)rnd.B	$(O)shk.B	$(O)shknam.B	$(O)sounds.B	\
+	$(O)steal.B	$(O)timeout.B	$(O)track.B	$(O)trap.B	\
+	$(O)vault.B	$(O)weapon.B	$(O)were.B	$(O)wizard.B	\
+	$(O)msdos.B	$(O)pcunix.B	$(O)termcap.B	$(O)topl.B	\
+	$(O)video.B	$(O)vidtxt.B	$(O)zap.B
+
+TILOBJ = $(TILEGAME) $(TILEVGA)
+
+VVOBJ =	$(O)version.o
+
+NVOBJ = $(OBJ01)	$(OVL0)		$(OVL1)		$(OVL2) \
+	$(OVL3) 	$(OVLB)		$(TILOBJ)
+
+ALLOBJ= $(NVOBJ) $(VVOBJ) $(OVLINIT)
+
+#
+# Header objects
+#
+
+# This comment copied from sys/unix/Makefile.src,
+# extern.h is ignored, even though its declared function types may affect the
+# compilation of all the .c files, since extern.h changes every time the
+# type of an external function does, and we would spend all our time recompiling
+# if we did not ignore it.
+#EXTERN_H    = $(INCL)\extern.h
+EXTERN_H    =
+PCCONF_H    = $(INCL)\pcconf.h $(INCL)\micro.h $(INCL)\system.h
+PERMONST_H  = $(INCL)\monattk.h $(INCL)\monflag.h $(INCL)\align.h
+YOUPROP_H   = $(INCL)\prop.h $(PERMONST_H) $(INCL)\pm.h $(INCL)\youprop.h \
+	      $(INCL)\mondata.h
+YOU_H	    = $(INCL)\attrib.h $(INCL)\monst.h $(YOUPROP_H) $(INCL)\align.h
+DECL_H      = $(INCL)\quest.h $(INCL)\spell.h $(INCL)\color.h \
+	      $(INCL)\obj.h $(YOU_H) $(INCL)\onames.h $(INCL)\pm.h
+
+CONFIG_H    = $(INCL)\tradstdc.h $(INCL)\coord.h $(PCCONF_H) $(INCL)\config.h
+HACK_H      = $(CONFIG_H) $(INCL)\dungeon.h $(INCL)\align.h $(INCL)\monsym.h \
+              $(INCL)\mkroom.h $(INCL)\objclass.h $(DECL_H) \
+	      $(INCL)\timeout.h $(INCL)\trap.h $(INCL)\flag.h $(INCL)\rm.h \
+	      $(INCL)\vision.h $(INCL)\mondata.h $(INCL)\wintype.h \
+	      $(INCL)\engrave.h $(INCL)\rect.h $(EXTERN_H) \
+	      $(INCL)\winprocs.h $(INCL)\trampoli.h $(INCL)\display.h
+TILE_H      = $(INCL)\tile.h $(INCL)\pctiles.h
+PCVIDEO_H   = $(INCL)\portio.h $(INCL)\pcvideo.h
+ALIGN_H     = $(INCL)\align.h
+ARTIFACT_H  = $(INCL)\artifact.h
+ARTILIST_H  = $(INCL)\artilist.h
+COLOR_H     = $(INCL)\color.h
+DATE_H      = $(INCL)\date.h
+DGN_FILE_H  = $(INCL)\dgn_file.h
+DLB_H	    = $(INCL)\dlb.h
+EMIN_H      = $(INCL)\emin.h
+EPRI_H      = $(INCL)\epri.h
+ESHK_H      = $(INCL)\eshk.h
+EDOG_H      = $(INCL)\edog.h
+FUNC_TAB_H  = $(INCL)\func_tab.h
+LEV_H       = $(INCL)\lev.h
+LEV_COMP_H  = $(INCL)\lev_comp.h
+MAIL_H      = $(INCL)\mail.h
+MFNDPOS_H   = $(INCL)\mfndpos.h
+MONSYM_H    = $(INCL)\monsym.h
+OBJ_H       = $(INCL)\obj.h
+OBJCLASS_H  = $(INCL)\objclass.h
+OBJECTS_H   = $(INCL)\objects.h
+PROP_H      = $(INCL)\prop.h
+QTEXT_H     = $(INCL)\qtext.h
+QUEST_H     = $(INCL)\quest.h
+SP_LEV_H    = $(INCL)\sp_lev.h
+TERMCAP_H   = $(INCL)\tcap.h
+VAULT_H     = $(INCL)\vault.h
+VIS_TAB_H   = $(INCL)\vis_tab.h
+WINTTY_H    = $(INCL)\wintty.h
+
+#
+# In the unix distribution this file is patchlevel.h, make it 8.3 here
+# to avoid an nmake warning under dos.
+#
+
+PATCHLEVEL_H   = $(INCL)\patchlev.h
+
+
+#
+#  The name of the game.
+#
+
+GAMEFILE = $(GAMEDIR)\$(GAME).exe
+
+#
+# make data.base an 8.3 filename to prevent an nmake warning
+#
+
+DATABASE = $(DAT)\data.bas
+
+#######################################################################
+#
+#  TARGETS
+
+#
+#  The main target.
+#
+
+$(GAME): obj.tag envchk $(U)utility.tag $(GAMEFILE)
+	@echo $(GAME) is up to date.
+
+#
+#  Everything
+#
+
+all :	install
+
+install: $(GAME) install.tag
+	@echo Done.
+
+
+install.tag: 	$(DAT)\data	$(DAT)\rumors	$(DAT)\dungeon \
+	 	$(DAT)\oracles	$(DAT)\quest.dat $(DAT)\sp_lev.tag $(DLB)
+! IF ("$(USE_DLB)"=="Y")
+	copy nhdat                $(GAMEDIR)
+	copy $(DAT)\license       $(GAMEDIR)
+! ELSE
+	copy $(DAT)\*.            $(GAMEDIR)
+	copy $(DAT)\*.dat         $(GAMEDIR)
+	copy $(DAT)\*.lev         $(GAMEDIR)
+	copy $(MSYS)\msdoshlp.txt $(GAMEDIR)
+	if exist $(GAMEDIR)\makefile del $(GAMEDIR)\makefile
+! ENDIF
+	copy $(SYS)\termcap       $(GAMEDIR)
+	if exist $(DOC)\guideb*.txt copy $(DOC)\guideb*.txt  $(GAMEDIR)
+	if exist $(DOC)\nethack.txt copy $(DOC)\nethack.txt  $(GAMEDIR)\NetHack.txt
+	if exist $(DOC)\recover.txt copy $(DOC)\recover.txt  $(GAMEDIR)
+	copy $(SYS)\nethack.cnf   $(GAMEDIR)\defaults.nh
+	copy $(U)recover.exe  $(GAMEDIR)
+	if exist *.tib copy *.tib $(GAMEDIR)
+	echo install done > $@
+
+$(DAT)\sp_lev.tag: $(U)utility.tag $(DAT)\bigroom.des  $(DAT)\castle.des \
+	$(DAT)\endgame.des $(DAT)\gehennom.des $(DAT)\knox.des   \
+	$(DAT)\medusa.des  $(DAT)\oracle.des   $(DAT)\tower.des  \
+	$(DAT)\yendor.des  $(DAT)\arch.des     $(DAT)\barb.des   \
+	$(DAT)\caveman.des $(DAT)\elf.des      $(DAT)\healer.des \
+	$(DAT)\knight.des  $(DAT)\priest.des   $(DAT)\rogue.des  \
+	$(DAT)\samurai.des $(DAT)\tourist.des  $(DAT)\valkyrie.des \
+	$(DAT)\wizard.des
+	cd $(DAT)
+	$(U)lev_comp bigroom.des
+	$(U)lev_comp castle.des
+	$(U)lev_comp endgame.des
+	$(U)lev_comp gehennom.des
+	$(U)lev_comp knox.des
+	$(U)lev_comp mines.des
+	$(U)lev_comp medusa.des
+	$(U)lev_comp oracle.des
+	$(U)lev_comp tower.des
+	$(U)lev_comp yendor.des
+	$(U)lev_comp arch.des
+	$(U)lev_comp barb.des
+	$(U)lev_comp caveman.des
+	$(U)lev_comp elf.des
+	$(U)lev_comp healer.des
+	$(U)lev_comp knight.des
+	$(U)lev_comp priest.des
+	$(U)lev_comp rogue.des
+	$(U)lev_comp samurai.des
+	$(U)lev_comp tourist.des
+	$(U)lev_comp valkyrie.des
+	$(U)lev_comp wizard.des
+	cd $(SRC)
+	echo sp_levs done > $(DAT)\sp_lev.tag
+
+$(U)utility.tag: envchk			$(INCL)\date.h	$(INCL)\onames.h \
+		$(INCL)\pm.h 		$(SRC)\monstr.c	$(SRC)\vis_tab.c \
+		$(U)lev_comp.exe	$(VIS_TAB_H) 	$(U)dgn_comp.exe \
+		$(U)recover.exe		$(TILEUTIL)
+             @echo utilities made >$@
+	     @echo utilities made.
+
+tileutil: $(U)gif2txt.exe $(U)txt2ppm.exe
+	@echo Optional tile development utilities are up to date.
+
+?MSC?
+#  The section for linking the NetHack image looks a little strange at
+#  first, especially if you are used to UNIX makes, or NDMAKE.  It is
+#  Microsoft nmake specific, and it gets around the problem of the link
+#  command line being too long for the linker.  An "in-line" linker
+#  response file is generated temporarily.
+#
+#  It takes advantage of the following features of nmake:
+?ENDMSC?
+#
+#  Inline files :
+#			Specifying the "<<" means to start an inline file.
+#                 	Another "<<" at the start of a line closes the
+#                 	inline file.
+#
+?MSC?
+#  Substitution within Macros:
+#                       $(mymacro:string1=string2) replaces every
+#                       occurrence of string1 with string2 in the
+#                       macro mymacro.  Special ascii key codes may be
+#                       used in the substitution text by preceding it
+#                       with ^ as we have done below.  Every occurrence
+#                       of a <tab> in $(ALLOBJ) is replaced by
+#                       <+><return><tab>.
+#
+?ENDMSC?
+#  DO NOT INDENT THE << below!
+#
+
+?MSC?
+$(GAMEFILE) :  $(LNKOPT) $(ALLOBJ)
+?ENDMSC?
+?BC?
+$(GAMEFILE) :  $(ALLOBJ)
+?ENDBC?
+	@echo Linking....
+	$(LINK) $(LFLAGSN) @<<$(GAME).lnk
+?BC?
+		$(ALLOBJ)
+?ENDBC?
+?MSC?
+		$(ALLOBJ:^	=+^
+		)
+?ENDMSC?
+		$(GAMEFILE)
+		$(GAME)
+		$(TERMLIB) $(MOVETR) $(CLIB) $(BCOVL) $(BCMDL)
+?MSC?
+		$(LNKOPT);
+?ENDMSC?
+<<
+	@if exist $(GAMEDIR)\$(GAME).bak del $(GAMEDIR)\$(GAME).bak
+
+#
+# Makedefs Stuff
+#
+
+$(U)makedefs.exe:	$(MAKEOBJS)
+	@$(LINK) $(LFLAGSU) $(MAKEOBJS), $@,, $(CLIB) $(BCMDL);
+
+$(O)makedefs.o: $(CONFIG_H)	    $(PERMONST_H)      $(OBJCLASS_H) \
+		 $(MONSYM_H)    $(QTEXT_H)	$(PATCHLEVEL_H) \
+		 $(U)makedefs.c
+	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)makedefs.c
+
+#
+#  date.h should be remade every time any of the source or include
+#  files is modified.
+#
+
+$(INCL)\date.h : $(U)makedefs.exe
+	$(U)makedefs -v
+	@echo A new $@ has been created.
+
+$(INCL)\onames.h : $(U)makedefs.exe
+	$(U)makedefs -o
+
+$(INCL)\pm.h : $(U)makedefs.exe
+	$(U)makedefs -p
+
+#$(INCL)\trap.h : $(U)makedefs.exe
+#	$(U)makedefs -t
+
+$(SRC)\monstr.c: $(U)makedefs.exe
+	$(U)makedefs -m
+
+$(INCL)\vis_tab.h: $(U)makedefs.exe
+	$(U)makedefs -z
+
+$(SRC)\vis_tab.c: $(U)makedefs.exe
+	$(U)makedefs -z
+
+#
+# Level Compiler Stuff
+#
+
+$(U)lev_comp.exe:  $(SPLEVOBJS)
+	@echo Linking $@...
+?MSC?
+	$(LINK) $(LFLAGSU) @<<$(@B).lnk
+?ENDMSC?
+?BC?
+	$(LINK) $(LFLAGSU) @&&!
+?ENDBC?
+?LINKLIST:SPLEVOBJS?
+		$@
+		$(@B)
+		$(BCMDL);
+?MSC?
+<<
+?ENDMSC?
+?BC?
+!
+?ENDBC?
+
+$(O)lev_yacc.o:  $(HACK_H)   $(SP_LEV_H) $(INCL)\lev_comp.h $(U)lev_yacc.c
+	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)lev_yacc.c
+
+$(O)lev_$(LEX).o:  $(HACK_H)   $(INCL)\lev_comp.h $(SP_LEV_H) \
+	$(U)lev_$(LEX).c
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)lev_$(LEX).c
+
+$(O)lev_main.o:	$(U)lev_main.c $(HACK_H)   $(SP_LEV_H)
+	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)lev_main.c
+
+$(U)lev_yacc.c $(INCL)\lev_comp.h : $(U)lev_comp.y
+!	IF "$(DO_YACC)"=="YACC_ACT"
+	   $(YACC) -d -l $(U)lev_comp.y
+	   copy $(YTABC) $(U)lev_yacc.c
+	   copy $(YTABH) $(INCL)\lev_comp.h
+	   @del $(YTABC)
+	   @del $(YTABH)
+!	ELSE
+	   @echo.
+	   @echo $(U)lev_comp.y has changed.
+	   @echo To update $(U)lev_yacc.c and $(INCL)\lev_comp.h run $(YACC).
+	   @echo.
+	   @echo For now, we will copy the prebuilt lev_yacc.c
+	   @echo from $(SYS) to $(U)lev_yacc.c, and copy the prebuilt
+	   @echo lev_comp.h from $(SYS) to $(UTIL)\lev_comp.h
+	   @echo and use those.
+	   @echo.
+	   copy $(SYS)\lev_yacc.c $@ >nul
+	   touch $@
+	   copy $(SYS)\lev_comp.h $(INCL)\lev_comp.h >nul
+	   touch $(INCL)\lev_comp.h
+!	ENDIF
+
+$(U)lev_$(LEX).c:  $(U)lev_comp.l
+!	IF "$(DO_LEX)"=="LEX_ACT"
+	   $(LEX) $(FLEXSKEL) $(U)lev_comp.l
+	   copy $(LEXYYC) $@
+	   @del $(LEXYYC)
+!	ELSE
+	   @echo.
+	   @echo $(U)lev_comp.l has changed. To update $@ run $(LEX).
+	   @echo.
+	   @echo For now, we will copy a prebuilt lev_lex.c
+	   @echo from $(SYS) to $@ and use it.
+	   @echo.
+	   copy $(SYS)\lev_lex.c $@ >nul
+	   touch $@
+!	ENDIF
+
+#
+# Dungeon Stuff
+#
+
+$(U)dgn_comp.exe: $(DGNCOMPOBJS)
+    @echo Linking $@...
+?MSC?
+	$(LINK) $(LFLAGSU) @<<$(@B).lnk
+?ENDMSC?
+?BC?
+	$(LINK) $(LFLAGSU) @&&!
+?ENDBC?
+?LINKLIST:DGNCOMPOBJS?
+		$@
+		$(@B)
+		$(BCMDL);
+?MSC?
+<<
+?ENDMSC?
+?BC?
+!
+?ENDBC?
+
+$(O)dgn_yacc.o:	$(HACK_H)   $(DGN_FILE_H) $(INCL)\dgn_comp.h \
+	$(U)dgn_yacc.c
+	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)dgn_yacc.c
+
+$(O)dgn_$(LEX).o: $(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h \
+	$(U)dgn_$(LEX).c
+	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)dgn_$(LEX).c
+
+$(O)dgn_main.o:	$(HACK_H) $(U)dgn_main.c
+	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)dgn_main.c
+
+$(U)dgn_yacc.c $(INCL)\dgn_comp.h : $(U)dgn_comp.y
+!	IF "$(DO_YACC)"=="YACC_ACT"
+	   $(YACC) -d -l $(U)dgn_comp.y
+	   copy $(YTABC) $(U)dgn_yacc.c
+	   copy $(YTABH) $(INCL)\dgn_comp.h
+	   @del $(YTABC)
+	   @del $(YTABH)
+!	ELSE
+	   @echo.
+	   @echo $(U)dgn_comp.y has changed. To update $@ and
+	   @echo $(INCL)\dgn_comp.h run $(YACC).
+	   @echo.
+	   @echo For now, we will copy the prebuilt dgn_yacc.c from
+	   @echo $(SYS) to $(U)dgn_yacc.c, and copy the prebuilt
+	   @echo dgn_comp.h from $(SYS) to $(INCL)\dgn_comp.h 
+	   @echo and use those.
+	   @echo.
+	   copy $(SYS)\dgn_yacc.c $@ >nul
+	   touch $@
+	   copy $(SYS)\dgn_comp.h $(INCL)\dgn_comp.h >nul
+	   touch $(INCL)\dgn_comp.h
+!	ENDIF
+
+$(U)dgn_$(LEX).c:  $(U)dgn_comp.l
+!	IF "$(DO_LEX)"=="LEX_ACT"
+	   $(LEX) $(FLEXSKEL)  $(U)dgn_comp.l
+	   copy $(LEXYYC) $@
+	   @del $(LEXYYC)
+!	ELSE
+	   @echo.
+	   @echo $(U)dgn_comp.l has changed. To update $@ run $(LEX).
+	   @echo.
+	   @echo For now, we will copy a prebuilt dgn_lex.c
+	   @echo from $(SYS) to $@ and use it.
+	   @echo.
+	   copy $(SYS)\dgn_lex.c $@ >nul
+	   touch $@
+!	ENDIF
+
+
+obj.tag:
+	@if not exist $(O)*.* mkdir $(OBJ)
+	@echo directory $(OBJ) created
+	@echo directory $(OBJ) created >$@
+
+?MSC?
+#
+#  The correct switches for the C compiler depend on the CL environment
+#  variable being set correctly.  This will check that it is.
+#  The correct setting needs to be:
+#    CL= /AL /G2 /Oo /Gs /Gt16 /Zp1 /W0 /I..\include /nologo /DMOVERLAY
+#
+
+?ENDMSC?
+envchk: precomp.msg
+?MSC?
+!	IF ("$(CL)"=="")
+!	   MESSAGE The CL environment variable is not defined!
+!	   MESSAGE You must CD $(MSYS) and execute the SETUP.BAT procedure
+!	   MESSAGE ie.        setup MSC
+!	   MESSAGE
+!	   ERROR
+!	ELSE
+	   @echo CL Environment variable is defined:
+	   @echo CL=$(CL)
+!	ENDIF
+?ENDMSC?
+?COMMENT?
+#    CL= /AL /G2 /Oo /Gs /Gt16 /Zp1 /W0 /I..\include /nologo /DMOVERLAY
+?ENDCOMMENT?
+?BC?
+#
+# Borland Configuration File Section
+#
+	@echo Making Borland configuration files...
+	@echo -Y -O -Z -Oe -Ob -Os -Ff -I$(BCINCL);$(INCL) > $(BCCFG)
+	@echo -m$(MODEL) -D__IO_H $(CFLGTOT) -DSTRNCMPI >> $(BCCFG)
+	@type $(BCCFG) > CFLAGCO.CFG
+	@type $(BCCFG) > CFLAGUO.CFG
+	@type $(BCCFG) > CFLAGC0.CFG
+	@type $(BCCFG) > CFLAGU0.CFG
+	@type $(BCCFG) > CFLAGC1.CFG
+	@type $(BCCFG) > CFLAGU1.CFG
+	@type $(BCCFG) > CFLAGC2.CFG
+	@type $(BCCFG) > CFLAGU2.CFG
+	@type $(BCCFG) > CFLAGC3.CFG
+	@type $(BCCFG) > CFLAGU3.CFG
+	@type $(BCCFG) > CFLAGCB.CFG
+	@type $(BCCFG) > CFLAGUB.CFG
+    	@echo -Y $(CFLAGCO) >> CFLAGCO.CFG
+	@echo -Y $(CFLAGUO) >> CFLAGUO.CFG
+	@echo -Y $(CFLAGC0) >> CFLAGC0.CFG
+	@echo -Y $(CFLAGU0) >> CFLAGU0.CFG
+	@echo -Y $(CFLAGC1) >> CFLAGC1.CFG
+	@echo -Y $(CFLAGU1) >> CFLAGU1.CFG
+	@echo -Y $(CFLAGC2) >> CFLAGC2.CFG
+	@echo -Y $(CFLAGU2) >> CFLAGU2.CFG
+	@echo -Y $(CFLAGC3) >> CFLAGC3.CFG
+	@echo -Y $(CFLAGU3) >> CFLAGU3.CFG
+	@echo -Y $(CFLAGCB) >> CFLAGCB.CFG
+	@echo -Y $(CFLAGUB) >> CFLAGUB.CFG
+?ENDBC?
+!	IF "$(TILEGAME)"==""
+	   @echo.
+	   @echo NOTE: This build will NOT include tile support.
+	   @echo.
+!	ELSE
+	   @echo.
+	   @echo This build includes tile support.
+	   @echo.
+!	ENDIF
+
+#
+# SECONDARY TARGETS
+#
+
+#
+# Header files NOT distributed in ..\include
+#
+
+$(INCL)\tile.h: $(WSHR)\tile.h
+	copy $(WSHR)\tile.h $@
+
+$(INCL)\pctiles.h: $(MSYS)\pctiles.h
+	copy $(MSYS)\pctiles.h $@
+
+$(INCL)\pcvideo.h: $(MSYS)\pcvideo.h
+	copy $(MSYS)\pcvideo.h $@
+
+$(INCL)\portio.h: $(MSYS)\portio.h
+	copy $(MSYS)\portio.h $@
+
+#
+#  Recover Utility
+#
+
+$(U)recover.exe: $(RECOVOBJS)
+	@$(LINK) $(LFLAGSU) $(RECOVOBJS),$@,, $(CLIB) $(BCMDL);
+
+#
+#  Tile Mapping
+#
+
+$(SRC)\tile.c: $(U)tilemap.exe
+	@echo A new $@ is being created.
+	@$(U)tilemap
+
+$(U)tilemap.exe: $(O)tilemap.o
+	@$(LINK) $(LFLAGSU) $(O)tilemap.o,$@,, $(CLIB) $(BCMDL);
+
+$(O)tilemap.o:  $(WSHR)\tilemap.c $(HACK_H)
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\tilemap.c
+
+
+#
+# Tile Utilities
+#
+
+#
+#  Optional (for development)
+#
+
+
+
+#
+
+$(U)gif2txt.exe: $(GIFREADERS) $(TEXT_IO)
+	@$(LINK) $(LFLAGSU) $(GIFREADERS) $(TEXT_IO),$@,, \
+		$(CLIB) $(BCMDL);
+
+$(U)txt2ppm.exe: $(PPMWRITERS) $(TEXT_IO)
+	@$(LINK) $(LFLAGSU) $(PPMWRITERS) $(TEXT_IO),$@,, \
+		$(CLIB) $(BCMDL);
+
+$(U)gif2txt2.exe: $(GIFREAD2) $(TEXT_IO2)
+	@$(LINK) $(LFLAGSU) $(GIFREAD2) $(TEXT_IO2),$@,, \
+		$(CLIB) $(BCMDL);
+
+$(U)txt2ppm2.exe: $(PPMWRIT2) $(TEXT_IO2)
+	@$(LINK) $(LFLAGSU) $(PPMWRIT2) $(TEXT_IO2),$@,, \
+		$(CLIB) $(BCMDL);
+
+#
+#  Required for tile support
+#
+
+NetHack1.tib: $(TILEFILES) $(U)tile2bin.exe
+	@echo Creating binary tile files (this may take some time)
+	@$(U)tile2bin
+
+NetHackO.tib: thintile.tag $(TILEFILES2) $(U)til2bin2.exe
+	@echo Creating overview binary tile files (this may take some time)
+	@$(U)til2bin2
+
+thintile.tag: $(U)thintile.exe $(TILEFILES)
+	$(U)thintile
+	@echo thintiles created >thintile.tag
+
+$(U)tile2bin.exe: $(O)tile2bin.o $(TEXT_IO)
+    @echo Linking $@...
+?MSC?
+	$(LINK) $(LFLAGSU) @<<$(@B).lnk
+?ENDMSC?
+?BC?
+	$(LINK) $(LFLAGSU) @&&!
+?ENDBC?
+		$(O)tile2bin.o+
+?LINKLIST:TEXT_IO?
+		$@
+		$(@B)
+		$(BCMDL);
+?MSC?
+<<
+?ENDMSC?
+?BC?
+!
+?ENDBC?
+
+$(U)til2bin2.exe: $(O)til2bin2.o $(TEXT_IO2)
+    @echo Linking $@...
+?MSC?
+	$(LINK) $(LFLAGSU) @<<$(@B).lnk
+?ENDMSC?
+?BC?
+	$(LINK) $(LFLAGSU) @&&!
+?ENDBC?
+		$(O)til2bin2.o+
+?LINKLIST:TEXT_IO2?
+		$@
+		$(@B)
+		$(BCMDL);
+?MSC?
+<<
+?ENDMSC?
+?BC?
+!
+?ENDBC?
+
+
+$(U)thintile.exe: $(O)thintile.o
+	@$(LINK) $(LFLAGSU) $(O)thintile.o,$@,, $(CLIB) $(BCMDL);
+
+$(O)thintile.o:  $(HACK_H) $(INCL)\tile.h $(WSHR)\thintile.c
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\thintile.c
+
+$(O)tile2bin.o:  $(HACK_H) $(TILE_H) $(PCVIDEO_H)
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(MSYS)\tile2bin.c
+
+$(O)til2bin2.o:  $(HACK_H) $(TILE_H) $(PCVIDEO_H)
+	$(CC) $(CFLAGSU) $(CDEFINE)TILE_X=8 $(CDEFINE)OVERVIEW_FILE \
+		$(COBJNAM)$@ $(MSYS)\tile2bin.c
+
+?COMMENT?
+$(U)tile2btb.exe: $(O)tile2btb.o $(GIFREADERS)
+    @echo Linking $@...
+	$(LINK) $(LFLAGSU) @&&!
+		$(O)tile2btb.o+
+?LINKLIST:GIFREADERS?
+		$@
+		$(@B)
+		$(BCMDL) $(BGI_LIB);
+!
+
+$(O)tile2btb.o:  $(HACK_H) $(TILE_H) $(PCVIDEO_H) $(MSYS)\tile2btb.c
+	$(CC) -DBGI_FILE $(CFLAGSU) $(COBJNAM)$@ $(MSYS)\tile2btb.c
+?ENDCOMMENT?
+  
+#
+# DLB stuff
+#
+
+nhdat:	$(U)dlb_main.exe
+	@copy $(MSYS)\msdoshlp.txt $(DAT)
+	@cd $(DAT)
+	@echo data >dlb.lst
+	@echo oracles >>dlb.lst
+	@echo options >>dlb.lst
+	@echo quest.dat >>dlb.lst
+	@echo rumors >>dlb.lst
+	@echo help >>dlb.lst
+	@echo hh >>dlb.lst
+	@echo cmdhelp >>dlb.lst
+	@echo history >>dlb.lst
+	@echo opthelp >>dlb.lst
+	@echo wizhelp >>dlb.lst
+	@echo dungeon >>dlb.lst
+	@echo license >>dlb.lst
+	@echo msdoshlp.txt >>dlb.lst
+	@for %%N in (*.lev) do echo %%N >>dlb.lst
+	$(U)dlb_main cvIf dlb.lst $(SRC)\nhdat
+	@cd $(SRC)
+
+$(U)dlb_main.exe: $(DLBOBJS)
+	@$(LINK) $(LFLAGSU) $(DLBOBJS),$@,, $(CLIB) $(BCMDL);
+
+$(O)dlb_main.o: $(U)dlb_main.c $(INCL)\config.h $(DLB_H)
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)dlb_main.c
+
+#
+# Housekeeping
+#
+
+spotless: clean
+	rmdir $(OBJ)
+	if exist $(DATE_H)    del $(DATE_H)
+	if exist $(INCL)\onames.h  del $(INCL)\onames.h
+	if exist $(INCL)\pm.h      del $(INCL)\pm.h
+	if exist $(VIS_TAB_H) del $(VIS_TAB_H)
+	if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
+	if exist $(SRC)\tile.c     del $(SRC)\tile.c
+	if exist $(DAT)\rumors     del $(DAT)\rumors
+	if exist $(DAT)\data		del $(DAT)\data
+	if exist $(DAT)\dungeon		del $(DAT)\dungeon
+	if exist $(DAT)\dungeon.pdf	del $(DAT)\dungeon.pdf
+	if exist $(DAT)\options		del $(DAT)\options
+	if exist $(DAT)\oracles		del $(DAT)\oracles
+	if exist $(DAT)\rumors		del $(DAT)\rumors
+	if exist $(DAT)\quest.dat	del $(DAT)\quest.dat
+	if exist $(DAT)\*.lev		del $(DAT)\*.lev
+	if exist $(DAT)\sp_lev.tag	del $(DAT)\sp_lev.tag
+	if exist $(SRC)\monstr.c        del $(SRC)\monstr.c
+	if exist $(SRC)\vis_tab.c       del $(SRC)\vis_tab.c
+	if exist $(SRC)\$(PLANAR_TIB)   del $(SRC)\$(PLANAR_TIB)
+	if exist $(SRC)\$(OVERVIEW_TIB) del $(SRC)\$(OVERVIEW_TIB)
+	if exist $(U)recover.exe        del $(U)recover.exe
+
+clean:
+	if exist $(O)*.o del $(O)*.o
+	if exist $(O)*.0 del $(O)*.0
+	if exist $(O)*.1 del $(O)*.1
+	if exist $(O)*.2 del $(O)*.2
+	if exist $(O)*.3 del $(O)*.3
+	if exist $(O)*.b del $(O)*.b
+	if exist $(U)utility.tag   del $(U)utility.tag
+	if exist $(U)makedefs.exe  del $(U)makedefs.exe
+	if exist $(U)lev_comp.exe  del $(U)lev_comp.exe
+	if exist $(U)dgn_comp.exe  del $(U)dgn_comp.exe
+	if exist $(U)dlb_main.exe  del $(U)dlb_main.exe
+	if exist $(SRC)\*.lnk      del $(SRC)\*.lnk
+	if exist $(SRC)\*.map      del $(SRC)\*.map
+	if exist $(SRC)\*$(CPCHEXT) del $(SRC)\*$(CPCHEXT)
+?BC?
+	if exist $(SRC)\*.cfg      del $(SRC)\*.cfg
+?ENDBC?
+	if exist $(DAT)\dlb.lst    del $(DAT)\dlb.lst
+
+pch.c:	$(HACK_H)
+	@echo ^#include "hack.h" > $@
+	@echo main(int argc, char *argv[]) >> $@
+	@echo { >> $@
+	@echo } >> $@
+	@echo. >> $@
+
+#
+# OTHER DEPENDENCIES
+#
+
+#
+# Precompiled Header dependencies
+# (We need to force the generation of these at the beginning)
+#
+
+PHO$(CPCHEXT): $(HACK_H) pch.c
+	@echo Generating new precompiled header for .O files
+	@$(CC) $(FLAGCO) pch.c
+PH0$(CPCHEXT): $(HACK_H) pch.c
+	@echo Generating new precompiled header for .0 files
+	@$(CC) $(FLAGC0) pch.c
+PH1$(CPCHEXT): $(HACK_H) pch.c
+	@echo Generating new precompiled header for .1 files
+	@$(CC) $(FLAGC1) pch.c
+PH2$(CPCHEXT): $(HACK_H) pch.c
+	@echo Generating new precompiled header for .2 files
+	@$(CC) $(FLAGC2) pch.c
+PH3$(CPCHEXT): $(HACK_H) pch.c
+	@echo Generating new precompiled header for .3 files
+	@$(CC) $(FLAGC3) pch.c
+PHB$(CPCHEXT): $(HACK_H) pch.c
+	@echo Generating new precompiled header for .B files
+	@$(CC) $(FLAGCB) pch.c
+
+?MSC?
+#
+# Compiler supplied, manually moved file - MOVEINIT.C.
+# - This is only compiled if you selected the alternate overlay
+#   schema3. (MOVEAPI.H must reside in your include search list,
+#   and MOVEINIT.C must be in your src directory).  The patch
+#   in sys/msdos/moveinit.pat must be applied to moveinit.c
+#   MS will not allow us to distribute an already patched version.
+
+$(O)moveinit.o: $(SRC)\moveinit.c
+	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(MVTRCL) $(SRC)\moveinit.c
+
+$(SRC)\moveinit.c:
+	@echo.
+	@echo * CANNOT COMPLETE THE BUILD *
+	@echo You must manually copy moveinit.c and moveinit.h
+	@echo from your Microsoft C Compiler directory tree
+	@echo source/move directory and apply the sys/msdos/moveinit.pat
+	@echo patch to moveinit.c after doing so.
+	@echo.
+?ENDMSC?
+
+?BC?
+# Overlay initialization routines used by pcmain() at startup to
+# determine EMS/XMS memory usage.
+
+# Comment out the following line if you don't want Borland C++ to check for
+# extended memory.
+RECOGNIZE_XMS = $(CDEFINE)RECOGNIZE_XMS
+
+?ENDBC?
+?MSC?
+# Overlay initialization routines used by MOVEINIT.C
+?ENDMSC?
+
+$(O)ovlinit.o: $(MSYS)\ovlinit.c $(HACK_H)
+	$(CC) $(CFLAGSN) $(RECOGNIZE_XMS) $(COBJNAM)$@ $(MSYS)\ovlinit.c
+
+#
+# dat dependencies
+#
+
+$(DAT)\data: $(U)utility.tag    $(DATABASE)
+	$(U)makedefs -d
+
+$(DAT)\rumors: $(U)utility.tag    $(DAT)\rumors.tru   $(DAT)\rumors.fal
+	$(U)makedefs -r
+
+$(DAT)\quest.dat: $(U)utility.tag  $(DAT)\quest.txt
+	$(U)makedefs -q
+
+$(DAT)\oracles: $(U)utility.tag    $(DAT)\oracles.txt
+	$(U)makedefs -h
+
+$(DAT)\dungeon: $(U)utility.tag  $(DAT)\dungeon.def
+	$(U)makedefs -e
+	cd $(DAT)
+	$(U)dgn_comp dungeon.pdf
+	cd $(SRC)
+
+#
+#  Util Dependencies.
+#
+
+$(O)panic.o:   $(U)panic.c $(CONFIG_H)
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)panic.c
+
+$(O)recover.o: $(CONFIG_H) $(U)recover.c
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)recover.c
+
+#
+#  from win\share
+#
+
+$(O)tiletxt.o:  $(WSHR)\tilemap.c $(HACK_H)
+	$(CC) $(CFLAGSU) $(CDEFINE)TILETEXT $(COBJNAM)$@ $(WSHR)\tilemap.c
+
+$(O)tiletxt2.o:  $(WSHR)\tilemap.c $(HACK_H)
+	$(CC) $(CFLAGSU) $(CDEFINE)TILETEXT \
+		$(CDEFINE)TILE_X=8 $(COBJNAM)$@ $(WSHR)\tilemap.c
+
+$(O)gifread.o:  $(WSHR)\gifread.c  $(CONFIG_H) $(INCL)\tile.h
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\gifread.c
+
+$(O)gifread2.o:  $(WSHR)\gifread.c  $(CONFIG_H) $(INCL)\tile.h
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(CDEFINE)TILE_X=8 $(WSHR)\gifread.c
+
+$(O)ppmwrite.o: $(WSHR)\ppmwrite.c $(CONFIG_H) $(INCL)\tile.h
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\ppmwrite.c
+
+$(O)ppmwrit2.o: $(WSHR)\ppmwrite.c $(CONFIG_H) $(INCL)\tile.h
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(CDEFINE)TILE_X=8 $(WSHR)\ppmwrite.c
+
+$(O)tiletext.o:   $(WSHR)\tiletext.c  $(CONFIG_H) $(INCL)\tile.h
+	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\tiletext.c
+
+$(O)tiletex2.o:   $(WSHR)\tiletext.c  $(CONFIG_H) $(INCL)\tile.h
+	$(CC) $(CFLAGSU) $(CDEFINE)TILE_X=8 $(COBJNAM)$@ $(WSHR)\tiletext.c
+
+#
+#  from win\tty
+#
+
+$(O)getline.1:  $(PCH1) $(WTTY)\getline.c  $(HACK_H) $(WINTTY_H) $(FUNC_TAB_H)
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $(WTTY)\getline.c
+
+$(O)getline.2:  $(PCH2) $(WTTY)\getline.c  $(HACK_H) $(WINTTY_H) $(FUNC_TAB_H)
+	$(CC) $(FLAGU2) ?[CSNAM2]$(COBJNAM)$@ $(WTTY)\getline.c
+
+$(O)termcap.0:  $(PCH0) $(WTTY)\termcap.c  $(HACK_H) $(WINTTY_H) $(TERMCAP_H)
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $(WTTY)\termcap.c
+
+$(O)termcap.1:  $(PCH1) $(WTTY)\termcap.c  $(HACK_H) $(WINTTY_H) $(TERMCAP_H)
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $(WTTY)\termcap.c
+
+$(O)termcap.B:  $(PCHB) $(WTTY)\termcap.c  $(HACK_H) $(WINTTY_H) $(TERMCAP_H)
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(WTTY)\termcap.c
+
+$(O)topl.1:     $(PCH1) $(WTTY)\topl.c     $(HACK_H) $(TERMCAP_H) $(WINTTY_H)
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $(WTTY)\topl.c
+
+$(O)topl.2:     $(PCH2) $(WTTY)\topl.c     $(HACK_H) $(TERMCAP_H) $(WINTTY_H)
+	$(CC) $(FLAGU2) ?[CSNAM2]$(COBJNAM)$@ $(WTTY)\topl.c
+
+$(O)topl.B:     $(PCHB) $(WTTY)\topl.c     $(HACK_H) $(TERMCAP_H) $(WINTTY_H)
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(WTTY)\topl.c
+
+$(O)wintty.o: $(PCHO) $(CONFIG_H) $(WTTY)\wintty.c $(PATCHLEVEL_H)
+	$(CC) $(FLAGUO) ?[CSNAMOB]$(COBJNAM)$@ $(WTTY)\wintty.c
+
+#
+# from sys\share
+#
+
+$(O)pcmain.0:   $(PCH0) $(HACK_H) $(SYS)\pcmain.c
+	$(CC)  $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $(SYS)\pcmain.c
+
+$(O)pcmain.1:   $(PCH1) $(HACK_H) $(SYS)\pcmain.c
+	$(CC)  $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $(SYS)\pcmain.c
+
+$(O)pcmain.B:   $(PCHB) $(HACK_H) $(SYS)\pcmain.c
+	$(CC)  $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(SYS)\pcmain.c
+
+$(O)pcunix.B:   $(PCHB) $(SYS)\pcunix.c   $(HACK_H)
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(SYS)\pcunix.c
+
+$(O)tty.o:     $(HACK_H) $(WINTTY_H) $(SYS)\pctty.c
+	$(CC)  $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@  $(SYS)\pctty.c
+
+$(O)sys.o:    $(HACK_H) $(SYS)\pcsys.c
+	$(CC)  $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SYS)\pcsys.c
+
+$(O)random.o: $(PCHO) $(HACK_H) $(SYS)\random.c
+	$(CC) $(FLAGUO) ?[CSNAMOB]$(COBJNAM)$@ $(SYS)\random.c
+
+#
+# from sys\msdos
+#
+
+$(O)msdos.0: $(MSYS)\msdos.c   $(HACK_H) $(PCVIDEO_H)
+?BC?
+	$(CC) $(CFLAGSN) $(COVL0) $$($(@B)_0) $(COBJNAM)$@ $(MSYS)\msdos.c
+?ENDBC?
+?MSC?
+	$(CC) $(FLAGU0) $(CCSNAM)$(@F) $(COBJNAM)$@ $(MSYS)\msdos.c
+?ENDMSC?
+?COMMENT?
+	$(CC) $(CFLAGSN) $(COVL0) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDCOMMENT?
+
+$(O)msdos.B: $(MSYS)\msdos.c   $(HACK_H) $(PCVIDEO_H)
+?BC?
+	$(CC) $(CFLAGSN) $(COVLB) $$($(@B)_b) $(COBJNAM)$@ $(MSYS)\msdos.c
+?ENDBC?
+?MSC?
+	$(CC) $(FLAGUB) $(CCSNAM)$(@F) $(COBJNAM)$@ $(MSYS)\msdos.c
+?ENDMSC?
+?COMMENT?
+	$(CC) $(CFLAGSN) $(COVLB) ?[CSNAMB]$(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDCOMMENT?
+
+$(O)pctiles.0: $(PCH0) $(MSYS)\pctiles.c $(HACK_H) $(TILE_H) $(PCVIDEO_H)
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\pctiles.c
+
+$(O)pctiles.B: $(PCHB) $(MSYS)\pctiles.c $(HACK_H) $(TILE_H) $(PCVIDEO_H)
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(MSYS)\pctiles.c
+
+$(O)sound.o: $(PCH0) $(MSYS)\sound.c   $(HACK_H) $(INCL)\portio.h
+	$(CC) $(FLAGUO) ?[CSNAMOB]$(COBJNAM)$@ $(MSYS)\sound.c
+
+$(O)pckeys.o: $(PCHO) $(MSYS)\pckeys.c   $(HACK_H) $(PCVIDEO_H)
+	$(CC) $(FLAGUO) ?[CSNAMOB]$(COBJNAM)$@ $(MSYS)\pckeys.c
+
+$(O)stubvid.o : $(MSYS)\video.c $(HACK_H)
+	$(CC) $(FLAGUO) $(CDEFINE)STUBVIDEO ?[CSNAMOB]$(COBJNAM)$@ $(MSYS)\video.c
+
+$(O)video.0: $(PCH0) $(MSYS)\video.c   $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+                $(TILE_H)
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\video.c
+
+$(O)video.1: $(PCH1) $(MSYS)\video.c   $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+                $(TILE_H)
+	$(CC) $(FLAGU1) ?[CSNAM1]$(COBJNAM)$@ $(MSYS)\video.c
+
+$(O)video.B: $(PCHB) $(MSYS)\video.c   $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+                $(TILE_H)
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(MSYS)\video.c
+
+$(O)vidtxt.0: $(MSYS)\vidtxt.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H)
+?BC?
+	$(CC) $(CFLAGSN) $(COVL0) $$($(@B)_0) $(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDBC?
+?MSC?
+	$(CC) $(FLAGU0) $(CCSNAM)$(@F) $(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDMSC?
+?COMMENT?
+	$(CC) $(CFLAGSN) $(COVL0) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDCOMMENT?
+
+$(O)vidtxt.B: $(MSYS)\vidtxt.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H)
+?BC?
+	$(CC) $(CFLAGSN) $(COVLB) $$($(@B)_b) $(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDBC?
+?MSC?
+	$(CC) $(FLAGUB) $(CCSNAM)$(@F) $(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDMSC?
+?COMMENT?
+	$(CC) $(CFLAGSN) $(COVLB) ?[CSNAMB]$(COBJNAM)$@ $(MSYS)\vidtxt.c
+?ENDCOMMENT?
+
+$(O)vidvga.0: $(PCH0) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+		$(TILE_H)
+	$(CC) $(FLAGU0) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\vidvga.c
+
+$(O)vidvga.1: $(PCH1) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+		$(TILE_H)
+	$(CC) $(FLAGU1) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\vidvga.c
+
+$(O)vidvga.2: $(PCH2) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+		$(TILE_H)
+	$(CC) $(FLAGU2) ?[CSNAM0]$(COBJNAM)$@ $(MSYS)\vidvga.c
+
+$(O)vidvga.B: $(PCHB) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
+		$(TILE_H)
+	$(CC) $(FLAGUB) ?[CSNAMB]$(COBJNAM)$@ $(MSYS)\vidvga.c
+
+#
+# from src
+#
+
+$(O)alloc.o:     $(SRC)\alloc.c    $(CONFIG_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\alloc.c
+$(O)ball.o:      $(PCHO) $(SRC)\ball.c     $(HACK_H)
+$(O)bones.o:     $(PCHO) $(SRC)\bones.c    $(HACK_H) $(LEV_H)
+$(O)decl.o:      $(PCHO) $(SRC)\decl.c     $(HACK_H) $(QUEST_H)
+$(O)detect.o:    $(PCHO) $(SRC)\detect.c   $(HACK_H) $(ARTIFACT_H)
+$(O)dig.o:	 $(PCHO) $(SRC)\dig.c	   $(HACK_H) $(EDOG_H) # check dep
+$(O)display.o:	 $(PCHO) $(SRC)\display.c  $(HACK_H)
+$(O)dlb.o:	 $(SRC)\dlb.c	   $(DLB_H) $(HACK_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\dlb.c
+$(O)dokick.o:    $(PCHO) $(SRC)\dokick.c   $(HACK_H) $(ESHK_H)
+$(O)dothrow.o:   $(PCHO) $(SRC)\dothrow.c  $(HACK_H)
+$(O)drawing.o:   $(SRC)\drawing.c  $(HACK_H) $(TERMCAP_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\drawing.c
+$(O)end.o:       $(SRC)\end.c      $(HACK_H) $(ESHK_H) $(DLB_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\end.c
+$(O)exper.o:     $(PCHO) $(SRC)\exper.c    $(HACK_H)
+$(O)extralev.o:  $(PCHO) $(SRC)\extralev.c $(HACK_H)
+$(O)files.o:	 $(PCHO) $(SRC)\files.c    $(HACK_H) $(DLB_H)
+$(O)fountain.o:  $(PCHO) $(SRC)\fountain.c $(HACK_H)
+$(O)minion.o:    $(PCHO) $(SRC)\minion.c   $(HACK_H) $(EMIN_H) $(EPRI_H)
+$(O)mklev.o:     $(PCHO) $(SRC)\mklev.c    $(HACK_H)
+$(O)mkmap.o:     $(PCHO) $(SRC)\mkmap.c    $(HACK_H) $(SP_LEV_H)
+$(O)mkmaze.o:	 $(PCHO) $(SRC)\mkmaze.c   $(HACK_H) $(SP_LEV_H) $(LEV_H)
+$(O)monst.o:     $(SRC)\monst.c    $(CONFIG_H) $(PERMONST_H) $(MONSYM_H) \
+		 $(ESHK_H) $(EPRI_H) $(COLOR_H) $(ALIGN_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\monst.c
+$(O)monstr.o:    $(SRC)\monstr.c   $(CONFIG_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\monstr.c
+$(O)mplayer.o:   $(PCHO) $(SRC)\mplayer.c  $(HACK_H)
+$(O)muse.o:      $(PCHO) $(SRC)\muse.c     $(HACK_H)
+$(O)music.o:     $(PCHO) $(SRC)\music.c    $(HACK_H)
+$(O)o_init.o:	 $(PCHO) $(SRC)\o_init.c   $(HACK_H) $(LEV_H)
+$(O)objects.o:   $(SRC)\objects.c  $(CONFIG_H) $(OBJ_H) $(OBJCLASS_H) \
+                 $(PROP_H) $(COLOR_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\objects.c
+$(O)options.o:	 $(SRC)\options.c  $(HACK_H) $(TERMCAP_H) $(OBJCLASS_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\options.c
+$(O)pager.o:	 $(SRC)\pager.c    $(HACK_H) $(DLB_H)
+	$(CC) $(CFLAGNO) $(COBJNAM)$@ ?[CSNAMOA]$(SRC)\pager.c
+$(O)pickup.o:    $(PCHO) $(SRC)\pickup.c   $(HACK_H)
+$(O)pray.o:      $(PCHO) $(SRC)\pray.c     $(HACK_H) $(EPRI_H)
+$(O)quest.o:     $(PCHO) $(SRC)\quest.c    $(HACK_H) $(QUEST_H) $(QTEXT_H)
+$(O)questpgr.o:  $(PCHO) $(SRC)\questpgr.c $(HACK_H) $(QTEXT_H) $(DLB_H)
+$(O)rect.o:      $(PCHO) $(SRC)\rect.c     $(HACK_H)
+$(O)region.o:    $(PCHO) $(SRC)\region.c   $(HACK_H)
+$(O)restore.o:   $(PCHO) $(SRC)\restore.c  $(HACK_H) $(LEV_H) $(TERMCAP_H) \
+		 $(QUEST_H)
+$(O)rip.o:       $(PCHO) $(SRC)\rip.c      $(HACK_H)
+$(O)role.o:	   $(PCHO) $(SRC)\role.c     $(HACK_H)
+$(O)rumors.o:	 $(PCHO) $(SRC)\rumors.c   $(HACK_H) $(DLB_H)
+$(O)save.o:      $(PCHO) $(SRC)\save.c     $(HACK_H) $(LEV_H) $(QUEST_H)
+$(O)sit.o:       $(PCHO) $(SRC)\sit.c      $(HACK_H) $(ARTIFACT_H)
+$(O)steed.o:	   $(PCHO) $(SRC)\steed.c    $(HACK_H)
+$(O)sp_lev.o:	 $(PCHO) $(SRC)\sp_lev.c   $(HACK_H) $(SP_LEV_H) $(DLB_H)
+$(O)spell.o:     $(PCHO) $(SRC)\spell.c    $(HACK_H)
+$(O)teleport.o:  $(PCHO) $(SRC)\teleport.c $(HACK_H)	# check dep
+$(O)tile.o:      $(PCHO) $(SRC)\tile.c     $(HACK_H)
+$(O)topten.o:	 $(PCHO) $(SRC)\topten.c   $(HACK_H) $(DLB_H) $(PATCHLEVEL_H)
+$(O)u_init.o:    $(PCHO) $(SRC)\u_init.c   $(HACK_H)
+$(O)uhitm.o:     $(PCHO) $(SRC)\uhitm.c    $(HACK_H)
+$(O)version.o:   $(PCHO) $(SRC)\version.c  $(HACK_H) $(PATCHLEVEL_H)
+$(O)vision.o:    $(PCHO) $(SRC)\vision.c   $(HACK_H) $(VIS_TAB_H)
+$(O)vis_tab.o:   $(SRC)\vis_tab.c  $(HACK_H) $(VIS_TAB_H)
+	$(CC) $(CFLAGSN) ?[CSNAMOB]$(COBJNAM)$@ $(SRC)\vis_tab.c
+$(O)wield.o:     $(PCHO) $(SRC)\wield.c    $(HACK_H)
+$(O)windows.o:   $(PCHO) $(SRC)\windows.c  $(HACK_H) $(WINTTY_H)
+$(O)worm.o:      $(PCHO) $(SRC)\worm.c     $(HACK_H) $(LEV_H)
+$(O)worn.o:      $(PCHO) $(SRC)\worn.c     $(HACK_H)
+$(O)write.o:     $(PCHO) $(SRC)\write.c    $(HACK_H)
+
+#
+# Overlays
+#
+
+# OVL0
+#
+
+$(O)allmain.0:  $(PCH0) $(SRC)\allmain.c  $(HACK_H)
+$(O)apply.0:    $(PCH0) $(SRC)\apply.c    $(HACK_H) $(EDOG_H)
+$(O)artifact.0: $(PCH0) $(SRC)\artifact.c $(HACK_H) $(ARTIFACT_H) $(ARTILIST_H)
+$(O)attrib.0:   $(PCH0) $(SRC)\attrib.c   $(HACK_H)
+$(O)botl.0:     $(PCH0) $(SRC)\botl.c     $(HACK_H)
+$(O)cmd.0:      $(PCH0) $(SRC)\cmd.c      $(HACK_H) $(FUNC_TAB_H)
+$(O)dbridge.0:  $(PCH0) $(SRC)\dbridge.c  $(HACK_H)
+$(O)do.0:       $(PCH0) $(SRC)\do.c       $(HACK_H) $(LEV_H)
+$(O)do_name.0:  $(PCH0) $(SRC)\do_name.c  $(HACK_H)
+$(O)do_wear.0:  $(PCH0) $(SRC)\do_wear.c  $(HACK_H)
+$(O)dogmove.0:  $(PCH0) $(SRC)\dogmove.c  $(HACK_H) $(MFNDPOS_H) $(EDOG_H)
+$(O)dungeon.0:	$(PCH0) $(SRC)\dungeon.c  $(HACK_H) $(ALIGN_H) $(DGN_FILE_H) \
+		$(DLB_H)
+$(O)eat.0:      $(PCH0) $(SRC)\eat.c      $(HACK_H)
+$(O)engrave.0:  $(PCH0) $(SRC)\engrave.c  $(HACK_H) $(LEV_H)
+$(O)explode.0:  $(PCH0) $(SRC)\explode.c  $(HACK_H)
+$(O)hacklib.0:  $(PCH0) $(SRC)\hacklib.c  $(HACK_H)
+$(O)invent.0:   $(PCH0) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
+$(O)lock.0:     $(PCH0) $(SRC)\lock.c     $(HACK_H)
+$(O)mail.0:     $(PCH0) $(SRC)\mail.c     $(HACK_H) $(MAIL_H) $(PATCHLEVEL_H)
+$(O)makemon.0:  $(PCH0) $(SRC)\makemon.c  $(HACK_H) $(EPRI_H) $(EMIN_H)
+$(O)mcastu.0:   $(PCH0) $(SRC)\mcastu.c   $(HACK_H)
+$(O)mhitm.0:    $(PCH0) $(SRC)\mhitm.c    $(HACK_H) $(ARTIFACT_H) $(EDOG_H)
+$(O)mhitu.0:    $(PCH0) $(SRC)\mhitu.c    $(HACK_H) $(ARTIFACT_H) $(EDOG_H)
+$(O)mkobj.0:    $(PCH0) $(SRC)\mkobj.c    $(HACK_H) $(ARTIFACT_H) $(PROP_H)
+$(O)mkroom.0:   $(PCH0) $(SRC)\mkroom.c   $(HACK_H)
+$(O)mon.0:      $(PCH0) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H) $(EDOG_H)
+$(O)mondata.0:  $(PCH0) $(SRC)\mondata.c  $(HACK_H) $(ESHK_H) $(EPRI_H)
+$(O)monmove.0:  $(PCH0) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
+$(O)mthrowu.0:  $(PCH0) $(SRC)\mthrowu.c  $(HACK_H)
+$(O)objnam.0:   $(PCH0) $(SRC)\objnam.c   $(HACK_H)
+$(O)polyself.0: $(PCH0) $(SRC)\polyself.c $(HACK_H)
+$(O)priest.0:   $(PCH0) $(SRC)\priest.c   $(HACK_H) $(MFNDPOS_H) $(ESHK_H) \
+		$(EPRI_H) $(EMIN_H)
+$(O)rnd.0:      $(PCH0) $(SRC)\rnd.c      $(HACK_H)
+$(O)shk.0:      $(PCH0) $(SRC)\shk.c      $(HACK_H) $(ESHK_H)
+$(O)shknam.0:   $(PCH0) $(SRC)\shknam.c   $(HACK_H) $(ESHK_H)
+$(O)sounds.0:   $(PCH0) $(SRC)\sounds.c   $(HACK_H) $(EDOG_H)
+$(O)steal.0:    $(PCH0) $(SRC)\steal.c    $(HACK_H)
+$(O)timeout.0:	$(PCH0) $(SRC)\timeout.c  $(HACK_H) $(LEV_H)
+$(O)track.0:    $(PCH0) $(SRC)\track.c    $(HACK_H)
+$(O)trap.0:     $(PCH0) $(SRC)\trap.c     $(HACK_H)
+$(O)vault.0:    $(PCH0) $(SRC)\vault.c    $(HACK_H) $(VAULT_H)
+$(O)weapon.0:   $(PCH0) $(SRC)\weapon.c   $(HACK_H)
+$(O)were.0:     $(PCH0) $(SRC)\were.c     $(HACK_H)
+$(O)wizard.0:   $(PCH0) $(SRC)\wizard.c   $(HACK_H) $(QTEXT_H)
+$(O)zap.0:      $(PCH0) $(SRC)\zap.c      $(HACK_H)
+
+#
+# OVL1
+#
+
+$(O)allmain.1:  $(PCH1) $(SRC)\allmain.c  $(HACK_H)
+$(O)apply.1:    $(PCH1) $(SRC)\apply.c    $(HACK_H) $(EDOG_H)
+$(O)artifact.1: $(PCH1) $(SRC)\artifact.c $(HACK_H) $(ARTIFACT_H) $(ARTILIST_H)
+$(O)attrib.1:   $(PCH1) $(SRC)\attrib.c   $(HACK_H)
+$(O)botl.1:     $(PCH1) $(SRC)\botl.c     $(HACK_H)
+$(O)cmd.1:      $(PCH1) $(SRC)\cmd.c      $(HACK_H) $(FUNC_TAB_H)
+$(O)dbridge.1:  $(PCH1) $(SRC)\dbridge.c  $(HACK_H)
+$(O)do.1:       $(PCH1) $(SRC)\do.c       $(HACK_H) $(LEV_H)
+$(O)do_wear.1:  $(PCH1) $(SRC)\do_wear.c  $(HACK_H)
+$(O)dog.1:      $(PCH1) $(SRC)\dog.c      $(HACK_H) $(EDOG_H)
+$(O)dungeon.1:	$(PCH1) $(SRC)\dungeon.c  $(HACK_H) $(ALIGN_H) $(DGN_FILE_H) $(DLB_H)
+$(O)eat.1:      $(PCH1) $(SRC)\eat.c      $(HACK_H)
+$(O)engrave.1:  $(PCH1) $(SRC)\engrave.c  $(HACK_H) $(LEV_H)
+$(O)explode.1:  $(PCH1) $(SRC)\explode.c  $(HACK_H)
+$(O)hack.1:     $(PCH1) $(SRC)\hack.c     $(HACK_H)
+$(O)hacklib.1:  $(PCH1) $(SRC)\hacklib.c  $(HACK_H)
+$(O)invent.1:   $(PCH1) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
+$(O)makemon.1:  $(PCH1) $(SRC)\makemon.c  $(HACK_H) $(EPRI_H) $(EMIN_H)
+$(O)mhitu.1:    $(PCH1) $(SRC)\mhitu.c    $(HACK_H) $(ARTIFACT_H) $(EDOG_H)
+$(O)mkobj.1:    $(PCH1) $(SRC)\mkobj.c    $(HACK_H) $(ARTIFACT_H) $(PROP_H)
+$(O)mon.1:      $(PCH1) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H) $(EDOG_H)
+$(O)mondata.1:  $(PCH1) $(SRC)\mondata.c  $(HACK_H) $(ESHK_H) $(EPRI_H)
+$(O)monmove.1:  $(PCH1) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
+$(O)mthrowu.1:  $(PCH1) $(SRC)\mthrowu.c  $(HACK_H)
+$(O)objnam.1:   $(PCH1) $(SRC)\objnam.c   $(HACK_H)
+$(O)polyself.1: $(PCH1) $(SRC)\polyself.c $(HACK_H)
+$(O)rnd.1:      $(PCH1) $(SRC)\rnd.c      $(HACK_H)
+$(O)shk.1:      $(PCH1) $(SRC)\shk.c      $(HACK_H) $(ESHK_H)
+$(O)steal.1:    $(PCH1) $(SRC)\steal.c    $(HACK_H)
+$(O)timeout.1:	$(PCH1) $(SRC)\timeout.c  $(HACK_H) $(LEV_H)
+$(O)track.1:    $(PCH1) $(SRC)\track.c    $(HACK_H)
+$(O)trap.1:     $(PCH1) $(SRC)\trap.c     $(HACK_H)
+$(O)weapon.1:   $(PCH1) $(SRC)\weapon.c   $(HACK_H)
+$(O)zap.1:      $(PCH1) $(SRC)\zap.c      $(HACK_H)
+
+#
+# OVL2
+#
+
+$(O)attrib.2:   $(PCH2) $(SRC)\attrib.c   $(HACK_H)
+$(O)do.2:       $(PCH2) $(SRC)\do.c       $(HACK_H) $(LEV_H)
+$(O)do_name.2:  $(PCH2) $(SRC)\do_name.c  $(HACK_H)
+$(O)do_wear.2:  $(PCH2) $(SRC)\do_wear.c  $(HACK_H)
+$(O)dog.2:      $(PCH2) $(SRC)\dog.c      $(HACK_H) $(EDOG_H)
+$(O)engrave.2:  $(PCH2) $(SRC)\engrave.c  $(HACK_H) $(LEV_H)
+$(O)hack.2:     $(PCH2) $(SRC)\hack.c     $(HACK_H)
+$(O)hacklib.2:  $(PCH2) $(SRC)\hacklib.c  $(HACK_H)
+$(O)invent.2:   $(PCH2) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
+$(O)makemon.2:  $(PCH2) $(SRC)\makemon.c  $(HACK_H) $(EPRI_H) $(EMIN_H)
+$(O)mon.2:      $(PCH2) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H) $(EDOG_H)
+$(O)mondata.2:  $(PCH2) $(SRC)\mondata.c  $(HACK_H) $(ESHK_H) $(EPRI_H)
+$(O)monmove.2:  $(PCH2) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
+$(O)shk.2:      $(PCH2) $(SRC)\shk.c      $(HACK_H) $(ESHK_H)
+$(O)trap.2:     $(PCH2) $(SRC)\trap.c     $(HACK_H)
+$(O)zap.2:      $(PCH2) $(SRC)\zap.c      $(HACK_H)
+
+#
+# OVL3
+#
+
+$(O)do.3:       $(PCH3) $(SRC)\do.c       $(HACK_H) $(LEV_H)
+$(O)hack.3:     $(PCH3) $(SRC)\hack.c     $(HACK_H)
+$(O)invent.3:	$(PCH3) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
+$(O)light.3:	$(PCH3) $(SRC)\light.c	  $(HACK_H)
+$(O)shk.3:      $(PCH3) $(SRC)\shk.c      $(HACK_H) $(ESHK_H)
+$(O)trap.3:     $(PCH3) $(SRC)\trap.c     $(HACK_H)
+$(O)zap.3:      $(PCH3) $(SRC)\zap.c      $(HACK_H)
+
+#
+# OVLB
+#
+
+$(O)allmain.B:  $(PCHB) $(SRC)\allmain.c  $(HACK_H)
+$(O)apply.B:    $(PCHB) $(SRC)\apply.c    $(HACK_H) $(EDOG_H)
+$(O)artifact.B: $(PCHB) $(SRC)\artifact.c $(HACK_H) $(ARTIFACT_H) $(ARTILIST_H)
+$(O)attrib.B:   $(PCHB) $(SRC)\attrib.c   $(HACK_H)
+$(O)botl.B:     $(PCHB) $(SRC)\botl.c     $(HACK_H)
+$(O)cmd.B:      $(PCHB) $(SRC)\cmd.c      $(HACK_H) $(FUNC_TAB_H)
+$(O)dbridge.B:  $(PCHB) $(SRC)\dbridge.c  $(HACK_H)
+$(O)do.B:       $(PCHB) $(SRC)\do.c       $(HACK_H) $(LEV_H)
+$(O)do_name.B:  $(PCHB) $(SRC)\do_name.c  $(HACK_H)
+$(O)do_wear.B:  $(PCHB) $(SRC)\do_wear.c  $(HACK_H)
+$(O)dog.B:      $(PCHB) $(SRC)\dog.c      $(HACK_H) $(EDOG_H)
+$(O)dogmove.B:  $(PCHB) $(SRC)\dogmove.c  $(HACK_H) $(MFNDPOS_H) $(EDOG_H)
+$(O)eat.B:      $(PCHB) $(SRC)\eat.c      $(HACK_H)
+$(O)engrave.B:  $(PCHB) $(SRC)\engrave.c  $(HACK_H) $(LEV_H)
+$(O)hack.B:     $(PCHB) $(SRC)\hack.c     $(HACK_H)
+$(O)hacklib.B:  $(PCHB) $(SRC)\hacklib.c  $(HACK_H)
+$(O)invent.B:   $(PCHB) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
+$(O)lock.B:     $(PCHB) $(SRC)\lock.c     $(HACK_H)
+$(O)mail.B:     $(PCHB) $(SRC)\mail.c     $(HACK_H) $(MAIL_H) $(PATCHLEVEL_H)
+$(O)makemon.B:  $(PCHB) $(SRC)\makemon.c  $(HACK_H) $(EPRI_H) $(EMIN_H)
+$(O)mcastu.B:   $(PCHB) $(SRC)\mcastu.c   $(HACK_H)
+$(O)mhitm.B:    $(PCHB) $(SRC)\mhitm.c    $(HACK_H) $(ARTIFACT_H) $(EDOG_H)
+$(O)mhitu.B:    $(PCHB) $(SRC)\mhitu.c    $(HACK_H) $(ARTIFACT_H) $(EDOG_H)
+$(O)mkobj.B:    $(PCHB) $(SRC)\mkobj.c    $(HACK_H) $(ARTIFACT_H) $(PROP_H)
+$(O)mkroom.B:   $(PCHB) $(SRC)\mkroom.c   $(HACK_H)
+$(O)mon.B:      $(PCHB) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H) $(EDOG_H)
+$(O)mondata.B:  $(PCHB) $(SRC)\mondata.c  $(HACK_H) $(ESHK_H) $(EPRI_H)
+$(O)monmove.B:  $(PCHB) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
+$(O)mthrowu.B:  $(PCHB) $(SRC)\mthrowu.c  $(HACK_H)
+$(O)objnam.B:   $(PCHB) $(SRC)\objnam.c   $(HACK_H)
+$(O)pline.B:    $(SRC)\pline.c    $(HACK_H) $(EPRI_H)
+	$(CC) $(CFLAGSN) ?[CSNAMB]$(COBJNAM)$@ $(SRC)\pline.c
+$(O)polyself.B: $(PCHB) $(SRC)\polyself.c $(HACK_H)
+$(O)potion.B:   $(PCHB) $(SRC)\potion.c   $(HACK_H)
+$(O)priest.B:   $(PCHB) $(SRC)\priest.c   $(HACK_H) $(MFNDPOS_H) $(ESHK_H) \
+		$(EPRI_H) $(EMIN_H)
+$(O)read.B:     $(PCHB) $(SRC)\read.c     $(HACK_H)
+$(O)rnd.B:      $(PCHB) $(SRC)\rnd.c      $(HACK_H)
+$(O)shk.B:      $(PCHB) $(SRC)\shk.c      $(HACK_H) $(ESHK_H)
+$(O)shknam.B:   $(PCHB) $(SRC)\shknam.c   $(HACK_H) $(ESHK_H)
+$(O)sounds.B:   $(PCHB) $(SRC)\sounds.c   $(HACK_H) $(EDOG_H)
+$(O)steal.B:    $(PCHB) $(SRC)\steal.c    $(HACK_H)
+$(O)timeout.B:	$(PCHB) $(SRC)\timeout.c  $(HACK_H) $(LEV_H)
+$(O)track.B:    $(PCHB) $(SRC)\track.c    $(HACK_H)
+$(O)trap.B:     $(PCHB) $(SRC)\trap.c     $(HACK_H)
+$(O)vault.B:    $(PCHB) $(SRC)\vault.c    $(HACK_H) $(VAULT_H)
+$(O)weapon.B:   $(PCHB) $(SRC)\weapon.c   $(HACK_H)
+$(O)were.B:     $(PCHB) $(SRC)\were.c     $(HACK_H)
+$(O)wizard.B:   $(PCHB) $(SRC)\wizard.c   $(HACK_H) $(QTEXT_H)
+$(O)zap.B:      $(PCHB) $(SRC)\zap.c      $(HACK_H)
+
+# end of file
diff -Pru nethack-3.4.1/sys/share/sounds/mgcharp.uu nethack/sys/share/sounds/mgcharp.uu
--- nethack-3.4.1/sys/share/sounds/mgcharp.uu	Sun Feb 23 06:43:38 2003
+++ nethack/sys/share/sounds/mgcharp.uu	Sun Mar  9 13:39:54 2003
@@ -329,17 +329,17 @@
 M_O__``````````````````````````````#___[]_?W]_O_______O[^_O[_
 M__[^_O[^_O___P`!`0$```````$"`@("`0$!`0$!`0$!`/____[^_O__````
 M``````````````````````````#___[]_?W]_O_______O[^_O[___[^_O[^
-M_O___P`!`0$```````$!`@(!`0$!`0$!`0$!``#___[^_O__````````````
+M_O___P`!`0$```````$!`@(!`0$!`0$!`0$!``#____^_O__````````````
 M````````````````````__[^_?W]_O_______O[^_O_____^_O[^_O___P`!
 M`0$````````!`0$!`0$!`0$!`0$!``#____^_O__````````````````````
 M````````````__[^_OW^_O________[^_O_______O[^_____P```0$`````
 M```!`0$!`0$!`0$!`0$!``#_________````````````````````````````
-M`````/_^_O[^_O____________________[^_____P```0$``````````0$!
+M`````/_^_O[^_O_____________________^_____P```0$``````````0$!
 M`0$!`0$!`0$!`0``_________P```````````````````````````````/_^
 M_O[^_O[___________________________\``````````````0$!`0$!`0$!
 M`0$!`0``_________P```````````````````````````````/___O[^_O[_
 M__________________________\```````#__P````$!`0$!`0$!`0$!`0$`
-M`/________\```````````````````````````````#___[^_O[_________
+M`/________\```````````````````````````````#____^_O[_________
 M__________________\```````#___\````!`0$!`0$!`0$!`0$```#_____
 M__\`````````````````````````````````__[^_O[_________________
 M____________````````____`````0$!`0$!`````0$`````________````
diff -Pru nethack-3.4.1/sys/share/sounds/toolhorn.uu nethack/sys/share/sounds/toolhorn.uu
--- nethack-3.4.1/sys/share/sounds/toolhorn.uu	Sun Feb 23 06:43:38 2003
+++ nethack/sys/share/sounds/toolhorn.uu	Sun Mar  9 13:39:55 2003
@@ -29,9 +29,9 @@
 M"@H)"`8$`?WX\>KCVM/,Q+ZZM[:VN+O"RM7D]`46)3(\1$A)1T,^-R\H(!H4
 M#PL(!0(`__[^_?W]_?S\_/S]_?[^_O[^_O[^_O\``@,%!@<("0H+"PL)"`8#
 M__KT[.7<U<S$OKBSL+"QM+O$T>'S!1<H-D%(3$U+1T`Y,"D@&A0."@8#`0#_
-M_O[]_?W]_?[^_O__``#___[^_O[^_O\!`@0&!P@("0D*"0@'!0/_^O7NY][7
+M_O[]_?W]_?[^_O__``#____^_O[^_O\!`@0&!P@("0D*"0@'!0/_^O7NY][7
 MS\C`NK6QL+"RMK[*V>K^$2,S0$A.4$]+1#PT*R(;%`\+!P0"`0#___[^_O[^
-M_O[^____``#___[^_?W]_?X``@,%!P@*"PP,"PH(!0+]^/'JX]K3S,2^N+.P
+M_O[^____``#____^_?W]_?X``@,%!P@*"PP,"PH(!0+]^/'JX]K3S,2^N+.P
 MK["RM\#-W?`%&2LZ1DY14D]*0SHP)Q\7$0P(!0,!``#___________\```$!
 M`0#___[]_/S\_/[_`0,%!@@)"@L,#`H(!0']^/'JXMO3S,6_N;2QL+"RM\#,
 MW?$&&RT\2$]34U!)0CDO)AT6$`L'!`,!````______[^_O___P```/___O[]
@@ -266,7 +266,7 @@
 M_OW\^_KY^?K[_/W_``($!@D+#0X/$`\.#0H'!`#Z]>[HX=K4S<2[LJJGK+G.
 MYP`6*#8_1$9$0#DS+"4?&100#0H(!0,!__W[^OGZ^OO\_?[______OW\^OKY
 M^?GZ^_S^``($!@D+#`T-#0T-#`H(!0'\]_'KY-[8T<G`MZ^JJ[?*XOL1(S([
-M04-"/C@R*R4>&141#0H(!@,!__W[^OKZ^OO\_?[^_____OW\^_KZ^?KZ^_S]
+M04-"/C@R*R4>&141#0H(!@,!__W[^OKZ^OO\_?_^_____OW\^_KZ^?KZ^_S]
 M_P$#!0@+#0X/#PX-#`H'!`'\]_+KY-[7T<K`M["LL+O-Y/P1(S`Z/T$_.S8P
 M*2,=&!00#`H'!0,!__W\^_KZ^_O\_?[______OW\^_KY^?GZ^_S^_P$#!0@*
 M#`T.#@X-#`H'!`'\]_+LYN#:U,W$N[6RM<#0Y?L/("TU.ST[.#,N*"(<%Q,/
diff -Pru nethack-3.4.1/sys/unix/Makefile.src nethack/sys/unix/Makefile.src
--- nethack-3.4.1/sys/unix/Makefile.src	Sun Feb 23 06:43:39 2003
+++ nethack/sys/unix/Makefile.src	Sun Mar  9 13:57:11 2003
@@ -203,9 +203,14 @@
 #WINBEOBJ = winbe.o NHWindow.o NHMenuWindow.o NHMapWindow.o tile.o
 
 #
+# Files for the lisp port
+WINLISPSRC = ../win/lisp/winlisp.c tile.c
+WINLISPOBJ = winlisp.o tile.o
+
+#
 #
-WINSRC = $(WINTTYSRC)
-WINOBJ = $(WINTTYOBJ)
+WINSRC = $(WINLISPSRC)
+WINOBJ = $(WINLISPOBJ)
 
 # on some systems the termcap library is in -ltermcap or -lcurses
 # on 386 Xenix, the -ltermlib tputs() seems not to work; use -lcurses instead
@@ -244,8 +249,11 @@
 #
 # libraries for BeOS 
 WINBELIB = -lbe
+#
+# libraries for lisp port
+WINLISPLIB =
 
-WINLIB = $(WINTTYLIB)
+WINLIB = $(WINLISPLIB)
 
 # any other strange libraries your system needs (for Sysunix only -- the more
 # specialized targets should already be right)
@@ -328,7 +336,7 @@
 GENCSRC = monstr.c vis_tab.c	#tile.c
 
 # all windowing-system-dependent .c (for dependencies and such)
-WINCSRC = $(WINTTYSRC) $(WINX11SRC) $(WINGNOMESRC) $(WINGEMSRC)
+WINCSRC = $(WINTTYSRC) $(WINX11SRC) $(WINGNOMESRC) $(WINGEMSRC) $(WINLISPSRC)
 # all windowing-system-dependent .cpp (for dependencies and such)
 WINCXXSRC = $(WINQTSRC) $(WINBESRC)
 
@@ -792,7 +800,8 @@
 weapon.o: weapon.c $(HACK_H)
 were.o: were.c $(HACK_H)
 wield.o: wield.c $(HACK_H)
-windows.o: windows.c $(HACK_H) ../include/wingem.h ../include/winGnome.h
+windows.o: windows.c $(HACK_H) ../include/wingem.h ../include/winGnome.h \
+	../include/winlisp.h
 wizard.o: wizard.c $(HACK_H) ../include/qtext.h ../include/epri.h
 worm.o: worm.c $(HACK_H) ../include/lev.h
 worn.o: worn.c $(HACK_H)
diff -Pru nethack-3.4.1/sys/wince/Install.ce nethack/sys/wince/Install.ce
--- nethack-3.4.1/sys/wince/Install.ce	Sun Feb 23 06:43:41 2003
+++ nethack/sys/wince/Install.ce	Sun Mar  9 13:39:57 2003
@@ -4,7 +4,7 @@
                  Instructions for compiling and installing
              NetHack 3.4.1 on a Windows CE or PocketPC system
 ========================================================================
-		      Last revision: $Date: 2003/02/22 01:20:07 $
+		      Last revision: $Date: 2003/03/09 21:39:57 $
 
 Credit for the porting of NetHack to Windows CE goes to Alex Kompel who 
 initially developed and contributed the port.
diff -Pru nethack-3.4.1/sys/wince/cesetup.bat nethack/sys/wince/cesetup.bat
--- nethack-3.4.1/sys/wince/cesetup.bat	Sun Feb 23 06:43:40 2003
+++ nethack/sys/wince/cesetup.bat	Sun Mar  9 13:39:56 2003
@@ -1,4 +1,4 @@
-@REM  SCCS Id: @(#)nhsetup.bat	$Date: 2003/02/13 05:10:04 $
+@REM  SCCS Id: @(#)nhsetup.bat	$Date: 2003/03/09 21:39:56 $
 @REM  Copyright (c) Alex Kompel, 2002
 @REM  NetHack may be freely redistributed.  See license for details. 
 @REM  Win32 nhsetup batch file, see Install.ce for details
diff -Pru nethack-3.4.1/sys/wince/cesound.c nethack/sys/wince/cesound.c
--- nethack-3.4.1/sys/wince/cesound.c	Sun Feb 23 06:43:40 2003
+++ nethack/sys/wince/cesound.c	Sun Mar  9 13:39:56 2003
@@ -1,4 +1,4 @@
-/*   SCCS Id: @(#)cesound.c   3.4     $Date: 2003/02/13 12:35:27 $                        */
+/*   SCCS Id: @(#)cesound.c   3.4     $Date: 2003/03/09 21:39:56 $                        */
 /*   Copyright (c) NetHack PC Development Team 1993                 */
 /*   NetHack may be freely redistributed.  See license for details. */
 /*                                                                  */
diff -Pru nethack-3.4.1/sys/winnt/Install.nt nethack/sys/winnt/Install.nt
--- nethack-3.4.1/sys/winnt/Install.nt	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/Install.nt	Sun Mar  9 13:39:59 2003
@@ -4,7 +4,7 @@
                  Instructions for compiling and installing
              NetHack 3.4 on a Windows 9x, NT, 2000, or XP system
          ==============================================================
-                 Last revision: $Date: 2003/02/22 01:20:14 $
+                 Last revision: $Date: 2003/03/09 21:39:59 $
 
 Credit for the porting of NetHack to the Win32 Console Subsystem goes to 
 the NT Porting Team started by Michael Allison.
diff -Pru nethack-3.4.1/sys/winnt/Makefile.bcc nethack/sys/winnt/Makefile.bcc
--- nethack-3.4.1/sys/winnt/Makefile.bcc	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/Makefile.bcc	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-#   SCCS Id: @(#)Makefile.bcc       3.4     $Date: 2003/02/19 14:20:46 $
+#   SCCS Id: @(#)Makefile.bcc       3.4     $Date: 2003/03/09 21:40:00 $
 #   Copyright (c) NetHack PC Development Team 1993-2003
 #
 #   NetHack 3.4.x Makefile for Borland C++ V5.5.1 and above and Borland's MAKE
diff -Pru nethack-3.4.1/sys/winnt/Makefile.gcc nethack/sys/winnt/Makefile.gcc
--- nethack-3.4.1/sys/winnt/Makefile.gcc	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/Makefile.gcc	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-#   SCCS Id: @(#)Makefile.gcc       3.4     $Date: 2003/02/19 14:20:47 $
+#   SCCS Id: @(#)Makefile.gcc       3.4     $Date: 2003/03/09 21:40:00 $
 #   Copyright (c) NetHack PC Development Team 1993-2003
 #
 #   NetHack 3.4.x Makefile for MinGW
diff -Pru nethack-3.4.1/sys/winnt/Makefile.msc nethack/sys/winnt/Makefile.msc
--- nethack-3.4.1/sys/winnt/Makefile.msc	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/Makefile.msc	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-#       SCCS Id: @(#)Makefile.msc       3.4     $Date: 2003/02/19 14:20:47 $
+#       SCCS Id: @(#)Makefile.msc       3.4     $Date: 2003/03/09 21:40:00 $
 #       Copyright (c) NetHack PC Development Team 1993-2003
 #
 #       NetHack 3.4.x Makefile for MS Visual C++ V6.x and above and MS NMAKE
diff -Pru nethack-3.4.1/sys/winnt/Makefile.nt nethack/sys/winnt/Makefile.nt
--- nethack-3.4.1/sys/winnt/Makefile.nt	Wed Dec 31 16:00:00 1969
+++ nethack/sys/winnt/Makefile.nt	Thu Jan 10 16:43:33 2002
@@ -0,0 +1,1148 @@
+#       SCCS Id: @(#)Makefile.nt       3.3     2000/08/01
+#       Copyright (c) NetHack PC Development Team 1993-2000
+#
+#       NetHack 3.2 Makefile for MS Visual C++ V4.x and above and MS NMAKE
+#  
+#       Win32 Compilers Tested:
+#                              - Microsoft 32 bit Visual C++ V4.x
+#                              - Microsoft 32 bit Visual C++ V6.0 SP3, SP4
+#
+#	This is used for building a TTY version of NetHack using WIN32 Console
+#	I/O routines only.
+#
+#       In addition to your C compiler,
+#
+#       if you want to change           you will need a
+#       files with suffix               workalike for
+#              .y                           yacc   (such as bison)
+#              .l                           lex    (such as flex)
+#
+#
+#       If you have any questions read the Install.nt file included with
+#       the distribution.
+#
+#       Michael Allison
+#
+#----------------------------------------------------------------------
+# Do not delete the following 3 lines.
+#
+TARGETOS=BOTH
+APPVER=4.0
+!include <win32.mak>
+
+#
+#  Set the gamedir according to your preference.  It must be present prior
+#  to compilation.
+
+GAME    = NetHack                # Game Name
+GAMEDIR = \games\nethackntty      # Game directory
+
+#
+#  Source directories.    Makedefs hardcodes these, don't change them.
+#
+
+INCL  = ..\include   # NetHack include files
+DAT   = ..\dat       # NetHack data files
+DOC   = ..\doc       # NetHack documentation files
+UTIL  = ..\util      # Utility source
+SRC   = ..\src       # Main source
+SSYS  = ..\sys\share # Shared system files
+NTSYS = ..\sys\winnt # NT Win32 specific files
+TTY   = ..\win\tty   # window port files (tty)
+WIN32 = ..\win\win32 # window port files (Win32)
+WSHR  = ..\win\share # Tile support files 
+
+#
+#  Object directory.
+#
+
+OBJ     = o
+
+
+#
+# Exe File Info.
+# ($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.)
+#
+
+MAKEBIN = nmake
+
+# 
+# Yacc/Lex ... if you got 'em.
+#
+# If you have yacc and lex programs (or work-alike such as bison 
+# and flex), comment out the upper two macros and uncomment 
+# the lower two.
+#
+
+DO_YACC = YACC_MSG
+DO_LEX  = LEX_MSG
+#DO_YACC  = YACC_ACT
+#DO_LEX   = LEX_ACT
+
+#
+# - Specify your yacc and lex programs (or work-alikes) here.
+#
+
+#YACC	= bison -y
+YACC   = byacc
+#YACC	= yacc
+
+#LEX	= lex
+LEX	= flex
+
+#
+# - Specify your flex skeleton file (if needed).
+#
+
+FLEXSKEL =
+#FLEXSKEL = -S../tools/flex.ske
+
+YTABC   = y_tab.c
+YTABH   = y_tab.h
+LEXYYC  = lexyy.c
+
+#
+# Optional high-quality BSD random number generation routines
+# (see pcconf.h). Set to nothing if not used.
+#
+
+RANDOM	= $(OBJ)\random.o
+#RANDOM	=
+
+#
+# - For debugging ability, comment out the upper two 
+#   macros and uncomment the lower two.
+#
+
+#
+#  Leave the next two lines uncommented _ONLY_ if you do NOT want any
+#  debug capability in the object files, or in the NetHack executable.
+#  Comment them if you want debug capability.
+
+#cdebug =
+#linkdebug =
+
+#
+# Compiler and Linker flags
+#
+
+PRECOMPHEAD = N			# set to Y if you want to use precomp. headers
+
+
+########################################################################
+########################################################################
+#
+# Nothing below this line should have to be changed.
+#
+
+#Do not uncomment these for 3.3.0
+#TILEGAME  = $(OBJ)\tile.o
+#TILEDEF   = -DTILES
+#TILEHDR   =
+#SOUND = $(OBJ)\ntsound.o
+
+#SOUND =
+#TILEUTIL  =
+#TILEBMP   =
+#TILEGAME  =
+#TILEDEF   =   
+#TILEHDR   =
+
+#
+# Uncomment the line below if you want to store all the level files,
+# help files, etc. in a single library file.
+
+USE_DLB = Y
+
+! IF ("$(USE_DLB)"=="Y")
+DLBFLG = -DDLB
+! ELSE
+DLBFLG =
+! ENDIF
+
+# You can actually build a set of tiles with this makefile
+# even though they are not used. 
+# Use 'nmake o\nhtiles.bmp'
+#
+TILEUTIL  = $(UTIL)\tile2bmp.exe
+TILEBMP   = $(OBJ)\nhtiles.bmp
+
+#
+# - Util builds
+#
+
+CFLAGSU	= -c $(cflags) $(cvarsmt) -I$(INCL) -nologo $(cdebug) \
+		$(TILEDEF) $(DLBFLG)
+LFLAGSU	= $(linkdebug) $(conflags) $(conlibsmt)
+
+#
+# - Game build
+#
+#
+
+CFLAGSG	= $(CFLAGSU)
+NHLFLAGS = /NODEFAULTLIB /INCREMENTAL:NO /PDB:"$(GAME).PDB" /RELEASE /NOLOGO
+#LFLAGSG = $(guiflags) $(linkdebug) -IGNORE:505 $(guilibsmt) comctl32.lib
+LFLAGSG	= $(NHLFLAGS) /MACHINE:$(CPU) /MAP:"$(GAME).MAP" $(linkdebug) -IGNORE:505 $(conlibsmt) 
+
+GAMEFILE = $(GAMEDIR)\$(GAME).exe # whole thing
+
+#  This line should not be deleted.
+NTSUB = -DWIN32CON
+
+! IF ("$(USE_DLB)"=="Y")
+DLB = nhdat
+! ELSE
+DLB =
+! ENDIF
+
+#
+#  Make Rules.
+#
+
+.SUFFIXES: .exe .o .til .uu .c .y .l
+
+#
+# Rules for files in src
+#
+
+
+.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSG)  $(NTSUB) -Fo$@ $<
+
+{$(SRC)}.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSG)  $(NTSUB)  -Fo$@  $<
+
+#
+# Rules for files in sys\share
+#
+
+{$(SSYS)}.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSG)  -Fo$@  $<
+
+#
+# Rules for files in sys\winnt
+#
+
+{$(NTSYS)}.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSG)  -Fo$@  $<
+
+{$(NTSYS)}.h{$(INCL)}.h:
+	@copy $< $@
+
+#
+# Rules for files in util
+#
+
+{$(UTIL)}.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSU) $(NTSUB) -Fo$@ $<
+
+#
+# Rules for files in win\share
+#
+
+{$(WSHR)}.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSG)  -Fo$@ $<
+
+{$(WSHR)}.h{$(INCL)}.h:
+	@copy $< $@
+
+#{$(WSHR)}.txt{$(DAT)}.txt:
+#	@copy $< $@
+
+
+#
+# Rules for files in win\tty
+#
+
+{$(TTY)}.c{$(OBJ)}.o:
+	@$(cc) $(CFLAGSG)  -Fo$@  $<
+
+#
+# NETHACK OBJECTS
+# 
+# This section creates shorthand macros for many objects
+# referenced later on in the Makefile.
+#
+
+
+DEFFILE = $(NTSYS)\$(GAME).def
+
+#
+# Shorten up the location for some files
+#
+
+O  = $(OBJ)^\
+
+U  = $(UTIL)^\
+
+#
+# Utility Objects.
+#
+
+MAKESRC        = $(U)makedefs.c
+
+SPLEVSRC       = $(U)lev_yacc.c	$(U)lev_$(LEX).c $(U)lev_main.c  $(U)panic.c
+
+DGNCOMPSRC     = $(U)dgn_yacc.c	$(U)dgn_$(LEX).c $(U)dgn_main.c
+
+MAKEOBJS       = $(O)makedefs.o $(O)monst.o $(O)objects.o
+
+SPLEVOBJS      = $(O)lev_yacc.o	$(O)lev_$(LEX).o $(O)lev_main.o \
+		 $(O)alloc.o	$(O)decl.o	$(O)drawing.o \
+		 $(O)monst.o	$(O)objects.o	$(O)panic.o
+
+DGNCOMPOBJS    = $(O)dgn_yacc.o	$(O)dgn_$(LEX).o $(O)dgn_main.o \
+		 $(O)alloc.o	$(O)panic.o
+
+RECOVOBJS      = $(O)recover.o
+
+#
+# These are not invoked during a normal game build in 3.3.0
+#
+TEXT_IO        = $(O)tiletext.o	$(O)tiletxt.o	$(O)drawing.o \
+		 $(O)decl.o	$(O)monst.o	$(O)objects.o
+
+GIFREADERS     = $(O)gifread.o	$(O)alloc.o $(O)panic.o
+
+PPMWRITERS     = $(O)ppmwrite.o $(O)alloc.o $(O)panic.o
+
+TILEFILES      = $(WSHR)\monsters.txt $(WSHR)\objects.txt $(WSHR)\other.txt
+
+#
+#  Object files for the game itself.
+#
+
+VOBJ01 = $(O)allmain.o  $(O)alloc.o    $(O)apply.o    $(O)artifact.o
+VOBJ02 = $(O)attrib.o   $(O)ball.o     $(O)bones.o    $(O)botl.o    
+VOBJ03 = $(O)cmd.o      $(O)dbridge.o  $(O)decl.o     $(O)detect.o  
+VOBJ04 = $(O)dig.o      $(O)display.o  $(O)do.o       $(O)do_name.o 
+VOBJ05 = $(O)do_wear.o  $(O)dog.o      $(O)dogmove.o  $(O)dokick.o  
+VOBJ06 = $(O)dothrow.o  $(O)drawing.o  $(O)dungeon.o  $(O)eat.o     
+VOBJ07 = $(O)end.o      $(O)engrave.o  $(O)exper.o    $(O)explode.o 
+VOBJ08 = $(O)extralev.o $(O)files.o    $(O)fountain.o $(O)hack.o    
+VOBJ09 = $(O)hacklib.o  $(O)invent.o   $(O)light.o    $(O)lock.o    
+VOBJ10 = $(O)mail.o     $(O)main.o     $(O)makemon.o  $(O)mcastu.o  
+VOBJ11 = $(O)mhitm.o    $(O)mhitu.o    $(O)minion.o   $(O)mklev.o   
+VOBJ12 = $(O)mkmap.o    $(O)mkmaze.o   $(O)mkobj.o    $(O)mkroom.o  
+VOBJ13 = $(O)mon.o      $(O)mondata.o  $(O)monmove.o  $(O)monst.o   
+VOBJ14 = $(O)monstr.o   $(O)mplayer.o  $(O)mthrowu.o  $(O)muse.o    
+VOBJ15 = $(O)music.o    $(O)o_init.o   $(O)objects.o  $(O)objnam.o  
+VOBJ16 = $(O)options.o  $(O)pager.o    $(O)pickup.o   $(O)pline.o   
+VOBJ17 = $(O)polyself.o $(O)potion.o   $(O)pray.o     $(O)priest.o  
+VOBJ18 = $(O)quest.o    $(O)questpgr.o $(RANDOM)      $(O)read.o    
+VOBJ19 = $(O)rect.o     $(O)region.o   $(O)restore.o  $(O)rip.o     
+VOBJ20 = $(O)rnd.o      $(O)role.o     $(O)rumors.o   $(O)save.o    
+VOBJ21 = $(O)shk.o      $(O)shknam.o   $(O)sit.o      $(O)sounds.o  
+VOBJ22 = $(O)sp_lev.o   $(O)spell.o    $(O)steal.o    $(O)steed.o   
+VOBJ23 = $(O)teleport.o $(O)timeout.o  $(O)topten.o   $(O)track.o   
+VOBJ24 = $(O)trap.o     $(O)u_init.o   $(O)uhitm.o    $(O)vault.o   
+VOBJ25 = $(O)vis_tab.o  $(O)vision.o   $(O)weapon.o   $(O)were.o    
+VOBJ26 = $(O)wield.o    $(O)windows.o  $(O)wizard.o   $(O)worm.o    
+VOBJ27 = $(O)worn.o     $(O)write.o    $(O)zap.o     
+
+DLBOBJ = $(O)dlb.o
+
+TTYOBJ = $(O)topl.o     $(O)getline.o  $(O)wintty.o
+
+SOBJ   = $(O)winnt.o    $(O)sys.o      $(O)nttty.o    $(O)unix.o  \
+	   $(SOUND) 	$(O)mapimail.o $(O)nhlan.o
+
+OBJS   = $(VOBJ01) $(VOBJ02) $(VOBJ03) $(VOBJ04) $(VOBJ05) \
+         $(VOBJ06) $(VOBJ07) $(VOBJ08) $(VOBJ09) $(VOBJ10) \
+         $(VOBJ11) $(VOBJ12) $(VOBJ13) $(VOBJ14) $(VOBJ15) \
+         $(VOBJ16) $(VOBJ17) $(VOBJ18) $(VOBJ19) $(VOBJ20) \
+         $(VOBJ21) $(VOBJ22) $(VOBJ23) $(VOBJ24) $(VOBJ25) \
+         $(VOBJ26) $(VOBJ27)
+
+TILOBJ = $(TILEGAME)
+
+VVOBJ  = $(O)version.o
+
+ALLOBJ  = $(TILOBJ) $(SOBJ) $(DLBOBJ)  $(TTYOBJ) $(WOBJ) $(OBJS) $(VVOBJ)
+
+#
+# Header objects
+#
+
+#NTCONF_H    = $(INCL)\ntwarn.h $(INCL)\ntconf.h $(INCL)\micro.h \
+NTCONF_H    = $(INCL)\ntconf.h $(INCL)\micro.h \
+	      $(INCL)\system.h $(INCL)\config.h
+PERMONST_H  = $(INCL)\monattk.h $(INCL)\monflag.h
+YOUPROP_H   = $(INCL)\prop.h $(PERMONST_H) $(INCL)\pm.h
+YOU_H       = $(INCL)\attrib.h $(INCL)\monst.h $(YOUPROP_H)
+DECL_H      = $(INCL)\quest.h $(INCL)\spell.h $(INCL)\color.h \
+              $(INCL)\obj.h $(YOU_H) $(INCL)\onames.h
+
+CONFIG_H    = $(INCL)\tradstdc.h $(INCL)\coord.h $(NTCONF_H)
+
+HACK_H      = $(CONFIG_H) $(INCL)\dungeon.h $(INCL)\align.h $(INCL)\monsym.h \
+              $(INCL)\mkroom.h $(INCL)\objclass.h $(DECL_H) $(INCL)\trap.h \
+              $(INCL)\flag.h $(INCL)\rm.h $(INCL)\vision.h $(INCL)\mondata.h \
+              $(INCL)\wintype.h $(INCL)\engrave.h $(INCL)\rect.h \
+              $(INCL)\winprocs.h $(INCL)\trampoli.h \
+              $(INCL)\align.h 
+TILE_H      = ..\win\share\tile.h
+ALIGN_H     = $(INCL)\align.h
+ARTIFACT_H  = $(INCL)\artifact.h
+ARTILIST_H  = $(INCL)\artilist.h
+COLOR_H     = $(INCL)\color.h
+DATE_H      = $(INCL)\date.h
+DLB_H       = $(INCL)\dlb.h
+DGN_FILE_H  = $(INCL)\dgn_file.h
+EMIN_H      = $(INCL)\emin.h
+EPRI_H      = $(INCL)\epri.h
+ESHK_H      = $(INCL)\eshk.h
+EDOG_H      = $(INCL)\edog.h
+FUNC_TAB_H  = $(INCL)\func_tab.h
+LEV_H       = $(INCL)\lev.h
+LEV_COMP_H  = $(INCL)\lev_comp.h
+MAIL_H      = $(INCL)\mail.h
+MFNDPOS_H   = $(INCL)\mfndpos.h
+MONSYM_H    = $(INCL)\monsym.h
+NHLAN_H     = $(INCL)\nhlan.h
+OBJ_H       = $(INCL)\obj.h
+OBJCLASS_H  = $(INCL)\objclass.h
+OBJECTS_H   = $(INCL)\objects.h
+PROP_H      = $(INCL)\prop.h
+QTEXT_H     = $(INCL)\qtext.h
+QUEST_H     = $(INCL)\quest.h
+SKILLS_H    = $(INCL)\skills.h
+SP_LEV_H    = $(INCL)\sp_lev.h
+TERMCAP_H   = $(INCL)\tcap.h
+VAULT_H     = $(INCL)\vault.h
+VIS_TAB_H   = $(INCL)\vis_tab.h
+WINTTY_H    = $(INCL)\wintty.h
+WIN32API_H  = $(INCL)\win32api.h
+WIN32_H     = $(INCL)\nhwin32.h
+PATCHLEVEL_H   = $(INCL)\patchlevel.h
+
+DATABASE = $(DAT)\data.base
+
+#
+#  The name of the game.
+#
+
+GAMEFILE = $(GAMEDIR)\$(GAME).exe
+
+
+#######################################################################
+#
+#  TARGETS
+
+#
+#  The default make target (so just typing 'nmake' is useful).
+#
+default : $(GAMEFILE)
+
+#
+#  The main target.
+#
+
+$(GAME): $(O)obj.tag $(O)utility.tag envchk $(GAMEFILE)
+	@echo $(GAME) is up to date.
+
+#
+#  Everything
+#
+
+all :	install
+
+install: envchk $(GAME) $(O)install.tag
+	 @echo Done.
+
+$(O)install.tag: 	$(DAT)\data	$(DAT)\rumors	 $(DAT)\dungeon \
+	 	$(DAT)\oracles	$(DAT)\quest.dat $(O)sp_lev.tag $(DLB)
+! IF ("$(USE_DLB)"=="Y")
+	copy nhdat                $(GAMEDIR)
+	copy $(DAT)\license       $(GAMEDIR)
+! ELSE
+	copy $(DAT)\*.            $(GAMEDIR)
+	copy $(DAT)\*.dat         $(GAMEDIR)
+	copy $(DAT)\*.lev         $(GAMEDIR)
+	if exist $(GAMEDIR)\makefile del $(GAMEDIR)\makefile
+! ENDIF
+	if exist $(DOC)\guidebook.txt copy $(DOC)\guidebook.txt $(GAMEDIR)\Guidebook.txt
+	if exist $(DOC)\nethack.txt copy $(DOC)\nethack.txt $(GAMEDIR)\NetHack.txt
+	if exist $(DOC)\recover.txt copy $(DOC)\recover.txt $(GAMEDIR)\recover.txt
+	@if exist $(SRC)\$(GAME).PDB copy $(SRC)\$(GAME).pdb $(GAMEDIR)\$(GAME).pdb
+	@if exist $(SRC)\$(GAME).PDB echo NOTE: You may want to remove $(GAMEDIR)\$(GAME).pdb to conserve space
+	-copy $(NTSYS)\winnt.cnf   $(GAMEDIR)\defaults.nh
+	copy $(U)recover.exe  $(GAMEDIR)
+! IF ("$(TILEDEF)"!="")
+        if exist $(TILEBMP) copy $(TILEBMP) $(GAMEDIR)
+! ENDIF
+	echo install done > $@
+
+#	copy $(NTSYS)\winnt.hlp    $(GAMEDIR)
+
+$(O)sp_lev.tag: $(O)utility.tag $(DAT)\bigroom.des  $(DAT)\castle.des \
+	$(DAT)\endgame.des $(DAT)\gehennom.des $(DAT)\knox.des   \
+	$(DAT)\medusa.des  $(DAT)\oracle.des   $(DAT)\tower.des  \
+	$(DAT)\yendor.des  $(DAT)\arch.des     $(DAT)\barb.des   \
+	$(DAT)\caveman.des $(DAT)\healer.des   $(DAT)\knight.des \
+	$(DAT)\monk.des    $(DAT)\priest.des   $(DAT)\ranger.des \
+	$(DAT)\rogue.des   $(DAT)\samurai.des  $(DAT)\sokoban.des \
+	$(DAT)\tourist.des $(DAT)\valkyrie.des $(DAT)\wizard.des
+	cd $(DAT)
+	$(U)lev_comp bigroom.des
+	$(U)lev_comp castle.des
+	$(U)lev_comp endgame.des
+	$(U)lev_comp gehennom.des
+	$(U)lev_comp knox.des
+	$(U)lev_comp mines.des
+	$(U)lev_comp medusa.des
+	$(U)lev_comp oracle.des
+	$(U)lev_comp sokoban.des
+	$(U)lev_comp tower.des
+	$(U)lev_comp yendor.des
+	$(U)lev_comp arch.des
+	$(U)lev_comp barb.des
+	$(U)lev_comp caveman.des
+	$(U)lev_comp healer.des
+	$(U)lev_comp knight.des
+	$(U)lev_comp monk.des
+	$(U)lev_comp priest.des
+	$(U)lev_comp ranger.des
+	$(U)lev_comp rogue.des
+	$(U)lev_comp samurai.des
+	$(U)lev_comp tourist.des
+	$(U)lev_comp valkyrie.des
+	$(U)lev_comp wizard.des
+	cd $(SRC)
+	echo sp_levs done > $(O)sp_lev.tag
+
+$(O)utility.tag: $(INCL)\date.h $(INCL)\onames.h $(INCL)\pm.h \
+		$(SRC)\monstr.c		$(SRC)\vis_tab.c  \
+		$(U)lev_comp.exe	$(VIS_TAB_H) \
+		$(U)dgn_comp.exe $(U)recover.exe  $(TILEUTIL)
+             @echo utilities made >$@
+	     @echo utilities made.
+
+tileutil: $(U)gif2txt.exe $(U)txt2ppm.exe
+	@echo Optional tile development utilities are up to date.
+
+#  The section for linking the NetHack image looks a little strange at 
+#  first, especially if you are used to UNIX makes, or NDMAKE.  It is 
+#  Microsoft nmake specific, and it gets around the problem of the 
+#  link command line being too long for the linker.  An "in-line" linker 
+#  response file is generated temporarily.
+#
+#  It takes advantage of the following features of nmake:
+#
+#  Inline files : 
+#			Specifying the "<<" means to start an inline file.
+#                 	Another "<<" at the start of a line closes the 
+#                 	inline file.
+#
+#  Substitution within Macros:
+#                       $(mymacro:string1=string2) replaces every
+#                       occurrence of string1 with string2 in the 
+#                       macro mymacro.  Special ascii key codes may be 
+#                       used in the substitution text by preceding it 
+#                       with ^ as we have done below.  Every occurence
+#                       of a <tab> in $(ALLOBJ) is replaced by 
+#                       <+><return><tab>.
+#
+#  DO NOT INDENT THE << below!
+#
+
+#
+#  The main target.
+#
+
+$(GAMEFILE) : $(ALLOBJ)
+	@echo Linking....
+	@$(link) $(LFLAGSG) -out:$@ @<<$(GAME).lnk
+		$(ALLOBJ:^	=^
+		) 
+<<
+	@if exist $(O)install.tag del $(O)install.tag
+	@if exist $(GAMEDIR)\$(GAME).bak del $(GAMEDIR)\$(GAME).bak
+
+$(GAME)_.ico : $(NTSYS)\$(GAME).ico
+	@copy $(NTSYS)\$(GAME).ico $@
+#
+#  Secondary Targets.
+#
+    
+#
+# Makedefs Stuff
+#
+
+$(U)makedefs.exe:	$(MAKEOBJS)
+	@$(link) $(LFLAGSU) -out:$@ $(MAKEOBJS)
+
+$(O)makedefs.o: $(CONFIG_H)	$(PERMONST_H)   $(OBJCLASS_H) \
+		 $(MONSYM_H)    $(QTEXT_H)	$(PATCHLEVEL_H) \
+		 $(U)makedefs.c
+	@$(cc) $(CFLAGSU) $(NTSUB) -Fo$@ $(U)makedefs.c
+
+#
+#  date.h should be remade every time any of the source or include
+#  files is modified.
+#
+
+$(INCL)\date.h : $(U)makedefs.exe
+	$(U)makedefs -v
+
+$(INCL)\onames.h : $(U)makedefs.exe
+	$(U)makedefs -o
+
+$(INCL)\pm.h : $(U)makedefs.exe
+	$(U)makedefs -p
+
+#$(INCL)\trap.h : $(U)makedefs.exe
+#	$(U)makedefs -t
+
+$(SRC)\monstr.c: $(U)makedefs.exe
+	$(U)makedefs -m
+
+$(INCL)\vis_tab.h: $(U)makedefs.exe
+	$(U)makedefs -z
+
+$(SRC)\vis_tab.c: $(U)makedefs.exe
+	$(U)makedefs -z
+
+#
+# Level Compiler Stuff
+#
+
+LEVCFLAGS=-c -nologo -DWINVER=0x0400 -DWIN32 -D_WIN32 -D_MT -MT -I..\include -nologo -Z7 -Od -DDLB
+
+$(U)lev_comp.exe: $(SPLEVOBJS)
+	@echo Linking $@...
+	@$(link) $(LFLAGSU) -out:$@ @<<$(@B).lnk
+ 		$(SPLEVOBJS:^	=^
+		)
+<<
+
+$(O)lev_yacc.o: $(HACK_H)   $(SP_LEV_H) $(INCL)\lev_comp.h $(U)lev_yacc.c
+	@$(cc) $(LEVCFLAGS) -W0 $(NTSUB) -Fo$@ $(U)lev_yacc.c
+
+$(O)lev_$(LEX).o: $(HACK_H)   $(INCL)\lev_comp.h $(SP_LEV_H) \
+               $(U)lev_$(LEX).c
+	@$(cc) $(LEVCFLAGS) -W0 $(NTSUB) -Fo$@ $(U)lev_$(LEX).c
+
+$(O)lev_main.o:	$(U)lev_main.c $(HACK_H)   $(SP_LEV_H)
+	@$(cc) $(LEVCFLAGS) -W0 $(NTSUB) -Fo$@ $(U)lev_main.c
+
+
+$(U)lev_yacc.c $(INCL)\lev_comp.h : $(U)lev_comp.y
+!	IF "$(DO_YACC)"=="YACC_ACT"
+	   chdir $(UTIL)
+	   $(YACC) -d lev_comp.y
+	   copy $(YTABC) lev_yacc.c
+	   copy $(YTABH) $(INCL)\lev_comp.h
+	   @del $(YTABC)
+	   @del $(YTABH)
+	   chdir $(SRC)
+!	ELSE
+	   @echo $(U)lev_comp.y has changed.
+	   @echo To update $(U)lev_yacc.c and $(INCL)\lev_comp.h run $(YACC).
+	   @echo ---
+	   @echo For now, we will copy the prebuilt lev_yacc.c and 
+	   @echo lev_comp.h from $(SSYS) into $(UTIL) and use them.
+	   @copy $(SSYS)\lev_yacc.c $(U)lev_yacc.c >nul
+	   @copy $(SSYS)\lev_comp.h $(INCL)\lev_comp.h >nul
+	   @echo /**/ >>$(U)lev_yacc.c
+	   @echo /**/ >>$(INCL)\lev_comp.h
+!	ENDIF
+
+$(U)lev_$(LEX).c: $(U)lev_comp.l
+!	IF "$(DO_LEX)"=="LEX_ACT"
+	   chdir $(UTIL)
+	   $(LEX) $(FLEXSKEL) lev_comp.l
+	   copy $(LEXYYC) $@
+	   @del $(LEXYYC)
+	   chdir $(SRC)
+!	ELSE
+	   @echo $(U)lev_comp.l has changed. To update $@ run $(LEX).
+	   @echo ---
+	   @echo For now, we will copy the prebuilt lev_lex.c 
+	   @echo from $(SSYS) into $(UTIL) and use it.
+	   @copy $(SSYS)\lev_lex.c $@ >nul
+	   @echo /**/ >>$@
+!	ENDIF
+
+#
+# Dungeon Stuff
+#
+
+$(U)dgn_comp.exe: $(DGNCOMPOBJS)
+    @echo Linking $@...
+	@$(link) $(LFLAGSU) -out:$@ @<<$(@B).lnk
+		$(DGNCOMPOBJS:^	=^
+		)
+<<
+
+$(O)dgn_yacc.o:	$(HACK_H)   $(DGN_FILE_H) $(INCL)\dgn_comp.h $(U)dgn_yacc.c
+	@$(cc) $(LEVCFLAGS) -W0 $(NTSUB) -Fo$@ $(U)dgn_yacc.c
+
+$(O)dgn_$(LEX).o: $(HACK_H)   $(DGN_FILE_H)  $(INCL)\dgn_comp.h \
+	$(U)dgn_$(LEX).c
+	@$(cc) $(LEVCFLAGS) -W0 $(NTSUB) -Fo$@ $(U)dgn_$(LEX).c
+
+$(O)dgn_main.o:	$(HACK_H) $(U)dgn_main.c
+	@$(cc) $(LEVCFLAGS) -W0 $(NTSUB) -Fo$@ $(U)dgn_main.c
+
+$(U)dgn_yacc.c $(INCL)\dgn_comp.h : $(U)dgn_comp.y
+!	IF "$(DO_YACC)"=="YACC_ACT"
+	   chdir $(UTIL)
+	   $(YACC) -d dgn_comp.y
+	   copy $(YTABC) dgn_yacc.c
+	   copy $(YTABH) $(INCL)\dgn_comp.h
+	   @del $(YTABC)
+	   @del $(YTABH)
+	   chdir $(SRC)
+!	ELSE
+	   @echo $(U)dgn_comp.y has changed. To update dgn_yacc.c and 
+	   @echo $(INCL)\dgn_comp.h run $(YACC).
+	   @echo ---
+	   @echo For now, we will copy the prebuilt $(U)dgn_yacc.c and 
+	   @echo dgn_comp.h from $(SSYS) into $(UTIL) and use them.
+	   @copy $(SSYS)\dgn_yacc.c $(U)dgn_yacc.c >nul
+	   @copy $(SSYS)\dgn_comp.h $(INCL)\dgn_comp.h >nul
+	   @echo /**/ >>$(U)dgn_yacc.c
+	   @echo /**/ >>$(INCL)\dgn_comp.h
+!	ENDIF
+
+$(U)dgn_$(LEX).c: $(U)dgn_comp.l
+!	IF "$(DO_LEX)"=="LEX_ACT"
+	   chdir $(UTIL)
+	   $(LEX) $(FLEXSKEL)  dgn_comp.l
+	   copy $(LEXYYC) $@
+	   @del $(LEXYYC)
+	   chdir $(SRC)
+!	ELSE
+	   @echo $(U)dgn_comp.l has changed. To update $@ run $(LEX).
+	   @echo ---
+	   @echo For now, we will copy the prebuilt dgn_lex.c 
+	   @echo from $(SSYS) into $(UTIL) and use it.
+	   @copy $(SSYS)\dgn_lex.c $@ >nul
+	   @echo /**/ >>$@
+!	ENDIF
+
+
+$(O)obj.tag:
+	@if not exist $(O)*.* mkdir $(OBJ)
+	@echo directory $(OBJ) created >$@
+
+#
+#
+envchk:
+!	IF "$(CL)"!=""
+	   @echo Warning, the CL Environment variable is defined:
+	   @echo CL=$(CL)
+!	ENDIF
+!	IF "$(TILEGAME)"!=""
+	   @echo ----
+	   @echo NOTE: This build will include tile support.
+	   @echo ----
+!	ENDIF
+
+#
+# SECONDARY TARGETS
+#
+
+#
+# Header files NOT distributed in ..\include
+#
+
+$(INCL)\win32api.h: $(NTSYS)\win32api.h
+	copy $(NTSYS)\win32api.h $@
+
+#
+#  Recover Utility
+#
+
+$(U)recover.exe: $(RECOVOBJS)
+	@$(link) $(LFLAGSU) -out:$@ $(RECOVOBJS)
+
+#
+#  Tile Mapping
+#
+
+$(SRC)\tile.c: $(U)tilemap.exe
+	@echo A new $@ has been created
+	@$(U)tilemap
+
+$(U)tilemap.exe: $(O)tilemap.o
+	@$(link) $(LFLAGSU) -out:$@ $(O)tilemap.o
+
+$(O)tilemap.o: $(WSHR)\tilemap.c $(HACK_H)
+	@$(cc) $(CFLAGSU) $(NTSUB) -Fo$@ $(WSHR)\tilemap.c
+
+
+#
+# Tile Utilities
+#
+
+#
+#  Optional (for development)
+#
+
+$(U)gif2txt.exe: $(GIFREADERS) $(TEXT_IO)
+    @echo Linking $@...
+	@$(link) $(LFLAGSU) -out:$@ @<<$(@B).lnk
+		$(GIFREADERS:^	=^
+		)
+		$(TEXT_IO:^	=^
+		)
+<<
+
+$(U)txt2ppm.exe: $(PPMWRITERS) $(TEXT_IO)
+    @echo Linking $@...
+	@$(link) $(LFLAGSU) -out:$@ @<<$(@B).lnk
+		$(PPMWRITERS:^	=^
+		)
+		$(TEXT_IO:^	=^
+		)
+<<
+
+#
+#  Required for tile support
+#
+
+$(TILEBMP): $(TILEUTIL) $(TILEFILES)
+	@echo Creating binary tile files (this may take some time)
+	@$(U)tile2bmp $(TILEBMP)
+
+$(U)tile2bmp.exe: $(O)tile2bmp.o $(TEXT_IO)
+    @echo Linking $@...
+	@$(link) $(LFLAGSU) -out:$@ @<<$(@B).lnk
+		$(O)tile2bmp.o
+		$(TEXT_IO:^  =^
+		)
+<<
+
+$(O)tile2bmp.o: $(WIN32)\tile2bmp.c $(HACK_H) $(TILE_H) $(WIN32API_H)
+	@$(cc) $(CFLAGSG) -I$(WSHR) $(NTSUB) /DPACKED_FILE /Fo$@ $(WIN32)\tile2bmp.c
+
+#
+# DLB stuff
+#
+nhdat:	$(U)dlb_main.exe $(DAT)\data $(DAT)\oracles $(DAT)\options \
+	$(DAT)\quest.dat $(DAT)\rumors $(DAT)\help $(DAT)\hh $(DAT)\cmdhelp \
+	$(DAT)\history $(DAT)\opthelp $(DAT)\wizhelp $(DAT)\dungeon \
+	$(DAT)\license $(O)sp_lev.tag
+	cd $(DAT)
+	echo data >dlb.lst
+	echo oracles >>dlb.lst
+	echo options >>dlb.lst
+	echo quest.dat >>dlb.lst
+	echo rumors >>dlb.lst
+	echo help >>dlb.lst
+	echo hh >>dlb.lst
+	echo cmdhelp >>dlb.lst
+	echo history >>dlb.lst
+	echo opthelp >>dlb.lst
+	echo wizhelp >>dlb.lst
+	echo dungeon >>dlb.lst
+	echo license >>dlb.lst
+	for %%N in (*.lev) do echo %%N >>dlb.lst
+	$(U)dlb_main cIf dlb.lst $(SRC)\nhdat
+	cd $(SRC)
+
+$(U)dlb_main.exe: $(DLBOBJ) $(O)dlb.o
+	@$(link) $(LFLAGSU) -out:$@ @<<$(@B).lnk
+		$(O)dlb_main.o
+		$(O)dlb.o
+		$(O)alloc.o
+		$(O)panic.o
+<<
+
+$(O)dlb.o:	$(O)dlb_main.o $(O)alloc.o $(O)panic.o $(DLB_H)
+	@$(cc) $(CFLAGSG) $(NTSUB) /Fo$@ $(SRC)\dlb.c
+	
+$(O)dlb_main.o: $(UTIL)\dlb_main.c $(INCL)\config.h $(DLB_H)
+	@$(cc) $(CFLAGSG) $(NTSUB) /Fo$@ $(UTIL)\dlb_main.c
+
+#
+# Housekeeping
+#
+
+spotless: clean
+	rmdir $(OBJ)
+	if exist $(DATE_H)    del $(DATE_H)
+	if exist $(INCL)\onames.h  del $(INCL)\onames.h
+	if exist $(INCL)\pm.h      del $(INCL)\pm.h
+	if exist $(VIS_TAB_H) del $(VIS_TAB_H)
+	if exist $(SRC)\vis_tab.c  del $(SRC)\vis_tab.c
+	if exist $(SRC)\tile.c     del $(SRC)\tile.c
+	if exist $(U)*.lnk         del $(U)*.lnk
+	if exist $(U)*.map         del $(U)*.map
+	if exist $(DAT)\data       del $(DAT)\data
+	if exist $(DAT)\rumors     del $(DAT)\rumors
+	if exist $(DAT)\???-fil?.lev	del $(DAT)\???-fil?.lev
+	if exist $(DAT)\???-goal.lev	del $(DAT)\???-goal.lev
+	if exist $(DAT)\???-loca.lev	del $(DAT)\???-loca.lev
+	if exist $(DAT)\???-strt.lev	del $(DAT)\???-strt.lev
+	if exist $(DAT)\air.lev		del $(DAT)\air.lev
+	if exist $(DAT)\asmodeus.lev	del $(DAT)\asmodeus.lev
+	if exist $(DAT)\astral.lev	del $(DAT)\astral.lev
+	if exist $(DAT)\baalz.lev	del $(DAT)\baalz.lev
+	if exist $(DAT)\bigroom.lev	del $(DAT)\bigroom.lev
+	if exist $(DAT)\castle.lev	del $(DAT)\castle.lev
+	if exist $(DAT)\data		del $(DAT)\data
+	if exist $(DAT)\dungeon		del $(DAT)\dungeon
+	if exist $(DAT)\dungeon.pdf	del $(DAT)\dungeon.pdf
+	if exist $(DAT)\earth.lev	del $(DAT)\earth.lev
+	if exist $(DAT)\fakewiz?.lev	del $(DAT)\fakewiz?.lev
+	if exist $(DAT)\fire.lev	del $(DAT)\fire.lev
+	if exist $(DAT)\juiblex.lev	del $(DAT)\juiblex.lev
+	if exist $(DAT)\knox.lev	del $(DAT)\knox.lev
+	if exist $(DAT)\medusa-?.lev	del $(DAT)\medusa-?.lev
+	if exist $(DAT)\mine*.lev	del $(DAT)\mine*.lev
+	if exist $(DAT)\options		del $(DAT)\options
+	if exist $(DAT)\oracle.lev	del $(DAT)\oracle.lev
+	if exist $(DAT)\oracles		del $(DAT)\oracles
+	if exist $(DAT)\orcus.lev	del $(DAT)\orcus.lev
+	if exist $(DAT)\rumors		del $(DAT)\rumors
+	if exist $(DAT)\quest.dat	del $(DAT)\quest.dat
+	if exist $(DAT)\sanctum.lev	del $(DAT)\sanctum.lev
+	if exist $(DAT)\soko?-?.lev	del $(DAT)\soko?-?.lev
+	if exist $(DAT)\tower?.lev	del $(DAT)\tower?.lev
+	if exist $(DAT)\valley.lev	del $(DAT)\valley.lev
+	if exist $(DAT)\water.lev	del $(DAT)\water.lev
+	if exist $(DAT)\wizard?.lev	del $(DAT)\wizard?.lev
+	if exist $(O)sp_lev.tag	        del $(O)sp_lev.tag
+	if exist $(SRC)\monstr.c        del $(SRC)\monstr.c
+	if exist $(SRC)\vis_tab.c       del $(SRC)\vis_tab.c
+	if exist $(U)recover.exe        del $(U)recover.exe
+
+clean:
+	if exist $(O)*.o del $(O)*.o
+	if exist $(O)utility.tag   del $(O)utility.tag
+	if exist $(U)makedefs.exe  del $(U)makedefs.exe
+	if exist $(U)lev_comp.exe  del $(U)lev_comp.exe
+	if exist $(U)dgn_comp.exe  del $(U)dgn_comp.exe
+	if exist $(SRC)\*.lnk      del $(SRC)\*.lnk
+	if exist $(SRC)\*.map      del $(SRC)\*.map
+! IF ("$(TILEDEF)"!="")
+	if exist $(TILEBMP)        del $(TILEBMP)
+! ENDIF
+
+#
+# OTHER DEPENDENCIES
+#
+
+#
+# dat dependencies
+#
+
+$(DAT)\data: $(O)utility.tag    $(DATABASE)
+	$(U)makedefs -d
+
+$(DAT)\rumors: $(O)utility.tag    $(DAT)\rumors.tru   $(DAT)\rumors.fal
+	$(U)makedefs -r
+
+$(DAT)\quest.dat: $(O)utility.tag  $(DAT)\quest.txt
+	$(U)makedefs -q
+
+$(DAT)\oracles: $(O)utility.tag    $(DAT)\oracles.txt
+	$(U)makedefs -h
+
+$(DAT)\dungeon: $(O)utility.tag  $(DAT)\dungeon.def
+	$(U)makedefs -e
+	cd $(DAT)
+	$(U)dgn_comp dungeon.pdf
+	cd $(SRC)
+
+#
+#  Util Dependencies.
+#
+
+$(O)panic.o:  $(U)panic.c $(CONFIG_H)
+	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@ $(U)panic.c
+
+$(O)recover.o: $(CONFIG_H) $(U)recover.c $(INCL)\win32api.h
+	@$(cc) $(CFLAGSU) $(NTSUB) -Fo$@ $(U)recover.c
+
+#
+#  from win\share
+#
+
+$(O)tiletxt.o: $(WSHR)\tilemap.c $(HACK_H)
+	@$(cc) $(CFLAGSG) $(NTSUB) /DTILETEXT -Fo$@ $(WSHR)\tilemap.c
+
+$(O)gifread.o: $(WSHR)\gifread.c  $(CONFIG_H) $(TILE_H)
+	@$(cc) $(CFLAGSG) -I$(WSHR) $(NTSUB) -Fo$@ $(WSHR)\gifread.c
+
+$(O)ppmwrite.o: $(WSHR)\ppmwrite.c $(CONFIG_H) $(TILE_H)
+	@$(cc) $(CFLAGSG) -I$(WSHR) $(NTSUB) -Fo$@ $(WSHR)\ppmwrite.c
+
+$(O)tiletext.o: $(WSHR)\tiletext.c  $(CONFIG_H) $(TILE_H)
+	@$(cc) $(CFLAGSG) -I$(WSHR) $(NTSUB) -Fo$@ $(WSHR)\tiletext.c
+
+#
+#  from win\tty
+#
+$(O)getline.o: $(TTY)\getline.c $(HACK_H) $(INCL)\func_tab.h
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(TTY)\getline.c
+$(O)termcap.o: $(TTY)\termcap.c $(HACK_H) $(INCL)\tcap.h
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(TTY)\termcap.c
+$(O)topl.o: $(TTY)\topl.c $(HACK_H) $(INCL)\tcap.h
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(TTY)\topl.c
+$(O)wintty.o: $(TTY)\wintty.c $(HACK_H) $(INCL)\dlb.h \
+		$(INCL)\patchlevel.h $(INCL)\tcap.h
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(TTY)\wintty.c
+
+#
+# from sys\share
+#
+$(O)main.o: $(SSYS)\pcmain.c $(HACK_H) $(INCL)\dlb.h
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(SSYS)\pcmain.c
+$(O)sys.o: $(SSYS)\pcsys.c $(HACK_H)
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(SSYS)\pcsys.c
+$(O)tty.o: $(SSYS)\pctty.c $(HACK_H)
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(SSYS)\pctty.c
+$(O)unix.o: $(SSYS)\pcunix.c $(HACK_H)
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(SSYS)\pcunix.c
+$(O)random.o: $(SSYS)\random.c $(HACK_H)
+	@$(CC) $(CFLAGSG) $(NTSUB) -Fo$@ $(SSYS)\random.c
+$(O)nhlan.o:	$(HACK_H) $(NHLAN_H) $(SSYS)\nhlan.c
+	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@ $(SSYS)\nhlan.c
+
+
+#
+# from sys\winnt
+#
+
+$(O)nttty.o:   $(NTSYS)\nttty.c   $(HACK_H) $(WINTTY_H) \
+                $(TILE_H) $(WIN32API_H)
+	@$(cc) $(CFLAGSG) -I$(WSHR) $(NTSUB) -Fo$@  $(NTSYS)\nttty.c
+$(O)winnt.o: $(NTSYS)\winnt.c   $(HACK_H) $(WIN32API_H)
+	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@  $(NTSYS)\winnt.c
+$(O)ntsound.o: $(NTSYS)\ntsound.c   $(HACK_H)
+	@$(cc) $(CFLAGSG)  $(NTSUB) -Fo$@ $(NTSYS)\ntsound.c
+$(O)mapimail.o: $(NTSYS)\mapimail.c   $(HACK_H) $(NHLAN_H)
+	@$(cc) $(CFLAGSG) -DMAPI_VERBOSE  $(NTSUB) -Fo$@ $(NTSYS)\mapimail.c
+
+#
+# from src
+#
+
+#$(O)alloc.o: $(SRC)\alloc.c    $(CONFIG_H)
+#	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@ $(SRC)\alloc.c
+#$(O)end.o: $(SRC)\end.c      $(HACK_H) $(ESHK_H) $(DLB_H)
+#	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@ $(SRC)\end.c
+#$(O)version.o: $(SRC)\version.c  $(HACK_H) $(DATE_H)  $(PATCHLEVEL_H)
+#	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@ $(SRC)\version.c
+#$(O)vis_tab.o: $(SRC)\vis_tab.c  $(HACK_H) $(VIS_TAB_H)
+#	@$(cc) $(CFLAGSG) $(NTSUB) -Fo$@ $(SRC)\vis_tab.c
+
+$(O)allmain.o: $(SRC)\allmain.c $(HACK_H)
+$(O)alloc.o: $(SRC)\alloc.c $(CONFIG_H)
+$(O)apply.o: $(SRC)\apply.c $(HACK_H) $(INCL)\edog.h
+$(O)artifact.o: $(SRC)\artifact.c $(HACK_H) $(INCL)\artifact.h $(INCL)\artilist.h
+$(O)attrib.o: $(SRC)\attrib.c $(HACK_H) $(INCL)\artifact.h
+$(O)ball.o: $(SRC)\ball.c $(HACK_H)
+$(O)bones.o: $(SRC)\bones.c $(HACK_H) $(INCL)\lev.h
+$(O)botl.o: $(SRC)\botl.c $(HACK_H)
+$(O)cmd.o: $(SRC)\cmd.c $(HACK_H) $(INCL)\func_tab.h
+$(O)dbridge.o: $(SRC)\dbridge.c $(HACK_H)
+$(O)decl.o: $(SRC)\decl.c $(HACK_H)
+$(O)detect.o: $(SRC)\detect.c $(HACK_H) $(INCL)\artifact.h
+$(O)dig.o: $(SRC)\dig.c $(HACK_H) $(INCL)\edog.h
+$(O)display.o: $(SRC)\display.c $(HACK_H)
+$(O)dlb.o: $(SRC)\dlb.c $(CONFIG_H) $(INCL)\dlb.h
+$(O)do.o: $(SRC)\do.c $(HACK_H) $(INCL)\lev.h
+$(O)do_name.o: $(SRC)\do_name.c $(HACK_H)
+$(O)do_wear.o: $(SRC)\do_wear.c $(HACK_H)
+$(O)dog.o: $(SRC)\dog.c $(HACK_H) $(INCL)\edog.h
+$(O)dogmove.o: $(SRC)\dogmove.c $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
+$(O)dokick.o: $(SRC)\dokick.c $(HACK_H) $(INCL)\eshk.h
+$(O)dothrow.o: $(SRC)\dothrow.c $(HACK_H)
+$(O)drawing.o: $(SRC)\drawing.c $(HACK_H) $(INCL)\tcap.h
+$(O)dungeon.o: $(SRC)\dungeon.c $(HACK_H) $(INCL)\dgn_file.h $(INCL)\dlb.h
+$(O)eat.o: $(SRC)\eat.c $(HACK_H)
+$(O)end.o: $(SRC)\end.c $(HACK_H) $(INCL)\eshk.h $(INCL)\dlb.h
+$(O)engrave.o: $(SRC)\engrave.c $(HACK_H) $(INCL)\lev.h
+$(O)exper.o: $(SRC)\exper.c $(HACK_H)
+$(O)explode.o: $(SRC)\explode.c $(HACK_H)
+$(O)extralev.o: $(SRC)\extralev.c $(HACK_H)
+$(O)files.o: $(SRC)\files.c $(HACK_H) $(INCL)\dlb.h
+$(O)fountain.o: $(SRC)\fountain.c $(HACK_H)
+$(O)hack.o: $(SRC)\hack.c $(HACK_H)
+$(O)hacklib.o: $(SRC)\hacklib.c $(HACK_H)
+$(O)invent.o: $(SRC)\invent.c $(HACK_H) $(INCL)\artifact.h
+$(O)light.o: $(SRC)\light.c $(HACK_H) $(INCL)\lev.h
+$(O)lock.o: $(SRC)\lock.c $(HACK_H)
+$(O)mail.o: $(SRC)\mail.c $(HACK_H) $(INCL)\mail.h
+$(O)makemon.o: $(SRC)\makemon.c $(HACK_H) $(INCL)\epri.h $(INCL)\emin.h \
+		$(INCL)\edog.h
+$(O)mcastu.o: $(SRC)\mcastu.c $(HACK_H)
+$(O)mhitm.o: $(SRC)\mhitm.c $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
+$(O)mhitu.o: $(SRC)\mhitu.c $(HACK_H) $(INCL)\artifact.h $(INCL)\edog.h
+$(O)minion.o: $(SRC)\minion.c $(HACK_H) $(INCL)\emin.h $(INCL)\epri.h
+$(O)mklev.o: $(SRC)\mklev.c $(HACK_H)
+$(O)mkmap.o: $(SRC)\mkmap.c $(HACK_H) $(INCL)\sp_lev.h
+$(O)mkmaze.o: $(SRC)\mkmaze.c $(HACK_H) $(INCL)\sp_lev.h $(INCL)\lev.h
+$(O)mkobj.o: $(SRC)\mkobj.c $(HACK_H) $(INCL)\artifact.h
+$(O)mkroom.o: $(SRC)\mkroom.c $(HACK_H)
+$(O)mon.o: $(SRC)\mon.c $(HACK_H) $(INCL)\mfndpos.h $(INCL)\edog.h
+$(O)mondata.o: $(SRC)\mondata.c $(HACK_H) $(INCL)\eshk.h $(INCL)\epri.h
+$(O)monmove.o: $(SRC)\monmove.c $(HACK_H) $(INCL)\mfndpos.h $(INCL)\artifact.h
+$(O)monst.o: $(SRC)\monst.c $(CONFIG_H) $(INCL)\permonst.h $(INCL)\align.h \
+		$(INCL)\monattk.h $(INCL)\monflag.h $(INCL)\monsym.h \
+		$(INCL)\dungeon.h $(INCL)\eshk.h $(INCL)\vault.h \
+		$(INCL)\epri.h $(INCL)\color.h
+$(O)mplayer.o: $(SRC)\mplayer.c $(HACK_H)
+$(O)mthrowu.o: $(SRC)\mthrowu.c $(HACK_H)
+$(O)muse.o: $(SRC)\muse.c $(HACK_H) $(INCL)\edog.h
+$(O)music.o: $(SRC)\music.c $(HACK_H) #interp.c
+$(O)o_init.o: $(SRC)\o_init.c $(HACK_H) $(INCL)\lev.h
+$(O)objects.o: $(SRC)\objects.c $(CONFIG_H) $(INCL)\obj.h $(INCL)\objclass.h \
+		$(INCL)\prop.h $(INCL)\skills.h $(INCL)\color.h
+$(O)objnam.o: $(SRC)\objnam.c $(HACK_H)
+$(O)options.o: $(SRC)\options.c $(CONFIG_H) $(INCL)\objclass.h $(INCL)\flag.h \
+		$(HACK_H) $(INCL)\tcap.h
+$(O)pager.o: $(SRC)\pager.c $(HACK_H) $(INCL)\dlb.h
+$(O)pickup.o: $(SRC)\pickup.c $(HACK_H)
+$(O)pline.o: $(SRC)\pline.c $(HACK_H) $(INCL)\epri.h
+$(O)polyself.o: $(SRC)\polyself.c $(HACK_H)
+$(O)potion.o: $(SRC)\potion.c $(HACK_H)
+$(O)pray.o: $(SRC)\pray.c $(HACK_H) $(INCL)\epri.h
+$(O)priest.o: $(SRC)\priest.c $(HACK_H) $(INCL)\mfndpos.h $(INCL)\eshk.h \
+		$(INCL)\epri.h $(INCL)\emin.h
+$(O)quest.o: $(SRC)\quest.c $(HACK_H) $(INCL)\qtext.h
+$(O)questpgr.o: $(SRC)\questpgr.c $(HACK_H) $(INCL)\dlb.h $(INCL)\qtext.h
+$(O)read.o: $(SRC)\read.c $(HACK_H)
+$(O)rect.o: $(SRC)\rect.c $(HACK_H)
+$(O)region.o: $(SRC)\region.c $(HACK_H)
+$(O)restore.o: $(SRC)\restore.c $(HACK_H) $(INCL)\lev.h $(INCL)\tcap.h
+$(O)rip.o: $(SRC)\rip.c $(HACK_H)
+$(O)rnd.o: $(SRC)\rnd.c $(HACK_H)
+$(O)role.o: $(SRC)\role.c $(HACK_H)
+$(O)rumors.o: $(SRC)\rumors.c $(HACK_H) $(INCL)\lev.h $(INCL)\dlb.h
+$(O)save.o: $(SRC)\save.c $(HACK_H) $(INCL)\lev.h
+$(O)shk.o: $(SRC)\shk.c $(HACK_H) $(INCL)\eshk.h
+$(O)shknam.o: $(SRC)\shknam.c $(HACK_H) $(INCL)\eshk.h
+$(O)sit.o: $(SRC)\sit.c $(HACK_H) $(INCL)\artifact.h
+$(O)sounds.o: $(SRC)\sounds.c $(HACK_H) $(INCL)\edog.h
+$(O)sp_lev.o: $(SRC)\sp_lev.c $(HACK_H) $(INCL)\dlb.h $(INCL)\sp_lev.h
+$(O)spell.o: $(SRC)\spell.c $(HACK_H)
+$(O)steal.o: $(SRC)\steal.c $(HACK_H)
+$(O)steed.o: $(SRC)\steed.c $(HACK_H)
+$(O)teleport.o: $(SRC)\teleport.c $(HACK_H)
+$(O)timeout.o: $(SRC)\timeout.c $(HACK_H) $(INCL)\lev.h
+$(O)topten.o: $(SRC)\topten.c $(HACK_H) $(INCL)\dlb.h $(INCL)\patchlevel.h
+$(O)track.o: $(SRC)\track.c $(HACK_H)
+$(O)trap.o: $(SRC)\trap.c $(HACK_H)
+$(O)u_init.o: $(SRC)\u_init.c $(HACK_H)
+$(O)uhitm.o: $(SRC)\uhitm.c $(HACK_H)
+$(O)vault.o: $(SRC)\vault.c $(HACK_H) $(INCL)\vault.h
+$(O)version.o: $(SRC)\version.c $(HACK_H) $(INCL)\date.h $(INCL)\patchlevel.h
+$(O)vision.o: $(SRC)\vision.c $(HACK_H) $(INCL)\vis_tab.h
+$(O)weapon.o: $(SRC)\weapon.c $(HACK_H)
+$(O)were.o: $(SRC)\were.c $(HACK_H)
+$(O)wield.o: $(SRC)\wield.c $(HACK_H)
+$(O)windows.o: $(SRC)\windows.c $(HACK_H) $(INCL)\wingem.h
+$(O)wizard.o: $(SRC)\wizard.c $(HACK_H) $(INCL)\qtext.h
+$(O)worm.o: $(SRC)\worm.c $(HACK_H) $(INCL)\lev.h
+$(O)worn.o: $(SRC)\worn.c $(HACK_H)
+$(O)write.o: $(SRC)\write.c $(HACK_H)
+$(O)zap.o: $(SRC)\zap.c $(HACK_H)
+
+# end of file
diff -Pru nethack-3.4.1/sys/winnt/console.rc nethack/sys/winnt/console.rc
--- nethack-3.4.1/sys/winnt/console.rc	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/console.rc	Sun Mar  9 13:39:59 2003
@@ -1,4 +1,4 @@
-/*	SCCS Id: @(#)console.rc	3.4	$Date: 2002/07/24 08:25:20 $			*/
+/*	SCCS Id: @(#)console.rc	3.4	$Date: 2003/03/09 21:39:59 $			*/
 /* Copyright (c) Yitzhak Sapir, 2002. 					*/
 /* NetHack may be freely redistributed.  See license for details. 	*/
 
diff -Pru nethack-3.4.1/sys/winnt/mapimail.c nethack/sys/winnt/mapimail.c
--- nethack-3.4.1/sys/winnt/mapimail.c	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/mapimail.c	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-/*      SCCS Id: @(#)mapimail.c 3.4     $Date: 2002/07/24 08:25:20 $        */
+/*      SCCS Id: @(#)mapimail.c 3.4     $Date: 2003/03/09 21:40:00 $        */
 /* Copyright (c) Michael Allison, 1997                  */
 /* NetHack may be freely redistributed.  See license for details. */
 
diff -Pru nethack-3.4.1/sys/winnt/nhsetup.bat nethack/sys/winnt/nhsetup.bat
--- nethack-3.4.1/sys/winnt/nhsetup.bat	Sun Feb 23 06:43:49 2003
+++ nethack/sys/winnt/nhsetup.bat	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-@REM  SCCS Id: @(#)nhsetup.bat  3.4     $Date: 2002/07/24 08:25:21 $
+@REM  SCCS Id: @(#)nhsetup.bat  3.4     $Date: 2003/03/09 21:40:00 $
 @REM  Copyright (c) NetHack PC Development Team 1993, 1996, 2002
 @REM  NetHack may be freely redistributed.  See license for details. 
 @REM  Win32 setup batch file, see Install.nt for details
diff -Pru nethack-3.4.1/sys/winnt/ntsound.c nethack/sys/winnt/ntsound.c
--- nethack-3.4.1/sys/winnt/ntsound.c	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/ntsound.c	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-/*   SCCS Id: @(#)ntsound.c   3.4     $Date: 2002/09/02 23:28:45 $                        */
+/*   SCCS Id: @(#)ntsound.c   3.4     $Date: 2003/03/09 21:40:00 $                        */
 /*   Copyright (c) NetHack PC Development Team 1993                 */
 /*   NetHack may be freely redistributed.  See license for details. */
 /*                                                                  */
diff -Pru nethack-3.4.1/sys/winnt/nttty.c nethack/sys/winnt/nttty.c
--- nethack-3.4.1/sys/winnt/nttty.c	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/nttty.c	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-/*	SCCS Id: @(#)nttty.c	3.4	$Date: 2003/02/06 03:04:37 $   */
+/*	SCCS Id: @(#)nttty.c	3.4	$Date: 2003/03/09 21:40:00 $   */
 /* Copyright (c) NetHack PC Development Team 1993    */
 /* NetHack may be freely redistributed.  See license for details. */
 
diff -Pru nethack-3.4.1/sys/winnt/win32api.h nethack/sys/winnt/win32api.h
--- nethack-3.4.1/sys/winnt/win32api.h	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/win32api.h	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-/*	SCCS Id: @(#)win32api.h	 3.4	 $Date: 2002/07/24 08:25:21 $		  */
+/*	SCCS Id: @(#)win32api.h	 3.4	 $Date: 2003/03/09 21:40:00 $		  */
 /* Copyright (c) NetHack PC Development Team 1996                 */
 /* NetHack may be freely redistributed.  See license for details. */
 
diff -Pru nethack-3.4.1/sys/winnt/winnt.c nethack/sys/winnt/winnt.c
--- nethack-3.4.1/sys/winnt/winnt.c	Sun Feb 23 06:43:43 2003
+++ nethack/sys/winnt/winnt.c	Sun Mar  9 13:40:00 2003
@@ -1,4 +1,4 @@
-/*	SCCS Id: @(#)winnt.c	 3.4	 $Date: 2002/08/21 15:21:50 $		  */
+/*	SCCS Id: @(#)winnt.c	 3.4	 $Date: 2003/03/09 21:40:00 $		  */
 /* Copyright (c) NetHack PC Development Team 1993, 1994 */
 /* NetHack may be freely redistributed.  See license for details. */
 
diff -Pru nethack-3.4.1/sys/winnt/winnt.cnf nethack/sys/winnt/winnt.cnf
--- nethack-3.4.1/sys/winnt/winnt.cnf	Wed Dec 31 16:00:00 1969
+++ nethack/sys/winnt/winnt.cnf	Thu Jan 10 16:43:33 2002
@@ -0,0 +1,106 @@
+# Sample config file for win32 NetHack
+# A '#' at the beginning of a line means the rest of the line is a comment.
+#
+# Some options MUST be set in this file, other options can be toggled while
+# playing.  For a list of options available see the <opthelp.> file.
+#
+# To change the configuration, comment out the unwanted lines, and
+# uncomment the configuration you want.
+
+# Use the IBM character set rather than just plain ascii characters.
+OPTIONS=IBMGraphics
+
+# *** OPTIONS ***
+# Some options to set personal preferences.  Uncomment and change these to
+# suit your personal preference.  If several people are to use the same
+# configuration, options like these should not be set.
+#
+#OPTIONS=name:Janet,role:Valkyrie,race:Human,gender:female,align:lawful
+#OPTIONS=dogname:Fido,catname:Morris,fruit:guava
+#OPTIONS=horsename:Silver
+#OPTIONS=autopickup,pickup_types:$"=/!?+
+#OPTIONS=packorder:")[%?+/=!(*0_`
+#OPTIONS=scores:10 top/2 around/own
+#OPTIONS=nolegacy,noverbose
+#OPTIONS=menustyle:traditional
+
+#
+# General options.  You might also set "silent" so as not to attract
+# the boss's attention.
+#
+OPTIONS=time,noshowexp,number_pad,lit_corridor,rest_on_space
+#
+# If you want to get rid of "use #quit to quit..." use:
+#OPTIONS=suppress_alert:3.3.1
+#
+
+#
+#HACKDIR=c:\games\nethack
+# 
+# Note: Under MSDOS ports HACKDIR defaults to the location 
+#       of the NetHack.exe file. Setting HACKDIR above will override that.
+#
+#   LEVELS and SAVE default to HACKDIR
+#
+#LEVELS=c:\games\nethack\bones
+#SAVE=c:\games\nethack\bones
+
+# *** CHARACTER GRAPHICS ***
+#
+# See the on-line help or the Guidebook for which symbols are in which
+# positions.
+#
+# If you merely set the IBMgraphics option as above, NetHack will use IBM
+# extended ASCII for dungeon characters.  If you don't like the selections,
+# you can make up your own via these graphics options, but you should still
+# set IBMgraphics if you are using IBM graphics characters to get the correct
+# processing.
+#
+# ================================================
+# An example using the IBM graphics character set:
+#DUNGEON=  032 179 196 218 191 192 217 197 193 194 \
+#	   180 195 249 239 239 254 254 240 241 249 \
+#	   177 177 060 062 060 062 220 124 190 035 \
+#	   244 247 249 247 042 042 186 205 046 035 \
+#	   247
+#
+#TRAPS=    094 094 094 094 094 094 094 094 094 094 \
+#	   094 094 094 094 232 232 232 157 094 094 \
+#	   094 094
+#
+#EFFECTS=  179 196 092 047 042 033 041 040	   \
+#	   048 035 064 042			   \
+#	   047 045 092 058 058 092 045 047	   \
+#	   047 045 092 058 032 058 092 045 047
+#
+# ================================================
+# Some alternatives:
+#DUNGEON=  032 186 205 201 187 200 188 206 202 203 \
+#	   185 204 249 239 239 254 254 240 241 249 \
+#	   177 177 060 062 060 062 095 124 092 035 \
+#	   244 247 249 247 042 042 179 196 046 035 \
+#	   247
+#
+#TRAPS=    094 094 094 094 094 094 094 094 094 094 \
+#	   094 094 094 094 094 034 094 094 094 094 \
+#	   094 094
+
+# ================================================
+# Here is a recommendation sent in by Michael Feir
+# for use by blind NetHack players.
+#
+#DUNGEON=  032 124 045 124 124 124 124 045 045 045 \
+#          124 124 046 045 124 043 043 046 035 035 \
+#          060 062 060 062 095 092 035 126 126 126 \
+#          126 042 042 035 035 032 035 126
+#
+#TRAPS=    094 094 094 094 094 094 094 094 094 094 \
+#          094 094 094 094 094 094 094 094 094 094 \
+#          094 094
+#
+#EFFECTS=  124 095 092 047 042 033 041 040         \
+#          048 035 064 042                         \
+#          047 045 092 058 058 092 045 047         \
+#          047 045 092 058 032 058 092 045 047
+
+
diff -Pru nethack-3.4.1/util/.cvsignore nethack/util/.cvsignore
--- nethack-3.4.1/util/.cvsignore	Wed Dec 31 16:00:00 1969
+++ nethack/util/.cvsignore	Thu Jan 10 20:03:17 2002
@@ -0,0 +1,9 @@
+Makefile
+dgn_comp
+dgn_lex.c
+dgn_yacc.c
+lev_comp
+lev_lex.c
+lev_yacc.c
+makedefs
+tilemap
diff -Pru nethack-3.4.1/win/Qt/qttableview.cpp nethack/win/Qt/qttableview.cpp
--- nethack-3.4.1/win/Qt/qttableview.cpp	Sun Feb 23 06:43:45 2003
+++ nethack/win/Qt/qttableview.cpp	Tue Apr 23 12:17:40 2002
@@ -1,5 +1,5 @@
 /**********************************************************************
-** $Id: qttableview.cpp,v 1.2 2002/03/09 03:13:15 jwalz Exp $
+** $Id: qttableview.cpp,v 1.1.1.1 2002/04/23 19:17:40 sabetts Exp $
 **
 ** Implementation of QtTableView class
 **
diff -Pru nethack-3.4.1/win/lisp/ChangeLog nethack/win/lisp/ChangeLog
--- nethack-3.4.1/win/lisp/ChangeLog	Wed Dec 31 16:00:00 1969
+++ nethack/win/lisp/ChangeLog	Thu Sep 19 21:15:20 2002
@@ -0,0 +1,293 @@
+2002-09-19  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_cmd): nethack-api-* renamed to nhapi-*.
+
+2002-09-16  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* ../tty/termcap.c (has_color): Add condition for LISP_GRAPHICS
+	which returns TRUE.
+
+2002-09-12  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_display_nhwindow): Add call to
+	`nethack-api-end'.
+
+	* ../../include/config.h: Default to LISP_GRAPHICS.
+
+	* ../../sys/unix/Makefile.src (WINSRC,WINOBJ,WINLIB): Set to
+	WINLISP* values.
+	(depend): Add winlisp.o dependancies.
+	
+	* winlisp.c (lisp_curs): Don't send winid.  Add error check.
+	(lisp_putstr): Call `nethack-api-message' or
+	`nethack-api-menu-putstr' when appropriate.
+	(lisp_nhgetch): Update error message call.
+	(lisp_create_nhwindow): Don't send winids when creating message,
+	map, or status windows.
+	(lisp_clear_nhwindow): Call clear-message or clear-map instead of
+	clear-nhwindow.
+	(lisp_display_nhwindow): Call display-menu instead of
+	display-nhwindow.  Call block when handling case of blocking on
+	displaying the map window.
+	(lisp_destroy_nhwindow): Use WIN_* values instead of hardcoded
+	numbers.
+	(lisp_print_glyph): Don't send winid.  Add error check for bad
+	winids.
+	(lisp_outrip): Change reference to Enethack to nethack-el.
+
+2002-04-23  Shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (lisp_player_selection): Update to use new 3.4.0
+	functionality.
+	(lisp_print_glyph): likewise
+
+2002-02-16  Shawn Betts  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (read_string): take a pointer to a string as the
+	second argument. All callers updated. Rewritten to dynamically
+	resize the string in order to read an entire line.
+	(read_command): free the string returned from read_string
+	(lisp_askname): likewise
+	(lisp_display_nhwindow): likewise
+	(lisp_delay_output): likewise
+	(lisp_yn_function): likewise
+
+2002-02-14  Shawn Betts  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (lisp_print_glyph): Handle warning glyphs.
+
+2002-01-27  Ryan C Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (generate_status_line): Send flag values
+	individually.  Always send values for all attributes.
+
+2002-01-21  Ryan C Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_add_menu): Add tile argument.
+
+2002-01-22  shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (lisp_player_selection): use the existing menu system
+	to select a player.
+	(lisp_menu_item_t): add a new member, accelerator.
+	(lisp_current_accelerator): new static global.
+	(lisp_add_menu): pick our own selector when ch is 0.
+	(lisp_start_menu): reset lisp_current_accelerator to 'a'.
+	(lisp_add_menu): remove the identifier argument to the lisp_cmd
+	"add_menu".
+	(lisp_get_menu_identifier): first argument is now a char.
+
+2002-01-20  Ryan C Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (cmd_index): Add remaining functions.
+
+2002-01-16  Ryan C Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_exit_nhwindows): Don't wait for a dummy return
+	value.
+	(lisp_destroy_nhwindow): Don't destroy the status, message or map
+	windows.
+
+2002-01-15  Ryan C Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_exit_nhwindows): Don't wait for a dummy return
+	value.
+	
+2002-01-10  shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (win_lisp_init): new function
+
+2002-01-09  Ryan C Yeske  <rcyeske@sfu.ca>
+
+	* winlisp.c (cmd_index): Add redraw command.	
+	(C): New macro.
+
+2002-01-01  shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (winid_list): new static global
+	(winid_list_len): likewise
+	(winid_list_max): likewise
+	(find_empty_cell): new function
+	(winid_is_taken): likewise
+	(add_winid): likewise
+	(get_unique_winid): likewise
+	(return_winid): likewise
+	(init_winid_list): likewise
+
+2001-12-20  shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (read_command): return the command count as a string.
+	(num_digits): remove function
+	(power_of_ten): likewise
+	(lisp_nhgetch): command count works.
+	(enc_stat): extern reference
+	(hunger_stat): new constant
+	(generate_status_line): new function
+	(lisp_putstr): use generate_status_line to create the status line
+	call.
+
+2001-12-19  shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c: add extern declaration for glyph2tile and
+	total_tiles_used.
+	(lisp_print_glyph): pass the glyph's graphics tile index as an argument.
+
+2001-12-02  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_cmd, lisp_list, lisp_t, lisp_nil, lisp_literal)
+	(lisp_cons, lisp_int, lisp_string): Update macros.  Update all api
+	functions to use these macros.
+	(read_int, read_string, read_command): New functions.  Update all
+	api functions to use these functions.
+	(lisp_create_nhwindow): Send specific window creation commands.
+	(lisp_cliparound): Comment out body.
+
+2001-10-23  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_nhgetch): Don't silently loop on invalid
+	commands, send back a warning.
+	(lisp_yn_function): Make sure special handling is done for all
+	direction questions.  Include prompt in call to
+	nethack-api-ask-direction.  Include up, down and self directions.
+	If no default is set for a direction question, return space.
+
+2001-10-19  shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (lisp_init_nhwindows): turn on showexp and time flags.
+
+2001-10-17  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_display_nhwindow): Wait for a string if we are
+	blocking.
+
+2001-07-19  shawn  <sabetts@diggin.lamenet.tmp>
+
+	* winlisp.c (lisp_player_selection): terminate if we read a -1 as
+	a selection.
+
+2001-07-16  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_delay_output): expect a return value from the
+	client.
+
+2001-07-14  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_add_menu): Quote the attribute.
+	(lisp_outrip): Add a newline to output.
+
+2001-07-06  shawn  <sabetts@diggin.lamenet.tmp>
+
+	* winlisp.c (num_digits): new function
+	(power_of_ten): likewise
+	(lisp_nhgetch): handles repeated commands.
+
+2001-07-05  shawn  <sabetts@diggin.lamenet.tmp>
+
+	* winlisp.c (WINLISP_VOID_RETVAL): flushes stdout
+
+2001-07-04  Ryan Yeske  <rcyeske@van.gobasis.com>
+
+	* winlisp.c (lisp_add_menu): Convert printf to lisp_* macros,
+	fixing a string quote bug.
+
+2001-06-28  shawn  <sabetts@diggin.lamenet.tmp>
+
+	* winlisp.c (zap_color): new define
+	(cmap_color): likewise
+	(obj_color): likewise
+	(mon_color): likewise
+	(invis_color): likewise
+	(pet_color): likewise
+	(lisp_print_glyph): export the color. export the ascii character
+	as a number.
+
+2001-06-27  shawn  <sabetts@diggin.lamenet.tmp>
+
+	* winlisp.c: fix a typo cmd_index
+	(lisp_yn_function): pass characters as numbers instead of ascii
+	characters. specially handle the "In what direction?" question.
+	(lisp_outrip): prints a properly formed lisp expression.
+
+2001-06-21  Shawn Betts  <sabetts@van.gobasis.com>
+
+	* winlisp.c (lisp_add_menu): items that are not selectable are
+	sent with an identifier of -1.
+	(lisp_select_menu): handle failed memory
+	allocation.
+
+2001-05-06  shawn  <sabetts@diggin.lamenet.tmp>
+
+	* winlisp.c (LINESIZ): new define
+	(lisp_menu_item_t): new struct
+	(lisp_menu_item_list): new static global
+	(lisp_menu_list_size): likewise
+	(lisp_menu_list_num): likewise
+	(cmd_index): fixed ddrop entry
+	(read_int): new function
+	(lisp_player_selection): use read_int
+	(lisp_askname): read the entire line to a string and parse data
+	from it.
+	(lisp_nhgetch): likewise
+	(lisp_create_nhwindow): likewise
+	(lisp_getlin): likewise
+	(lisp_yn_function): likewise
+	(lisp_start_menu): set lisp_menu_list_num to 0
+	(lisp_add_menu): add an entry to lisp_menu_item_list
+	(lisp_add_menu): pass the item's ID to the client instead of the
+	actual identifier.
+	(lisp_get_menu_identifier): new function
+	(lisp_select_menu): parse the list of selected menu items
+	(lisp_print_glyph): escape backslashes in output
+
+2000-10-01  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (cmd_index): renamed "ddoremarm" to "remarm" and
+	"ddoinv" to "inv".
+
+2000-09-25  Shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c: Added more key commands.
+	(lisp_player_selection): honours default player selections as
+	specified in the nethackrc file.
+
+2000-09-22  Shawn  <sabetts@vcn.bc.ca>
+
+	* winlisp.c (lisp_nhgetch): changed while loop stop condition.
+
+2000-09-19  Ryan yeske  <rcyeske@van.gobasis.com>
+
+	* winlisp.c (lisp_nh_getch): renamed from lisp_nh_getcmd() since
+	this is really called by the core when nethack wants a key.
+	(cmd_index): added gowest, gosouth, gonorth, goeast.
+
+2000-09-12  shawn  <sabetts@gobasis.com>
+
+	* winlisp.c (lisp_nh_poskey): Added code to read in an x,y,mod
+	combination instead of calling lisp_nhgetcmd. Currently commented
+	out until the lisp side catches up.  added cmd_index structure to
+	translate incoming command strings to extended commands or
+	keystrokes. Changed lisp_nhgetch to lisp_nhgetcmd and changed the
+	lisp command it calls to 'nethack-get-command'.
+
+2000-09-11  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_cmd, lisp_close_cmd, lisp_open, lisp_close,
+	lisp_quote, lisp_int, lisp_string, lisp_dot): created macros.
+
+2000-09-10  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_outrip): added closing paren.
+
+2000-08-21  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_nhgetch): change ch type to int from char.
+
+2000-08-20  Ryan Yeske  <rcyeske@vcn.bc.ca>
+
+	* winlisp.c (lisp_player_selection): role/race/gender/alignment
+	selection now sends (nethack-apix-choose-X ALIST) instead of
+	simply an alist.
+	(lisp_update_inventory):
+	s/nethack-api-updated-inventory/nethack-api-update-inventory/
+	(WINLISP_VOID_RETVAL): added macro, called for every void
+	function.
diff -Pru nethack-3.4.1/win/lisp/winlisp.c nethack/win/lisp/winlisp.c
--- nethack-3.4.1/win/lisp/winlisp.c	Wed Dec 31 16:00:00 1969
+++ nethack/win/lisp/winlisp.c	Thu Sep 19 21:15:20 2002
@@ -0,0 +1,1820 @@
+/* Copyright (c) Shawn Betts, Ryan Yeske, 2001                    */
+/* NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * "Main" file for the lisp/emacs window-port.  This contains most of
+ * the interface routines.  Please see doc/window.doc for an
+ * description of the window interface.  
+ */
+
+#ifdef MSDOS			/* from compiler */
+#define SHORT_FILENAMES
+#endif
+
+#include "hack.h"
+#include "winlisp.h"
+#include "func_tab.h"
+
+#include "dlb.h"
+#ifdef SHORT_FILENAMES
+#include "patchlev.h"
+#else
+#include "patchlevel.h"
+#endif
+
+#define CMD_KEY 0
+#define CMD_EXT 1
+
+/* from tile.c */
+extern short glyph2tile[];
+extern int total_tiles_used;
+
+typedef struct
+{
+  anything identifier;
+  char accelerator;
+} lisp_menu_item_t;
+
+/* An iterator for assigning accelerator keys. */
+static char lisp_current_accelerator;
+
+/* Helper structures to map menu id's to nethack anything's */
+static lisp_menu_item_t lisp_menu_item_list[1000];
+static int lisp_menu_list_size = 1000;
+static int lisp_menu_list_num;
+
+extern char *enc_stat[];
+const char *hunger_stat[] = {
+	"Satiated",
+	"",
+	"Hungry",
+	"Weak",
+	"Fainting",
+	"Fainted",
+	"Starved"
+};
+
+typedef struct 
+{
+  char *name;
+  int type;
+  int cmd;			/* The command (a keystroke) */
+}cmd_index_t;
+
+#ifndef C
+#define C(c)		(0x1f & (c))
+#endif
+
+cmd_index_t cmd_index[] = { {"gowest", CMD_KEY, 'h'},
+			    {"gowestontop", CMD_KEY, 'H'},
+			    {"gowestnear", CMD_KEY, C('h')},
+
+			    {"gosouth", CMD_KEY, 'j'},
+			    {"gosouthontop", CMD_KEY, 'J'},
+			    {"gosouthnear", CMD_KEY,  C('j')},
+
+			    {"gonorth", CMD_KEY, 'k'},
+			    {"gonorthontop", CMD_KEY, 'K'},
+			    {"gonorthnear", CMD_KEY, C('k')},
+
+			    {"goeast", CMD_KEY, 'l'},
+			    {"goeastontop", CMD_KEY, 'L'},
+			    {"goeastnear", CMD_KEY, C('l')},
+
+			    {"gonorthwest", CMD_KEY, 'y'},
+			    {"gonorthwestontop", CMD_KEY, 'Y'},
+			    {"gonorthwestnear", CMD_KEY, C('y')},
+
+			    {"gonortheast", CMD_KEY, 'u'},
+			    {"gonortheastontop", CMD_KEY, 'U'},
+			    {"gonortheastnear", CMD_KEY, C('u')},
+
+			    {"gosouthwest", CMD_KEY, 'b'},
+			    {"gosouthwestontop", CMD_KEY, 'B'},
+			    {"gosouthwestnear", CMD_KEY, C('b')},
+
+			    {"gosoutheast", CMD_KEY, 'n'},
+			    {"gosoutheastontop", CMD_KEY, 'N'},
+			    {"gosoutheastnear", CMD_KEY, C('n')},
+
+			    {"idtrap", CMD_KEY, '^'},
+			    {"apply", CMD_KEY, 'a'},
+			    {"remarm", CMD_KEY, 'A'},
+			    {"close", CMD_KEY, 'c'},
+			    {"drop", CMD_KEY, 'd'},
+
+			    {"ddrop", CMD_KEY, 'D'},
+			    {"eat", CMD_KEY, 'e'},
+			    {"engrave", CMD_KEY, 'E'},
+			    {"fire", CMD_KEY, 'f'},
+			    {"inv", CMD_KEY, 'i'},
+
+			    {"typeinv", CMD_KEY, 'I'},
+			    {"open", CMD_KEY, 'o'},
+			    {"set", CMD_KEY, 'O'},
+			    {"pay", CMD_KEY, 'p'},
+			    {"puton", CMD_KEY, 'P'},
+
+			    {"drink", CMD_KEY, 'q'},
+			    {"wieldquiver", CMD_KEY, 'Q'},
+			    {"read", CMD_KEY, 'r'},
+			    {"remring", CMD_KEY, 'R'},
+			    {"search", CMD_KEY, 's'},
+
+			    {"save", CMD_KEY, 'S'},
+			    {"throw", CMD_KEY, 't'},
+			    {"takeoff", CMD_KEY, 'T'},
+			    {"simpleversion", CMD_KEY, 'v'},
+			    {"history", CMD_KEY, 'V'},
+
+			    {"wield", CMD_KEY, 'w'},
+			    {"wear", CMD_KEY, 'W'},
+			    {"swapweapon", CMD_KEY, 'x'},
+			    {"enter_explore_mode", CMD_KEY, 'X'},
+			    {"zap", CMD_KEY, 'z'},
+
+			    {"cast", CMD_KEY, 'Z'},
+			    {"up", CMD_KEY, '<'},
+			    {"down", CMD_KEY, '>'},
+			    {"whatis", CMD_KEY, '/'},
+			    {"help", CMD_KEY, '?'},
+
+			    {"whatdoes", CMD_KEY, '&'},
+			    {"sh", CMD_KEY, '!'},
+			    {"discovered", CMD_KEY, '\\'},
+			    {"null", CMD_KEY, '.'},
+			    {"look", CMD_KEY, ':'},
+
+			    {"quickwhatis", CMD_KEY, ';'},
+			    {"pickup", CMD_KEY, ','},
+			    {"togglepickup", CMD_KEY, '@'},
+			    {"prinuse", CMD_KEY, '*'},
+			    {"countgold", CMD_KEY, '$'},
+
+			    {"kick", CMD_KEY, C('d')},
+			    {"listspells", CMD_KEY, '+'},
+			    {"redraw", CMD_KEY, C('r')},
+			    {"teleport", CMD_KEY, C('t')},
+			    {"callmon", CMD_KEY, 'C'},
+			    {"fight", CMD_KEY, 'F'},
+			    {"movenear", CMD_KEY, 'g'},
+			    {"move", CMD_KEY, 'G'},
+			    {"movenopickuporfight", CMD_KEY, 'm'},
+			    {"movenopickup", CMD_KEY, 'M'},
+			    {"showweapon", CMD_KEY, ')'},
+			    {"showarmor", CMD_KEY, '['},
+			    {"showrings", CMD_KEY, '='},
+			    {"showamulet", CMD_KEY, '"'},
+			    {"showtool", CMD_KEY, '('},
+			    {"attributes", CMD_KEY, C('x')},
+#ifdef REDO
+			    {"again", CMD_KEY, DOAGAIN},
+#endif /* REDO */
+
+			    /* wizard commands */
+			    {"wiz_detect", CMD_KEY, C('e')},
+			    {"wiz_map", CMD_KEY, C('f')},
+			    {"wiz_genesis", CMD_KEY, C('g')},
+			    {"wiz_identify", CMD_KEY, C('i')},
+			    {"wiz_where", CMD_KEY, C('o')},
+			    {"wiz_level_tele", CMD_KEY, C('v')},
+			    {"wiz_wish", CMD_KEY, C('w')},
+
+			    /* wizard extended commands */
+#ifdef WIZARD
+			    {"light sources", CMD_EXT, 0},
+			    {"seenv", CMD_EXT, 0},
+			    {"stats", CMD_EXT, 0},
+			    {"timeout", CMD_EXT, 0},
+			    {"vision", CMD_EXT, 0},
+#ifdef DEBUG
+			    {"wizdebug", CMD_EXT, 0},
+#endif /* DEBUG */
+			    {"wmode", CMD_EXT, 0},
+#endif /* WIZARD */
+			    {"pray", CMD_EXT, 0},
+			    {"adjust", CMD_EXT, 0},
+			    {"chat", CMD_EXT, 0},
+			    {"conduct", CMD_EXT, 0},
+			    {"dip", CMD_EXT, 0},
+
+			    {"enhance", CMD_EXT, 0},
+			    {"force", CMD_EXT, 0},
+			    {"invoke", CMD_EXT, 0},
+			    {"jump", CMD_EXT, 0},
+			    {"loot", CMD_EXT, 0},
+
+			    {"monster", CMD_EXT, 0},
+			    {"name", CMD_EXT, 0},
+			    {"offer", CMD_EXT, 0},
+			    {"quit", CMD_EXT, 0},
+			    {"ride", CMD_EXT, 0},
+
+			    {"rub", CMD_EXT, 0},
+			    {"sit", CMD_EXT, 0},
+			    {"turn", CMD_EXT, 0},
+			    {"twoweapon", CMD_EXT, 0},
+			    {"untrap", CMD_EXT, 0},
+
+			    {"version", CMD_EXT, 0},
+			    {"wipe", CMD_EXT, 0},
+
+			    {0, CMD_KEY, '\0'} };
+
+/* This variable is set when the user has selected an extended command. */
+static int extended_cmd_id;
+  
+/* Interface definition, for windows.c */
+struct window_procs lisp_procs = {
+  "lisp",
+  WC_COLOR|WC_HILITE_PET,
+  lisp_init_nhwindows,
+  lisp_player_selection,
+  lisp_askname,
+  lisp_get_nh_event,
+  lisp_exit_nhwindows,
+  lisp_suspend_nhwindows,
+  lisp_resume_nhwindows,
+  lisp_create_nhwindow,
+  lisp_clear_nhwindow,
+  lisp_display_nhwindow,
+  lisp_destroy_nhwindow,
+  lisp_curs,
+  lisp_putstr,
+  lisp_display_file,
+  lisp_start_menu,
+  lisp_add_menu,
+  lisp_end_menu,
+  lisp_select_menu,
+  genl_message_menu,
+  lisp_update_inventory,
+  lisp_mark_synch,
+  lisp_wait_synch,
+#ifdef CLIPPING
+  lisp_cliparound,
+#endif
+#ifdef POSITIONBAR
+  lisp_update_positionbar,
+#endif
+  lisp_print_glyph,
+  lisp_raw_print,
+  lisp_raw_print_bold,
+  lisp_nhgetch,
+  lisp_nh_poskey,
+  lisp_nhbell,
+  lisp_doprev_message,
+  lisp_yn_function,
+  lisp_getlin,
+  lisp_get_ext_cmd,
+  lisp_number_pad,
+  lisp_delay_output,
+#ifdef CHANGE_COLOR	/* the Mac uses a palette device */
+  donull,
+  donull,
+#endif
+  /* other defs that really should go away (they're tty specific) */
+  lisp_start_screen,
+  lisp_end_screen,
+  lisp_outrip,
+  genl_preference_update,
+};
+
+/* macros for printing lisp output */
+#define lisp_cmd(s,body)			\
+  do						\
+    {						\
+      printf("(nhapi-%s ",s);		\
+      body;					\
+      printf(")\n");				\
+    }						\
+  while (0)
+/* #define lisp_cmd0(s) printf ("(nhapi-%s)\n", s) */
+#define lisp_list(body)				\
+  do						\
+    {						\
+      printf("(");				\
+      body; 					\
+      printf(") ");				\
+    }						\
+  while (0)
+
+#define lisp_open printf("(")
+#define lisp_close printf(") ")
+#define lisp_quote printf("'")
+#define lisp_dot printf(". ")
+#define lisp_t printf("t ")
+#define lisp_nil printf("nil ")
+#define lisp_literal(x)				\
+  do						\
+    {						\
+      lisp_quote;				\
+      printf ("%s ", x);			\
+    }						\
+  while (0)
+#define lisp_cons(x,y)				\
+  do						\
+    {						\
+      lisp_open;				\
+      x;					\
+      lisp_dot;					\
+      y;					\
+      lisp_close;				\
+    }						\
+  while (0)
+#define lisp_int(i) printf("%d ",i)
+#define lisp_string(s)				\
+  do 						\
+     {						\
+       int nhi;					\
+       printf ("\"");				\
+       if (s)					\
+	 for (nhi=0;nhi<strlen(s);nhi++) 	\
+	   {					\
+	     if (s[nhi] == 34) putchar('\\');	\
+	     putchar(s[nhi]);			\
+	   }					\
+       printf("\" ");				\
+     } 						\
+  while (0)
+
+static const char*
+attr_to_string(attr)
+     int attr;
+{
+  switch (attr)
+    {
+    case ATR_NONE:
+      return "atr-none";
+    case ATR_ULINE:
+      return "atr-uline";
+    case ATR_BOLD:
+      return "atr-bold";
+    case ATR_BLINK:
+      return "atr-blink";
+    case ATR_INVERSE:
+      return "atr-inverse";
+    default:
+      /* Should never happen. */
+      impossible ("Invalid attribute code.");
+      exit (EXIT_FAILURE);
+      break;
+    }
+}
+
+static const char*
+wintype_to_string(type)
+     int type;
+{
+  switch (type)
+    {
+    case NHW_MAP:
+      return "nhw-map";
+    case NHW_MESSAGE:
+      return "nhw-message";
+    case NHW_STATUS:
+      return "nhw-status";
+    case NHW_MENU:
+      return "nhw-menu";
+    case NHW_TEXT:
+      return "nhw-text";
+    default:
+      fprintf (stderr, "Invalid window code\n");
+      exit (EXIT_FAILURE);
+      break;
+    }
+}
+
+static const char*
+how_to_string (how)
+     int how;
+{
+  switch (how)
+    {
+    case PICK_NONE:
+      return "pick-none";
+    case PICK_ONE:
+      return "pick-one";
+    case PICK_ANY:
+      return "pick-any";
+    default:
+      impossible ("Invalid how value %d", how);
+    }
+}
+
+static int
+read_int (prompt, i)
+     const char* prompt;
+     int *i;
+{
+  char line[BUFSZ];
+  int rv;
+  printf ("%s> ", prompt);
+  fgets (line, BUFSZ, stdin);
+  rv = sscanf (line, "%d", i);
+  if (rv != 1) *i = -1;
+  return rv;
+}
+
+static int
+read_string (prompt, str)
+     const char* prompt;
+     char **str;
+{
+  char* rv;
+  int len;
+  int size;
+  char tmp[BUFSZ];
+
+  len = 0;
+  size = BUFSZ * 2;
+  *str = malloc (size);
+  (*str)[0] = '\0';
+
+  printf ("%s> ", prompt);
+
+  do
+    {
+      /* Read the string */
+      rv = fgets (tmp, BUFSZ, stdin);
+      if (rv == NULL)
+	break;
+
+      len += strlen (tmp);
+      if (len >= size - 1)
+	{
+	  size *= 2;
+	  *str = realloc (*str, size);
+	  if (*str == NULL)
+	    panic ("Memory allocation failure; cannot get %u bytes", size);
+	}
+      strcat (*str, tmp);
+    } while (tmp[strlen (tmp) - 1] != '\n');
+
+  /* Did we read a string or error out? */
+  if (rv == NULL)
+    {
+      free (*str);
+      return -1;
+    }
+  else
+    {
+      /* chop the newline */
+      (*str) [strlen (*str) - 1] = '\0';
+      return 0;
+    }
+}
+
+
+static int
+read_command (prompt, cmd, count)
+     const char *prompt;
+     char *cmd;
+     char *count;
+{
+  char *buf;
+  int rv;
+  cmd[0] = '\0';
+  *count = 0;
+  if (read_string (prompt, &buf) == -1)
+    return -1;
+  rv = sscanf (buf, "%s %s", cmd, count);
+  free (buf);
+  if (rv != 2) *count = 0;
+  return rv;
+}
+
+void
+bail(mesg)
+     const char *mesg;
+{
+  clearlocks ();
+  lisp_exit_nhwindows (mesg);
+  terminate (EXIT_SUCCESS);
+  /*NOTREACHED*/
+}
+
+void
+win_lisp_init ()
+{
+  /* Code to be executed on startup. */
+}
+
+void
+lisp_player_selection ()
+{
+	int i, k, n;
+	char pick4u = 'n', thisch, lastch = 0;
+	char pbuf[QBUFSZ], plbuf[QBUFSZ];
+	winid win;
+	anything any;
+	menu_item *selected = 0;
+
+	/* prevent an unnecessary prompt */
+	rigid_role_checks();
+
+	/* Should we randomly pick for the player? */
+	if (!flags.randomall &&
+	    (flags.initrole == ROLE_NONE || flags.initrace == ROLE_NONE ||
+	     flags.initgend == ROLE_NONE || flags.initalign == ROLE_NONE)) {
+
+	  pick4u = lisp_yn_function ("Shall I pick a character for you? [ynq] ", "ynq", 'y');
+
+	  if (pick4u != 'y' && pick4u != 'n') 
+	    {
+	    give_up:	/* Quit */
+	      if (selected) free((genericptr_t) selected);
+	      bail((char *)0);
+	      /*NOTREACHED*/
+	      return;
+	    }
+
+	}
+
+	(void)  root_plselection_prompt(plbuf, QBUFSZ - 1,
+			flags.initrole, flags.initrace, flags.initgend, flags.initalign);
+
+	/* Select a role, if necessary */
+	/* we'll try to be compatible with pre-selected race/gender/alignment,
+	 * but may not succeed */
+	if (flags.initrole < 0) {
+	    char rolenamebuf[QBUFSZ];
+	    /* Process the choice */
+	    if (pick4u == 'y' || flags.initrole == ROLE_RANDOM || flags.randomall) {
+		/* Pick a random role */
+		flags.initrole = pick_role(flags.initrace, flags.initgend,
+						flags.initalign, PICK_RANDOM);
+		if (flags.initrole < 0) {
+/* 		    lisp_putstr(BASE_WINDOW, 0, "Incompatible role!"); */
+		    flags.initrole = randrole();
+		}
+ 	    } else {
+		/* Prompt for a role */
+		win = create_nhwindow(NHW_MENU);
+		start_menu(win);
+		any.a_void = 0;         /* zero out all bits */
+		for (i = 0; roles[i].name.m; i++) {
+		    if (ok_role(i, flags.initrace, flags.initgend,
+							flags.initalign)) {
+			any.a_int = i+1;	/* must be non-zero */
+			thisch = lowc(roles[i].name.m[0]);
+			if (thisch == lastch) thisch = highc(thisch);
+			if (flags.initgend != ROLE_NONE && flags.initgend != ROLE_RANDOM) {
+				if (flags.initgend == 1  && roles[i].name.f)
+					Strcpy(rolenamebuf, roles[i].name.f);
+				else
+					Strcpy(rolenamebuf, roles[i].name.m);
+			} else {
+				if (roles[i].name.f) {
+					Strcpy(rolenamebuf, roles[i].name.m);
+					Strcat(rolenamebuf, "/");
+					Strcat(rolenamebuf, roles[i].name.f);
+				} else 
+					Strcpy(rolenamebuf, roles[i].name.m);
+			}	
+			add_menu(win, NO_GLYPH, &any, thisch,
+			    0, ATR_NONE, an(rolenamebuf), MENU_UNSELECTED);
+			lastch = thisch;
+		    }
+		}
+		any.a_int = pick_role(flags.initrace, flags.initgend,
+				    flags.initalign, PICK_RANDOM)+1;
+		if (any.a_int == 0)	/* must be non-zero */
+		    any.a_int = randrole()+1;
+		add_menu(win, NO_GLYPH, &any , '*', 0, ATR_NONE,
+				"Random", MENU_UNSELECTED);
+		any.a_int = i+1;	/* must be non-zero */
+		add_menu(win, NO_GLYPH, &any , 'q', 0, ATR_NONE,
+				"Quit", MENU_UNSELECTED);
+		Sprintf(pbuf, "Pick a role for your %s", plbuf);
+		end_menu(win, pbuf);
+		n = select_menu(win, PICK_ONE, &selected);
+		destroy_nhwindow(win);
+
+		/* Process the choice */
+		if (n != 1 || selected[0].item.a_int == any.a_int)
+		    goto give_up;		/* Selected quit */
+
+		flags.initrole = selected[0].item.a_int - 1;
+		free((genericptr_t) selected),	selected = 0;
+	    }
+	    (void)  root_plselection_prompt(plbuf, QBUFSZ - 1,
+			flags.initrole, flags.initrace, flags.initgend, flags.initalign);
+	}
+	
+	/* Select a race, if necessary */
+	/* force compatibility with role, try for compatibility with
+	 * pre-selected gender/alignment */
+	if (flags.initrace < 0 || !validrace(flags.initrole, flags.initrace)) {
+	    /* pre-selected race not valid */
+	    if (pick4u == 'y' || flags.initrace == ROLE_RANDOM || flags.randomall) {
+		flags.initrace = pick_race(flags.initrole, flags.initgend,
+							flags.initalign, PICK_RANDOM);
+		if (flags.initrace < 0) {
+/* 		    lisp_putstr(BASE_WINDOW, 0, "Incompatible race!"); */
+		    flags.initrace = randrace(flags.initrole);
+		}
+	    } else {	/* pick4u == 'n' */
+		/* Count the number of valid races */
+		n = 0;	/* number valid */
+		k = 0;	/* valid race */
+		for (i = 0; races[i].noun; i++) {
+		    if (ok_race(flags.initrole, i, flags.initgend,
+							flags.initalign)) {
+			n++;
+			k = i;
+		    }
+		}
+		if (n == 0) {
+		    for (i = 0; races[i].noun; i++) {
+			if (validrace(flags.initrole, i)) {
+			    n++;
+			    k = i;
+			}
+		    }
+		}
+
+		/* Permit the user to pick, if there is more than one */
+		if (n > 1) {
+		    win = create_nhwindow(NHW_MENU);
+		    start_menu(win);
+		    any.a_void = 0;         /* zero out all bits */
+		    for (i = 0; races[i].noun; i++)
+			if (ok_race(flags.initrole, i, flags.initgend,
+							flags.initalign)) {
+			    any.a_int = i+1;	/* must be non-zero */
+			    add_menu(win, NO_GLYPH, &any, races[i].noun[0],
+				0, ATR_NONE, races[i].noun, MENU_UNSELECTED);
+			}
+		    any.a_int = pick_race(flags.initrole, flags.initgend,
+					flags.initalign, PICK_RANDOM)+1;
+		    if (any.a_int == 0)	/* must be non-zero */
+			any.a_int = randrace(flags.initrole)+1;
+		    add_menu(win, NO_GLYPH, &any , '*', 0, ATR_NONE,
+				    "Random", MENU_UNSELECTED);
+		    any.a_int = i+1;	/* must be non-zero */
+		    add_menu(win, NO_GLYPH, &any , 'q', 0, ATR_NONE,
+				    "Quit", MENU_UNSELECTED);
+		    Sprintf(pbuf, "Pick the race of your %s", plbuf);
+		    end_menu(win, pbuf);
+		    n = select_menu(win, PICK_ONE, &selected);
+		    destroy_nhwindow(win);
+		    if (n != 1 || selected[0].item.a_int == any.a_int)
+			goto give_up;		/* Selected quit */
+
+		    k = selected[0].item.a_int - 1;
+		    free((genericptr_t) selected),	selected = 0;
+		}
+		flags.initrace = k;
+	    }
+	    (void)  root_plselection_prompt(plbuf, QBUFSZ - 1,
+			flags.initrole, flags.initrace, flags.initgend, flags.initalign);
+	}
+
+	/* Select a gender, if necessary */
+	/* force compatibility with role/race, try for compatibility with
+	 * pre-selected alignment */
+	if (flags.initgend < 0 || !validgend(flags.initrole, flags.initrace,
+						flags.initgend)) {
+	    /* pre-selected gender not valid */
+	    if (pick4u == 'y' || flags.initgend == ROLE_RANDOM || flags.randomall) {
+		flags.initgend = pick_gend(flags.initrole, flags.initrace,
+						flags.initalign, PICK_RANDOM);
+		if (flags.initgend < 0) {
+/* 		    lisp_putstr(BASE_WINDOW, 0, "Incompatible gender!"); */
+		    flags.initgend = randgend(flags.initrole, flags.initrace);
+		}
+	    } else {	/* pick4u == 'n' */
+		/* Count the number of valid genders */
+		n = 0;	/* number valid */
+		k = 0;	/* valid gender */
+		for (i = 0; i < ROLE_GENDERS; i++) {
+		    if (ok_gend(flags.initrole, flags.initrace, i,
+							flags.initalign)) {
+			n++;
+			k = i;
+		    }
+		}
+		if (n == 0) {
+		    for (i = 0; i < ROLE_GENDERS; i++) {
+			if (validgend(flags.initrole, flags.initrace, i)) {
+			    n++;
+			    k = i;
+			}
+		    }
+		}
+
+		/* Permit the user to pick, if there is more than one */
+		if (n > 1) {
+		    win = create_nhwindow(NHW_MENU);
+		    start_menu(win);
+		    any.a_void = 0;         /* zero out all bits */
+		    for (i = 0; i < ROLE_GENDERS; i++)
+			if (ok_gend(flags.initrole, flags.initrace, i,
+							    flags.initalign)) {
+			    any.a_int = i+1;
+			    add_menu(win, NO_GLYPH, &any, genders[i].adj[0],
+				0, ATR_NONE, genders[i].adj, MENU_UNSELECTED);
+			}
+		    any.a_int = pick_gend(flags.initrole, flags.initrace,
+					    flags.initalign, PICK_RANDOM)+1;
+		    if (any.a_int == 0)	/* must be non-zero */
+			any.a_int = randgend(flags.initrole, flags.initrace)+1;
+		    add_menu(win, NO_GLYPH, &any , '*', 0, ATR_NONE,
+				    "Random", MENU_UNSELECTED);
+		    any.a_int = i+1;	/* must be non-zero */
+		    add_menu(win, NO_GLYPH, &any , 'q', 0, ATR_NONE,
+				    "Quit", MENU_UNSELECTED);
+		    Sprintf(pbuf, "Pick the gender of your %s", plbuf);
+		    end_menu(win, pbuf);
+		    n = select_menu(win, PICK_ONE, &selected);
+		    destroy_nhwindow(win);
+		    if (n != 1 || selected[0].item.a_int == any.a_int)
+			goto give_up;		/* Selected quit */
+
+		    k = selected[0].item.a_int - 1;
+		    free((genericptr_t) selected),	selected = 0;
+		}
+		flags.initgend = k;
+	    }
+	    (void)  root_plselection_prompt(plbuf, QBUFSZ - 1,
+			flags.initrole, flags.initrace, flags.initgend, flags.initalign);
+	}
+
+	/* Select an alignment, if necessary */
+	/* force compatibility with role/race/gender */
+	if (flags.initalign < 0 || !validalign(flags.initrole, flags.initrace,
+							flags.initalign)) {
+	    /* pre-selected alignment not valid */
+	    if (pick4u == 'y' || flags.initalign == ROLE_RANDOM || flags.randomall) {
+		flags.initalign = pick_align(flags.initrole, flags.initrace,
+							flags.initgend, PICK_RANDOM);
+		if (flags.initalign < 0) {
+/* 		    lisp_putstr(BASE_WINDOW, 0, "Incompatible alignment!"); */
+		    flags.initalign = randalign(flags.initrole, flags.initrace);
+		}
+	    } else {	/* pick4u == 'n' */
+		/* Count the number of valid alignments */
+		n = 0;	/* number valid */
+		k = 0;	/* valid alignment */
+		for (i = 0; i < ROLE_ALIGNS; i++) {
+		    if (ok_align(flags.initrole, flags.initrace, flags.initgend,
+							i)) {
+			n++;
+			k = i;
+		    }
+		}
+		if (n == 0) {
+		    for (i = 0; i < ROLE_ALIGNS; i++) {
+			if (validalign(flags.initrole, flags.initrace, i)) {
+			    n++;
+			    k = i;
+			}
+		    }
+		}
+
+		/* Permit the user to pick, if there is more than one */
+		if (n > 1) {
+		    win = create_nhwindow(NHW_MENU);
+		    start_menu(win);
+		    any.a_void = 0;         /* zero out all bits */
+		    for (i = 0; i < ROLE_ALIGNS; i++)
+			if (ok_align(flags.initrole, flags.initrace,
+							flags.initgend, i)) {
+			    any.a_int = i+1;
+			    add_menu(win, NO_GLYPH, &any, aligns[i].adj[0],
+				 0, ATR_NONE, aligns[i].adj, MENU_UNSELECTED);
+			}
+		    any.a_int = pick_align(flags.initrole, flags.initrace,
+					    flags.initgend, PICK_RANDOM)+1;
+		    if (any.a_int == 0)	/* must be non-zero */
+			any.a_int = randalign(flags.initrole, flags.initrace)+1;
+		    add_menu(win, NO_GLYPH, &any , '*', 0, ATR_NONE,
+				    "Random", MENU_UNSELECTED);
+		    any.a_int = i+1;	/* must be non-zero */
+		    add_menu(win, NO_GLYPH, &any , 'q', 0, ATR_NONE,
+				    "Quit", MENU_UNSELECTED);
+		    Sprintf(pbuf, "Pick the alignment of your %s", plbuf);
+		    end_menu(win, pbuf);
+		    n = select_menu(win, PICK_ONE, &selected);
+		    destroy_nhwindow(win);
+		    if (n != 1 || selected[0].item.a_int == any.a_int)
+			goto give_up;		/* Selected quit */
+
+		    k = selected[0].item.a_int - 1;
+		    free((genericptr_t) selected),	selected = 0;
+		}
+		flags.initalign = k;
+	    }
+	}
+	/* Success! */
+/* 	lisp_display_nhwindow(BASE_WINDOW, FALSE); */
+}
+
+/* Reads from standard in, the player's name. */
+void
+lisp_askname ()
+{
+  char *line;
+  lisp_cmd ("askname",);
+  read_string ("string", &line);
+  strncpy (plname, line, PL_NSIZ);
+  plname[PL_NSIZ-1] = '\0';
+  free (line);
+}
+
+/* This is a noop for tty and X, so should it be a noop for us too? */
+void
+lisp_get_nh_event ()
+{
+/*   lisp_cmd ("get-event",); */
+}
+
+/* Global Functions */
+void
+lisp_raw_print(str)
+     const char *str;
+{
+  lisp_cmd ("raw-print", lisp_string (str));
+}
+
+void
+lisp_raw_print_bold(str)
+     const char *str;
+{
+  lisp_cmd ("raw-print-bold", lisp_string (str));
+}
+
+void
+lisp_curs(window, x, y)
+     winid window;
+     int x, y;
+{
+  if (window == WIN_MAP)
+    lisp_cmd ("curs",
+	      lisp_int (x);
+	      lisp_int (y));
+  else if (window == WIN_STATUS)
+    {
+      /* do nothing */
+    }
+  else
+    lisp_cmd ("error", lisp_string("lisp_curs bad window"); lisp_int (window));
+}
+
+static void
+generate_status_line ()
+{
+  /* Ripped from botl.c */
+  int hp, hpmax;
+
+  hp = Upolyd ? u.mh : u.uhp;
+  hpmax = Upolyd ? u.mhmax : u.uhpmax;
+  if(hp < 0) hp = 0;
+
+  printf ("(nhapi-update-status ");
+  lisp_quote;
+  printf ("(");
+  lisp_list (lisp_string ("name");
+	     lisp_string (plname););
+  if (Upolyd) 
+    {
+      char mbot[BUFSZ];
+      int k = 0;
+
+      lisp_list (lisp_string ("rank");
+		 lisp_nil);
+      lisp_list (lisp_string ("monster");
+		 lisp_string (mons[u.umonnum].mname));
+    }
+  else
+    {
+      lisp_list (lisp_string ("rank");
+		 lisp_string (rank_of(u.ulevel, Role_switch, flags.female)););;
+      lisp_list (lisp_string ("monster");
+		 lisp_nil);
+    }
+
+  lisp_list (lisp_string ("St");
+	     lisp_int (ACURR(A_STR)););
+  lisp_list (lisp_string ("Dx");
+	     lisp_int (ACURR(A_DEX)););
+  lisp_list (lisp_string ("Co");
+	     lisp_int (ACURR(A_CON)););
+  lisp_list (lisp_string ("In");
+	     lisp_int (ACURR(A_INT)););
+  lisp_list (lisp_string ("Wi");
+	     lisp_int (ACURR(A_WIS)););
+  lisp_list (lisp_string ("Ch");
+	     lisp_int (ACURR(A_CHA)););
+  lisp_list (lisp_string ("Align");
+	     if (u.ualign.type == A_CHAOTIC)
+	     lisp_string ("Chaotic");
+	     else if (u.ualign.type == A_NEUTRAL)
+	     lisp_string ("Neutral");
+	     else
+	     lisp_string ("Lawful"););
+
+#ifdef SCORE_ON_BOTL
+  lisp_list (lisp_string ("Score");
+	     lisp_int (botl_score()););
+#endif
+
+  if (In_endgame(&u.uz))
+    {
+      lisp_list (lisp_string ("Dungeon");
+		 if (Is_astralevel(&u.uz))
+		 lisp_string ("Astral Plane");
+		 else
+		 lisp_string ("End Game"););
+    }
+  else
+    {
+      lisp_list (lisp_string ("Dungeon");
+		 lisp_string (dungeons[u.uz.dnum].dname););
+    }
+
+      lisp_list (lisp_string ("Dlvl");
+		 lisp_int (depth(&u.uz)););
+
+  lisp_list (lisp_string ("$");
+	     lisp_int (u.ugold););
+  lisp_list (lisp_string ("HP");
+	     lisp_int (hp););
+  lisp_list (lisp_string ("HPmax");
+	     lisp_int (hpmax););
+  lisp_list (lisp_string ("PW");
+	     lisp_int (u.uen););
+  lisp_list (lisp_string ("PWmax");
+	     lisp_int (u.uenmax););
+  lisp_list (lisp_string ("AC");
+	     lisp_int (u.uac););
+
+  if (Upolyd)
+    {
+      lisp_list (lisp_string ("HD");
+		 lisp_int (mons[u.umonnum].mlevel););
+    }
+  else
+    {
+      lisp_list (lisp_string ("HD");
+		 lisp_nil);
+    }
+
+  lisp_list (lisp_string ("Level");
+	     lisp_int (u.ulevel););
+#ifdef EXP_ON_BOTL
+  lisp_list (lisp_string ("XP");
+	     lisp_int (u.uexp););
+#endif
+  lisp_list (lisp_string ("T");
+	     lisp_int (moves););
+
+  if (Confusion)
+    lisp_list (lisp_string ("confusion"); lisp_string ("Conf"));
+  else
+    lisp_list (lisp_string ("confusion"); lisp_nil);
+
+  if (u.uhs != 1)
+    lisp_list (lisp_string ("hunger"); lisp_string (hunger_stat[u.uhs]));
+  else
+    lisp_list (lisp_string ("hunger"); lisp_nil);
+
+  if (Sick) 
+    {
+      if (u.usick_type & SICK_VOMITABLE)
+	lisp_list (lisp_string ("sick"); lisp_string ("FoodPois"));
+      if (u.usick_type & SICK_NONVOMITABLE)
+	lisp_list (lisp_string ("sick"); lisp_string ("Ill"));
+    }
+  else
+    lisp_list (lisp_string ("sick"); lisp_nil);
+
+  if (Blind)
+    lisp_list (lisp_string ("blind"); lisp_string ("Blind"));
+  else
+    lisp_list (lisp_string ("blind"); lisp_nil);
+
+  if (Stunned)
+    lisp_list (lisp_string ("stunned"); lisp_string ("Stun"));
+  else
+    lisp_list (lisp_string ("stunned"); lisp_nil);
+
+  if (Hallucination)
+    lisp_list (lisp_string ("hallucination"); lisp_string ("Hallu"));
+  else
+    lisp_list (lisp_string ("hallucination"); lisp_nil);
+
+  if (Slimed)
+    lisp_list (lisp_string ("slimed"); lisp_string ("Slime"));
+  else
+    lisp_list (lisp_string ("slimed"); lisp_nil);
+
+  if (near_capacity() > UNENCUMBERED)
+    lisp_list (lisp_string ("encumbrance"); 
+	       lisp_string (enc_stat[near_capacity()]));
+  else
+    lisp_list (lisp_string ("encumbrance"); lisp_nil);
+
+  printf (" ))\n");
+}
+
+void
+lisp_putstr(window, attr, str)
+     winid window;
+     int attr;
+     const char *str;
+{
+  static char statline1[BUFSZ] = "";
+  if (window == WIN_STATUS)
+    {
+      if (statline1[0]=='\0')
+	Strcpy (statline1, str);
+      else
+	{
+	  generate_status_line ();
+	  statline1[0]='\0';
+	}
+    }
+  else if (window == WIN_MESSAGE)
+    lisp_cmd ("message", 
+	      lisp_literal (attr_to_string (attr));
+	      lisp_string (str));
+  else
+    lisp_cmd ("menu-putstr",
+	      lisp_int (window);
+	      lisp_literal (attr_to_string (attr));
+	      lisp_string (str));
+}
+
+void
+lisp_start_menu(window)
+     winid window;
+{
+  lisp_menu_list_num = 0;
+  lisp_current_accelerator = 'a';
+  lisp_cmd ("start-menu", lisp_int (window));
+}
+
+void
+lisp_add_menu(window, glyph, identifier, ch, gch, attr, str, preselected)
+    winid window;		/* window to use, must be of type NHW_MENU */
+    int glyph;			/* glyph to display with item (unused) */
+    const anything *identifier;	/* what to return if selected */
+    char ch;			/* keyboard accelerator (0 = pick our own) */
+    char gch;			/* group accelerator (0 = no group) */
+    int attr;			/* attribute for string (like tty_putstr()) */
+    const char *str;		/* menu string */
+    boolean preselected;	/* item is marked as selected */
+{
+  if (identifier->a_void)
+    {
+      lisp_menu_item_list[lisp_menu_list_num].identifier = *identifier;
+      if (ch == 0)
+	{
+	  ch = lisp_menu_item_list[lisp_menu_list_num].accelerator = lisp_current_accelerator;
+	  if (lisp_current_accelerator == 'z')
+	    lisp_current_accelerator = 'A';
+	  else
+	    lisp_current_accelerator++;
+	}      
+      else
+	lisp_menu_item_list[lisp_menu_list_num].accelerator = ch;
+
+      lisp_menu_list_num++;
+    }
+  else
+    ch = -1;
+
+  lisp_cmd ("add-menu",
+	    lisp_int (window);
+	    lisp_int (glyph);
+	    lisp_int (glyph2tile[glyph]);
+	    lisp_int (ch);
+	    lisp_int (gch);
+	    lisp_literal (attr_to_string (attr));
+	    lisp_string (str);
+	    preselected ? lisp_t : lisp_nil);
+}
+
+void
+lisp_end_menu(window, prompt)
+    winid window;	/* menu to use */
+    const char *prompt;	/* prompt to for menu */
+{
+  lisp_cmd ("end-menu",
+	    lisp_int (window);
+	    lisp_string (prompt));
+}
+
+static int
+lisp_get_menu_identifier(ch, identifier)
+     char ch;
+     anything *identifier;
+{
+  int i;
+
+  for(i=0; i < lisp_menu_list_num; i++)
+    {
+      if( lisp_menu_item_list[i].accelerator == ch )
+	{
+	  *identifier = lisp_menu_item_list[i].identifier;
+	  return 1;
+	}
+    }
+
+  return 0;
+}
+
+int
+lisp_select_menu(window, how, menu_list)
+    winid window;
+    int how;
+    menu_item **menu_list;
+{
+  const char *delim = "() \n";
+  char *list;
+  char *token;
+  int size = 0;
+  int toggle;
+
+  lisp_cmd ("select-menu",
+	    lisp_int (window);
+	    lisp_literal (how_to_string (how)));
+
+  read_string ("menu", &list);
+
+/*   lisp_prompt ("menu"); */
+/*   fgets (list, LINESIZ, stdin); */
+
+  /* The client should submit a structure like this:
+
+   ((ch count) (ch count) (ch count) ...) 
+
+   where ch is the accelerator for the menu item and count is the
+   number of them to select.
+   
+   We strtok it so we just get id count id count id count. */
+
+  token = strtok (list, delim);
+
+  /* Start with some memory so realloc doesn't fail. */
+  *menu_list = malloc (sizeof (menu_item));
+  if (*menu_list == NULL)
+    {
+      panic ("Memory allocation failure; cannot get %u bytes", 
+	     sizeof (menu_item));
+    }
+  size = 0;
+
+  while (token != NULL)
+    {
+      /* Make more room in the array for the new item */
+      size++;
+      if ((*menu_list = realloc (*menu_list, size * sizeof (menu_item))) == NULL)
+	{
+	  panic ("Memory allocation failure; cannot get %u bytes", 
+		 size * sizeof (menu_item));
+	}
+
+      /* assign the item ID */
+      lisp_get_menu_identifier (atoi (token), &(*menu_list)[size-1].item );
+
+      /* Read the item count */
+      token = strtok (NULL, delim);
+      (*menu_list)[size-1].count = atoi (token);
+
+      /* read the next item ID */
+      token = strtok (NULL, delim);
+    }
+
+  free (list);
+
+  return size;
+}
+
+/* This is a tty-specific hack. Do we need it? */
+char
+lisp_message_menu(let, how, mesg)
+     char let;
+     int how;
+     const char *mesg;
+{
+  lisp_cmd ("message-menu",
+	    lisp_int (let);
+	    lisp_literal (how_to_string (how));
+	    lisp_string (mesg));
+  return '\0';
+}
+
+static int
+lisp_get_cmd(str)
+     const char *str;
+{
+  int i;
+
+  for (i=0; cmd_index[i].name != (char *)0; i++)
+    {
+      if (!strcmp (str, cmd_index[i].name)) 
+	return i;
+    }	  
+
+  return -1;
+}
+
+static int
+lisp_get_ext_cmd_id (str)
+     const char *str;
+{
+  int i;
+
+  for (i=0; extcmdlist[i].ef_txt != (char *)0; i++) {
+    if (!strcmp (str, extcmdlist[i].ef_txt)) return i;
+  }
+  
+  return -1;
+}
+
+/* static int */
+/* num_digits(n) */
+/*      int n; */
+/* { */
+/*   int i; */
+/*   int ret = 1; */
+  
+/*   for (i=10;n / i; i *= 10) */
+/*     { */
+/*       ret++; */
+/*     } */
+
+/*   return ret; */
+/* } */
+
+/* static */
+/* int */
+/* power_of_ten (n) */
+/*      int n; */
+/* { */
+/*   int i; */
+/*   int power = 1; */
+
+/*   for (i=0; i<n; i++) */
+/*     { */
+/*       power *= 10; */
+/*     } */
+
+/*   return power; */
+/* } */
+
+int
+lisp_nhgetch()
+{
+  /* multi is not 0 if this  */
+  static char count_buf[BUFSIZ] = "";
+  static char *count_pos = count_buf;
+  static int count_cmd = -1;
+  int cmd;
+
+  if (*count_pos)
+    {
+      char *tmp = count_pos;
+      count_pos++;
+      return *tmp;
+    }
+
+  if (count_cmd >= 0)
+    {
+      cmd = count_cmd;
+      count_cmd = -1;
+    }
+  else
+    {
+      char cmdstr[BUFSZ];
+
+      read_command ("command", cmdstr, count_buf);
+
+      count_pos = count_buf;
+      cmd = lisp_get_cmd (cmdstr);
+      if (cmd == -1)
+	{
+	  printf ("(nhapi-message 'atr-none \"undefined-command %s\")\n", cmdstr);
+	  cmd = lisp_get_cmd ("null");
+	}
+
+      if (atoi (count_pos) > 1)
+	{
+	  char* tmp = count_pos;
+	  count_pos++;
+	  count_cmd = cmd;
+	  return *tmp;
+	}
+      else
+	{
+	  /* Since the count is 1, zero out the string. */
+	  *count_pos = 0;
+	}
+    }
+
+  if (cmd_index[cmd].type == CMD_KEY)
+    {
+      return cmd_index[cmd].cmd;
+    }
+  else
+    {
+      if ((extended_cmd_id = lisp_get_ext_cmd_id (cmd_index[cmd].name)) == -1)
+	{
+	  /* Can never happen. */
+	  printf ("%s:%d: Bad extended command name\n", __FILE__,  __LINE__);
+	}
+      return '#';
+    }
+}
+
+int
+lisp_nh_poskey(x, y, mod)
+     int *x, *y, *mod;
+{
+/*    char scratch[256]; */
+
+/*    printf ("(nethack-api-poskey)\n"); */
+
+/*    scanf ("( %d %d '%255s )", x, y, scratch); */
+/*    if (!strcmp (scratch, "click-1")) *mod = CLICK_1; */
+/*    else *mod = CLICK_2; */
+
+/*    return 0; */
+
+  return lisp_nhgetch();
+}
+
+static boolean inven_win_created = FALSE;
+
+/* These globals are used to keep track of window IDs. */
+static winid *winid_list = NULL;
+static int winid_list_len = 0;
+static int winid_list_max = 0;
+
+/* returns index into winid_list that can be used. */
+static int
+find_empty_cell ()
+{
+  int i;
+
+  /* Check for a vacant spot in the list. */
+  for (i=0; i<winid_list_len; i++)
+    {
+      if (winid_list[i] == -1) return i;
+    }
+
+  /* no vacant ones, so grow the array. */
+  if (winid_list_len >= winid_list_max)
+    {
+      winid_list_max *= 2;
+      winid_list = realloc (winid_list, sizeof (int) * winid_list_max);
+      if (winid_list == NULL)
+	bail ("Out of memory\n");
+    }
+  winid_list_len++;
+
+  return winid_list_len-1;
+}
+
+static int
+winid_is_taken (winid n)
+{
+  int i;
+
+  for (i=0; i<winid_list_len; i++)
+    if (winid_list[i] == n) return 1;
+  
+  return 0;
+}
+
+static int
+add_winid (winid n)
+{
+  if (winid_is_taken (n)) return 0; /* failed. */
+  
+  winid_list[find_empty_cell()] = n;
+  return 1; /* success! */
+}
+
+static winid
+get_unique_winid ()
+{
+  winid i;
+  
+  /* look for a unique number, and add it to the list of taken
+     numbers. */
+  i = 0;
+  while (!add_winid (i)) i++;
+
+  return i;	  
+}
+
+/* When a window is destroyed, it gives back its window number with
+   this function. */
+static void
+return_winid (winid n)
+{
+  int i;
+
+  for (i=0; i<winid_list_len; i++)
+    {
+      if (winid_list[i] == n) 
+	{
+	  winid_list[i] = -1;
+	  return;
+	}
+    }
+}
+
+static void
+init_winid_list ()
+{
+  winid_list_max = 10;
+  winid_list_len = 0;
+
+  winid_list = malloc (winid_list_max * sizeof (int));
+}
+
+/* Prints a create_nhwindow function and expects from stdin the id of
+   this new window as a number. */
+winid
+lisp_create_nhwindow(type)
+     int type;
+{
+  winid id = get_unique_winid();
+
+  switch (type)
+    {
+    case NHW_MESSAGE:
+      lisp_cmd ("create-message-window",);
+      break;
+    case NHW_MAP:
+      lisp_cmd ("create-map-window",);
+      break;
+    case NHW_STATUS:
+      lisp_cmd ("create-status-window",);
+      break;
+    case NHW_TEXT:
+      lisp_cmd ("create-text-window", lisp_int (id));
+      break;
+    case NHW_MENU:
+      if (!inven_win_created)
+	{
+	  lisp_cmd ("create-inventory-window", lisp_int (id));
+	  inven_win_created = TRUE;
+	}
+      else
+	lisp_cmd ("create-menu-window", lisp_int (id));
+      break;
+    default:
+      impossible ("Unknown window type: %d", type);
+    };
+
+  return id;
+}
+
+void
+lisp_clear_nhwindow(window)
+     winid window;
+{
+  if (window == WIN_MESSAGE)
+    lisp_cmd ("clear-message",);
+  else if (window == WIN_MAP)
+    lisp_cmd ("clear-map",);
+  else
+    /* are other window types ever cleared? */
+    lisp_cmd ("error", lisp_string("clearing unknown winid"));
+}
+
+void
+lisp_display_nhwindow(window, blocking)
+     winid window;
+     boolean blocking;
+{
+  /* don't send display messages for anything but menus */
+  char *dummy;
+  if (window != WIN_MESSAGE && window != WIN_STATUS && window != WIN_MAP)
+    {
+      lisp_cmd ("display-menu", lisp_int (window));
+      read_string ("menu", &dummy);
+      free (dummy);
+    }
+  else if (blocking)
+    {
+      if (window == WIN_MESSAGE)
+	{
+	  /* blocking on the message window happens only at the end of
+	     the game */
+	  lisp_cmd ("end",);
+	}
+      else
+	{
+	  lisp_cmd ("block",);
+	  read_string ("dummy", &dummy);
+	  free (dummy);
+	}
+    }
+  else if (window == WIN_STATUS)
+    {
+      /* initial window setup hack here :) */
+      lisp_cmd ("restore-window-configuration",);
+    }
+}
+
+void
+lisp_destroy_nhwindow(window)
+     winid window;
+{
+  if ((window != WIN_STATUS)
+      && (window != WIN_MESSAGE)
+      && (window != WIN_MAP))
+    {
+      lisp_cmd ("destroy-menu", lisp_int (window));
+      return_winid (window);
+    }
+}
+
+void
+lisp_update_inventory()
+{
+  lisp_cmd ("update-inventory",);
+}
+
+int
+lisp_doprev_message()
+{
+  lisp_cmd ("doprev-message",);
+  return 0;
+}
+
+void
+lisp_nhbell()
+{
+  lisp_cmd ("nhbell",);
+}
+
+/* Can be an empty call says window.doc. */
+void
+lisp_mark_synch()
+{
+  /* lisp_cmd ("mark-sync",); */
+}
+
+void
+lisp_wait_synch()
+{
+  lisp_cmd ("wait-synch",);
+}
+
+/* Since nethack will never be suspended, we need not worry about this
+   function. */
+void
+lisp_resume_nhwindows()
+{
+  return;
+}
+
+/* Since nethack will never be suspended, we need not worry about this
+   function. */
+void
+lisp_suspend_nhwindows(str)
+     const char *str;
+{
+  return;
+}
+
+/* All keys are defined in emacs, so number_pad makes no sense. */
+void
+lisp_number_pad(state)
+     int state;
+{
+  return;
+}
+
+void
+lisp_init_nhwindows(argcp,argv)
+     int* argcp;
+     char** argv;
+{
+  int i;
+
+  /* Print each command-line option, constructing a list of strings */
+  lisp_cmd ("init-nhwindows",
+	    for (i=0; i<*argcp; i++) 
+	      lisp_string (argv[i]));
+
+  /* FIXME: doesn't remove the arguments parsed, as specified in the
+     api doc. */
+
+  /* Setup certain flags lisp clients need */
+  iflags.num_pad = FALSE;
+#ifdef EXP_ON_BOTL		/* we are going to lose if Nethack is
+				   compiled without this option -rcy */
+  flags.showexp = TRUE;
+#endif
+  flags.time = TRUE;
+
+  /* inform nethack that the windows have been initialized. */
+  iflags.window_inited = TRUE;
+
+  init_winid_list();
+}
+
+void
+lisp_exit_nhwindows (str)
+     const char *str;
+{
+  lisp_cmd ("exit-nhwindows ", lisp_string (str));
+}
+
+void
+lisp_delay_output()
+{
+  char *dummy;
+  lisp_cmd ("delay-output",);
+  read_string ("dummy", &dummy);
+  free (dummy);
+}
+
+void
+lisp_getlin(question, input)
+     const char *question;
+     char *input;
+{
+  char *tmp;
+  lisp_cmd ("getlin", lisp_string (question));
+  read_string ("string", &tmp);
+  /* FIXME: potential buffer overflow. */
+  strcpy (input, tmp);
+}
+
+int
+lisp_get_ext_cmd()
+{
+/*    int cmd; */
+/*    int i; */
+
+/*    printf ("(nethack-api-get-ext-cmd '("); */
+
+/*    for (i=0; extcmdlist[i].ef_txt != (char *)0; i++) { */
+/*      printf ("(\"%s\" . %d)", extcmdlist[i].ef_txt, i); */
+/*    } */
+/*    printf ("))\n"); */
+
+/*    scanf ("%d", &cmd); */
+
+  /* This is set when the user chooses an extended command. */
+  return extended_cmd_id;
+}
+
+void
+lisp_display_file(str, complain)
+     const char *str;
+     boolean complain;
+{
+  lisp_cmd ("display-file",
+	    lisp_string (str);
+	    complain ? lisp_t : lisp_nil);;
+}
+
+char
+lisp_yn_function(ques, choices, def)
+     const char *ques;
+     const char *choices;
+     char def;
+{
+  int answer;
+
+  /* Some questions have special functions. */
+  if (!strncmp (ques, "In what direction", 17))
+    {
+      char *dir;
+      lisp_cmd ("ask-direction",
+		lisp_string (ques));
+      read_string ("direction", &dir);
+      if (!strcmp (dir, "n"))
+	answer = 'k';
+      else if (!strcmp (dir, "s"))
+	answer = 'j';
+      else if (!strcmp (dir, "e"))
+	answer = 'l';
+      else if (!strcmp (dir, "w"))
+	answer = 'h';
+      else if (!strcmp (dir, "ne"))
+	answer = 'u';
+      else if (!strcmp (dir, "nw"))
+	answer = 'y';
+      else if (!strcmp (dir, "se"))
+	answer = 'n';
+      else if (!strcmp (dir, "sw"))
+	answer = 'b';
+      else if (!strcmp (dir, "up"))
+	answer = '<';
+      else if (!strcmp (dir, "down"))
+	answer = '>';
+      else if (!strcmp (dir, "self"))
+	answer = '.';
+      else
+	{
+	  if (def == '\0')
+	    answer = 0x20;		/* space */
+	  else
+	    answer = def;
+	}
+
+      free (dir);
+    }
+  else
+    {
+      lisp_cmd ("yn-function",
+		lisp_string (ques);
+		lisp_string (choices);
+		lisp_int (def));
+      read_int ("number", &answer);
+    }
+
+  return (char)answer;
+}
+
+#ifdef POSITIONBAR
+void
+lisp_update_positionbar(features)
+     char *features;
+{
+  lisp_cmd ("update-positionbar", lisp_string (features));
+}
+#endif
+
+#define zap_color(n)  zapcolors[n]
+#define cmap_color(n) defsyms[n].color
+#define obj_color(n)  objects[n].oc_color
+#define mon_color(n)  mons[n].mcolor
+#define invis_color(n) NO_COLOR
+#define pet_color(n)  mons[n].mcolor
+#define warn_color(n) def_warnsyms[n].color
+
+void
+lisp_print_glyph(window, x, y, glyph)
+    winid window;
+    xchar x, y;
+    int glyph;
+{
+    int ch;
+    boolean reverse_on = FALSE;
+    int	    color;
+    unsigned special;
+
+    /* map glyph to character and color */
+    mapglyph(glyph, &ch, &color, &special, x, y);
+
+    if (window == WIN_MAP)
+      lisp_cmd ("print-glyph",
+		lisp_int (x);
+		lisp_int (y);
+		lisp_int (color);
+		lisp_int (glyph);
+		lisp_int (glyph2tile[glyph]);
+		lisp_int (ch););
+    else
+      lisp_cmd ("error",
+		lisp_string ("lisp_print_glyph bad window");
+		lisp_int (window));
+}
+
+#ifdef CLIPPING
+void
+lisp_cliparound(x, y)
+     int x;
+     int y;
+{
+  /* as far as I can tell, the x and y values here are exactly the
+     ones given by the next lisp_curs call, so its redundant
+     information -rcy */
+
+  /*   lisp_cmd ("cliparound", lisp_int (x); lisp_int (y)); */
+}
+#endif
+
+void lisp_start_screen() { return; } /* called from setftty() in unixtty.c */
+void lisp_end_screen() {return; }    /* called from settty() in unixtty.c */
+
+static void
+get_death_text (buf)
+     char buf[BUFSZ];
+{
+  
+}
+
+void
+lisp_outrip(window, how)
+     winid window;
+     int how;
+{
+  lisp_cmd ("outrip",
+	    lisp_int (window);	    
+	    lisp_string (plname);
+	    lisp_int (u.ugold);
+	    lisp_string ("Died while trying to finish nethack-el."));
+}
diff -Pru nethack-3.4.1/win/tty/termcap.c nethack/win/tty/termcap.c
--- nethack-3.4.1/win/tty/termcap.c	Sun Feb 23 06:43:46 2003
+++ nethack/win/tty/termcap.c	Sun Mar  9 13:49:04 2003
@@ -1161,6 +1161,11 @@
 	if (windowprocs.name != NULL &&
 	    !strcmpi(windowprocs.name, "Gem")) return TRUE;
 #endif
+#ifdef LISP_GRAPHICS
+	/* XXX has_color() should be added to windowprocs */
+	if (windowprocs.name != NULL &&
+	    !strcmpi(windowprocs.name, "lisp")) return TRUE;
+#endif
 #ifdef QT_GRAPHICS
 	/* XXX has_color() should be added to windowprocs */
 	if (windowprocs.name != NULL &&
diff -Pru nethack-3.4.1/win/win32/tile2bmp.c nethack/win/win32/tile2bmp.c
--- nethack-3.4.1/win/win32/tile2bmp.c	Wed Dec 31 16:00:00 1969
+++ nethack/win/win32/tile2bmp.c	Thu Jan 10 16:43:38 2002
@@ -0,0 +1,272 @@
+/*	SCCS Id: @(#)tile2bmp.c	3.3	1999/08/29	*/
+/*   Copyright (c) NetHack PC Development Team 1995                 */
+/*   NetHack may be freely redistributed.  See license for details. */
+
+/*
+ * Edit History:
+ *
+ *	Initial Creation			M.Allison   94/01/11
+ *
+ */
+
+/* #pragma warning(4103:disable) */
+
+#include "hack.h"
+#include "tile.h"
+#ifndef __DJGPP__
+#include "win32api.h"
+#endif
+
+/* #define COLORS_IN_USE MAXCOLORMAPSIZE       /* 256 colors */
+#define COLORS_IN_USE 16                       /* 16 colors */
+
+#define BITCOUNT 8
+
+extern char *FDECL(tilename, (int, int));
+
+#if BITCOUNT==4
+#define MAX_X 320		/* 2 per byte, 4 bits per pixel */
+#else
+#define MAX_X 640		/* 1 per byte, 8 bits per pixel */
+#endif	
+#define MAX_Y 480
+
+/* GCC fix by Paolo Bonzini 1999/03/28 */
+#ifdef __GNUC__
+#define PACK		__attribute__((packed))
+#else
+#define PACK
+#endif 
+
+#if defined(__DJGPP__)
+typedef struct tagBMIH {
+        unsigned long   biSize;
+        long       	biWidth;
+        long       	biHeight;
+        unsigned short  biPlanes;
+        unsigned short  biBitCount;
+        unsigned long   biCompression;
+        unsigned long   biSizeImage;
+        long       	biXPelsPerMeter;
+        long       	biYPelsPerMeter;
+        unsigned long   biClrUsed;
+        unsigned long   biClrImportant;
+} PACK BITMAPINFOHEADER;
+
+typedef struct tagBMFH {
+        unsigned short bfType;
+        unsigned long  bfSize;
+        unsigned short bfReserved1;
+        unsigned short bfReserved2;
+        unsigned long  bfOffBits;
+} PACK BITMAPFILEHEADER;
+
+typedef struct tagRGBQ {
+        unsigned char    rgbBlue;
+        unsigned char    rgbGreen;
+        unsigned char    rgbRed;
+        unsigned char    rgbReserved;
+} PACK RGBQUAD;
+#define UINT unsigned int
+#define DWORD unsigned long
+#define LONG long
+#define WORD unsigned short
+#define BI_RGB        0L
+#define BI_RLE8       1L
+#define BI_RLE4       2L
+#define BI_BITFIELDS  3L
+#endif /* defined(__DJGPP__) */
+
+#pragma pack(1)
+struct tagBMP{
+    BITMAPFILEHEADER bmfh;
+    BITMAPINFOHEADER bmih;
+#if BITCOUNT==4
+#define RGBQUAD_COUNT 16
+    RGBQUAD          bmaColors[RGBQUAD_COUNT];
+#else
+#define RGBQUAD_COUNT 16
+    RGBQUAD          bmaColors[RGBQUAD_COUNT];
+#endif
+#if COLORS_IN_USE==16
+    uchar            packtile[MAX_Y][MAX_X];
+#else
+    uchar            packtile[TILE_Y][TILE_X];
+#endif
+} PACK bmp;
+#pragma pack()
+
+#define BMPFILESIZE (sizeof(struct tagBMP))
+
+FILE *tibfile2;
+
+pixel tilepixels[TILE_Y][TILE_X];
+
+static void FDECL(build_bmfh,(BITMAPFILEHEADER *));
+static void FDECL(build_bmih,(BITMAPINFOHEADER *));
+static void FDECL(build_bmptile,(pixel (*)[TILE_X]));
+
+char *tilefiles[] = {	"../win/share/monsters.txt",
+			"../win/share/objects.txt",
+			"../win/share/other.txt"};
+
+int num_colors = 0;
+int tilecount;
+int max_tiles_in_row = 40;
+int tiles_in_row;
+int filenum;
+int initflag;
+int yoffset,xoffset;
+char bmpname[128];
+FILE *fp;
+
+int
+main(argc, argv)
+int argc;
+char *argv[];
+{
+	int i;
+
+	if (argc != 2) {
+		Fprintf(stderr, "usage: tile2bmp outfile.bmp\n");
+		exit(EXIT_FAILURE);
+	} else
+		strcpy(bmpname, argv[1]);
+
+#ifdef OBSOLETE
+	bmpfile2 = fopen(NETHACK_PACKED_TILEFILE, WRBMODE);
+	if (bmpfile2 == (FILE *)0) {
+		Fprintf(stderr, "Unable to open output file %s\n",
+				NETHACK_PACKED_TILEFILE);
+		exit(EXIT_FAILURE);
+	}
+#endif
+
+	tilecount = 0;
+	xoffset = yoffset = 0;
+	initflag = 0;
+	filenum = 0;
+	fp = fopen(bmpname,"wb");
+	if (!fp) {
+	    printf("Error creating tile file %s, aborting.\n",bmpname);
+	    exit(1);
+	}
+	while (filenum < 3) {
+		if (!fopen_text_file(tilefiles[filenum], RDTMODE)) {
+			Fprintf(stderr,
+				"usage: tile2bmp (from the util directory)\n");
+			exit(EXIT_FAILURE);
+		}
+		num_colors = colorsinmap;
+		if (num_colors > 62) {
+			Fprintf(stderr, "too many colors (%d)\n", num_colors);
+			exit(EXIT_FAILURE);
+		}
+		if (!initflag) {
+		    build_bmfh(&bmp.bmfh);
+		    build_bmih(&bmp.bmih);
+		    memset(&bmp.packtile,0,
+				(MAX_X * MAX_Y * sizeof(uchar)));
+		    for (i = 0; i < num_colors; i++) {
+			    bmp.bmaColors[i].rgbRed = ColorMap[CM_RED][i];
+			    bmp.bmaColors[i].rgbGreen = ColorMap[CM_GREEN][i];
+			    bmp.bmaColors[i].rgbBlue = ColorMap[CM_BLUE][i];
+			    bmp.bmaColors[i].rgbReserved = 0;
+		    }
+		    initflag = 1;
+		}
+/*		printf("Colormap initialized\n"); */
+		while (read_text_tile(tilepixels)) {
+			build_bmptile(tilepixels);
+			tilecount++;
+#if BITCOUNT==4
+			xoffset += (TILE_X / 2);
+#else
+			xoffset += TILE_X;
+#endif
+			if (xoffset >= MAX_X) {
+				yoffset += TILE_Y;
+				xoffset = 0;
+			}
+		}
+		(void) fclose_text_file();
+		++filenum;
+	}
+	fwrite(&bmp, sizeof(bmp), 1, fp);
+	fclose(fp);
+	Fprintf(stderr, "Total of %d tiles written to %s.\n",
+		tilecount, bmpname);
+
+	exit(EXIT_SUCCESS);
+	/*NOTREACHED*/
+	return 0;
+}
+
+
+static void
+build_bmfh(pbmfh)
+BITMAPFILEHEADER *pbmfh;
+{
+	pbmfh->bfType = (UINT)0x4D42;
+	pbmfh->bfSize = (DWORD)BMPFILESIZE;
+	pbmfh->bfReserved1 = (UINT)0;
+	pbmfh->bfReserved2 = (UINT)0;
+	pbmfh->bfOffBits = sizeof(bmp.bmfh) + sizeof(bmp.bmih) +
+			   (RGBQUAD_COUNT * sizeof(RGBQUAD));
+}
+
+static void
+build_bmih(pbmih)
+BITMAPINFOHEADER *pbmih;
+{
+	pbmih->biSize = (DWORD) sizeof(bmp.bmih);
+#if BITCOUNT==4
+	pbmih->biWidth = (LONG) MAX_X * 2;
+#else
+	pbmih->biWidth = (LONG) MAX_X;
+#endif
+	pbmih->biHeight = (LONG) MAX_Y;
+	pbmih->biPlanes = (WORD) 1;
+#if BITCOUNT==4
+	pbmih->biBitCount = (WORD) 4;
+#else
+	pbmih->biBitCount = (WORD) 8;
+#endif
+	pbmih->biCompression = (DWORD) BI_RGB;
+	pbmih->biSizeImage = (DWORD)0;
+	pbmih->biXPelsPerMeter = (LONG)0;
+	pbmih->biYPelsPerMeter = (LONG)0;
+	pbmih->biClrUsed = (DWORD)RGBQUAD_COUNT;
+	pbmih->biClrImportant = (DWORD)0;
+}
+
+static void
+build_bmptile(pixels)
+pixel (*pixels)[TILE_X];
+{
+	int cur_x, cur_y, cur_color;
+	int x,y;
+
+	for (cur_y = 0; cur_y < TILE_Y; cur_y++) {
+	 for (cur_x = 0; cur_x < TILE_X; cur_x++) {
+	  for (cur_color = 0; cur_color < num_colors; cur_color++) {
+	   if (ColorMap[CM_RED][cur_color] == pixels[cur_y][cur_x].r &&
+	      ColorMap[CM_GREEN][cur_color]== pixels[cur_y][cur_x].g &&
+	      ColorMap[CM_BLUE][cur_color] == pixels[cur_y][cur_x].b)
+		break;
+	  }
+	  if (cur_color >= num_colors)
+		Fprintf(stderr, "color not in colormap!\n");
+	  y = (MAX_Y - 1) - (cur_y + yoffset);
+#if BITCOUNT==4
+	  x = (cur_x / 2) + xoffset;
+	  bmp.packtile[y][x] = cur_x%2 ?
+		(uchar)(bmp.packtile[y][x] | cur_color) :
+		(uchar)(cur_color<<4);
+#else
+	  x = cur_x + xoffset;
+	  bmp.packtile[y][x] = (uchar)cur_color;
+#endif
+	 }
+	}
+}
diff -Pru nethack-3.4.1/win/win32/winhack.h nethack/win/win32/winhack.h
--- nethack-3.4.1/win/win32/winhack.h	Wed Dec 31 16:00:00 1969
+++ nethack/win/win32/winhack.h	Tue Apr 23 12:20:07 2002
@@ -0,0 +1,18 @@
+/*	SCCS Id: @(#)winhack.h	3.4	2002/03/06	*/
+/* Copyright (c) Alex Kompel, 2002                                */
+/* NetHack may be freely redistributed.  See license for details. */
+
+
+#if !defined(AFX_WINHACK_H__6397C328_BAF8_460C_9465_F12C596C5732__INCLUDED_)
+#define AFX_WINHACK_H__6397C328_BAF8_460C_9465_F12C596C5732__INCLUDED_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif // _MSC_VER > 1000
+
+#define STRICT 
+#include <windows.h>
+#include "resource.h"
+
+
+#endif // !defined(AFX_WINHACK_H__6397C328_BAF8_460C_9465_F12C596C5732__INCLUDED_)
